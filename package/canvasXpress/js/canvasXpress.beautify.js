/**
 * CanvasXpress 17.7 - JavaScript Canvas Library
 * 
 * Copyright (c) 2009-2017 Isaac Neuhaus
 * 
 * imnphd@gmail.com
 * 
 * 
 * Redistributions of this source code must retain this copyright notice and the following disclaimer.
 * 
 * CanvasXpress is licensed under the terms of the Open Source GPL version 3.0 license.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * Please see a copy of the GNU General Public License at http://www.gnu.org/licenses.
 * 
 * Commercial use may be granted to the extent that this source code does NOT become part of any other Open Source or Commercially licensed development library or toolkit without explicit permission.
 * Please contact me for additional information.
 * 
 * Thanks to Mingyi Liu for his contributions with the Ext-JS panel and network graphs and Charles Tilford for his input to the Genome Browser.
 * 
 */
/**
 * 
 * canvas.text.js
 * @projectDescription An cross-browser implementation of the HTML5 <canvas> text methods 
 * @author Fabien Mï¿½nager 
 * @version $Revision: 1.4 $ 
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php> 
 * 
 * Known issues: 
 * - The 'light' font weight is not supported, neither is the 'oblique' font style. 
 * - Optimize the different hacks (for Opera9) 
 * 
 ****
 *
 * HeyGraph by Tom Martin
 * 
 * Copyright (c) 2010 Tom Martin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 ****
 * 
 * sprintf() for JavaScript v.0.4
 *
 * Copyright (c) 2007 Alexandru Marasteanu <http://alexei.417.ro/>
 * Thanks to David Baird (unit test and patch).
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 ***
 * 
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 *
 ****
 *
 * canvas_wrapper.js
 * Canvas doesn't support getCoords() which I really need....
 * So I made a wrapper, code mostly taken from excanvas.js by Google - http://code.google.com/p/explorercanvas/
 * alias some functions to make (compiled) code shorter
 *
 ****
 *
 * conrec.js
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://paulbourke.net/papers/conrec for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 ****
 *
 * conrec.js
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 * 
 **** 
 *
 * jLouvain.js
 * Author: Corneliu S. (github.com/upphiminn)
 * This is a javascript implementation of the Louvain
 * community detection algorithm (http://arxiv.org/abs/0803.0476)
 * Based on https://bitbucket.org/taynaud/python-louvain/overview
 * 
 ****
 * 
 * science.js
 * Copyright (c) 2011, Jason Davies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * The name Jason Davies may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 ****
 *
 * Apache-Style Software License for ColorBrewer software and ColorBrewer Color
 * Schemes
 * 
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State
 * University.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions as source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * 2. The end-user documentation included with the redistribution, if any, must
 * include the following acknowledgment: "This product includes color
 * specifications and designs developed by Cynthia Brewer
 * (http://colorbrewer.org/)." Alternately, this acknowledgment may appear in the
 * software itself, if and wherever such third-party acknowledgments normally
 * appear.
 * 
 * 4. The name "ColorBrewer" must not be used to endorse or promote products
 * derived from this software without prior written permission. For written
 * permission, please contact Cynthia Brewer at cbrewer@psu.edu.
 * 
 * 5. Products derived from this software may not be called "ColorBrewer", nor
 * may "ColorBrewer" appear in their name, without prior written permission of
 * Cynthia Brewer.
 *
 ****
 * 
 * FileSaver.js
 * Copyright Â© 2015 [Eli Grey][1].
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **** 
 * 
 * canvas-toBlob.js
 * Copyright Â© 2011 Eli Grey and Devin Samarin.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 ****
 *
 * Blob.js
 * Copyright Â© 2014 Eli Grey.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 ****
 *
 * jstat.js
 * Copyright (c) 2013 jStat
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 ****
 *
 * numeric.js
 * Numeric Javascript
 * Copyright (C) 2011 by SÃ©bastien Loisel
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 ****
 *
 * spark-md5.js
 * Copyright (c) 2015 AndrÃ© Cruz <amdfcruz@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the 'Software'), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ****
 *
 * Sankey.js
 * Copyright (c) 2012, Michael Bostock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * The name Michael Bostock may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ****
 *
 * canvas2svg
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Gliffy Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
function str_repeat(b, a) {
	for (var c = []; a > 0; c[--a] = b) {}
	return (c.join(""))
}

function sprintf() {
	var g = 0,
		e, h = arguments[g++],
		k = [],
		d, j, l, b;
	while (h) {
		if (d = /^[^\x25]+/.exec(h)) {
			k.push(d[0])
		} else {
			if (d = /^\x25{2}/.exec(h)) {
				k.push("%")
			} else {
				if (d = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(h)) {
					if (((e = arguments[d[1] || g++]) == null) || (e == undefined)) {
						throw ("Too few arguments.")
					}
					if (/[^s]/.test(d[7]) && (typeof(e) != "number")) {
						throw ("Expecting number but found " + typeof(e))
					}
					switch (d[7]) {
						case "b":
							e = e.toString(2);
							break;
						case "c":
							e = String.fromCharCode(e);
							break;
						case "d":
							e = parseInt(e);
							break;
						case "e":
							e = d[6] ? e.toExponential(d[6]) : e.toExponential();
							break;
						case "f":
							e = d[6] ? parseFloat(e).toFixed(d[6]) : parseFloat(e);
							break;
						case "o":
							e = e.toString(8);
							break;
						case "s":
							e = ((e = String(e)) && d[6] ? e.substring(0, d[6]) : e);
							break;
						case "u":
							e = Math.abs(e);
							break;
						case "x":
							e = e.toString(16);
							break;
						case "X":
							e = e.toString(16).toUpperCase();
							break
					}
					e = (/[def]/.test(d[7]) && d[2] && e > 0 ? "+" + e : e);
					l = d[3] ? d[3] == "0" ? "0" : d[3].charAt(1) : " ";
					b = d[5] - String(e).length;
					j = d[5] ? str_repeat(l, b) : "";
					k.push(d[4] ? e + j : j + e)
				} else {
					throw ("Huh ?!")
				}
			}
		}
		h = h.substring(d[0].length)
	}
	return k.join("")
};
var dateFormat = function() {
	var a = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
		b = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
		d = /[^-+\dA-Z]/g,
		c = function(f, e) {
			f = String(f);
			e = e || 2;
			while (f.length < e) {
				f = "0" + f
			}
			return f
		};
	return function(i, v, q) {
		var g = dateFormat;
		if (arguments.length == 1 && Object.prototype.toString.call(i) == "[object String]" && !/\d/.test(i)) {
			v = i;
			i = undefined
		}
		i = i ? new Date(i) : new Date;
		if (isNaN(i)) {
			throw SyntaxError("invalid date")
		}
		v = String(g.masks[v] || v || g.masks["default"]);
		if (v.slice(0, 4) == "UTC:") {
			v = v.slice(4);
			q = true
		}
		var t = q ? "getUTC" : "get",
			l = i[t + "Date"](),
			e = i[t + "Day"](),
			j = i[t + "Month"](),
			p = i[t + "FullYear"](),
			r = i[t + "Hours"](),
			k = i[t + "Minutes"](),
			u = i[t + "Seconds"](),
			n = i[t + "Milliseconds"](),
			f = q ? 0 : i.getTimezoneOffset(),
			h = {
				d: l,
				dd: c(l),
				ddd: g.i18n.dayNames[e],
				dddd: g.i18n.dayNames[e + 7],
				m: j + 1,
				mm: c(j + 1),
				mmm: g.i18n.monthNames[j],
				mmmm: g.i18n.monthNames[j + 12],
				yy: String(p).slice(2),
				yyyy: p,
				h: r % 12 || 12,
				hh: c(r % 12 || 12),
				H: r,
				HH: c(r),
				M: k,
				MM: c(k),
				s: u,
				ss: c(u),
				l: c(n, 3),
				L: c(n > 99 ? Math.round(n / 10) : n),
				t: r < 12 ? "a" : "p",
				tt: r < 12 ? "am" : "pm",
				T: r < 12 ? "A" : "P",
				TT: r < 12 ? "AM" : "PM",
				Z: q ? "UTC" : (String(i).match(b) || [""]).pop().replace(d, ""),
				o: (f > 0 ? "-" : "+") + c(Math.floor(Math.abs(f) / 60) * 100 + Math.abs(f) % 60, 4),
				S: ["th", "st", "nd", "rd"][l % 10 > 3 ? 0 : (l % 100 - l % 10 != 10) * l % 10]
			};
		return v.replace(a, function(m) {
			return m in h ? h[m] : m.slice(1, m.length - 1)
		})
	}
}();
dateFormat.masks = {
	"default": "ddd mmm dd yyyy HH:MM:ss",
	shortDate: "m/d/yy",
	mediumDate: "mmm d, yyyy",
	longDate: "mmmm d, yyyy",
	fullDate: "dddd, mmmm d, yyyy",
	shortTime: "h:MM TT",
	mediumTime: "h:MM:ss TT",
	longTime: "h:MM:ss TT Z",
	isoDate: "yyyy-mm-dd",
	isoTime: "HH:MM:ss",
	isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
	dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function(a, b) {
	return dateFormat(this, a, b)
};
var Conrec = (function() {
	var d = 1e-20;
	var c = function(h, g) {
		var f = h.x - g.x,
			i = h.y - g.y;
		return f * f + i * i < d
	};
	var e = function(h) {
		var f = h.head;
		while (f) {
			var g = f.next;
			f.next = f.prev;
			f.prev = g;
			f = g
		}
		var g = h.head;
		h.head = h.tail;
		h.tail = g
	};
	var b = function(f) {
		this.level = f;
		this.s = null;
		this.count = 0
	};
	b.prototype.remove_seq = function(f) {
		if (f.prev) {
			f.prev.next = f.next
		} else {
			this.s = f.next
		}
		if (f.next) {
			f.next.prev = f.prev
		}--this.count
	};
	b.prototype.addSegment = function(k, j) {
		var p = this.s;
		var m = null;
		var l = null;
		var o = false;
		var n = false;
		while (p) {
			if (m == null) {
				if (c(k, p.head.p)) {
					m = p;
					o = true
				} else {
					if (c(k, p.tail.p)) {
						m = p
					}
				}
			}
			if (l == null) {
				if (c(j, p.head.p)) {
					l = p;
					n = true
				} else {
					if (c(j, p.tail.p)) {
						l = p
					}
				}
			}
			if (l != null && m != null) {
				break
			} else {
				p = p.next
			}
		}
		var i = ((m != null) ? 1 : 0) | ((l != null) ? 2 : 0);
		switch (i) {
			case 0:
				var f = {
					p: k,
					prev: null
				};
				var h = {
					p: j,
					next: null
				};
				f.next = h;
				h.prev = f;
				m = {
					head: f,
					tail: h,
					next: this.s,
					prev: null,
					closed: false
				};
				if (this.s) {
					this.s.prev = m
				}
				this.s = m;
				++this.count;
				break;
			case 1:
				var g = {
					p: j
				};
				if (o) {
					g.next = m.head;
					g.prev = null;
					m.head.prev = g;
					m.head = g
				} else {
					g.next = null;
					g.prev = m.tail;
					m.tail.next = g;
					m.tail = g
				}
				break;
			case 2:
				var g = {
					p: k
				};
				if (n) {
					g.next = l.head;
					g.prev = null;
					l.head.prev = g;
					l.head = g
				} else {
					g.next = null;
					g.prev = l.tail;
					l.tail.next = g;
					l.tail = g
				}
				break;
			case 3:
				if (m === l) {
					var g = {
						p: m.tail.p,
						next: m.head,
						prev: null
					};
					m.head.prev = g;
					m.head = g;
					m.closed = true;
					break
				}
				switch ((o ? 1 : 0) | (n ? 2 : 0)) {
					case 0:
						e(m);
					case 1:
						l.tail.next = m.head;
						m.head.prev = l.tail;
						l.tail = m.tail;
						this.remove_seq(m);
						break;
					case 3:
						e(m);
					case 2:
						m.tail.next = l.head;
						l.head.prev = m.tail;
						m.tail = l.tail;
						this.remove_seq(l);
						break
				}
		}
	};
	var a = function(f) {
		if (!f) {
			var g = this;
			g.contours = {};
			this.drawContour = function(j, i, o, n, m, l) {
				var h = g.contours[l];
				if (!h) {
					h = g.contours[l] = new b(m)
				}
				h.addSegment({
					x: j,
					y: i
				}, {
					x: o,
					y: n
				})
			};
			this.contourList = function() {
				var m = [];
				var j = g.contours;
				for (var n in j) {
					var p = j[n].s;
					var q = j[n].level;
					while (p) {
						var o = p.head;
						var i = [];
						i.level = q;
						i.k = n;
						while (o && o.p) {
							i.push(o.p);
							o = o.next
						}
						m.push(i);
						p = p.next
					}
				}
				m.sort(function(k, h) {
					return h.k - k.k
				});
				return m
			}
		} else {
			this.drawContour = f
		}
		this.h = new Array(5);
		this.sh = new Array(5);
		this.xh = new Array(5);
		this.yh = new Array(5)
	};
	a.prototype.contour = function(Q, L, P, r, u, B, A, t, v) {
		var N = this.h,
			S = this.sh,
			D = this.xh,
			U = this.yh;
		var H = this.drawContour;
		this.contours = {};
		var q = function(i, h) {
			return (N[h] * D[i] - N[i] * D[h]) / (N[h] - N[i])
		};
		var R = function(i, h) {
			return (N[h] * U[i] - N[i] * U[h]) / (N[h] - N[i])
		};
		var l;
		var g;
		var f;
		var s;
		var C;
		var E;
		var O = 0;
		var M = 0;
		var o = 0;
		var n = 0;
		var w = [0, 1, 1, 0];
		var K = [0, 0, 1, 1];
		var p = [
			[
				[0, 0, 8],
				[0, 2, 5],
				[7, 6, 9]
			],
			[
				[0, 3, 4],
				[1, 3, 1],
				[4, 3, 0]
			],
			[
				[9, 6, 7],
				[5, 2, 0],
				[8, 0, 0]
			]
		];
		for (var I = (u - 1); I >= r; I--) {
			for (var J = L; J <= P - 1; J++) {
				var V, T;
				V = Math.min(Q[J][I], Q[J][I + 1]);
				T = Math.min(Q[J + 1][I], Q[J + 1][I + 1]);
				C = Math.min(V, T);
				V = Math.max(Q[J][I], Q[J][I + 1]);
				T = Math.max(Q[J + 1][I], Q[J + 1][I + 1]);
				E = Math.max(V, T);
				if (E >= v[0] && C <= v[t - 1]) {
					for (var G = 0; G < t; G++) {
						if (v[G] >= C && v[G] <= E) {
							for (var F = 4; F >= 0; F--) {
								if (F > 0) {
									N[F] = Q[J + w[F - 1]][I + K[F - 1]] - v[G];
									D[F] = B[J + w[F - 1]];
									U[F] = A[I + K[F - 1]]
								} else {
									N[0] = 0.25 * (N[1] + N[2] + N[3] + N[4]);
									D[0] = 0.5 * (B[J] + B[J + 1]);
									U[0] = 0.5 * (A[I] + A[I + 1])
								}
								if (N[F] > 0) {
									S[F] = 1
								} else {
									if (N[F] < 0) {
										S[F] = -1
									} else {
										S[F] = 0
									}
								}
							}
							for (F = 1; F <= 4; F++) {
								l = F;
								g = 0;
								if (F != 4) {
									f = F + 1
								} else {
									f = 1
								}
								s = p[S[l] + 1][S[g] + 1][S[f] + 1];
								if (s != 0) {
									switch (s) {
										case 1:
											O = D[l];
											o = U[l];
											M = D[g];
											n = U[g];
											break;
										case 2:
											O = D[g];
											o = U[g];
											M = D[f];
											n = U[f];
											break;
										case 3:
											O = D[f];
											o = U[f];
											M = D[l];
											n = U[l];
											break;
										case 4:
											O = D[l];
											o = U[l];
											M = q(g, f);
											n = R(g, f);
											break;
										case 5:
											O = D[g];
											o = U[g];
											M = q(f, l);
											n = R(f, l);
											break;
										case 6:
											O = D[f];
											o = U[f];
											M = q(l, g);
											n = R(l, g);
											break;
										case 7:
											O = q(l, g);
											o = R(l, g);
											M = q(g, f);
											n = R(g, f);
											break;
										case 8:
											O = q(g, f);
											o = R(g, f);
											M = q(f, l);
											n = R(f, l);
											break;
										case 9:
											O = q(f, l);
											o = R(f, l);
											M = q(l, g);
											n = R(l, g);
											break;
										default:
											break
									}
									H(O, o, M, n, v[G], G)
								}
							}
						}
					}
				}
			}
		}
	};
	return a
})();
if (typeof exports !== "undefined") {
	exports.Conrec = Conrec
};
(function() {
	jLouvain = function() {
		var l = -1;
		var k = 1e-7;
		var i;
		var y;
		var s = {};
		var a;

		function d(C) {
			var B = {};
			C.forEach(function(E, D) {
				B[E] = true
			});
			return Object.keys(B)
		}

		function x(D) {
			var C = [];
			for (var B in D) {
				if (D.hasOwnProperty(B)) {
					C.push(D[B])
				}
			}
			return C
		}

		function v(E, C) {
			var B = E._assoc_mat[C] ? Object.keys(E._assoc_mat[C]) : [];
			var D = 0;
			B.forEach(function(F, G) {
				var H = E._assoc_mat[C][F] || 1;
				if (C == F) {
					H *= 2
				}
				D += H
			});
			return D
		}

		function f(D, C) {
			if (typeof D._assoc_mat[C] == "undefined") {
				return []
			}
			var B = Object.keys(D._assoc_mat[C]);
			return B
		}

		function g(D, C, B) {
			return D._assoc_mat[C] ? D._assoc_mat[C][B] : undefined
		}

		function A(C) {
			var B = 0;
			C.edges.forEach(function(D) {
				B += D.weight
			});
			return B
		}

		function c(D, C) {
			e(D, C);
			var B = D.edges.map(function(E) {
				return E.id1 + "_" + E.id2
			}).indexOf(C.id1 + "_" + C.id2);
			if (B != -1) {
				D.edges[B].weight = C.weight
			} else {
				D.edges.push(C)
			}
		}

		function z(B) {
			var C = {};
			B.forEach(function(E, D) {
				E.weight = E.weight || 1;
				C[E.id1] = C[E.id1] || {};
				C[E.id1][E.id2] = E.weight;
				C[E.id2] = C[E.id2] || {};
				C[E.id2][E.id1] = E.weight
			});
			return C
		}

		function e(C, B) {
			C._assoc_mat[B.id1] = C._assoc_mat[B.id1] || {};
			C._assoc_mat[B.id1][B.id2] = B.weight;
			C._assoc_mat[B.id2] = C._assoc_mat[B.id2] || {};
			C._assoc_mat[B.id2][B.id1] = B.weight
		}

		function t(D) {
			if (D == null || typeof(D) != "object") {
				return D
			}
			var B = D.constructor();
			for (var C in D) {
				B[C] = t(D[C])
			}
			return B
		}

		function p(D, B, C) {
			B.nodes_to_com = {};
			B.total_weight = 0;
			B.internals = {};
			B.degrees = {};
			B.gdegrees = {};
			B.loops = {};
			B.total_weight = A(D);
			if (typeof C == "undefined") {
				D.nodes.forEach(function(G, E) {
					B.nodes_to_com[G] = E;
					var F = v(D, G);
					if (F < 0) {
						throw "Bad graph type, use positive weights!"
					}
					B.degrees[E] = F;
					B.gdegrees[G] = F;
					B.loops[G] = g(D, G, G) || 0;
					B.internals[E] = B.loops[G]
				})
			} else {
				D.nodes.forEach(function(I, G) {
					var E = C[I];
					B.nodes_to_com[I] = E;
					var H = v(D, I);
					B.degrees[E] = (B.degrees[E] || 0) + H;
					B.gdegrees[I] = H;
					var J = 0;
					var F = f(D, I);
					F.forEach(function(K, L) {
						var M = D._assoc_mat[I][K];
						if (M <= 0) {
							throw "Bad graph type, use positive weights"
						}
						if (C[K] == E) {
							if (K == I) {
								J += M
							} else {
								J += M / 2
							}
						}
					});
					B.internals[E] = (B.internals[E] || 0) + J
				})
			}
		}

		function o(C) {
			var E = C.total_weight;
			var B = 0;
			var D = d(x(C.nodes_to_com));
			D.forEach(function(F, G) {
				var I = C.internals[F] || 0;
				var H = C.degrees[F] || 0;
				if (E > 0) {
					B = B + I / E - Math.pow((H / (2 * E)), 2)
				}
			});
			return B
		}

		function m(D, E, B) {
			var C = {};
			var F = f(E, D);
			F.forEach(function(G, H) {
				if (G != D) {
					var I = E._assoc_mat[D][G] || 1;
					var J = B.nodes_to_com[G];
					C[J] = (C[J] || 0) + I
				}
			});
			return C
		}

		function u(D, C, E, B) {
			B.nodes_to_com[D] = +C;
			B.degrees[C] = (B.degrees[C] || 0) + (B.gdegrees[D] || 0);
			B.internals[C] = (B.internals[C] || 0) + E + (B.loops[D] || 0)
		}

		function r(D, C, E, B) {
			B.degrees[C] = ((B.degrees[C] || 0) - (B.gdegrees[D] || 0));
			B.internals[C] = ((B.internals[C] || 0) - E - (B.loops[D] || 0));
			B.nodes_to_com[D] = -1
		}

		function j(F) {
			var D = 0;
			var B = t(F);
			var C = {};
			var E = Object.keys(F);
			E.forEach(function(H) {
				var I = F[H];
				var G = typeof C[I] == "undefined" ? -1 : C[I];
				if (G == -1) {
					C[I] = D;
					G = D;
					D = D + 1
				}
				B[H] = G
			});
			return B
		}

		function b(F, B) {
			var D = true,
				G = 0,
				E = o(B),
				C = E;
			while (D && G != l) {
				E = C;
				D = false;
				G += 1;
				F.nodes.forEach(function(J, I) {
					var M = B.nodes_to_com[J];
					var O = (B.gdegrees[J] || 0) / (B.total_weight * 2);
					var L = m(J, F, B);
					r(J, M, (L[M] || 0), B);
					var N = M;
					var H = 0;
					var K = Object.keys(L);
					K.forEach(function(P, Q) {
						var R = L[P] - (B.degrees[P] || 0) * O;
						if (R > H) {
							H = R;
							N = P
						}
					});
					u(J, N, L[N] || 0, B);
					if (N != M) {
						D = true
					}
				});
				C = o(B);
				if (C - E < k) {
					break
				}
			}
		}

		function h(C, G) {
			var B = {
				nodes: [],
				edges: [],
				_assoc_mat: {}
			};
			var D, F;
			var E = x(C);
			B.nodes = B.nodes.concat(d(E));
			G.edges.forEach(function(I, H) {
				F = I.weight || 1;
				var L = C[I.id1];
				var J = C[I.id2];
				D = (g(B, L, J) || 0);
				var K = (D + F);
				c(B, {
					source: L,
					target: J,
					weight: K
				})
			});
			return B
		}

		function w(C, E) {
			var B = t(C[0]);
			for (var D = 1; D < E + 1; D++) {
				Object.keys(B).forEach(function(H, G) {
					var I = H;
					var F = B[H];
					B[I] = C[D][F]
				})
			}
			return B
		}

		function n(J, D) {
			if (J.edges.length == 0) {
				var C = {};
				J.nodes.forEach(function(L, K) {
					C[L] = L
				});
				return C
			}
			var F = {};
			p(s, F, D);
			var H = o(F);
			var I = [];
			b(s, F);
			var B = o(F);
			var G = j(F.nodes_to_com);
			I.push(G);
			H = B;
			var E = h(G, s);
			p(E, F);
			while (true) {
				b(E, F);
				B = o(F);
				if (B - H < k) {
					break
				}
				G = j(F.nodes_to_com);
				I.push(G);
				H = B;
				E = h(G, E);
				p(E, F)
			}
			return I
		}
		var q = function() {
			var B = {};
			var C = n(s, a);
			return w(C, C.length - 1)
		};
		q.nodes = function(B) {
			if (arguments.length > 0) {
				i = B
			}
			return q
		};
		q.edges = function(C) {
			if (typeof i == "undefined") {
				throw "Please provide the graph nodes first!"
			}
			if (arguments.length > 0) {
				y = C;
				var B = z(C);
				s = {
					nodes: i,
					edges: y,
					_assoc_mat: B
				}
			}
			return q
		};
		q.partition_init = function(B) {
			if (arguments.length > 0) {
				a = B
			}
			return q
		};
		return q
	}
})(); /*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */
(function(a) {
	a.URL = a.URL || a.webkitURL;
	if (a.Blob && a.URL) {
		try {
			new Blob;
			return
		} catch (d) {}
	}
	var c = a.BlobBuilder || a.WebKitBlobBuilder || a.MozBlobBuilder || (function(p) {
		var g = function(z) {
				return Object.prototype.toString.call(z).match(/^\[object\s(.*)\]$/)[1]
			},
			y = function m() {
				this.data = []
			},
			w = function i(B, z, A) {
				this.data = B;
				this.size = B.length;
				this.type = z;
				this.encoding = A
			},
			q = y.prototype,
			v = w.prototype,
			s = p.FileReaderSync,
			e = function(z) {
				this.code = this[this.name = z]
			},
			r = ("NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
			u = r.length,
			l = p.URL || p.webkitURL || p,
			t = l.createObjectURL,
			f = l.revokeObjectURL,
			k = l,
			o = p.btoa,
			j = p.atob,
			h = p.ArrayBuffer,
			n = p.Uint8Array,
			x = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
		w.fake = v.fake = true;
		while (u--) {
			e.prototype[r[u]] = u + 1
		}
		if (!l.createObjectURL) {
			k = p.URL = function(A) {
				var z = document.createElementNS("http://www.w3.org/1999/xhtml", "a"),
					B;
				z.href = A;
				if (!("origin" in z)) {
					if (z.protocol.toLowerCase() === "data:") {
						z.origin = null
					} else {
						B = A.match(x);
						z.origin = B && B[1]
					}
				}
				return z
			}
		}
		k.createObjectURL = function(A) {
			var B = A.type,
				z;
			if (B === null) {
				B = "application/octet-stream"
			}
			if (A instanceof w) {
				z = "data:" + B;
				if (A.encoding === "base64") {
					return z + ";base64," + A.data
				} else {
					if (A.encoding === "URI") {
						return z + "," + decodeURIComponent(A.data)
					}
				}
				if (o) {
					return z + ";base64," + o(A.data)
				} else {
					return z + "," + encodeURIComponent(A.data)
				}
			} else {
				if (t) {
					return t.call(l, A)
				}
			}
		};
		k.revokeObjectURL = function(z) {
			if (z.substring(0, 5) !== "data:" && f) {
				f.call(l, z)
			}
		};
		q.append = function(D) {
			var F = this.data;
			if (n && (D instanceof h || D instanceof n)) {
				var E = "",
					A = new n(D),
					B = 0,
					C = A.length;
				for (; B < C; B++) {
					E += String.fromCharCode(A[B])
				}
				F.push(E)
			} else {
				if (g(D) === "Blob" || g(D) === "File") {
					if (s) {
						var z = new s;
						F.push(z.readAsBinaryString(D))
					} else {
						throw new e("NOT_READABLE_ERR")
					}
				} else {
					if (D instanceof w) {
						if (D.encoding === "base64" && j) {
							F.push(j(D.data))
						} else {
							if (D.encoding === "URI") {
								F.push(decodeURIComponent(D.data))
							} else {
								if (D.encoding === "raw") {
									F.push(D.data)
								}
							}
						}
					} else {
						if (typeof D !== "string") {
							D += ""
						}
						F.push(unescape(encodeURIComponent(D)))
					}
				}
			}
		};
		q.getBlob = function(z) {
			if (!arguments.length) {
				z = null
			}
			return new w(this.data.join(""), z, "raw")
		};
		q.toString = function() {
			return "[object BlobBuilder]"
		};
		v.slice = function(C, z, B) {
			var A = arguments.length;
			if (A < 3) {
				B = null
			}
			return new w(this.data.slice(C, A > 1 ? z : this.data.length), B, this.encoding)
		};
		v.toString = function() {
			return "[object Blob]"
		};
		v.close = function() {
			this.size = 0;
			delete this.data
		};
		return y
	}(a));
	a.Blob = function(j, h) {
		var l = h ? (h.type || "") : "";
		var g = new c();
		if (j) {
			for (var k = 0, e = j.length; k < e; k++) {
				if (Uint8Array && j[k] instanceof Uint8Array) {
					g.append(j[k].buffer)
				} else {
					g.append(j[k])
				}
			}
		}
		var f = g.getBlob(l);
		if (!f.slice && f.webkitSlice) {
			f.slice = f.webkitSlice
		}
		return f
	};
	var b = Object.getPrototypeOf || function(e) {
		return e.__proto__
	};
	a.Blob.prototype = b(new a.Blob())
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */
(function(a) {
	var b = a.Uint8Array,
		d = a.HTMLCanvasElement,
		c = d && d.prototype,
		e = /\s*;\s*base64\s*(?:;|$)/i,
		f = "toDataURL",
		h, g = function(p) {
			var q = p.length,
				m = new b(q / 4 * 3 | 0),
				o = 0,
				s = 0,
				t = [0, 0],
				j = 0,
				r = 0,
				n, k, l;
			while (q--) {
				k = p.charCodeAt(o++);
				n = h[k - 43];
				if (n !== 255 && n !== l) {
					t[1] = t[0];
					t[0] = k;
					r = (r << 6) | n;
					j++;
					if (j === 4) {
						m[s++] = r >>> 16;
						if (t[1] !== 61) {
							m[s++] = r >>> 8
						}
						if (t[0] !== 61) {
							m[s++] = r
						}
						j = 0
					}
				}
			}
			return m
		};
	if (b) {
		h = new b([62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51])
	}
	if (d && !c.toBlob) {
		c.toBlob = function(p, n) {
			if (!n) {
				n = "image/png"
			}
			if (this.mozGetAsFile) {
				p(this.mozGetAsFile("canvas", n));
				return
			}
			if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(n)) {
				p(this.msToBlob());
				return
			}
			var m = Array.prototype.slice.call(arguments, 1),
				k = this[f].apply(this, m),
				j = k.indexOf(","),
				o = k.substring(j + 1),
				i = e.test(k.substring(0, j)),
				l;
			if (Blob.fake) {
				l = new Blob;
				if (i) {
					l.encoding = "base64"
				} else {
					l.encoding = "URI"
				}
				l.data = o;
				l.size = o.length
			} else {
				if (b) {
					if (i) {
						l = new Blob([g(o)], {
							type: n
						})
					} else {
						l = new Blob([decodeURIComponent(o)], {
							type: n
						})
					}
				}
			}
			p(l)
		};
		if (c.toDataURLHD) {
			c.toBlobHD = function() {
				f = "toDataURLHD";
				var i = this.toBlob();
				f = "toDataURL";
				return i
			}
		} else {
			c.toBlobHD = c.toBlob
		}
	}
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
;
var saveAs = saveAs || (function(g) {
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return
	}
	var r = g.document,
		l = function() {
			return g.URL || g.webkitURL || g
		},
		n = r.createElementNS("http://www.w3.org/1999/xhtml", "a"),
		e = "download" in n,
		j = function(t) {
			var s = r.createEvent("MouseEvents");
			s.initMouseEvent("click", true, false, g, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
			t.dispatchEvent(s)
		},
		o = g.webkitRequestFileSystem,
		p = g.requestFileSystem || o || g.mozRequestFileSystem,
		m = function(s) {
			(g.setImmediate || g.setTimeout)(function() {
				throw s
			}, 0)
		},
		b = "application/octet-stream",
		k = 0,
		h = 500,
		i = function(t) {
			var s = function() {
				if (typeof t === "string") {
					l().revokeObjectURL(t)
				} else {
					t.remove()
				}
			};
			if (g.chrome) {
				s()
			} else {
				setTimeout(s, h)
			}
		},
		q = function(t, s, w) {
			s = [].concat(s);
			var v = s.length;
			while (v--) {
				var x = t["on" + s[v]];
				if (typeof x === "function") {
					try {
						x.call(t, w || t)
					} catch (u) {
						m(u)
					}
				}
			}
		},
		f = function(s) {
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(s.type)) {
				return new Blob(["\ufeff", s], {
					type: s.type
				})
			}
			return s
		},
		d = function(s, t) {
			s = f(s);
			var u = this,
				A = s.type,
				D = false,
				w, v, z = function() {
					q(u, "writestart progress write writeend".split(" "))
				},
				C = function() {
					if (D || !w) {
						w = l().createObjectURL(s)
					}
					if (v) {
						v.location.href = w
					} else {
						var E = g.open(w, "_blank");
						if (E == undefined && typeof safari !== "undefined") {
							g.location.href = w
						}
					}
					u.readyState = u.DONE;
					z();
					i(w)
				},
				y = function(E) {
					return function() {
						if (u.readyState !== u.DONE) {
							return E.apply(this, arguments)
						}
					}
				},
				x = {
					create: true,
					exclusive: false
				},
				B;
			u.readyState = u.INIT;
			if (!t) {
				t = "download"
			}
			if (e) {
				w = l().createObjectURL(s);
				n.href = w;
				n.download = t;
				j(n);
				u.readyState = u.DONE;
				z();
				i(w);
				return
			}
			if (g.chrome && A && A !== b) {
				B = s.slice || s.webkitSlice;
				s = B.call(s, 0, s.size, b);
				D = true
			}
			if (o && t !== "download") {
				t += ".download"
			}
			if (A === b || o) {
				v = g
			}
			if (!p) {
				C();
				return
			}
			k += s.size;
			p(g.TEMPORARY, k, y(function(E) {
				E.root.getDirectory("saved", x, y(function(F) {
					var G = function() {
						F.getFile(t, x, y(function(H) {
							H.createWriter(y(function(I) {
								I.onwriteend = function(J) {
									v.location.href = H.toURL();
									u.readyState = u.DONE;
									q(u, "writeend", J);
									i(H)
								};
								I.onerror = function() {
									var J = I.error;
									if (J.code !== J.ABORT_ERR) {
										C()
									}
								};
								"writestart progress write abort".split(" ").forEach(function(J) {
									I["on" + J] = u["on" + J]
								});
								I.write(s);
								u.abort = function() {
									I.abort();
									u.readyState = u.DONE
								};
								u.readyState = u.WRITING
							}), C)
						}), C)
					};
					F.getFile(t, {
						create: false
					}, y(function(H) {
						H.remove();
						G()
					}), y(function(H) {
						if (H.code === H.NOT_FOUND_ERR) {
							G()
						} else {
							C()
						}
					}))
				}), C)
			}), C)
		},
		c = d.prototype,
		a = function(s, t) {
			return new d(s, t)
		};
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(s, t) {
			return navigator.msSaveOrOpenBlob(f(s), t)
		}
	}
	c.abort = function() {
		var s = this;
		s.readyState = s.DONE;
		q(s, "abort")
	};
	c.readyState = c.INIT = 0;
	c.WRITING = 1;
	c.DONE = 2;
	c.error = c.onwritestart = c.onprogress = c.onwrite = c.onabort = c.onerror = c.onwriteend = null;
	return a
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content));
if (typeof module !== "undefined" && module.exports) {
	module.exports.saveAs = saveAs
} else {
	if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
		define([], function() {
			return saveAs
		})
	}
};
"use strict";
var numeric = (typeof exports === "undefined") ? (function numeric() {}) : (exports);
if (typeof global !== "undefined") {
	global.numeric = numeric
}
numeric.version = "1.2.6";
numeric._myIndexOf = (function _myIndexOf(a) {
	var c = this.length,
		b;
	for (b = 0; b < c; ++b) {
		if (this[b] === a) {
			return b
		}
	}
	return -1
});
numeric.myIndexOf = (Array.prototype.indexOf) ? Array.prototype.indexOf : numeric._myIndexOf;
numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;
numeric._dim = function _dim(a) {
	var b = [];
	while (typeof a === "object") {
		b.push(a.length);
		a = a[0]
	}
	return b
};
numeric.dim = function dim(a) {
	var c, b;
	if (typeof a === "object") {
		c = a[0];
		if (typeof c === "object") {
			b = c[0];
			if (typeof b === "object") {
				return numeric._dim(a)
			}
			return [a.length, c.length]
		}
		return [a.length]
	}
	return []
};
numeric.mapreduce = function mapreduce(a, b) {
	return Function("x", "accum", "_s", "_k", 'if(typeof accum === "undefined") accum = ' + b + ';\nif(typeof x === "number") { var xi = x; ' + a + '; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    ' + a + ";\n    xi = x[i-1];\n    " + a + ";\n}\nif(i === 0) {\n    xi = x[i];\n    " + a + "\n}\nreturn accum;")
};
numeric.mapreduce2 = function mapreduce2(b, a) {
	return Function("x", "var n = x.length;\nvar i,xi;\n" + a + ";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    " + b + ";\n}\nreturn accum;")
};
numeric.same = function same(a, d) {
	var b, c;
	if (!(a instanceof Array) || !(d instanceof Array)) {
		return false
	}
	c = a.length;
	if (c !== d.length) {
		return false
	}
	for (b = 0; b < c; b++) {
		if (a[b] === d[b]) {
			continue
		}
		if (typeof a[b] === "object") {
			if (!same(a[b], d[b])) {
				return false
			}
		} else {
			return false
		}
	}
	return true
};
numeric.rep = function rep(e, b, a) {
	if (typeof a === "undefined") {
		a = 0
	}
	var f = e[a],
		c = Array(f),
		d;
	if (a === e.length - 1) {
		for (d = f - 2; d >= 0; d -= 2) {
			c[d + 1] = b;
			c[d] = b
		}
		if (d === -1) {
			c[0] = b
		}
		return c
	}
	for (d = f - 1; d >= 0; d--) {
		c[d] = numeric.rep(e, b, a + 1)
	}
	return c
};
numeric.dotMMsmall = function dotMMsmall(v, u) {
	var l, g, e, c, b, a, n, s, m, h, f, o, w, d;
	c = v.length;
	b = u.length;
	a = u[0].length;
	n = Array(c);
	for (l = c - 1; l >= 0; l--) {
		s = Array(a);
		m = v[l];
		for (e = a - 1; e >= 0; e--) {
			h = m[b - 1] * u[b - 1][e];
			for (g = b - 2; g >= 1; g -= 2) {
				f = g - 1;
				h += m[g] * u[g][e] + m[f] * u[f][e]
			}
			if (g === 0) {
				h += m[0] * u[0][e]
			}
			s[e] = h
		}
		n[l] = s
	}
	return n
};
numeric._getCol = function _getCol(b, c, a) {
	var e = b.length,
		d;
	for (d = e - 1; d > 0; --d) {
		a[d] = b[d][c];
		--d;
		a[d] = b[d][c]
	}
	if (d === 0) {
		a[0] = b[0][c]
	}
};
numeric.dotMMbig = function dotMMbig(r, q) {
	var s = numeric._getCol,
		a = q.length,
		u = Array(a);
	var d = r.length,
		c = q[0].length,
		b = new Array(d),
		l;
	var f = numeric.dotVV;
	var h, g, e, o;
	--a;
	--d;
	for (h = d; h !== -1; --h) {
		b[h] = Array(c)
	}--c;
	for (h = c; h !== -1; --h) {
		s(q, h, u);
		for (g = d; g !== -1; --g) {
			o = 0;
			l = r[g];
			b[g][h] = f(l, u)
		}
	}
	return b
};
numeric.dotMV = function dotMV(a, g) {
	var e = a.length,
		d = g.length,
		c;
	var b = Array(e),
		f = numeric.dotVV;
	for (c = e - 1; c >= 0; c--) {
		b[c] = f(a[c], g)
	}
	return b
};
numeric.dotVM = function dotVM(h, g) {
	var w, v, u, n, m, l, D, B, A, e, s, f, c, z, d, b, a, o, C;
	n = h.length;
	m = g[0].length;
	D = Array(m);
	for (u = m - 1; u >= 0; u--) {
		e = h[n - 1] * g[n - 1][u];
		for (v = n - 2; v >= 1; v -= 2) {
			s = v - 1;
			e += h[v] * g[v][u] + h[s] * g[s][u]
		}
		if (v === 0) {
			e += h[0] * g[0][u]
		}
		D[u] = e
	}
	return D
};
numeric.dotVV = function dotVV(a, f) {
	var c, e = a.length,
		d, b = a[e - 1] * f[e - 1];
	for (c = e - 2; c >= 1; c -= 2) {
		d = c - 1;
		b += a[c] * f[c] + a[d] * f[d]
	}
	if (c === 0) {
		b += a[0] * f[0]
	}
	return b
};
numeric.dot = function dot(a, c) {
	var b = numeric.dim;
	switch (b(a).length * 1000 + b(c).length) {
		case 2002:
			if (c.length < 10) {
				return numeric.dotMMsmall(a, c)
			} else {
				return numeric.dotMMbig(a, c)
			}
		case 2001:
			return numeric.dotMV(a, c);
		case 1002:
			return numeric.dotVM(a, c);
		case 1001:
			return numeric.dotVV(a, c);
		case 1000:
			return numeric.mulVS(a, c);
		case 1:
			return numeric.mulSV(a, c);
		case 0:
			return a * c;
		default:
			throw new Error("numeric.dot only works on vectors and matrices")
	}
};
numeric.diag = function diag(g) {
	var e, f, c, h = g.length,
		a = Array(h),
		b;
	for (e = h - 1; e >= 0; e--) {
		b = Array(h);
		f = e + 2;
		for (c = h - 1; c >= f; c -= 2) {
			b[c] = 0;
			b[c - 1] = 0
		}
		if (c > e) {
			b[c] = 0
		}
		b[e] = g[e];
		for (c = e - 1; c >= 1; c -= 2) {
			b[c] = 0;
			b[c - 1] = 0
		}
		if (c === 0) {
			b[0] = 0
		}
		a[e] = b
	}
	return a
};
numeric.getDiag = function(a) {
	var d = Math.min(a.length, a[0].length),
		c, b = Array(d);
	for (c = d - 1; c >= 1; --c) {
		b[c] = a[c][c];
		--c;
		b[c] = a[c][c]
	}
	if (c === 0) {
		b[0] = a[0][0]
	}
	return b
};
numeric.identity = function identity(a) {
	return numeric.diag(numeric.rep([a], 1))
};
numeric.pointwise2 = function pointwise2(d, g, c) {
	if (typeof c === "undefined") {
		c = ""
	}
	var h = [];
	var e;
	var i = /\[i\]$/,
		a, f = "";
	var b = false;
	for (e = 0; e < d.length; e++) {
		if (i.test(d[e])) {
			a = d[e].substring(0, d[e].length - 3);
			f = a
		} else {
			a = d[e]
		}
		if (a === "ret") {
			b = true
		}
		h.push(a)
	}
	h[d.length] = ("var _n = " + f + ".length;\nvar i" + (b ? "" : ", ret = Array(_n)") + ";\n" + c + "\nfor(i=_n-1;i!==-1;--i) {\n" + g + "\n}\nreturn ret;");
	return Function.apply(null, h)
};
numeric._biforeach = (function _biforeach(a, h, d, b, e) {
	if (b === d.length - 1) {
		e(a, h);
		return
	}
	var c, g = d[b];
	for (c = g - 1; c >= 0; c--) {
		_biforeach(typeof a === "object" ? a[c] : a, typeof h === "object" ? h[c] : h, d, b + 1, e)
	}
});
numeric._biforeach2 = (function _biforeach2(a, j, e, b, g) {
	if (b === e.length - 1) {
		return g(a, j)
	}
	var d, h = e[b],
		c = Array(h);
	for (d = h - 1; d >= 0; --d) {
		c[d] = _biforeach2(typeof a === "object" ? a[d] : a, typeof j === "object" ? j[d] : j, e, b + 1, g)
	}
	return c
});
numeric._foreach = (function _foreach(a, d, b, e) {
	if (b === d.length - 1) {
		e(a);
		return
	}
	var c, g = d[b];
	for (c = g - 1; c >= 0; c--) {
		_foreach(a[c], d, b + 1, e)
	}
});
numeric._foreach2 = (function _foreach2(a, e, b, g) {
	if (b === e.length - 1) {
		return g(a)
	}
	var d, h = e[b],
		c = Array(h);
	for (d = h - 1; d >= 0; d--) {
		c[d] = _foreach2(a[d], e, b + 1, g)
	}
	return c
});
numeric.ops2 = {
	add: "+",
	sub: "-",
	mul: "*",
	div: "/",
	mod: "%",
	and: "&&",
	or: "||",
	eq: "===",
	neq: "!==",
	lt: "<",
	gt: ">",
	leq: "<=",
	geq: ">=",
	band: "&",
	bor: "|",
	bxor: "^",
	lshift: "<<",
	rshift: ">>",
	rrshift: ">>>"
};
numeric.opseq = {
	addeq: "+=",
	subeq: "-=",
	muleq: "*=",
	diveq: "/=",
	modeq: "%=",
	lshifteq: "<<=",
	rshifteq: ">>=",
	rrshifteq: ">>>=",
	bandeq: "&=",
	boreq: "|=",
	bxoreq: "^="
};
numeric.mathfuns = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan", "isNaN", "isFinite"];
numeric.mathfuns2 = ["atan2", "pow", "max", "min"];
numeric.ops1 = {
	neg: "-",
	not: "!",
	bnot: "~",
	clone: ""
};
numeric.mapreducers = {
	any: ["if(xi) return true;", "var accum = false;"],
	all: ["if(!xi) return false;", "var accum = true;"],
	sum: ["accum += xi;", "var accum = 0;"],
	prod: ["accum *= xi;", "var accum = 1;"],
	norm2Squared: ["accum += xi*xi;", "var accum = 0;"],
	norminf: ["accum = max(accum,abs(xi));", "var accum = 0, max = Math.max, abs = Math.abs;"],
	norm1: ["accum += abs(xi)", "var accum = 0, abs = Math.abs;"],
	sup: ["accum = max(accum,xi);", "var accum = -Infinity, max = Math.max;"],
	inf: ["accum = min(accum,xi);", "var accum = Infinity, min = Math.min;"]
};
(function() {
	var b, e;
	for (b = 0; b < numeric.mathfuns2.length; ++b) {
		e = numeric.mathfuns2[b];
		numeric.ops2[e] = e
	}
	for (b in numeric.ops2) {
		if (numeric.ops2.hasOwnProperty(b)) {
			e = numeric.ops2[b];
			var c, d, a = "";
			if (numeric.myIndexOf.call(numeric.mathfuns2, b) !== -1) {
				a = "var " + e + " = Math." + e + ";\n";
				c = function(g, f, h) {
					return g + " = " + e + "(" + f + "," + h + ")"
				};
				d = function(f, g) {
					return f + " = " + e + "(" + f + "," + g + ")"
				}
			} else {
				c = function(g, f, h) {
					return g + " = " + f + " " + e + " " + h
				};
				if (numeric.opseq.hasOwnProperty(b + "eq")) {
					d = function(f, g) {
						return f + " " + e + "= " + g
					}
				} else {
					d = function(f, g) {
						return f + " = " + f + " " + e + " " + g
					}
				}
			}
			numeric[b + "VV"] = numeric.pointwise2(["x[i]", "y[i]"], c("ret[i]", "x[i]", "y[i]"), a);
			numeric[b + "SV"] = numeric.pointwise2(["x", "y[i]"], c("ret[i]", "x", "y[i]"), a);
			numeric[b + "VS"] = numeric.pointwise2(["x[i]", "y"], c("ret[i]", "x[i]", "y"), a);
			numeric[b] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric." + b + "VV, VS = numeric." + b + "VS, SV = numeric." + b + 'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else ' + d("x", "y") + "\n}\nreturn x;\n");
			numeric[e] = numeric[b];
			numeric[b + "eqV"] = numeric.pointwise2(["ret[i]", "x[i]"], d("ret[i]", "x[i]"), a);
			numeric[b + "eqS"] = numeric.pointwise2(["ret[i]", "x"], d("ret[i]", "x"), a);
			numeric[b + "eq"] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric." + b + "eqV, S = numeric." + b + 'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')
		}
	}
	for (b = 0; b < numeric.mathfuns2.length; ++b) {
		e = numeric.mathfuns2[b];
		delete numeric.ops2[e]
	}
	for (b = 0; b < numeric.mathfuns.length; ++b) {
		e = numeric.mathfuns[b];
		numeric.ops1[e] = e
	}
	for (b in numeric.ops1) {
		if (numeric.ops1.hasOwnProperty(b)) {
			a = "";
			e = numeric.ops1[b];
			if (numeric.myIndexOf.call(numeric.mathfuns, b) !== -1) {
				if (Math.hasOwnProperty(e)) {
					a = "var " + e + " = Math." + e + ";\n"
				}
			}
			numeric[b + "eqV"] = numeric.pointwise2(["ret[i]"], "ret[i] = " + e + "(ret[i]);", a);
			numeric[b + "eq"] = Function("x", 'if(typeof x !== "object") return ' + e + "x\nvar i;\nvar V = numeric." + b + "eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n");
			numeric[b + "V"] = numeric.pointwise2(["x[i]"], "ret[i] = " + e + "(x[i]);", a);
			numeric[b] = Function("x", 'if(typeof x !== "object") return ' + e + "(x)\nvar i;\nvar V = numeric." + b + "V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n")
		}
	}
	for (b = 0; b < numeric.mathfuns.length; ++b) {
		e = numeric.mathfuns[b];
		delete numeric.ops1[e]
	}
	for (b in numeric.mapreducers) {
		if (numeric.mapreducers.hasOwnProperty(b)) {
			e = numeric.mapreducers[b];
			numeric[b + "V"] = numeric.mapreduce2(e[0], e[1]);
			numeric[b] = Function("x", "s", "k", e[1] + 'if(typeof x !== "object") {    xi = x;\n' + e[0] + ';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.' + b + "V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n" + e[0] + ";\n}\nreturn accum;\n")
		}
	}
}());
numeric.det = function det(p) {
	var u = numeric.dim(p);
	if (u.length !== 2 || u[0] !== u[1]) {
		throw new Error("numeric: det() only works on square matrices")
	}
	var b = u[0],
		l = 1,
		f, e, d, a = numeric.clone(p),
		o, q, c, r, m, h, g;
	for (e = 0; e < b - 1; e++) {
		d = e;
		for (f = e + 1; f < b; f++) {
			if (Math.abs(a[f][e]) > Math.abs(a[d][e])) {
				d = f
			}
		}
		if (d !== e) {
			r = a[d];
			a[d] = a[e];
			a[e] = r;
			l *= -1
		}
		o = a[e];
		for (f = e + 1; f < b; f++) {
			q = a[f];
			c = q[e] / o[e];
			for (d = e + 1; d < b - 1; d += 2) {
				m = d + 1;
				q[d] -= o[d] * c;
				q[m] -= o[m] * c
			}
			if (d !== b) {
				q[d] -= o[d] * c
			}
		}
		if (o[e] === 0) {
			return 0
		}
		l *= o[e]
	}
	return l * a[e][e]
};
numeric.transpose = function transpose(k) {
	var g, e, c = k.length,
		a = k[0].length,
		h = Array(a),
		d, b, f;
	for (e = 0; e < a; e++) {
		h[e] = Array(c)
	}
	for (g = c - 1; g >= 1; g -= 2) {
		b = k[g];
		d = k[g - 1];
		for (e = a - 1; e >= 1; --e) {
			f = h[e];
			f[g] = b[e];
			f[g - 1] = d[e];
			--e;
			f = h[e];
			f[g] = b[e];
			f[g - 1] = d[e]
		}
		if (e === 0) {
			f = h[0];
			f[g] = b[0];
			f[g - 1] = d[0]
		}
	}
	if (g === 0) {
		d = k[0];
		for (e = a - 1; e >= 1; --e) {
			h[e][0] = d[e];
			--e;
			h[e][0] = d[e]
		}
		if (e === 0) {
			h[0][0] = d[0]
		}
	}
	return h
};
numeric.negtranspose = function negtranspose(k) {
	var g, e, c = k.length,
		a = k[0].length,
		h = Array(a),
		d, b, f;
	for (e = 0; e < a; e++) {
		h[e] = Array(c)
	}
	for (g = c - 1; g >= 1; g -= 2) {
		b = k[g];
		d = k[g - 1];
		for (e = a - 1; e >= 1; --e) {
			f = h[e];
			f[g] = -b[e];
			f[g - 1] = -d[e];
			--e;
			f = h[e];
			f[g] = -b[e];
			f[g - 1] = -d[e]
		}
		if (e === 0) {
			f = h[0];
			f[g] = -b[0];
			f[g - 1] = -d[0]
		}
	}
	if (g === 0) {
		d = k[0];
		for (e = a - 1; e >= 1; --e) {
			h[e][0] = -d[e];
			--e;
			h[e][0] = -d[e]
		}
		if (e === 0) {
			h[0][0] = -d[0]
		}
	}
	return h
};
numeric.norm2 = function norm2(a) {
	return Math.sqrt(numeric.norm2Squared(a))
};
numeric.getBlock = function getBlock(a, e, d) {
	var b = numeric.dim(a);

	function c(f, h) {
		var l, g = e[h],
			m = d[h] - g,
			j = Array(m);
		if (h === b.length - 1) {
			for (l = m; l >= 0; l--) {
				j[l] = f[l + g]
			}
			return j
		}
		for (l = m; l >= 0; l--) {
			j[l] = c(f[l + g], h + 1)
		}
		return j
	}
	return c(a, 0)
};
numeric.setBlock = function setBlock(a, f, e, d) {
	var b = numeric.dim(a);

	function c(g, o, j) {
		var l, h = f[j],
			m = e[j] - h;
		if (j === b.length - 1) {
			for (l = m; l >= 0; l--) {
				g[l + h] = o[l]
			}
		}
		for (l = m; l >= 0; l--) {
			c(g[l + h], o[l], j + 1)
		}
	}
	c(a, d, 0);
	return a
};
numeric.getRange = function getRange(b, l, k) {
	var e = l.length,
		d = k.length;
	var g, f;
	var a = Array(e),
		h, c;
	for (g = e - 1; g !== -1; --g) {
		a[g] = Array(d);
		h = a[g];
		c = b[l[g]];
		for (f = d - 1; f !== -1; --f) {
			h[f] = c[k[f]]
		}
	}
	return a
};
numeric.tensor = function tensor(h, g) {
	if (typeof h === "number" || typeof g === "number") {
		return numeric.mul(h, g)
	}
	var o = numeric.dim(h),
		k = numeric.dim(g);
	if (o.length !== 1 || k.length !== 1) {
		throw new Error("numeric: tensor product is only defined for vectors")
	}
	var c = o[0],
		b = k[0],
		a = Array(c),
		l, e, d, f;
	for (e = c - 1; e >= 0; e--) {
		l = Array(b);
		f = h[e];
		for (d = b - 1; d >= 3; --d) {
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d]
		}
		while (d >= 0) {
			l[d] = f * g[d];
			--d
		}
		a[e] = l
	}
	return a
};
numeric.T = function T(a, b) {
	this.x = a;
	this.y = b
};
numeric.t = function t(a, b) {
	return new numeric.T(a, b)
};
numeric.Tbinop = function Tbinop(c, e, d, g, a) {
	var f = numeric.indexOf;
	if (typeof a !== "string") {
		var b;
		a = "";
		for (b in numeric) {
			if (numeric.hasOwnProperty(b) && (c.indexOf(b) >= 0 || e.indexOf(b) >= 0 || d.indexOf(b) >= 0 || g.indexOf(b) >= 0) && b.length > 1) {
				a += "var " + b + " = numeric." + b + ";\n"
			}
		}
	}
	return Function(["y"], "var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n" + a + "\nif(x.y) {  if(y.y) {    return new numeric.T(" + g + ");\n  }\n  return new numeric.T(" + d + ");\n}\nif(y.y) {\n  return new numeric.T(" + e + ");\n}\nreturn new numeric.T(" + c + ");\n")
};
numeric.T.prototype.add = numeric.Tbinop("add(x.x,y.x)", "add(x.x,y.x),y.y", "add(x.x,y.x),x.y", "add(x.x,y.x),add(x.y,y.y)");
numeric.T.prototype.sub = numeric.Tbinop("sub(x.x,y.x)", "sub(x.x,y.x),neg(y.y)", "sub(x.x,y.x),x.y", "sub(x.x,y.x),sub(x.y,y.y)");
numeric.T.prototype.mul = numeric.Tbinop("mul(x.x,y.x)", "mul(x.x,y.x),mul(x.x,y.y)", "mul(x.x,y.x),mul(x.y,y.x)", "sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))");
numeric.T.prototype.reciprocal = function reciprocal() {
	var a = numeric.mul,
		c = numeric.div;
	if (this.y) {
		var b = numeric.add(a(this.x, this.x), a(this.y, this.y));
		return new numeric.T(c(this.x, b), c(numeric.neg(this.y), b))
	}
	return new T(c(1, this.x))
};
numeric.T.prototype.div = function div(b) {
	if (!(b instanceof numeric.T)) {
		b = new numeric.T(b)
	}
	if (b.y) {
		return this.mul(b.reciprocal())
	}
	var a = numeric.div;
	if (this.y) {
		return new numeric.T(a(this.x, b.x), a(this.y, b.x))
	}
	return new numeric.T(a(this.x, b.x))
};
numeric.T.prototype.dot = numeric.Tbinop("dot(x.x,y.x)", "dot(x.x,y.x),dot(x.x,y.y)", "dot(x.x,y.x),dot(x.y,y.x)", "sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))");
numeric.T.prototype.transpose = function transpose() {
	var b = numeric.transpose,
		a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(b(a), b(c))
	}
	return new numeric.T(b(a))
};
numeric.T.prototype.transjugate = function transjugate() {
	var b = numeric.transpose,
		a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(b(a), numeric.negtranspose(c))
	}
	return new numeric.T(b(a))
};
numeric.Tunop = function Tunop(b, d, a) {
	if (typeof a !== "string") {
		a = ""
	}
	return Function("var x = this;\n" + a + "\nif(x.y) {  " + d + ";\n}\n" + b + ";\n")
};
numeric.T.prototype.exp = numeric.Tunop("return new numeric.T(ex)", "return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))", "var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;");
numeric.T.prototype.conj = numeric.Tunop("return new numeric.T(x.x);", "return new numeric.T(x.x,numeric.neg(x.y));");
numeric.T.prototype.neg = numeric.Tunop("return new numeric.T(neg(x.x));", "return new numeric.T(neg(x.x),neg(x.y));", "var neg = numeric.neg;");
numeric.T.prototype.sin = numeric.Tunop("return new numeric.T(numeric.sin(x.x))", "return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));");
numeric.T.prototype.cos = numeric.Tunop("return new numeric.T(numeric.cos(x.x))", "return x.exp().add(x.neg().exp()).div(2);");
numeric.T.prototype.abs = numeric.Tunop("return new numeric.T(numeric.abs(x.x));", "return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));", "var mul = numeric.mul;");
numeric.T.prototype.log = numeric.Tunop("return new numeric.T(numeric.log(x.x));", "var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);");
numeric.T.prototype.norm2 = numeric.Tunop("return numeric.norm2(x.x);", "var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));");
numeric.T.prototype.get = function get(d) {
	var a = this.x,
		f = this.y,
		b = 0,
		c, e = d.length;
	if (f) {
		while (b < e) {
			c = d[b];
			a = a[c];
			f = f[c];
			b++
		}
		return new numeric.T(a, f)
	}
	while (b < e) {
		c = d[b];
		a = a[c];
		b++
	}
	return new numeric.T(a)
};
numeric.T.prototype.set = function set(c, j) {
	var g = this.x,
		e = this.y,
		b = 0,
		h, a = c.length,
		f = j.x,
		d = j.y;
	if (a === 0) {
		if (d) {
			this.y = d
		} else {
			if (e) {
				this.y = undefined
			}
		}
		this.x = g;
		return this
	}
	if (d) {
		if (e) {} else {
			e = numeric.rep(numeric.dim(g), 0);
			this.y = e
		}
		while (b < a - 1) {
			h = c[b];
			g = g[h];
			e = e[h];
			b++
		}
		h = c[b];
		g[h] = f;
		e[h] = d;
		return this
	}
	if (e) {
		while (b < a - 1) {
			h = c[b];
			g = g[h];
			e = e[h];
			b++
		}
		h = c[b];
		g[h] = f;
		if (f instanceof Array) {
			e[h] = numeric.rep(numeric.dim(f), 0)
		} else {
			e[h] = 0
		}
		return this
	}
	while (b < a - 1) {
		h = c[b];
		g = g[h];
		b++
	}
	h = c[b];
	g[h] = f;
	return this
};
numeric.T.prototype.getRows = function getRows(e, c) {
	var h = c - e + 1,
		b;
	var f = Array(h),
		d, a = this.x,
		g = this.y;
	for (b = e; b <= c; b++) {
		f[b - e] = a[b]
	}
	if (g) {
		d = Array(h);
		for (b = e; b <= c; b++) {
			d[b - e] = g[b]
		}
		return new numeric.T(f, d)
	}
	return new numeric.T(f)
};
numeric.T.prototype.setRows = function setRows(f, d, b) {
	var c;
	var g = this.x,
		e = this.y,
		a = b.x,
		h = b.y;
	for (c = f; c <= d; c++) {
		g[c] = a[c - f]
	}
	if (h) {
		if (!e) {
			e = numeric.rep(numeric.dim(g), 0);
			this.y = e
		}
		for (c = f; c <= d; c++) {
			e[c] = h[c - f]
		}
	} else {
		if (e) {
			for (c = f; c <= d; c++) {
				e[c] = numeric.rep([a[c - f].length], 0)
			}
		}
	}
	return this
};
numeric.T.prototype.getRow = function getRow(b) {
	var a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(a[b], c[b])
	}
	return new numeric.T(a[b])
};
numeric.T.prototype.setRow = function setRow(c, b) {
	var e = this.x,
		d = this.y,
		a = b.x,
		f = b.y;
	e[c] = a;
	if (f) {
		if (!d) {
			d = numeric.rep(numeric.dim(e), 0);
			this.y = d
		}
		d[c] = f
	} else {
		if (d) {
			d = numeric.rep([a.length], 0)
		}
	}
	return this
};
numeric.T.prototype.getBlock = function getBlock(f, e) {
	var c = this.x,
		d = this.y,
		a = numeric.getBlock;
	if (d) {
		return new numeric.T(a(c, f, e), a(d, f, e))
	}
	return new numeric.T(a(c, f, e))
};
numeric.T.prototype.setBlock = function setBlock(i, h, d) {
	if (!(d instanceof numeric.T)) {
		d = new numeric.T(d)
	}
	var c = this.x,
		g = this.y,
		a = numeric.setBlock,
		f = d.x,
		e = d.y;
	if (e) {
		if (!g) {
			this.y = numeric.rep(numeric.dim(this), 0);
			g = this.y
		}
		a(c, i, h, f);
		a(g, i, h, e);
		return this
	}
	a(c, i, h, f);
	if (g) {
		a(g, i, h, numeric.rep(numeric.dim(f), 0))
	}
};
numeric.T.rep = function rep(d, b) {
	var c = numeric.T;
	if (!(b instanceof c)) {
		b = new c(b)
	}
	var a = b.x,
		f = b.y,
		e = numeric.rep;
	if (f) {
		return new c(e(d, a), e(d, f))
	}
	return new c(e(d, a))
};
numeric.T.diag = function diag(c) {
	if (!(c instanceof numeric.T)) {
		c = new numeric.T(c)
	}
	var a = c.x,
		e = c.y,
		b = numeric.diag;
	if (e) {
		return new numeric.T(b(a), b(e))
	}
	return new numeric.T(b(a))
};
numeric.T.eig = function eig() {
	if (this.y) {
		throw new Error("eig: not implemented for complex matrices.")
	}
	return numeric.eig(this.x)
};
numeric.T.identity = function identity(a) {
	return new numeric.T(numeric.identity(a))
};
numeric.T.prototype.getDiag = function getDiag() {
	var c = numeric;
	var a = this.x,
		b = this.y;
	if (b) {
		return new c.T(c.getDiag(a), c.getDiag(b))
	}
	return new c.T(c.getDiag(a))
};
numeric.house = function house(a) {
	var b = numeric.clone(a);
	var c = a[0] >= 0 ? 1 : -1;
	var d = c * numeric.norm2(a);
	b[0] += d;
	var e = numeric.norm2(b);
	if (e === 0) {
		throw new Error("eig: internal error")
	}
	return numeric.div(b, e)
};
numeric.toUpperHessenberg = function toUpperHessenberg(o) {
	var u = numeric.dim(o);
	if (u.length !== 2 || u[0] !== u[1]) {
		throw new Error("numeric: toUpperHessenberg() only works on square matrices")
	}
	var f = u[0],
		l, h, g, p, r, d = numeric.clone(o),
		c, a, q, b, n = numeric.identity(f),
		e;
	for (h = 0; h < f - 2; h++) {
		p = Array(f - h - 1);
		for (l = h + 1; l < f; l++) {
			p[l - h - 1] = d[l][h]
		}
		if (numeric.norm2(p) > 0) {
			r = numeric.house(p);
			c = numeric.getBlock(d, [h + 1, h], [f - 1, f - 1]);
			a = numeric.tensor(r, numeric.dot(r, c));
			for (l = h + 1; l < f; l++) {
				q = d[l];
				b = a[l - h - 1];
				for (g = h; g < f; g++) {
					q[g] -= 2 * b[g - h]
				}
			}
			c = numeric.getBlock(d, [0, h + 1], [f - 1, f - 1]);
			a = numeric.tensor(numeric.dot(c, r), r);
			for (l = 0; l < f; l++) {
				q = d[l];
				b = a[l];
				for (g = h + 1; g < f; g++) {
					q[g] -= 2 * b[g - h - 1]
				}
			}
			c = Array(f - h - 1);
			for (l = h + 1; l < f; l++) {
				c[l - h - 1] = n[l]
			}
			a = numeric.tensor(r, numeric.dot(r, c));
			for (l = h + 1; l < f; l++) {
				e = n[l];
				b = a[l - h - 1];
				for (g = 0; g < f; g++) {
					e[g] -= 2 * b[g]
				}
			}
		}
	}
	return {
		H: d,
		Q: n
	}
};
numeric.epsilon = 2.220446049250313e-16;
numeric.QRFrancis = function(z, h) {
	if (typeof h === "undefined") {
		h = 10000
	}
	z = numeric.clone(z);
	var D = numeric.clone(z);
	var E = numeric.dim(z),
		K = E[0],
		y, A, U, S, R, P, n, e, l, q = numeric.identity(K),
		u, r, I, G, F, O, M, L, N;
	if (K < 3) {
		return {
			Q: q,
			B: [
				[0, K - 1]
			]
		}
	}
	var V = numeric.epsilon;
	for (N = 0; N < h; N++) {
		for (M = 0; M < K - 1; M++) {
			if (Math.abs(z[M + 1][M]) < V * (Math.abs(z[M][M]) + Math.abs(z[M + 1][M + 1]))) {
				var p = numeric.QRFrancis(numeric.getBlock(z, [0, 0], [M, M]), h);
				var o = numeric.QRFrancis(numeric.getBlock(z, [M + 1, M + 1], [K - 1, K - 1]), h);
				I = Array(M + 1);
				for (O = 0; O <= M; O++) {
					I[O] = q[O]
				}
				G = numeric.dot(p.Q, I);
				for (O = 0; O <= M; O++) {
					q[O] = G[O]
				}
				I = Array(K - M - 1);
				for (O = M + 1; O < K; O++) {
					I[O - M - 1] = q[O]
				}
				G = numeric.dot(o.Q, I);
				for (O = M + 1; O < K; O++) {
					q[O] = G[O - M - 1]
				}
				return {
					Q: q,
					B: p.B.concat(numeric.add(o.B, M + 1))
				}
			}
		}
		U = z[K - 2][K - 2];
		S = z[K - 2][K - 1];
		R = z[K - 1][K - 2];
		P = z[K - 1][K - 1];
		e = U + P;
		n = (U * P - S * R);
		l = numeric.getBlock(z, [0, 0], [2, 2]);
		if (e * e >= 4 * n) {
			var g, f;
			g = 0.5 * (e + Math.sqrt(e * e - 4 * n));
			f = 0.5 * (e - Math.sqrt(e * e - 4 * n));
			l = numeric.add(numeric.sub(numeric.dot(l, l), numeric.mul(l, g + f)), numeric.diag(numeric.rep([3], g * f)))
		} else {
			l = numeric.add(numeric.sub(numeric.dot(l, l), numeric.mul(l, e)), numeric.diag(numeric.rep([3], n)))
		}
		y = [l[0][0], l[1][0], l[2][0]];
		A = numeric.house(y);
		I = [z[0], z[1], z[2]];
		G = numeric.tensor(A, numeric.dot(A, I));
		for (O = 0; O < 3; O++) {
			r = z[O];
			F = G[O];
			for (L = 0; L < K; L++) {
				r[L] -= 2 * F[L]
			}
		}
		I = numeric.getBlock(z, [0, 0], [K - 1, 2]);
		G = numeric.tensor(numeric.dot(I, A), A);
		for (O = 0; O < K; O++) {
			r = z[O];
			F = G[O];
			for (L = 0; L < 3; L++) {
				r[L] -= 2 * F[L]
			}
		}
		I = [q[0], q[1], q[2]];
		G = numeric.tensor(A, numeric.dot(A, I));
		for (O = 0; O < 3; O++) {
			u = q[O];
			F = G[O];
			for (L = 0; L < K; L++) {
				u[L] -= 2 * F[L]
			}
		}
		var w;
		for (M = 0; M < K - 2; M++) {
			for (L = M; L <= M + 1; L++) {
				if (Math.abs(z[L + 1][L]) < V * (Math.abs(z[L][L]) + Math.abs(z[L + 1][L + 1]))) {
					var p = numeric.QRFrancis(numeric.getBlock(z, [0, 0], [L, L]), h);
					var o = numeric.QRFrancis(numeric.getBlock(z, [L + 1, L + 1], [K - 1, K - 1]), h);
					I = Array(L + 1);
					for (O = 0; O <= L; O++) {
						I[O] = q[O]
					}
					G = numeric.dot(p.Q, I);
					for (O = 0; O <= L; O++) {
						q[O] = G[O]
					}
					I = Array(K - L - 1);
					for (O = L + 1; O < K; O++) {
						I[O - L - 1] = q[O]
					}
					G = numeric.dot(o.Q, I);
					for (O = L + 1; O < K; O++) {
						q[O] = G[O - L - 1]
					}
					return {
						Q: q,
						B: p.B.concat(numeric.add(o.B, L + 1))
					}
				}
			}
			w = Math.min(K - 1, M + 3);
			y = Array(w - M);
			for (O = M + 1; O <= w; O++) {
				y[O - M - 1] = z[O][M]
			}
			A = numeric.house(y);
			I = numeric.getBlock(z, [M + 1, M], [w, K - 1]);
			G = numeric.tensor(A, numeric.dot(A, I));
			for (O = M + 1; O <= w; O++) {
				r = z[O];
				F = G[O - M - 1];
				for (L = M; L < K; L++) {
					r[L] -= 2 * F[L - M]
				}
			}
			I = numeric.getBlock(z, [0, M + 1], [K - 1, w]);
			G = numeric.tensor(numeric.dot(I, A), A);
			for (O = 0; O < K; O++) {
				r = z[O];
				F = G[O];
				for (L = M + 1; L <= w; L++) {
					r[L] -= 2 * F[L - M - 1]
				}
			}
			I = Array(w - M);
			for (O = M + 1; O <= w; O++) {
				I[O - M - 1] = q[O]
			}
			G = numeric.tensor(A, numeric.dot(A, I));
			for (O = M + 1; O <= w; O++) {
				u = q[O];
				F = G[O - M - 1];
				for (L = 0; L < K; L++) {
					u[L] -= 2 * F[L]
				}
			}
		}
	}
	throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")
};
numeric.eig = function eig(L, l) {
	var f = numeric.toUpperHessenberg(L);
	var o = numeric.QRFrancis(f.H, l);
	var r = numeric.T;
	var O = L.length,
		W, S, V = false,
		J = o.B,
		D = numeric.dot(o.Q, numeric.dot(f.H, numeric.transpose(o.Q)));
	var u = new r(numeric.dot(o.Q, f.Q)),
		G;
	var P = J.length,
		U;
	var aa, Z, Y, X, h, g, e, C, z, K, I, w, v;
	var ab = Math.sqrt;
	for (S = 0; S < P; S++) {
		W = J[S][0];
		if (W === J[S][1]) {} else {
			U = W + 1;
			aa = D[W][W];
			Z = D[W][U];
			Y = D[U][W];
			X = D[U][U];
			if (Z === 0 && Y === 0) {
				continue
			}
			h = -aa - X;
			g = aa * X - Z * Y;
			e = h * h - 4 * g;
			if (e >= 0) {
				if (h < 0) {
					C = -0.5 * (h - ab(e))
				} else {
					C = -0.5 * (h + ab(e))
				}
				w = (aa - C) * (aa - C) + Z * Z;
				v = Y * Y + (X - C) * (X - C);
				if (w > v) {
					w = ab(w);
					K = (aa - C) / w;
					I = Z / w
				} else {
					v = ab(v);
					K = Y / v;
					I = (X - C) / v
				}
				G = new r([
					[I, -K],
					[K, I]
				]);
				u.setRows(W, U, G.dot(u.getRows(W, U)))
			} else {
				C = -0.5 * h;
				z = 0.5 * ab(-e);
				w = (aa - C) * (aa - C) + Z * Z;
				v = Y * Y + (X - C) * (X - C);
				if (w > v) {
					w = ab(w + z * z);
					K = (aa - C) / w;
					I = Z / w;
					C = 0;
					z /= w
				} else {
					v = ab(v + z * z);
					K = Y / v;
					I = (X - C) / v;
					C = z / v;
					z = 0
				}
				G = new r([
					[I, -K],
					[K, I]
				], [
					[C, z],
					[z, -C]
				]);
				u.setRows(W, U, G.dot(u.getRows(W, U)))
			}
		}
	}
	var s = u.dot(L).dot(u.transjugate()),
		O = L.length,
		F = numeric.T.identity(O);
	for (U = 0; U < O; U++) {
		if (U > 0) {
			for (S = U - 1; S >= 0; S--) {
				var M = s.get([S, S]),
					N = s.get([U, U]);
				if (numeric.neq(M.x, N.x) || numeric.neq(M.y, N.y)) {
					C = s.getRow(S).getBlock([S], [U - 1]);
					z = F.getRow(U).getBlock([S], [U - 1]);
					F.set([U, S], (s.get([S, U]).neg().sub(C.dot(z))).div(M.sub(N)))
				} else {
					F.setRow(U, F.getRow(S));
					continue
				}
			}
		}
	}
	for (U = 0; U < O; U++) {
		C = F.getRow(U);
		F.setRow(U, C.div(C.norm2()))
	}
	F = F.transpose();
	F = u.transjugate().dot(F);
	return {
		lambda: s.getDiag(),
		E: F
	}
};
/*!!
 *  Canvas 2 Svg v1.0.19
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */
;
(function() {
	var j, k, i, e, a;

	function g(o, l) {
		var n = Object.keys(l),
			m;
		for (m = 0; m < n.length; m++) {
			o = o.replace(new RegExp("\\{" + n[m] + "\\}", "gi"), l[n[m]])
		}
		return o
	}

	function h(m) {
		var o, n, l;
		if (!m) {
			throw new Error("cannot create a random attribute name for an undefined object")
		}
		o = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
		n = "";
		do {
			n = "";
			for (l = 0; l < 12; l++) {
				n += o[Math.floor(Math.random() * o.length)]
			}
		} while (m[n]);
		return n
	}

	function d(n, p) {
		var o, m, r = {},
			q, l;
		n = n.split(",");
		p = p || 10;
		for (o = 0; o < n.length; o += 2) {
			m = "&" + n[o + 1] + ";";
			q = parseInt(n[o], p);
			r[m] = "&#" + q + ";"
		}
		r["\\xa0"] = "&#160;";
		return r
	}

	function f(m) {
		var l = {
			left: "start",
			right: "end",
			center: "middle",
			start: "start",
			end: "end"
		};
		return l[m] || l.start
	}

	function c(m) {
		var l = {
			alphabetic: "alphabetic",
			hanging: "hanging",
			top: "text-before-edge",
			bottom: "text-after-edge",
			middle: "central"
		};
		return l[m] || l.alphabetic
	}
	a = d("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
	j = {
		strokeStyle: {
			svgAttr: "stroke",
			canvas: "#000000",
			svg: "none",
			apply: "stroke"
		},
		fillStyle: {
			svgAttr: "fill",
			canvas: "#000000",
			svg: null,
			apply: "fill"
		},
		lineCap: {
			svgAttr: "stroke-linecap",
			canvas: "butt",
			svg: "butt",
			apply: "stroke"
		},
		lineJoin: {
			svgAttr: "stroke-linejoin",
			canvas: "miter",
			svg: "miter",
			apply: "stroke"
		},
		miterLimit: {
			svgAttr: "stroke-miterlimit",
			canvas: 10,
			svg: 4,
			apply: "stroke"
		},
		lineWidth: {
			svgAttr: "stroke-width",
			canvas: 1,
			svg: 1,
			apply: "stroke"
		},
		globalAlpha: {
			svgAttr: "opacity",
			canvas: 1,
			svg: 1,
			apply: "fill stroke"
		},
		font: {
			canvas: "10px sans-serif"
		},
		shadowColor: {
			canvas: "#000000"
		},
		shadowOffsetX: {
			canvas: 0
		},
		shadowOffsetY: {
			canvas: 0
		},
		shadowBlur: {
			canvas: 0
		},
		textAlign: {
			canvas: "start"
		},
		textBaseline: {
			canvas: "alphabetic"
		},
		lineDash: {
			svgAttr: "stroke-dasharray",
			canvas: [],
			svg: null,
			apply: "stroke"
		}
	};
	i = function(m, l) {
		this.__root = m;
		this.__ctx = l
	};
	i.prototype.addColorStop = function(p, l) {
		var m = this.__ctx.__createElement("stop"),
			n, o;
		m.setAttribute("offset", p);
		if (l.indexOf("rgba") !== -1) {
			n = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
			o = n.exec(l);
			m.setAttribute("stop-color", g("rgb({r},{g},{b})", {
				r: o[1],
				g: o[2],
				b: o[3]
			}));
			m.setAttribute("stop-opacity", o[4])
		} else {
			m.setAttribute("stop-color", l)
		}
		this.__root.appendChild(m)
	};
	e = function(m, l) {
		this.__root = m;
		this.__ctx = l
	};
	k = function(n) {
		var l = {
				width: 500,
				height: 500,
				enableMirroring: false
			},
			m;
		if (arguments.length > 1) {
			m = l;
			m.width = arguments[0];
			m.height = arguments[1]
		} else {
			if (!n) {
				m = l
			} else {
				m = n
			}
		}
		if (!(this instanceof k)) {
			return new k(m)
		}
		this.width = m.width || l.width;
		this.height = m.height || l.height;
		this.enableMirroring = m.enableMirroring !== undefined ? m.enableMirroring : l.enableMirroring;
		this.canvas = this;
		this.__document = m.document || document;
		if (m.ctx) {
			this.__ctx = m.ctx
		} else {
			this.__canvas = this.__document.createElement("canvas");
			this.__ctx = this.__canvas.getContext("2d")
		}
		this.__setDefaultStyles();
		this.__stack = [this.__getStyleState()];
		this.__groupStack = [];
		this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
		this.__root.setAttribute("version", 1.1);
		this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
		this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
		this.__root.setAttribute("width", this.width);
		this.__root.setAttribute("height", this.height);
		this.__ids = {};
		this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
		this.__root.appendChild(this.__defs);
		this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
		this.__root.appendChild(this.__currentElement)
	};
	k.prototype.__createElement = function(l, p, r) {
		if (typeof p === "undefined") {
			p = {}
		}
		var o = this.__document.createElementNS("http://www.w3.org/2000/svg", l),
			q = Object.keys(p),
			n, m;
		if (r) {
			o.setAttribute("fill", "none");
			o.setAttribute("stroke", "none")
		}
		for (n = 0; n < q.length; n++) {
			m = q[n];
			o.setAttribute(m, p[m])
		}
		return o
	};
	k.prototype.__setDefaultStyles = function() {
		var n = Object.keys(j),
			m, l;
		for (m = 0; m < n.length; m++) {
			l = n[m];
			this[l] = j[l].canvas
		}
	};
	k.prototype.__applyStyleState = function(l) {
		var o = Object.keys(l),
			n, m;
		for (n = 0; n < o.length; n++) {
			m = o[n];
			this[m] = l[m]
		}
	};
	k.prototype.__getStyleState = function() {
		var n, l = {},
			o = Object.keys(j),
			m;
		for (n = 0; n < o.length; n++) {
			m = o[n];
			l[m] = this[m]
		}
		return l
	};
	k.prototype.__applyStyleToCurrentElement = function(u) {
		var q = this.__currentElement;
		var n = this.__currentElementsToStyle;
		if (n) {
			q.setAttribute(u, "");
			q = n.element;
			n.children.forEach(function(y) {
				y.setAttribute(u, "")
			})
		}
		var x = Object.keys(j),
			o, l, w, m, v, p;
		for (o = 0; o < x.length; o++) {
			l = j[x[o]];
			w = this[x[o]];
			if (l.apply) {
				if (w instanceof e) {
					if (w.__ctx) {
						while (w.__ctx.__defs.childNodes.length) {
							m = w.__ctx.__defs.childNodes[0].getAttribute("id");
							this.__ids[m] = m;
							this.__defs.appendChild(w.__ctx.__defs.childNodes[0])
						}
					}
					q.setAttribute(l.apply, g("url(#{id})", {
						id: w.__root.getAttribute("id")
					}))
				} else {
					if (w instanceof i) {
						q.setAttribute(l.apply, g("url(#{id})", {
							id: w.__root.getAttribute("id")
						}))
					} else {
						if (l.apply.indexOf(u) !== -1 && l.svg !== w) {
							if ((l.svgAttr === "stroke" || l.svgAttr === "fill") && w.indexOf("rgba") !== -1) {
								v = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
								p = v.exec(w);
								q.setAttribute(l.svgAttr, g("rgb({r},{g},{b})", {
									r: p[1],
									g: p[2],
									b: p[3]
								}));
								var r = p[4];
								var t = this.globalAlpha;
								if (t != null) {
									r *= t
								}
								q.setAttribute(l.svgAttr + "-opacity", r)
							} else {
								var s = l.svgAttr;
								if (x[o] === "globalAlpha") {
									s = u + "-" + l.svgAttr;
									if (q.getAttribute(s)) {
										continue
									}
								}
								q.setAttribute(s, w)
							}
						}
					}
				}
			}
		}
	};
	k.prototype.__closestGroupOrSvg = function(l) {
		l = l || this.__currentElement;
		if (l.nodeName === "g" || l.nodeName === "svg") {
			return l
		} else {
			return this.__closestGroupOrSvg(l.parentNode)
		}
	};
	k.prototype.getSerializedSvg = function(s) {
		var q = new XMLSerializer().serializeToString(this.__root),
			n, m, l, p, o, r;
		r = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
		if (r.test(q)) {
			q = q.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink')
		}
		if (s) {
			n = Object.keys(a);
			for (m = 0; m < n.length; m++) {
				l = n[m];
				p = a[l];
				o = new RegExp(l, "gi");
				if (o.test(q)) {
					q = q.replace(o, p)
				}
			}
		}
		return q
	};
	k.prototype.getSvg = function() {
		return this.__root
	};
	k.prototype.save = function() {
		var m = this.__createElement("g");
		var l = this.__closestGroupOrSvg();
		this.__groupStack.push(l);
		l.appendChild(m);
		this.__currentElement = m;
		this.__stack.push(this.__getStyleState())
	};
	k.prototype.restore = function() {
		this.__currentElement = this.__groupStack.pop();
		this.__currentElementsToStyle = null;
		if (!this.__currentElement) {
			this.__currentElement = this.__root.childNodes[1]
		}
		var l = this.__stack.pop();
		this.__applyStyleState(l)
	};
	k.prototype.__addTransform = function(m) {
		var n = this.__closestGroupOrSvg();
		if (n.childNodes.length > 0) {
			if (this.__currentElement.nodeName === "path") {
				if (!this.__currentElementsToStyle) {
					this.__currentElementsToStyle = {
						element: n,
						children: []
					}
				}
				this.__currentElementsToStyle.children.push(this.__currentElement);
				this.__applyCurrentDefaultPath()
			}
			var o = this.__createElement("g");
			n.appendChild(o);
			this.__currentElement = o
		}
		var l = this.__currentElement.getAttribute("transform");
		if (l) {
			l += " "
		} else {
			l = ""
		}
		l += m;
		this.__currentElement.setAttribute("transform", l)
	};
	k.prototype.scale = function(l, m) {
		if (m === undefined) {
			m = l
		}
		this.__addTransform(g("scale({x},{y})", {
			x: l,
			y: m
		}))
	};
	k.prototype.rotate = function(m) {
		var l = (m * 180 / Math.PI);
		this.__addTransform(g("rotate({angle},{cx},{cy})", {
			angle: l,
			cx: 0,
			cy: 0
		}))
	};
	k.prototype.translate = function(l, m) {
		this.__addTransform(g("translate({x},{y})", {
			x: l,
			y: m
		}))
	};
	k.prototype.transform = function(m, l, q, p, o, n) {
		this.__addTransform(g("matrix({a},{b},{c},{d},{e},{f})", {
			a: m,
			b: l,
			c: q,
			d: p,
			e: o,
			f: n
		}))
	};
	k.prototype.beginPath = function() {
		var m, l;
		this.__currentDefaultPath = "";
		this.__currentPosition = {};
		m = this.__createElement("path", {}, true);
		l = this.__closestGroupOrSvg();
		l.appendChild(m);
		this.__currentElement = m
	};
	k.prototype.__applyCurrentDefaultPath = function() {
		var l = this.__currentElement;
		if (l.nodeName === "path") {
			l.setAttribute("d", this.__currentDefaultPath)
		} else {
			console.error("Attempted to apply path command to node", l.nodeName)
		}
	};
	k.prototype.__addPathCommand = function(l) {
		this.__currentDefaultPath += " ";
		this.__currentDefaultPath += l
	};
	k.prototype.moveTo = function(l, m) {
		if (this.__currentElement.nodeName !== "path") {
			this.beginPath()
		}
		this.__currentPosition = {
			x: l,
			y: m
		};
		this.__addPathCommand(g("M {x} {y}", {
			x: l,
			y: m
		}))
	};
	k.prototype.closePath = function() {
		if (this.__currentDefaultPath) {
			this.__addPathCommand("Z")
		}
	};
	k.prototype.lineTo = function(l, m) {
		this.__currentPosition = {
			x: l,
			y: m
		};
		if (this.__currentDefaultPath.indexOf("M") > -1) {
			this.__addPathCommand(g("L {x} {y}", {
				x: l,
				y: m
			}))
		} else {
			this.__addPathCommand(g("M {x} {y}", {
				x: l,
				y: m
			}))
		}
	};
	k.prototype.bezierCurveTo = function(n, m, p, o, l, q) {
		this.__currentPosition = {
			x: l,
			y: q
		};
		this.__addPathCommand(g("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}", {
			cp1x: n,
			cp1y: m,
			cp2x: p,
			cp2y: o,
			x: l,
			y: q
		}))
	};
	k.prototype.quadraticCurveTo = function(n, m, l, o) {
		this.__currentPosition = {
			x: l,
			y: o
		};
		this.__addPathCommand(g("Q {cpx} {cpy} {x} {y}", {
			cpx: n,
			cpy: m,
			x: l,
			y: o
		}))
	};
	var b = function(m) {
		var l = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
		return [m[0] / l, m[1] / l]
	};
	k.prototype.arcTo = function(F, o, E, n, q) {
		var G = this.__currentPosition && this.__currentPosition.x;
		var p = this.__currentPosition && this.__currentPosition.y;
		if (typeof G == "undefined" || typeof p == "undefined") {
			return
		}
		if (q < 0) {
			throw new Error("IndexSizeError: The radius provided (" + q + ") is negative.")
		}
		if (((G === F) && (p === o)) || ((F === E) && (o === n)) || (q === 0)) {
			this.lineTo(F, o);
			return
		}
		var u = b([G - F, p - o]);
		var t = b([E - F, n - o]);
		if (u[0] * t[1] === u[1] * t[0]) {
			this.lineTo(F, o);
			return
		}
		var m = (u[0] * t[0] + u[1] * t[1]);
		var v = Math.acos(Math.abs(m));
		var B = b([u[0] + t[0], u[1] + t[1]]);
		var r = q / Math.sin(v / 2);
		var A = F + r * B[0];
		var z = o + r * B[1];
		var l = [-u[1], u[0]];
		var w = [t[1], -t[0]];
		var s = function(I) {
			var H = I[0];
			var J = I[1];
			if (J >= 0) {
				return Math.acos(H)
			} else {
				return -Math.acos(H)
			}
		};
		var D = s(l);
		var C = s(w);
		this.lineTo(A + l[0] * q, z + l[1] * q);
		this.arc(A, z, q, D, C)
	};
	k.prototype.stroke = function() {
		if (this.__currentElement.nodeName === "path") {
			this.__currentElement.setAttribute("paint-order", "fill stroke markers")
		}
		this.__applyCurrentDefaultPath();
		this.__applyStyleToCurrentElement("stroke")
	};
	k.prototype.fill = function() {
		if (this.__currentElement.nodeName === "path") {
			this.__currentElement.setAttribute("paint-order", "stroke fill markers")
		}
		this.__applyCurrentDefaultPath();
		this.__applyStyleToCurrentElement("fill")
	};
	k.prototype.rect = function(m, o, n, l) {
		if (this.__currentElement.nodeName !== "path") {
			this.beginPath()
		}
		this.moveTo(m, o);
		this.lineTo(m + n, o);
		this.lineTo(m + n, o + l);
		this.lineTo(m, o + l);
		this.lineTo(m, o);
		this.closePath()
	};
	k.prototype.fillRect = function(m, q, o, l) {
		var p, n;
		p = this.__createElement("rect", {
			x: m,
			y: q,
			width: o,
			height: l
		}, true);
		n = this.__closestGroupOrSvg();
		n.appendChild(p);
		this.__currentElement = p;
		this.__applyStyleToCurrentElement("fill")
	};
	k.prototype.strokeRect = function(m, q, o, l) {
		var p, n;
		p = this.__createElement("rect", {
			x: m,
			y: q,
			width: o,
			height: l
		}, true);
		n = this.__closestGroupOrSvg();
		n.appendChild(p);
		this.__currentElement = p;
		this.__applyStyleToCurrentElement("stroke")
	};
	k.prototype.__clearCanvas = function() {
		var o = this.__closestGroupOrSvg(),
			l = o.getAttribute("transform");
		var n = this.__root.childNodes[1];
		var p = n.childNodes;
		for (var m = p.length - 1; m >= 0; m--) {
			if (p[m]) {
				n.removeChild(p[m])
			}
		}
		this.__currentElement = n;
		this.__groupStack = [];
		if (l) {
			this.__addTransform(l)
		}
	};
	k.prototype.clearRect = function(m, q, o, l) {
		if (m === 0 && q === 0 && o === this.width && l === this.height) {
			this.__clearCanvas();
			return
		}
		var p, n = this.__closestGroupOrSvg();
		p = this.__createElement("rect", {
			x: m,
			y: q,
			width: o,
			height: l,
			fill: "#FFFFFF"
		}, true);
		n.appendChild(p)
	};
	k.prototype.createLinearGradient = function(m, o, l, n) {
		var p = this.__createElement("linearGradient", {
			id: h(this.__ids),
			x1: m + "px",
			x2: l + "px",
			y1: o + "px",
			y2: n + "px",
			gradientUnits: "userSpaceOnUse"
		}, false);
		this.__defs.appendChild(p);
		return new i(p, this)
	};
	k.prototype.createRadialGradient = function(o, q, n, m, p, l) {
		var r = this.__createElement("radialGradient", {
			id: h(this.__ids),
			cx: m + "px",
			cy: p + "px",
			r: l + "px",
			fx: o + "px",
			fy: q + "px",
			gradientUnits: "userSpaceOnUse"
		}, false);
		this.__defs.appendChild(r);
		return new i(r, this)
	};
	k.prototype.__parseFont = function() {
		var m = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
		var l = m.exec(this.font);
		var n = {
			style: l[1] || "normal",
			size: l[4] || "10px",
			family: l[6] || "sans-serif",
			weight: l[3] || "normal",
			decoration: l[2] || "normal",
			href: null
		};
		if (this.__fontUnderline === "underline") {
			n.decoration = "underline"
		}
		if (this.__fontHref) {
			n.href = this.__fontHref
		}
		return n
	};
	k.prototype.__wrapTextLink = function(m, n) {
		if (m.href) {
			var l = this.__createElement("a");
			l.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", m.href);
			l.appendChild(n);
			return l
		}
		return n
	};
	k.prototype.__applyText = function(q, l, r, p) {
		var n = this.__parseFont(),
			o = this.__closestGroupOrSvg(),
			m = this.__createElement("text", {
				"font-family": n.family,
				"font-size": n.size,
				"font-style": n.style,
				"font-weight": n.weight,
				"text-decoration": n.decoration,
				x: l,
				y: r,
				"text-anchor": f(this.textAlign),
				"dominant-baseline": c(this.textBaseline)
			}, true);
		m.appendChild(this.__document.createTextNode(q));
		this.__currentElement = m;
		this.__applyStyleToCurrentElement(p);
		o.appendChild(this.__wrapTextLink(n, m))
	};
	k.prototype.fillText = function(m, l, n) {
		this.__applyText(m, l, n, "fill")
	};
	k.prototype.strokeText = function(m, l, n) {
		this.__applyText(m, l, n, "stroke")
	};
	k.prototype.measureText = function(l) {
		this.__ctx.font = this.font;
		return this.__ctx.measureText(l)
	};
	k.prototype.arc = function(t, s, q, r, m, v) {
		if (r === m) {
			return
		}
		r = r % (2 * Math.PI);
		m = m % (2 * Math.PI);
		if (r === m) {
			m = ((m + (2 * Math.PI)) - 0.001 * (v ? -1 : 1)) % (2 * Math.PI)
		}
		var z = t + q * Math.cos(m),
			w = s + q * Math.sin(m),
			p = t + q * Math.cos(r),
			o = s + q * Math.sin(r),
			n = v ? 0 : 1,
			l = 0,
			u = m - r;
		if (u < 0) {
			u += 2 * Math.PI
		}
		if (v) {
			l = u > Math.PI ? 0 : 1
		} else {
			l = u > Math.PI ? 1 : 0
		}
		this.lineTo(p, o);
		this.__addPathCommand(g("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}", {
			rx: q,
			ry: q,
			xAxisRotation: 0,
			largeArcFlag: l,
			sweepFlag: n,
			endX: z,
			endY: w
		}));
		this.__currentPosition = {
			x: z,
			y: w
		}
	};
	k.prototype.clip = function() {
		var m = this.__closestGroupOrSvg(),
			l = this.__createElement("clipPath"),
			o = h(this.__ids),
			n = this.__createElement("g");
		this.__applyCurrentDefaultPath();
		m.removeChild(this.__currentElement);
		l.setAttribute("id", o);
		l.appendChild(this.__currentElement);
		this.__defs.appendChild(l);
		m.setAttribute("clip-path", g("url(#{id})", {
			id: o
		}));
		m.appendChild(n);
		this.__currentElement = n
	};
	k.prototype.drawImage = function() {
		var n = Array.prototype.slice.call(arguments),
			z = n[0],
			u, t, v, F, x = 0,
			w = 0,
			C, G, s, y, l, q, o, D, p, m, B;
		if (n.length === 3) {
			u = n[1];
			t = n[2];
			C = z.width;
			G = z.height;
			v = C;
			F = G
		} else {
			if (n.length === 5) {
				u = n[1];
				t = n[2];
				v = n[3];
				F = n[4];
				C = z.width;
				G = z.height
			} else {
				if (n.length === 9) {
					x = n[1];
					w = n[2];
					C = n[3];
					G = n[4];
					u = n[5];
					t = n[6];
					v = n[7];
					F = n[8]
				} else {
					throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length)
				}
			}
		}
		s = this.__closestGroupOrSvg();
		o = this.__currentElement;
		var r = "translate(" + u + ", " + t + ")";
		if (z instanceof k) {
			y = z.getSvg().cloneNode(true);
			if (y.childNodes && y.childNodes.length > 1) {
				l = y.childNodes[0];
				while (l.childNodes.length) {
					B = l.childNodes[0].getAttribute("id");
					this.__ids[B] = B;
					this.__defs.appendChild(l.childNodes[0])
				}
				q = y.childNodes[1];
				if (q) {
					var E = q.getAttribute("transform");
					var A;
					if (E) {
						A = E + " " + r
					} else {
						A = r
					}
					q.setAttribute("transform", A);
					s.appendChild(q)
				}
			}
		} else {
			if (z.nodeName === "CANVAS" || z.nodeName === "IMG") {
				D = this.__createElement("image");
				D.setAttribute("width", v);
				D.setAttribute("height", F);
				D.setAttribute("preserveAspectRatio", "none");
				if (x || w || C !== z.width || G !== z.height) {
					p = this.__document.createElement("canvas");
					p.width = v;
					p.height = F;
					m = p.getContext("2d");
					m.drawImage(z, x, w, C, G, 0, 0, v, F);
					z = p
				}
				D.setAttribute("transform", r);
				D.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", z.nodeName === "CANVAS" ? z.toDataURL() : z.getAttribute("src"));
				s.appendChild(D)
			}
		}
	};
	k.prototype.createPattern = function(o, m) {
		var n = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"),
			p = h(this.__ids),
			l;
		n.setAttribute("id", p);
		n.setAttribute("width", o.width);
		n.setAttribute("height", o.height);
		if (o.nodeName === "CANVAS" || o.nodeName === "IMG") {
			l = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
			l.setAttribute("width", o.width);
			l.setAttribute("height", o.height);
			l.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o.nodeName === "CANVAS" ? o.toDataURL() : o.getAttribute("src"));
			n.appendChild(l);
			this.__defs.appendChild(n)
		} else {
			if (o instanceof k) {
				n.appendChild(o.__root.childNodes[1]);
				this.__defs.appendChild(n)
			}
		}
		return new e(n, this)
	};
	k.prototype.setLineDash = function(l) {
		if (l && l.length > 0) {
			this.lineDash = l.join(",")
		} else {
			this.lineDash = null
		}
	};
	k.prototype.drawFocusRing = function() {};
	k.prototype.createImageData = function() {};
	k.prototype.getImageData = function() {};
	k.prototype.putImageData = function() {};
	k.prototype.globalCompositeOperation = function() {};
	k.prototype.setTransform = function() {};
	if (typeof window === "object") {
		window.C2S = k
	}
	if (typeof module === "object" && typeof module.exports === "object") {
		module.exports = k
	}
}());
if (typeof(CanvasXpress) == "undefined") {
	CanvasXpress = {}
}(function() {
	if (navigator.onLine) {
		var b = document.createElement("link");
		b.type = "text/css";
		b.rel = "stylesheet";
		b.href = "https://fonts.googleapis.com/css?family=Indie+Flower|Ubuntu|Architects+Daughter|Roboto:400,700,700italic";
		var a = document.getElementsByTagName("head")[0];
		a.appendChild(b);
		var c = new Image;
		c.onerror = function() {
			var f = document.createElement("canvas");
			var e = f.getContext("2d", {
				willReadFrequently: true
			});
			var d = "10px Ubuntu";
			e.font = d;
			e.fillText("css loaded", 100, 100);
			d = "10px Indie Flower";
			e.font = d;
			e.fillText("css loaded", 100, 100);
			d = "10px Architects Daughter";
			e.font = d;
			e.fillText("css loaded", 100, 100);
			d = "10px Roboto";
			e.font = d;
			e.fillText("css loaded", 100, 100)
		};
		c.src = "https://fonts.googleapis.com/css?family=Indie+Flower|Ubuntu|Architects+Daughter|Roboto:400,700,700italic"
	}
}());
var CanvasXpress = function(f, d, a, b, e, g, c) {
	this.setInit = function() {
		this.target = f;
		this.events = b;
		this.info = e;
		this.userId = 294882621166851;
		this.href = location.href;
		this.protocol = this.href.split(":")[0];
		this.meta = {
			factory: {
				version: 17.7,
				buildDate: "11-06-2017",
				client: "",
				siteSrc: false,
				valid: null
			},
			ids: {},
			time: {
				start: new Date().getTime(),
				elapsed: null,
				end: null
			},
			data: false,
			canvas: {},
			config: {
				user: a,
				orig: {},
				vals: {},
				keys: []
			},
			vals: {},
			render: {
				objects: [],
				groups: {},
				types: {},
				order: [],
				map: {},
				origin: [],
				transition: false
			},
			events: {},
			system: {},
			geo: false,
			state: {
				save: 0,
				clip: false,
				translate: [0, 0],
				rotate: [0],
				scale: [1, 1]
			},
			def: {}
		}
	};
	this.validateParameters = function() {
		this.validateData();
		this.validateConfig();
		this.validateEvents();
		this.validateInfo();
		this.validateAfterRender()
	};
	this.validateData = function() {
		this.dataURL = false;
		if (typeof(d) == "string") {
			if (!this.isValidURL(d)) {
				alert("Not a valid url\n")
			} else {
				this.dataURL = d;
				d = false
			}
		} else {
			try {
				JSON.stringify(d)
			} catch (h) {
				alert("Data object malformed:\n" + h)
			}
		}
	};
	this.validateConfig = function() {
		if (!a) {
			a = {}
		} else {
			try {
				JSON.stringify(a)
			} catch (h) {
				alert("Config object malformed:\n" + h)
			}
		}
	};
	this.validateEvents = function() {};
	this.validateInfo = function() {
		if (!e) {
			e = ""
		}
	};
	this.validateAfterRender = function() {
		if (g) {
			try {
				JSON.stringify(g)
			} catch (h) {
				alert("AfterRender object malformed:\n" + h)
			}
		}
	};
	this.afterRender = function() {
		if (g) {
			if (this.graphType != "Map") {
				for (var j = 0; j < g.length; j++) {
					var h = g[j];
					var k = h.shift();
					var n = h.length > 0 ? h.shift() : [];
					var m = h.length > 0 ? h.shift() : {};
					this.flashInfoSpan(20, 20, k);
					for (var l in m) {
						this[l] = m[l]
					}
					this[k].apply(this, n)
				}
			} else {
				this.deferedAfterRender = g
			}
		}
	};
	if (!f) {
		f = this.createNewTarget()
	} else {
		if (typeof(f) == "object") {
			d = f.data || false;
			a = f.config || false;
			b = f.events || false;
			e = f.info || false;
			g = f.afterRender || false;
			c = f.hidden || false;
			f = f.renderTo || this.createNewTarget()
		}
	}
	this.initialize = function() {
		CanvasXpress.instances.push(this);
		this.setInit();
		this.initDOM();
		this.initInterface();
		this.validateParameters();
		this.initConfig(a);
		this.initViewport(c);
		this.initPrimitives();
		this.initUtils();
		this.initMathUtils();
		this.initLegendUtils();
		this.initFilterUtils();
		this.initClusterUtils();
		this.initSortUtils();
		this.initExample();
		this.initVocabulary();
		this.initDataUtils();
		this.initData(d);
		this.initValidity();
		this.initLayout();
		this.initEvents();
		this.initTooltip();
		this.initToolbar();
		this.initMenus();
		this.initLinks();
		this.initConfigurator();
		this.initDataFilter();
		this.initDataTable();
		this.initAcknowlegments();
		this.initCodeInfo();
		this.initBin();
		this.initDataExplorer();
		this.initAnimation();
		this.initRemote();
		this.initStack(d, a, b, e);
		this.initTransitions();
		this.initGraph();
// this.afterRender(); // Baohong
		this.getDataFromURL();
		this.showToolbar(2000);
		this.teaseMobileControls(2000);
		CanvasXpress.current = this.target;
		this.meta.time.end = new Date().getTime();
		this.meta.time.elapsed = this.meta.time.end - this.meta.time.start;
		this.hideMask()
	};
	this.initialize()
};
CanvasXpress.instances = [];
CanvasXpress.transitions = {};
CanvasXpress.cacheImages = {};
CanvasXpress.cacheImagesReady = false;
CanvasXpress.cachePatterns = {};
CanvasXpress.cacheText = {};
CanvasXpress.vocabulary = {};
CanvasXpress.stack = {};
CanvasXpress.current = false;
CanvasXpress.resizing = false;
CanvasXpress.loading = false;
CanvasXpress.loadScripts = function() {
	var i = 0;
	CanvasXpress.loading = true;
	return function(files, callback, scope) {
		var head = document.getElementsByTagName("head")[0];
		var loadScript = function(s, c) {
			var t = s.type;
			if (t.match(/javascript/i)) {
				s.onreadystatechange = function() {
					if (s.readyState === "loaded" || s.readyState === "complete") {
						s.onreadystatechange = null;
						c()
					}
				};
				s.onload = function() {
					c()
				};
				head.appendChild(s)
			} else {
				head.appendChild(s);
				c()
			}
		};
		var count = function() {
			if (i === files.length) {
				i = 0;
				if (callback) {
					CanvasXpress.loading = false;
					if (typeof(callback) == "function") {
						callback.call(scope)
					} else {
						if (typeof(callback) == "string") {
							eval("var fn = " + callback);
							fn()
						}
					}
				}
			} else {
				CanvasXpress.loadScripts(files, callback, scope)
			}
		};
		i++;
		loadScript(files[i - 1], count)
	}
}();
CanvasXpress.getObject = function(c, b) {
	for (var a = 0; a < CanvasXpress.instances.length; a++) {
		if (CanvasXpress.instances[a].target == c) {
			return CanvasXpress.instances[a]
		}
	}
	if (b) {
		return CanvasXpress.injectObject(c)
	}
};
CanvasXpress.$ = function(b, a) {
	return CanvasXpress.getObject(b, a)
};
CanvasXpress.destroy = function(a) {
	if (CanvasXpress.instances.length > 0) {
		CanvasXpress.instances[0].destroy(a)
	}
};
CanvasXpress.injectObject = function(d) {
	var a = document.getElementById(d);
	if (!a) {
		var b = document.createElement("canvas");
		b.id = d;
		b.width = 100;
		b.height = 100;
		document.body.appendChild(b);
		a = new CanvasXpress({
			renderTo: d,
			hidden: true
		})
	}
	return a
};
CanvasXpress.setExampleContainer = function(a) {
	if (!a) {
		a = "Show-All"
	}
	var j = CanvasXpress.getObject("CanvasXpress-Silent", true);
	var d = j.getWindowSize();
	var e = j.getWindowScroll();
	var c = Math.max(0, ((d[0] - 500) / 2) + e[0]);
	var h = Math.max(0, ((d[1] - 500) / 2) + e[1]);
	var g = j.$cX("div", {
		id: a + "-cX-API-Example",
		className: "CanvasXpressConfiguratorExample draggable"
	}, {
		width: "500px",
		maxHeight: "482px",
		cursor: "move",
		display: "block",
		padding: "10px",
		position: "absolute",
		overflow: "hidden",
		paddingBottom: "25px",
		paddingRight: "5px",
		left: c + "px",
		top: h + "px"
	});
	var b = j.$cX("span", {
		id: a + "-cX-API-ExampleSpan",
		className: "CanvasXpressConfiguratorExample",
		innerHTML: ""
	});
	var f = j.$cX("img", {
		id: a + "-cX-API-ExampleClose",
		className: "CanvasXpressConfigurator",
		property: a,
		src: CanvasXpress.images.cancel1,
		alt: "Close",
		title: "Close"
	});
	var i = j.$cX("div", {
		id: a + "-cX-API-ExampleContent",
		className: "CanvasXpressConfiguratorExampleContent"
	}, {
		width: "500px",
		maxHeight: "482px",
		overflow: "auto"
	});
	g.appendChild(b);
	g.appendChild(f);
	g.appendChild(j.$cX("br"));
	g.appendChild(i);
	document.body.appendChild(g);
	return j
};
CanvasXpress.showExample = function(h, g) {
	if (g) {
		var c = CanvasXpress.setExampleContainer(g);
		var b = c.$(g + "-cX-API-Example");
		var f = c.$(g + "-cX-API-ExampleSpan");
		var d = c.$(g + "-cX-API-ExampleClose");
		var a = c.$(g + "-cX-API-ExampleContent");
		d.onclick = function() {
			var j = c.$(this.property + "-cX-API-Example");
			if (j) {
				c.removeEvtListener(j, "mousedown", c.registerMousemove, false);
				var l = j.getElementsByTagName("canvas");
				var k = [];
				for (var e = 0; e < l.length; e++) {
					k.push(l[e].id)
				}
				for (var e = 0; e < k.length; e++) {
					c.destroy(k[e])
				}
				j.parentNode.removeChild(j)
			}
		};
		c.addEvtListener(b, "mousedown", c.registerMousemove, false);
		c.stopEvent(h);
		c.cancelEvent(h);
		c.clickExamplePropertyDescription(h, g, true);
		return false
	}
};
CanvasXpress.showAllExamples = function(v, x) {
	var o = CanvasXpress.setExampleContainer();
	var u = o.$("Show-All-cX-API-Example");
	var g = o.$("Show-All-cX-API-ExampleSpan");
	var m = o.$("Show-All-cX-API-ExampleClose");
	var p = o.$("Show-All-cX-API-ExampleContent");
	m.onclick = function() {
		var c = o.$(this.property + "-cX-API-Example");
		if (c) {
			clearInterval(w);
			o.removeEvtListener(c, "mousedown", o.registerMousemove, false);
			var e = c.getElementsByTagName("canvas");
			while (e.length > 0) {
				o.destroy(e[0].id)
			}
			c.parentNode.removeChild(c)
		}
	};
	p.appendChild(o.$cX("canvas", {
		id: "Show-All-cX-API-Example-Canvas",
		width: 500,
		height: 500
	}));
	o.addEvtListener(u, "mousedown", o.registerMousemove, false);
	o.stopEvent(v);
	o.cancelEvent(v);
	new CanvasXpress("Show-All-cX-API-Example-Canvas");
	var a = [];
	var l = x ? [x] : o.getKeys(CanvasXpress.doc.M).sort();
	for (var s = 0; s < l.length; s++) {
		var k = l[s];
		for (var q = 0; q < CanvasXpress.doc.M[k]["P"].length; q++) {
			var b = CanvasXpress.doc.M[k]["P"][q];
			var n = CanvasXpress.doc.P[b];
			if (n.H) {
				var h = o.getExamplesDocObject(b);
				a = a.concat(h)
			}
		}
	}
	var r = 0;
	var d = "Show-All-cX-API-Example-Canvas";
	var f = function() {
		o.destroy(d);
		d = a[r][0];
		o.insertTarget(d, p, 500, 500);
		var y = a[r][1];
		var z = a[r][2];
		z.disableToolbar = true;
		var e = new CanvasXpress(d, y, z);
		g.innerHTML = d.replace("CanvasXpress-Silent-cX-ConfiguratorExample-", "").split("-")[0];
		var t = a[r][3];
		if (t) {
			for (var j = 0; j < t.length; j++) {
				if (t[j].match(/:/)) {
					var c = t[j].split(":");
					e[c.shift()].apply(e, c)
				} else {
					e[t[j]]()
				}
			}
		}
		r++;
		if (r == a.length) {
			r = 0
		}
	};
	var w = this.setInterval(function() {
		f()
	}, 1000);
	return false
};
CanvasXpress.prototype.initDOM = function() {
	this.$ = function(a) {
		return document.getElementById(a)
	};
	this.$cX = function(b, f, c) {
		var d = document.createElement(b);
		if (f) {
			for (var a in f) {
				d[a] = f[a]
			}
		}
		if (c) {
			for (var a in c) {
				d.style[a] = c[a]
			}
		}
		return d
	};
	this.createNewTarget = function() {
		var a = this.$cX("canvas", {
			id: this.newId("canvasXpress")
		});
		document.body.appendChild(a);
		return a.id
	};
	this.newId = function(b) {
		var c = 0;
		var a = this.target + b + c;
		while (this.meta.ids[a]) {
			c++;
			a = this.target + b + c
		}
		this.meta.ids[a] = true;
		return a
	};
	this.insertTarget = function(e, g, d, f, b) {
		if (e && g) {
			var i = this.$(e);
			if (i) {
				return
			} else {
				i = this.$cX("canvas", {
					id: e,
					width: d,
					height: f
				})
			}
			if (b) {
				g.parentNode.insertBefore(i, g.nextSibling)
			} else {
				g.parentNode.insertBefore(i, g)
			}
		}
	};
	this.removeTarget = function(a) {
		var b = this.$(a);
		if (b) {
			b.parentNode.removeChild(b)
		}
	};
	this.getWindowSize = function() {
		var a = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		var b = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		return [a, b]
	};
	this.getWindowScroll = function() {
		var c = document.documentElement;
		var a = (window.pageXOffset || c.scrollLeft) - (c.clientLeft || 0);
		var b = (window.pageYOffset || c.scrollTop) - (c.clientTop || 0);
		return [a, b]
	};
	this.hasClass = function(a, b) {
		return new RegExp("(\\s|^)" + b + "(\\s|$)").test(a.className)
	};
	this.addClass = function(a, b) {
		if (!this.hasClass(a, b)) {
			a.className += (a.className ? " " : "") + b
		}
	};
	this.removeClass = function(a, b) {
		if (this.hasClass(a, b)) {
			a.className = a.className.replace(new RegExp("(\\s|^)" + b + "(\\s|$)"), " ").replace(/^\s+|\s+$/g, "")
		}
	};
	this.getComputedCSS = function(c) {
		var b = "";
		var d = getComputedStyle(c);
		for (var a = 0; a < d.length; a++) {
			b += d[a] + ":" + d.getPropertyValue(d[a]) + ";"
		}
		return b
	};
	this.cancelEvent = function(a) {
		if (!a) {
			a = window.event
		}
		if (!a) {
			return
		}
		if (this.meta.system.browser.match(/safari/i)) {
			return false
		} else {
			if (a.preventDefault) {
				a.preventDefault()
			} else {
				a.returnValue = false
			}
		}
	};
	this.stopEvent = function(a) {
		if (!a) {
			a = window.event
		}
		if (!a) {
			return
		}
		if (a.stopPropagation) {
			a.stopPropagation()
		} else {
			a.cancelBubble = true
		}
	};
	this.normalizeEvtName = function(a) {
		return this.meta.system.isIE ? "on" + a : a
	};
	this.copyEvent = function(c) {
		var b = {};
		for (var a in c) {
			b[a] = c[a]
		}
		return b
	};
	this.addEvtListener = function(g, d, h, b) {
		if (g && d && h) {
			var a = this.meta.events;
			if (g.id) {
				if (!a[g.id]) {
					a[g.id] = {}
				}
				a[g.id][d] = [h, b]
			} else {
				if (!a[g]) {
					a[g] = {}
				}
				a[g][d] = [h, b]
			}
			if (this.meta.system.isIE) {
				g.attachEvent(this.normalizeEvtName(d), h)
			} else {
				if (d == "touchstart") {
					g.addEventListener(d, h, b)
				} else {
					if (d == "mousewheel") {
						g.addEventListener(d, h, b);
						g.addEventListener("DOMMouseScroll", h, b)
					} else {
						g.addEventListener(d, h, b)
					}
				}
			}
		}
	};
	this.removeEvtListener = function(i, h, j, g) {
		if (i && h && j) {
			var a = this.meta.events;
			var d = a[i.id || i];
			if (d && d.hasOwnProperty(h)) {
				delete(d[h]);
				if (this.meta.system.isIE) {
					i.detachEvent(this.normalizeEvtName(h), j)
				} else {
					i.removeEventListener(h, j, g);
					if (h == "mousewheel") {
						i.removeEventListener("DOMMouseScroll", j, g)
					}
				}
				var b = this.getKeys(a[i.id || i]);
				if (b && b.length < 1) {
					delete(a[i.id || i])
				}
			}
		}
	};
	this.addRemoveEvtListener = function(a, g, d, h, b) {
		if (a && g && d && h) {
			this[a](g, d, h, b)
		}
	};
	this.purgeEventListeners = function() {
		var a = this.meta.events;
		for (var b in a) {
			var d = this.$(b) || b;
			for (var c in a[b]) {
				this.removeEvtListener(d, c, a[b][0], a[b][1])
			}
		}
	};
	this.preventSelection = function() {
		if (document.selection) {
			document.selection.empty()
		} else {
			if (window.getSelection) {
				window.getSelection().removeAllRanges()
			}
		}
	};
	this.getTargetEvent = function(a) {
		return a.target || a.srcElement
	};
	this.setInterval = function(i, f) {
		var e = Date.now;
		var a = window.requestAnimationFrame;
		var h = e();
		var b;
		var g = function() {
			e() - h < f || (h += f, i());
			b || a(g)
		};
		a(g);
		return {
			clear: function() {
				b = 1
			}
		}
	};
	this.setTimeout = function(i, g) {
		var f = Date.now;
		var a = window.requestAnimationFrame;
		var h = f();
		var e;
		var b = function() {
			f() - h < g ? e || a(b) : i()
		};
		a(b);
		return {
			clear: function() {
				e = 1
			}
		}
	};
	if (!Array.from) {
		Array.from = (function() {
			var d = Object.prototype.toString;
			var e = function(g) {
				return typeof g === "function" || d.call(g) === "[object Function]"
			};
			var c = function(h) {
				var g = Number(h);
				if (isNaN(g)) {
					return 0
				}
				if (g === 0 || !isFinite(g)) {
					return g
				}
				return (g > 0 ? 1 : -1) * Math.floor(Math.abs(g))
			};
			var b = Math.pow(2, 53) - 1;
			var a = function(h) {
				var g = c(h);
				return Math.min(Math.max(g, 0), b)
			};
			return function f(p) {
				var g = this;
				var o = Object(p);
				if (p == null) {
					throw new TypeError("Array.from requires an array-like object - not null or undefined")
				}
				var m = arguments.length > 1 ? arguments[1] : void undefined;
				var i;
				if (typeof m !== "undefined") {
					if (!e(m)) {
						throw new TypeError("Array.from: when provided, the second argument must be a function")
					}
					if (arguments.length > 2) {
						i = arguments[2]
					}
				}
				var n = a(o.length);
				var h = e(g) ? Object(new g(n)) : new Array(n);
				var j = 0;
				var l;
				while (j < n) {
					l = o[j];
					if (m) {
						h[j] = typeof i === "undefined" ? m(l, j) : m.call(i, l, j)
					} else {
						h[j] = l
					}
					j += 1
				}
				h.length = n;
				return h
			}
		}())
	}
	this.initializeBrowser = function() {
		var b = function() {
			var e = navigator.userAgent;
			var d;
			var c = e.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
			if (/trident/i.test(c[1])) {
				d = /\brv[ :]+(\d+)/g.exec(e) || [];
				return "IE " + (d[1] || "")
			}
			if (c[1] === "Chrome") {
				d = e.match(/\b(OPR|Edge)\/(\d+)/);
				if (d != null) {
					return d.slice(1).join(" ").replace("OPR", "Opera")
				}
			}
			c = c[2] ? [c[1], c[2]] : [navigator.appName, navigator.appVersion, "-?"];
			if ((d = e.match(/version\/(\d+)/i)) != null) {
				c.splice(1, 1, d[1])
			}
			return c.join(" ")
		};
		var a = b().split(" ");
		this.meta.system = {
			browser: a[0],
			browserVersion: a[1],
			isjQuery: typeof $ === "function" ? true : false,
			isIE: this.browser == "IE" ? true : false,
			isTouchScreen: "ontouchstart" in window || "onmsgesturechange" in window || navigator.maxTouchPoints
		}
	};
	this.initializeBrowser()
};
CanvasXpress.prototype.initInterface = function() {
	this.isValidURL = function(b) {
		var a = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;,\\s\\(\\)\\[\\]&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
		return a.test(b)
	};
	this.loadParamsFile = function(a) {
		return function(h) {
			a.removeMenus();
			a.resetConfigurator();
			var d = h.target.files[0];
			var g = d.type;
			var c = d.name.split(".");
			var b = new FileReader();
			var f = c.pop();
			if (f == "json") {
				b.onload = function() {
					try {
						var m = JSON.parse(b.result);
						a.setConfigDefaults();
						a.layoutValid = false;
						for (var o in m.config) {
							a[o] = m.config[o]
						}
						for (var k = 0; k < m.afterRender.length; k++) {
							var j = m.afterRender[k];
							var l = j[0];
							var q = j[1] || [];
							a[l].apply(a, q)
						}
					} catch (n) {
						alert("Oooops! Not a CanvasXpress json parameter file")
					}
				};
				b.readAsText(d)
			} else {
				alert("Oooops! Not a CanvasXpress json  parameter file")
			}
		}
	}(this);
	this.parseDataFromPNG = function(c) {
		var e = function(o, m) {
			var p = "";
			for (var n = 0; n < 4; n++) {
				p += String.fromCharCode(o.getUint8(m + n))
			}
			return p == "tEXt"
		};
		var d = function(p, n, m) {
			var q = "";
			for (var o = 0; o < m; o++) {
				q += String.fromCharCode(p.getUint8(n + o))
			}
			return q.match(/CanvasXpress/)
		};
		var b = function(p, n, m) {
			var q = "";
			for (var o = 0; o < m; o++) {
				console.log(n + o + " = " + p.getUint8(n + o) + ":" + String.fromCharCode(p.getUint8(n + o)))
			}
			return q
		};
		var a = new DataView(c);
		var g = a.getUint32(8);
		var j = a.getUint32(8 + 4 + 4 + g + 4);
		if (e(a, 8 + 4 + 4 + g + 4 + 4) && d(a, 8 + 4 + 4 + g + 4 + 4 + 4, j)) {
			var l = a.getUint32(8 + 4 + 4 + g + 4 + 4 + 4 + j + 4);
			var h = 8 + 4 + 4 + g + 4 + 4 + 4 + j + 4 + 4 + 4;
			var k = "";
			for (var f = 0; f < l; f++) {
				k += String.fromCharCode(a.getUint8(h + f))
			}
			k = k.replace("ReproducibleResearch\0", "");
			return JSON.parse(k)
		} else {
			alert("Oooops! Not a CanvasXpress Image")
		}
	};
	this.loadFile = function(a) {
		return function(l, c, n, k) {
			a.removeMenus();
			a.resetConfigurator();
			a.showMask();
			var h = k ? k : l.target ? l.target.files[0] : l.files[0];
			var m = h.type;
			var d = h.name.split(".");
			var j = new FileReader();
			if (m == "image/png") {
				var i = function(o, e) {
					var p = "";
					for (var f = 0; f < 4; f++) {
						p += String.fromCharCode(o.getUint8(e + f))
					}
					return p == "tEXt"
				};
				var g = function(p, f, e) {
					var q = "";
					for (var o = 0; o < e; o++) {
						q += String.fromCharCode(p.getUint8(f + o))
					}
					return q.match(/CanvasXpress/)
				};
				j.onload = function() {
					var r = new DataView(this.result);
					var f = r.getUint32(8);
					var e = r.getUint32(8 + 4 + 4 + f + 4);
					if (i(r, 8 + 4 + 4 + f + 4 + 4) && g(r, 8 + 4 + 4 + f + 4 + 4 + 4, e)) {
						var q = r.getUint32(8 + 4 + 4 + f + 4 + 4 + 4 + e + 4);
						var s = 8 + 4 + 4 + f + 4 + 4 + 4 + e + 4 + 4 + 4;
						var p = "";
						for (var o = 0; o < q; o++) {
							p += String.fromCharCode(r.getUint8(s + o))
						}
						p = p.replace("ReproducibleResearch\0", "");
						var t = JSON.parse(p);
						if (c) {
							return t
						}
						t.uploadFile = true;
						a.remoteServiceType = "file";
						a.updateRemoteData(t, n);
						a.hideMask()
					} else {
						a.hideMask();
						alert("Oooops! Not a CanvasXpress Image")
					}
				};
				j.readAsArrayBuffer(h)
			} else {
				var b = d.pop();
				if (b == "json") {
					j.onload = function() {
						try {
							var f = JSON.parse(j.result);
							f.uploadFile = true;
							a.remoteServiceType = "file";
							a.updateRemoteData(f, n);
							a.hideMask()
						} catch (o) {
							a.hideMask();
							alert("Oooops! Not a CanvasXpress json file")
						}
					}
				} else {
					if (b == "svg") {
						j.onload = function() {
							try {
								var f = a.SVGtoCX(j.result);
								f.uploadFile = true;
								a.remoteServiceType = "file";
								a.updateRemoteData(f, n);
								a.hideMask()
							} catch (o) {
								a.hideMask();
								alert("Oooops! Not a CanvasXpress json file")
							}
						}
					} else {
						if (b == "txt" || b == "csv" || b == "tsv" || b == "tab") {
							j.onload = function() {
								try {
									var s = j.result;
									var f = 0;
									var p = 0;
									if (s.match(/,/g)) {
										f = s.match(/,/g).length
									}
									if (s.match(/\t/g)) {
										p = s.match(/\t/g).length
									}
									var o = b == "csv" && f > p ? "," : "\t";
									var q = a.delimitedToArray(s, o, true);
									q.renderTo = d[0];
									q.uploadFile = true;
									a.remoteServiceType = "file";
									a.updateRemoteData(q, n);
									a.hideMask()
								} catch (r) {
									a.hideMask();
									alert("Oooops! Not a CanvasXpress delimited file")
								}
							}
						}
					}
				}
				j.readAsText(h)
			}
		}
	}(this);
	this.save = function(a) {
		return function(d, c) {
			a.removeMenus();
			a.resetConfigurator();
			CanvasXpress.stack[a.target].client = a.meta.factory.client;
			CanvasXpress.stack[a.target].clientIP = a.meta.geo;
			var g = c ? c + ".json" : "cX-" + a.target + ".json";
			g = g.replace(/.json.json$/, ".json");
			var b = new Blob([a.prettyJSON(CanvasXpress.stack[a.target])], {
				type: "text/plain;charset=" + document.characterSet
			});
			saveAs(b, g)
		}
	}(this);
	this.saveSVG = function(a) {
		return function(h, g) {
			a.removeMenus();
			a.resetConfigurator();
			CanvasXpress.stack[a.target].client = a.meta.factory.client;
			CanvasXpress.stack[a.target].clientIP = a.meta.geo;
			a.isSVG = true;
			var d = a.showTransition;
			a.showTransition = false;
			a.meta.canvas.ctx5 = new C2S({
				width: a.width,
				height: a.height,
				desc: a.isReproducibleResearch ? JSON.stringify(CanvasXpress.stack[a.target]) : ""
			});
			a.renderGraph(true);
			var c = a.meta.canvas.ctx5.getSerializedSvg();
			if (a.isReproducibleResearch) {
				a.flashInfoSpan(100, 100, "<h2>Please be aware <br>the actual data is stored<br>inside the downloaded image</h2>", 5000)
			}
			var i = g ? g + ".svg" : "cX-" + a.target + ".svg";
			i = i.replace(/.svg.svg$/, ".svg");
			var b = new Blob([c], {
				type: "image/svg+xml;charset=" + document.characterSet
			});
			saveAs(b, i);
			a.showTransition = d;
			delete(a.meta.canvas.ctx5);
			a.isSVG = false
		}
	}(this);
	this.parseXml = function(a) {
		var c = null;
		if (window.DOMParser) {
			try {
				c = (new DOMParser()).parseFromString(a, "text/xml")
			} catch (b) {
				c = null
			}
		} else {
			if (window.ActiveXObject) {
				try {
					c = new ActiveXObject("Microsoft.XMLDOM");
					c.async = false;
					if (!c.loadXML(a)) {
						window.alert(c.parseError.reason + c.parseError.srcText)
					}
				} catch (b) {
					c = null
				}
			} else {
				alert("cannot parse xml string!")
			}
		}
		return c
	};
	this.SVGtoCX = function(b) {
		var d = this.parseXml(b);
		var a = d.childNodes[0];
		if (a.tagName.match(/svg/i)) {
			var c = a.getAttribute("desc");
			if (c) {
				return JSON.parse(c)
			}
		}
	};
	this.print = function(a) {
		return function(l, k) {
			var h = function() {
				var p;
				var e = [];
				for (var o = 0; o < 256; o++) {
					p = o;
					for (var f = 0; f < 8; f++) {
						p = ((p & 1) ? (3988292384 ^ (p >>> 1)) : (p >>> 1))
					}
					e[o] = p
				}
				return e
			};
			var d = function(o) {
				var e = window.crcTable || (window.crcTable = h());
				var n = 0 ^ (-1);
				for (var f = 0; f < o.length; f++) {
					n = (n >>> 8) ^ e[(n ^ o.charCodeAt(f)) & 255]
				}
				return (n ^ (-1)) >>> 0
			};
			var g = function(f, e) {
				var n = new Uint8Array(f.byteLength + e.byteLength);
				n.set(new Uint8Array(f), 0);
				n.set(new Uint8Array(e), f.byteLength);
				return n.buffer
			};
			var i = function(n) {
				var r = "tEXt";
				var f = n.length;
				var q = d(r + n);
				var e = new ArrayBuffer(12 + f);
				var p = new DataView(e);
				p.setUint32(0, f);
				for (var o = 0; o < r.length; o++) {
					p.setUint8(4 + o, r.charCodeAt(o))
				}
				for (var o = 0; o < n.length; o++) {
					p.setUint8(8 + o, n.charCodeAt(o))
				}
				p.setUint32(4 + 4 + f, q);
				return e
			};
			var c = function() {
				if (a.isReproducibleResearch) {
					return JSON.stringify(CanvasXpress.stack[a.target])
				} else {
					var e = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target]));
					e.afterRender = [e.afterRender[0]];
					return JSON.stringify(e)
				}
			};
			var m = function(p, o, e, f) {
				var n = g(p, o);
				n = g(n, e);
				n = g(n, f);
				return n
			};
			var j = function(e) {
				var n = new FileReader();
				var f = "";
				if (a.isReproducibleResearch) {
					f += "<h2>Please be aware that the actual data is stored inside the image! Right click to save!</h2>"
				} else {
					f += "<h2>Right click to save image</h2>"
				}
				n.onload = function(o) {
// Baohong
					f += "<img width=" + a.width/3 + " height=" + a.height/3 + " src= '" + o.target.result + "'/>";
					a.showTooltipDiv(l, f, a.getTargetEvent(l), {
						maxWidth: a.width + "px",
						whiteSpace: "normal"
					}, 40, 40)
// Baohong
					a.boxplotConnectWidth /= 3;
					a.outlineWidth /= 3;
					a.lineThickness /= 3;
					a.maxTextSize /= 3;
					a.overlayScaleFontFactor /=3;
					a.setDimensions(a.width/3, a.height/3, true);
				};
				n.readAsDataURL(e)
			};
			a.removeMenus();
			a.resetConfigurator();

// Baohong: high-resolution png
			a.boxplotConnectWidth *= 3;
			a.outlineWidth *= 3;
			a.lineThickness *= 3;
			a.maxTextSize *= 3;
			a.overlayScaleFontFactor *=3;
			a.autoScaleFont = true;
			a.setDimensions(a.width*3, a.height*3, true);

			CanvasXpress.stack[a.target].client = a.meta.factory.client;
			CanvasXpress.stack[a.target].clientIP = a.meta.geo;
			var b = a.isMap ? a.getLeafletCanvas() : a.meta.canvas.ctx.canvas;
			b.toBlob(function(f) {
				var e = new FileReader();
				var n = k ? k + ".png" : "cX-" + a.target + ".png";
				n = n.replace(/.png.png$/, ".png");
				e.onloadend = function() {
					var o = new DataView(this.result);
					var q = o.getUint32(8);
					var r = 8 + 4 + 4 + q + 4;
					var s = this.result.slice(0, r);
					var t = this.result.slice(r);
					var w = i("Software\0CanvasXpress Version: " + a.meta.factory.version);
					var u = i("ReproducibleResearch\0" + c());
					var v = m(s, w, u, t);
					var p = new Blob([v], {
						type: "image/png"
					});
					if (a.printType == "download") {
						if (a.isReproducibleResearch) {
							a.flashInfoSpan(100, 100, "<h2>Please be aware <br>the actual data is stored<br>inside the downloaded image</h2>", 5000)
						}
						saveAs(p, n)
// Baohong
						a.boxplotConnectWidth /= 3;
						a.outlineWidth /= 3;
						a.lineThickness /= 3;
						a.maxTextSize /= 3;
						a.overlayScaleFontFactor /=3;
						a.setDimensions(a.width/3, a.height/3, true);
					} else {
						j(p)
					}
				};
				e.readAsArrayBuffer(f);
			}, "image/png");
//			if (a.maximized) { a.clickGraphMaxMin(l) }
		}
	}(this);
	this.exportToSVG = function(a) {
		return function() {
			var b = a.meta.canvas.ctx;
			a.meta.canvas.ctx = new C2S({
				width: a.width,
				height: a.height
			});
			a.draw();
			var c = a.prettyXML(a.meta.canvas.ctx.getSerializedSvg());
			var d = window.open("", a.target + "-SVG");
			d.document.write(c);
			a.meta.canvas.ctx = b;
			a.draw();
			return false
		}
	}(this);
	this.exportToExcel = function(i) {
		return this.exportToTabDelimited(i);
		var g = this.exportToHTML(i, true);
		var f = "data:application/vnd.ms-excel;base64,";
		var c = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="https://www.w3.org/TR/REC-html40"><head><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>{worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head><body><table>{table}</table></body></html>';
		var b = function(d) {
			return window.btoa(unescape(encodeURIComponent(d)))
		};
		var h = function(d, j) {
			return d.replace(/{(\w+)}/g, function(k, l) {
				return j[l]
			})
		};
		var a = {
			worksheet: "Worksheet",
			table: g
		};
		var e = this.$(this.target + "-cX-linkExcel");
		if (!e) {
			e = this.$cX("a", {
				id: this.target + "-cX-linkExcel"
			}, {
				display: "none"
			});
			document.body.appendChild(e)
		}
		e.href = f + b(h(c, a));
		e.download = this.target + ".xls";
		e.click()
	};
	this.exportToHTML = function(e, b) {
		var c = "<table>";
		for (var a = 0; a < e.length; a++) {
			c += "<tr><td>";
			c += e[a].join("</td><td>");
			c += "</td></tr>"
		}
		c += "</table>";
		return b ? c : window.open().document.write(c)
	};
	this.exportToTabDelimited = function(e) {
		var c = "";
		for (var a = 0; a < e.length; a++) {
			c += e[a].join("\t") + "\n"
		}
		var b = this.$(this.target + "-cX-linkTab");
		if (!b) {
			b = this.$cX("a", {
				id: this.target + "-cX-linkTab"
			}, {
				display: "none"
			});
			document.body.appendChild(b)
		}
		b.download = this.target + ".tsv";
		b.href = "data:text/tab-separated-values;charset=UTF-8," + encodeURIComponent(c);
		b.click()
	};
	this.arrayToHTML = function(e) {
		var c = "";
		c += '<div class="CanvasXpressDataTableContainer" style="overflow:scroll;max-height:400px;max-width:600px;position:inherit;padding-left:18px;">';
		c += '<table class="CanvasXpressDataTable" style="position:inherit;">';
		c += "<tbody>";
		c += "<tr>";
		for (var b = 0; b < e[0][0].length; b++) {
			c += '<th class="CanvasXpressTableCellHead" style="height:18px">';
			c += '<div class="CanvasXpressTableCell" style="height:18px">';
			c += e[0][0][b];
			c += "</div>";
			c += "</th>"
		}
		c += "</tr>";
		for (var b = 1; b < e[0].length; b++) {
			c += "<tr>";
			for (var a = 0; a < e[0][b].length; a++) {
				if (a == 0) {
					c += '<th class="CanvasXpressTableCellHead" style="height:18px">';
					c += '<div class="CanvasXpressTableCell" style="height:18px">';
					c += e[0][b][a];
					c += "</div>";
					c += "</th>"
				} else {
					c += '<td class="CanvasXpressTableCell" style="height:18px">';
					c += '<div class="CanvasXpressTableCell" style="height:18px">';
					c += e[0][b][a];
					c += "</div>";
					c += "</td>"
				}
			}
			c += "</tr>"
		}
		c += "</tbody>";
		c += "</table>";
		c += "</div>";
		return c
	};
	this.prettyJSON = function(a) {
		return JSON.stringify(a, null, 2)
	};
	this.prettyXML = function(n) {
		var f = /(>)\s*(<)(\/*)/g;
		var t = / *(.*) +\n/g;
		var e = /(<.+>)(.+\n)/g;
		var d = n.replace(f, "$1\n$2$3").replace(t, "$1\n").replace(e, "$1\n$2");
		var r = 0;
		var b = "";
		var a = d.split("\n");
		var k = 0;
		var q = "other";
		var v = {
			"single->single": 0,
			"single->closing": -1,
			"single->opening": 0,
			"single->other": 0,
			"closing->single": 0,
			"closing->closing": -1,
			"closing->opening": 0,
			"closing->other": 0,
			"opening->single": 1,
			"opening->closing": 0,
			"opening->opening": 1,
			"opening->other": 1,
			"other->single": 0,
			"other->closing": -1,
			"other->opening": 0,
			"other->other": 0
		};
		for (var p = 0; p < a.length; p++) {
			var h = a[p];
			var u = Boolean(h.match(/<.+\/>/));
			var g = Boolean(h.match(/<\/.+>/));
			var m = Boolean(h.match(/<[^!].*>/));
			var c = u ? "single" : g ? "closing" : m ? "opening" : "other";
			var s = q + "->" + c;
			q = c;
			var l = "";
			k += v[s];
			for (var o = 0; o < k; o++) {
				l += "  "
			}
			b += l + h + "\n"
		}
		return b
	};
	this.delimitedToArray = function(h, g, b) {
		g = g || ",";
		var e = new RegExp(("(\\" + g + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + g + "\\r\\n]*))"), "gi");
		var a = [
			[]
		];
		var f = null;
		while (f = e.exec(h)) {
			var c = f[1];
			if (c.length && c !== g) {
				a.push([])
			}
			var d;
			if (f[2]) {
				d = f[2].replace(new RegExp('""', "g"), '"')
			} else {
				d = f[3]
			}
			a[a.length - 1].push(this.isNumber(d) ? Number(d) : d != this.missingDataValue ? d : null)
		}
		return b ? this.delimitedToCanvasXpress(a) : a
	};
	this.delimitedToCanvasXpress = function(h) {
		var c = function(g) {
			return g.filter(function(j, n) {
				return g.indexOf(j) === n
			})
		};
		var d = {
			y: {
				vars: [],
				smps: [],
				data: []
			}
		};
		var k = "Scatter2D";
		var m = h[0].filter(Number);
		if (m.length == 0) {
			m = h.shift()
		} else {
			m = [];
			for (var e = 0; e < h[0].length; e++) {
				m.push("C" + (e + 1))
			}
		}
		var o = [];
		for (var e = 0; e < h.length; e++) {
			o.push(h[e][0].toString())
		}
		var f = c(o);
		if (f.length == o.length) {
			for (var e = 0; e < h.length; e++) {
				h[e].shift(h[e][0])
			}
		} else {
			o = [];
			for (var e = 0; e < h.length; e++) {
				o.push("R" + (e + 1))
			}
		}
		if (m.length > h[0].length) {
			m.shift();
			if (!m.length == h[0].length) {
				return false
			}
		}
		if (h[0].length != h[h.length - 1].length) {
			h.pop();
			o.pop();
			if (h[0].length != h[h.length - 1].length) {
				return false
			}
		}
		var l = [];
		for (var e = 0; e < m.length; e++) {
			l[e] = false;
			for (var b = 0; b < o.length; b++) {
				if (isNaN(h[b][e])) {
					l[e] = true;
					break
				}
			}
			if (!l[e]) {
				for (var b = 0; b < o.length; b++) {
					h[b][e] = Number(h[b][e])
				}
			} else {
				d.z = {}
			}
		}
		for (var e = 0; e < o.length; e++) {
			d.y.data[e] = [];
			d.y.vars.push(o[e])
		}
		for (var e = 0; e < m.length; e++) {
			if (l[e]) {
				d.z[m[e]] = [];
				for (var b = 0; b < o.length; b++) {
					d.z[m[e]].push(h[b][e])
				}
			} else {
				d.y.smps.push(m[e]);
				for (var b = 0; b < o.length; b++) {
					d.y.data[b].push(h[b][e])
				}
			}
		}
		if (d.y.smps.length == 0) {
			var a = d.y.data.length;
			d.y.data = [
				[]
			];
			for (var e = 0; e < a; e++) {
				d.y.data[0].push(1)
			}
			d.y.smps = d.y.vars;
			d.y.vars = ["counts"];
			d.x = d.z;
			delete(d.z);
			k = "Bar"
		} else {
			if (d.y.smps.length == 1) {
				d.y.data = this.transposeMatrix(d.y.data);
				d.y.vars = d.y.smps;
				d.y.smps = o;
				d.x = d.z;
				delete(d.z);
				k = "Bar"
			}
		}
		return {
			data: d,
			config: {
				graphType: k
			}
		}
	};
	this.getRDatasets = function() {
		var b = function(c) {
			return function(d) {
				c.Rdatasets = JSON.parse(d)
			}
		}(this);
		var a = this.RdatasetsURL + "datasets.json";
		this.ajaxRequest(a, false, b)
	};
	this.getRLibraryDataSets = function(a) {
		this.getDataSetListFromURL(this.RdatasetsURL + "json/" + a + "/datasets.json")
	};
	this.getDataFromURL = function() {
		if (this.dataURL) {
			var a = function(b) {
				return function(c) {
					var d = JSON.parse(c);
					b.remoteService = b.dataURL;
					b.remoteServiceType = "file";
					if (Array.isArray(d)) {
						b.setDataSetsFromURL(c)
					} else {
						d.renderTo = d.renderTo || b.newId("cX-data-url-");
						d.records = 0;
						b.updateRemoteData(d)
					}
				}
			}(this);
			this.ajaxRequest(this.dataURL, false, a)
		}
	};
	this.getDataSetListFromURL = function(a) {
		this.remoteService = a;
		this.ajaxRequest(a, false, this.setDataSetsFromURL)
	};
	this.setDataSetsFromURL = function(a) {
		return function(b) {
			var g = function(i) {
				return function(n) {
					var p = JSON.parse(n);
					f.updateRemoteData({
						data: p,
						ids: f.remoteIds,
						records: f.remoteIds.length
					})
				}
			}(f);
			var o = function() {
				var i = a.$("container-" + a.target).parentNode;
				while (i.id.match("canvasXpressRemoteWindow")) {
					i = i.parentNode
				}
				if (!i.id) {
					i.id = a.newId("-cX-data-sets-url-container-")
				}
				return i.id
			};
			var h = JSON.parse(b);
			var d = h[0][1];
			var c = [];
			for (var j = 0; j < h.length; j++) {
				c.push(h[j][0])
			}
			var k = o();
			var m = a.$("container-" + a.target).parentNode;
			var l = a.newId("cX-data-sets-");
			var e = a.$cX("canvas", {
				id: l,
				width: a.originalWidth + 18,
				height: a.originalHeight + 18
			});
			m.appendChild(e);
			var f = new CanvasXpress(l, false, {
				remoteService: a.remoteService
			});
			a.remoteIds = c;
			a.destroy(a.target);
			f.remoteData = h;
			f.remoteParentId = k;
			f.remoteIds = c;
			f.remoteServiceType = "file";
			f.ajaxRequest(d, false, g)
		}
	}(this);
	this.dumpToConsole = function(a) {
		console.log(this.target);
		console.log(this.prettyJSON(a))
	};
	this.initVocabulary = function() {
		if (!CanvasXpress.vocabulary) {
			CanvasXpress.vocabulary = {}
		}
		if (!CanvasXpress.vocabulary.n) {
			CanvasXpress.vocabulary.n = 0;
			CanvasXpress.vocabulary.byId = [];
			CanvasXpress.vocabulary.byStr = {}
		}
	};
	this.getLeafletCanvas = function() {
		if (this.isMap) {
			var i = this.meta.leaflet.ctx;
			var k = this.width;
			var g = this.height;
			var e = i.canvas.width;
			var a = i.canvas.height;
			var b = parseInt((e - k) / 2);
			var j = parseInt((a - g) / 2);
			var f = i.getImageData(b, j, k, g);
			var d = document.createElement("canvas");
			d.width = k;
			d.height = g;
			var l = d.getContext("2d");
			l.putImageData(f, 0, 0);
			return d
		}
	};
	this.initStack = function(d, b, c, e) {
		if (!CanvasXpress.stack) {
			CanvasXpress.stack = {}
		}
		if (navigator.onLine && !this.meta.geo) {
			this.setClientGeo()
		}
		var a = this.$(this.target);
		if (a) {
			if (this.graphType == "Map" && b.leafletInit) {
				b.leafletInitString = b.leafletInit.toString()
			}
			CanvasXpress.stack[this.target] = {
				version: this.meta.factory.version,
				renderTo: this.target,
				data: d ? JSON.parse(JSON.stringify(d)) : false,
				config: b ? JSON.parse(JSON.stringify(b)) : false,
				events: c || false,
				info: e || false,
				afterRender: [
// Baohong : redundant operation for subsequent plots
//                   ["setDimensions", [a.originalWidth, a.originalHeight, true]]
				]
			}
		}
	};
	this.getStack = function() {
		return CanvasXpress.stack[this.target].afterRender
	};
	this.stack = function() {
		if (!this.skipStack) {
			var g = arguments.callee.caller.caller;
			var e = this.getFunctionCallerName(g);
			if (g && e) {
				var b = this.cleanEventInArguments(Array.from(g.arguments));
				var h = CanvasXpress.stack[this.target].afterRender.length;
				switch (e) {
					case "sortSamples":
					case "sortSamplesByCategory":
					case "sortSamplesByVariable":
					case "sortVariables":
					case "sortVariablesByCategory":
					case "sortVariablesBySample":
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							sortDir: this.sortDir
						}]);
						break;
					case "desegregate":
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							segregateSamplesBy: this.segregateSamplesBy,
							segregateVariablesBy: this.segregateVariablesBy
						}]);
						break;
					case "broadcastDraw":
					case "segregateSamplesVariables":
						g = g.caller;
						e = this.getFunctionCallerName(g);
						b = this.cleanEventInArguments(Array.from(g.arguments));
						CanvasXpress.stack[this.target].afterRender.push([e, b]);
						break;
					case "updateDataFilter":
						CanvasXpress.stack[this.target].afterRender.push([e, [true], {
							toDoFilter: this.toDoFilter
						}]);
						break;
					case "endCanvasResizer":
						CanvasXpress.stack[this.target].afterRender.push(["setDimensions", Array.from(arguments.callee.caller.arguments)]);
						break;
					case "drawIndicesAfterWheelEvent":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (h > 1 && c[h - 1][0] == "drawIndicesAfterWheelEvent") {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							varIndicesStart: this.varIndicesStart,
							smpIndicesStart: this.smpIndicesStart
						}]);
						break;
					case "drawRangesAfterWheelEvent":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (h > 1 && c[h - 1][0] == "drawRangesAfterWheelEvent") {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([e, b]);
						break;
					case "drawIndicesAfterPannEvent":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (h > 1 && c[h - 1][0] == "drawIndicesAfterPannEvent") {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							varIndicesStart: this.varIndicesStart,
							smpIndicesStart: this.smpIndicesStart
						}]);
						break;
					case "updateDragScatter":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (h > 1 && c[h - 1][0] == "updateDragScatter" && !b[0].shiftKey) {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							moveLegend: this.moveLegend,
							moveLegendX: this.moveLegendX,
							moveLegendY: this.moveLegendY,
							moveLegendCurX: this.moveLegendCurX,
							moveLegendCurY: this.moveLegendCurY
						}]);
						break;
					case "handleDragEventOneDimension":
						CanvasXpress.stack[this.target].afterRender.push([e, b, {
							moveDendrogram: this.moveDendrogram,
							moveVarOverlay: this.moveVarOverlay,
							moveVar: this.moveVar,
							moveSmpOverlay: this.moveSmpOverlay,
							moveSmp: this.moveSmp
						}]);
						break;
// Baohong: can easily flood the stack when zoom in-and-out
                    case "setIndicesAfterWheelEvent":
                        break;

					default:
						CanvasXpress.stack[this.target].afterRender.push([e, b])
				}
			}
		}
	};
	this.getDragDivDimensions = function(E, y, A) {
		var w, k, m, i, x, n, r, j, B, s, z, q;
		var F = y[0];
		var G = null;
		var D = this.graphType;
		switch (E) {
			case "handleDragEventGenome":
			case "handleDragEventHeatmap":
			case "handleDragEventOneDimension":
			case "handleDragEventScatter":
			case "handlePanning":
			case "showHideSelectedDataPoint":
				G = y[1];
				break;
			case "updateDragNetwork":
				G = y[5];
				break
		}
		var H = G != null ? this.getBoundsXY(G) : false;
		if (H != false) {
			var C = F.xMouseDown;
			var v = F.yMouseDown;
			var u = F.ac.x;
			var a = F.ac.y;
			if (C >= H[0] && C <= H[1] && v >= H[2] && v <= H[3]) {
				if ((!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !F.shiftKey) || (!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && F.shiftKey)) {
					w = x = H[0];
					m = r = H[1] - H[0]
				} else {
					w = x = Math.min(C, u);
					m = 0;
					r = u > C ? u - C : C - u
				}
				B = x;
				z = x + r;
				if ((!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !F.shiftKey) || (!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && F.shiftKey) || D == "Genome") {
					k = n = H[2];
					i = j = H[3] - H[2]
				} else {
					k = n = Math.min(v, a);
					i = 0;
					j = a > v ? a - v : v - a
				}
				s = n;
				q = n + j
			} else {
				if (A && C >= H[4] && C <= H[5] && v >= H[6] && v <= H[7]) {
					var h = function() {
						w = x = H[4];
						k = v;
						n = a;
						m = r = H[5] - H[4];
						i = j = 3;
						B = C;
						s = v;
						z = C;
						q = n
					};
					var d = function() {
						w = C;
						x = u;
						k = n = H[6];
						m = r = 3;
						i = j = H[7] - H[6];
						B = C;
						s = v;
						z = x;
						q = v
					};
					if (A.moveDendrogram) {
						if (A.moveDendrogram == "varDendrogram" || (A.moveDendrogram == "smpDendrogram" && this.graphOrientation == "vertical")) {
							h()
						} else {
							d()
						}
					} else {
						if (A.moveSmpOverlay) {
							if (D.match(/Heatmap/) || this.graphOrientation == "horizontal") {
								d()
							} else {
								h()
							}
						} else {
							if (A.moveSmp) {
								if (D.match(/Heatmap/) || this.graphOrientation == "horizontal") {
									h()
								} else {
									d()
								}
							} else {
								if (A.moveVarOverlay) {
									h()
								} else {
									if (A.moveVar) {
										d()
									} else {
										alert("Ooop! Something went wrong")
									}
								}
							}
						}
					}
				} else {
					alert("Ooop! Something went really wrong")
				}
			}
		}
		return [w, k, m, i, x, n, r, j, B, s, z, q]
	};
	this.reproduce = function(a) {
		return function(l) {
			if (!l) {
				l = window.event
			}
			a.skipStack = true;
			a.resetMenus();
			a.resetLinks();
			var k = document.body;
			var s = a.$(a.target);
			var g = s.parentNode.getClientRects();
			var j = a.$(a.target + "-cX-Drag");
			var p = a.$(a.target + "-cX-Icon-Reproduce");
			if (!p) {
				p = a.$cX("img", {
					id: this.target + "-cX-Icon-Reproduce"
				}, {
					display: "none",
					position: "absolute",
					zIndex: 239010
				});
				document.body.appendChild(p)
			}
			var h = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target].data));
			var d = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target].config));
			var r = CanvasXpress.stack[a.target].afterRender;
			var b = r.length;
			a.setConfigDefaults();
			for (var o in d) {
				a[o] = d[o]
			}
			a.layoutValid = false;
			a.initializeData(h, true);
			a.resetLegendPosition();
			a.resetDendrograms();
			a.initializeGraph(true);
			a.flashInfoSpan(0, 0, "<b>Initial Graph</b>", a.reproduceTime);
			a[r[0][0]].apply(a, r[0][1]);
			var f = 1;
			var q = r.length;
			(function m() {
				setTimeout(function() {
					if (f < b) {
						var A = function(c) {
							if (z == "updateClickConfigurator") {
								return '<img src="' + CanvasXpress.images.mouseLeft2 + '"/>'
							} else {
								if (c.type.match(/wheel/)) {
									return '<img src="' + CanvasXpress.images.mouseScroll + '"/>'
								} else {
									if (c.type.match(/key/)) {
										return '<img src="' + CanvasXpress.images.keyEscape + '"/>'
									} else {
										if (c.type.match(/mouse/)) {
											return '<img src="' + CanvasXpress.images.mouseLeft + '"/>' + x(c)
										} else {
											return '<img src="' + CanvasXpress.images.mouseRight + '"/>'
										}
									}
								}
							}
						};
						var x = function(E) {
							var c = "";
							if (E.shiftKey) {
								c += '<img src="' + CanvasXpress.images.keyShiftIcon + '"/>'
							}
							if (E.ctrlKey) {
								c += '<img src="' + CanvasXpress.images.keyCtrlIcon + '"/>'
							}
							if (E.altKey) {
								c += '<img src="' + CanvasXpress.images.keyAltIcon + '"/>'
							}
							return c
						};
						var n = r[f];
						var z = n[0];
						var e = n[1] || [];
						var C = n[2] || {};
						var u = "<b>Next modification...</b><br><br><b>Function:</b> " + z + "<br><br>";
						var i = "";
						var D = false;
						if (e[0] && e[0].type) {
							i = A(e[0]);
							D = e[0].type.match(/wheel/) ? true : false
						} else {
							if (z == "updateDragScatter" || z == "setDimensions") {
								i = '<img src="' + CanvasXpress.images.mouseLeft + '"/>'
							}
						}
						var B = a.prettyJSON(e);
						if (B.length > 200) {
							B = B.substring(0, 250) + "..."
						}
						u += "<b>Parameters:</b> " + i + '<pre class="CanvasXpressCode">' + B + "</pre><br>";
						var t = a.prettyJSON(C);
						if (t.length > 200) {
							t = B.substring(0, 250) + "..."
						}
						u += '<b>Config:</b> <pre class="CanvasXpressCode">' + t + "</pre><br>";
						for (var w in C) {
							a[w] = C[w]
						}
						a.flashInfoSpan(0, 0, u, a.reproduceTime * 2);
						if (D && p) {
							var y = e[0];
							p.src = CanvasXpress.images.mouseScroll;
							p.style.left = k.scrollLeft + g[0].left + e[0].ac.x - 8 + "px";
							p.style.top = k.scrollTop + g[0].top + e[0].ac.y - 8 + "px";
							p.style.width = "16px";
							p.style.height = "16px";
							p.style.display = "block"
						} else {
							if (i != "" && z != "updateDragScatter" && j && p) {
								var y = e[0];
								var v = a.getDragDivDimensions(z, e, C);
								p.src = CanvasXpress.images.mouseLeft;
								p.style.left = k.scrollLeft + g[0].left + v[8] - 8 + "px";
								p.style.top = k.scrollTop + g[0].top + v[9] - 8 + "px";
								p.style.width = "16px";
								p.style.height = "16px";
								p.style.display = "block";
								j.style.left = v[0] + "px";
								j.style.top = v[1] + "px";
								j.style.width = v[2] + "px";
								j.style.height = v[3] + "px";
								j.style.display = "block";
								a.resizeMove(j, v[4], v[5], v[6], v[7], a.reproduceTime);
								a.resizeMove(p, k.scrollLeft + g[0].left + v[10] - 8, k.scrollTop + g[0].top + v[11] - 8, 16, 16, a.reproduceTime)
							}
						}
						setTimeout(function() {
							if (j && p) {
								a.resetDrag();
								if (D == "") {
									p.style.display = "none"
								}
							}
							a[z].apply(a, e);
							f++;
							m()
						}, z == "updateDragScatter" ? a.reproduceTime / 5000 : a.reproduceTime + 100)
					} else {
						if (p) {
							p.style.display = "none"
						}
						a.flashInfoSpan(0, 0, "<b>That's All Folks</b>", a.reproduceTime);
						a.skipStack = false;
						return
					}
				}, a.reproduceTime)
			})()
		}
	}(this)
};
CanvasXpress.prototype.initConfig = function(a) {
	this.setConfigDefaults = function() {
		var b = this.meta.config.keys;
		this.graphType = "Bar";
		b.push("graphType");
		this.graphOrientation = "horizontal";
		b.push("graphOrientation");
		this.transparency = null;
		b.push("transparency");
		this.canvasBox = false;
		b.push("canvasBox");
		this.canvasBoxColor = "rgb(204,204,204)";
		b.push("canvasBoxColor");
		this.plotBox = false;
		b.push("plotBox");
		this.plotBoxColor = "rgb(204,204,204)";
		b.push("plotBoxColor");
		this.invertGraph = false;
		b.push("invertGraph");
		this.loadImagesTimeOut = 100;
		b.push("loadImagesTimeOut");
		this.isR = false;
		b.push("isR");
		this.isReproducibleResearch = true;
		b.push("isReproducibleResearch");
		this.printType = "download";
		b.push("printType");
		this.thumbnail = false;
		b.push("thumbnail");
		this.reproduceTime = 1000;
		b.push("reproduceTime");
		this.higlightGreyOut = false;
		b.push("higlightGreyOut");
		this.higlightGreyOutTransparency = 0.67;
		b.push("higlightGreyOutTransparency");
		this.theme = "none";
		b.push("theme");
		this.functions = [];
		this.gradient = false;
		b.push("gradient");
		this.gradientType = "radial";
		b.push("gradientType");
		this.gradientOrientation = "vertical";
		b.push("gradientOrientation");
		this.gradientRatio = 1.3;
		b.push("gradientRatio");
		this.useVocabulary = false;
		b.push("useVocabulary");
		this.adjustAspectRatio = true;
		b.push("adjustAspectRatio");
		this.adjustAspectRatioMax = 3;
		b.push("adjustAspectRatioMax");
		this.percentAspectRatioPlotArea = 0.5;
		b.push("percentAspectRatioPlotArea");
		this.adjustAspectRatioYTries = 0;
		this.adjustAspectRatioXTries = 0;
		this.variableSeparationFactor = 2;
		b.push("variableSeparationFactor");
		this.sampleSeparationFactor = 1;
		b.push("sampleSeparationFactor");
		this.widthFactor = 1;
		b.push("widthFactor");
		this.acknowledgment = false;
		b.push("acknowledgment");
		this.foreground = "rgb(0,0,0)";
		b.push("foreground");
		this.foregroundWindow = "rgb(0,0,0)";
		b.push("foregroundWindow");
		this.windowBox = "rgb(0,0,0)";
		b.push("windowBox");
		this.background = "rgb(255,255,255)";
		b.push("background");
		this.backgroundWindow = "rgb(244,244,244)";
		b.push("backgroundWindow");
		this.backgroundType = "solid";
		b.push("backgroundType");
		this.backgroundImage = false;
		b.push("backgroundImage");
		this.backgroundVideo = false;
		b.push("backgroundVideo");
		this.backgroundWindowGradientOrientation = "vertical";
		b.push("backgroundWindowGradientOrientation");
		this.backgroundGradient1Color = "rgb(0,0,200)";
		b.push("backgroundGradient1Color");
		this.backgroundGradient2Color = "rgb(0,0,36)";
		b.push("backgroundGradient2Color");
		this.backgroundWindowGradient1Color = "rgb(0,0,200)";
		b.push("backgroundWindowGradient1Color");
		this.backgroundWindowGradient2Color = "rgb(0,0,36)";
		b.push("backgroundWindowGradient2Color");
		this.margin = 5;
		b.push("margin");
		this.marginLeft = 5;
		b.push("marginLeft");
		this.marginTop = 5;
		b.push("marginTop");
		this.marginBottom = 5;
		b.push("marginBottom");
		this.marginRight = 5;
		b.push("marginRight");
		this.showShadow = false;
		b.push("showShadow");
		this.showTextShadow = false;
		b.push("showTextShadow");
		this.shadowOffsetX = 1;
		b.push("shadowOffsetX");
		this.shadowOffsetY = 1;
		b.push("shadowOffsetY");
		this.shadowBlur = 2;
		b.push("shadowBlur");
		this.shadowColor = "rgba(0,0,0,0.5)";
		b.push("shadowColor");
		this.topoJSON = false;
		b.push("topoJSON");
		this.leafletLayer = true;
		b.push("leafletLayer");
		this.leafletJS = ["https://canvasxpress.org/js/topojson.v2.js", "https://canvasxpress.org/js/leaflet.js"];
		b.push("leafletJS");
		this.leafletCSS = ["https://canvasxpress.org/css/leaflet.css"];
		b.push("leafletCSS");
		this.leafletInit = false;
		b.push("leafletInit");
		this.leafletInitString = false;
		b.push("leafletInitString");
		this.leafletId = false;
		b.push("leafletId");
		this.leafletConfig = false;
		b.push("leafletConfig");
		this.isMap = false;
		this.videoControls = true;
		b.push("videoControls");
		this.videoAutoplay = true;
		b.push("videoAutoplay");
		this.videoLoop = false;
		b.push("videoLoop");
		this.videoPreload = "none";
		b.push("videoPreload");
		this.videoData = "{}";
		b.push("videoData");
		this.videoPoster = "";
		b.push("videoPoster");
		this.videoClassName = "video-js vjs-default-skin";
		b.push("videoClassName");
		this.videoPlaybackRate = 1;
		b.push("videoPlaybackRate");
		this.videoCurrentTime = false;
		b.push("videoCurrentTime");
		this.videoGrid = false;
		b.push("videoGrid");
		this.videoGridStep = 10;
		b.push("videoGridStep");
		this.videoColor = "rgb(255,0,0)";
		b.push("videoColor");
		this.fontName = "Arial";
		b.push("fontName");
		this.fontStyle = "";
		b.push("fontStyle");
		this.fontSize = 12;
		b.push("fontSize");
		this.fontScaleFontFactor = 1;
		b.push("fontScaleFontFactor");
		this.align = "center";
		b.push("align");
		this.baseline = "middle";
		b.push("baseline");
		this.maxTextSize = 40;
		b.push("maxTextSize");
		this.minTextSize = 4;
		b.push("minTextSize");
		this.autoScaleFont = true;
		b.push("autoScaleFont");
		this.scaleTextConstantMult = 30;
		this.scaleTextConstantAdd = 2;
		this.title = false;
		b.push("title");
		this.titleAlign = "center";
		b.push("titleAlign");
		this.titleFontSize = 16;
		b.push("titleFontSize");
		this.titleColor = "rgb(0,0,0)";
		b.push("titleColor");
		this.titleScaleFontFactor = 1;
		b.push("titleScaleFontFactor");
		this.titleFontStyle = "";
		b.push("titleFontStyle");
		this.subtitle = false;
		b.push("subtitle");
		this.subtitleAlign = "center";
		b.push("subtitleAlign");
		this.subtitleFontSize = 14;
		b.push("subtitleFontSize");
		this.subtitleColor = "rgb(0,0,0)";
		b.push("subtitleColor");
		this.subtitleScaleFontFactor = 1;
		b.push("subtitleScaleFontFactor");
		this.subtitleFontStyle = "";
		b.push("subtitleFontStyle");
		this.citation = false;
		b.push("citation");
		this.citationColor = "rgb(0,0,0)";
		b.push("citationColor");
		this.citationFontStyle = "";
		b.push("citationFontStyle");
		this.citationFontSize = 7;
		b.push("citationFontSize");
		this.citationScaleFontFactor = 1;
		b.push("citationScaleFontFactor");
		this.dashLength = 8;
		b.push("dashLength");
		this.dotLength = 1;
		b.push("dotLength");
		this.arrowPointSize = 10;
		b.push("arrowPointSize");
		this.capType = "butt";
		b.push("capType");
		this.joinType = "mitter";
		b.push("joinType");
		this.lineWidthEvent = 3;
		b.push("lineWidthEvent");
		this.outlineWidth = 1;
		b.push("outlineWidth");
		this.lines = [];
		this.colorScheme = "User";
		b.push("colorScheme");
		this.colors = ["#fe296c", "#487eb6", "#a7ce31", "#f8cc03", "#ff8c02", "#699696", "#b77844", "#83acd0", "#c2e076", "#fadc5a", "#ff549f", "#ffaf54", "#9ab8b7", "#d2a683", "#3d699b", "#87ac22", "#cda908", "#d02158", "#d07300", "#567676"];
		b.push("colors");
		this.colorHSV = [0, 0, 1];
		this.colorRGB = [1, 1, 1];
		this.colorSpectrum = ["#4575b4", "#91bfdb", "#e0f3f8", "#ffffbf", "#fee090", "#fc8d59", "#d73027"];
		b.push("colorSpectrum");
		this.colorSpectrumBreaks = [];
		b.push("colorSpectrumBreaks");
		this.colorSpectrumZeroValue = null;
		b.push("colorSpectrumZeroValue");
		this.colorSpectrumNumber = 100;
		b.push("colorSpectrumNumber");
		this.oddColor = this.background;
		b.push("oddColor");
		this.evenColor = "rgb(245,245,245)";
		b.push("evenColor");
		this.patterns = ["solid", "hatchForward", "hatchReverse", "stripeHorizontal", "stripeVertical", "polkaDot", "crossHatch", "crossStripe", "squares", "circles", "plus", "minus", "bars", "squiglesVertical", "squiglesHorizontal", "brickForward", "brickReverse", "art", "pcx", "hatchForward3", "hatchReverse3"];
		b.push("patterns");
		this.shapes = ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "pacman2", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"];
		b.push("shapes");
		this.sizes = [16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46];
		b.push("sizes");
		this.images = [];
		b.push("images");
		this.timeFormat = "isoDate";
		b.push("timeFormat");
		this.maxSmpStringLen = 30;
		b.push("maxSmpStringLen");
		this.smpLabelDescription = false;
		b.push("smpLabelDescription");
		this.smpTitle = false;
		b.push("smpTitle");
		this.smpTitleFontStyle = "";
		b.push("smpTitleFontStyle");
		this.smpTitleFontSize = 12;
		b.push("smpTitleFontSize");
		this.smpTitleFontColor = this.foreground;
		b.push("smpTitleFontColor");
		this.smpTitleScaleFontFactor = 1;
		b.push("smpTitleScaleFontFactor");
		this.smpLabelFontStyle = "";
		b.push("smpLabelFontStyle");
		this.smpLabelFontSize = 12;
		b.push("smpLabelFontSize");
		this.smpLabelFontColor = this.foreground;
		b.push("smpLabelFontColor");
		this.smpLabelScaleFontFactor = 1;
		b.push("smpLabelScaleFontFactor");
		this.smpLabelRotate = 0;
		b.push("smpLabelRotate");
		this.smpLabelInterval = 1;
		b.push("smpLabelInterval");
		this.showSampleNames = true;
		b.push("showSampleNames");
		this.highlightSmp = [];
		b.push("highlightSmp");
		this.smpHighlightColor = "rgb(255,0,0)";
		b.push("smpHighlightColor");
		this.filterSmpBy = [];
		b.push("filterSmpBy");
		this.filterSmpByOp = [];
		b.push("filterSmpByOp");
		this.filterSmpByValue = [];
		b.push("filterSmpByValue");
		this.filterSmpByCase = [];
		b.push("filterSmpByCase");
		this.filteredSmpIndices = [];
		b.push("filteredSmpIndices");
		this.maxVarStringLen = 30;
		b.push("maxVarStringLen");
		this.varLabelDescription = false;
		b.push("varLabelDescription");
		this.varTitle = false;
		b.push("varTitle");
		this.varTitleFontStyle = "";
		b.push("varTitleFontStyle");
		this.varTitleFontSize = 12;
		b.push("varTitleFontSize");
		this.varTitleFontColor = this.foreground;
		b.push("varTitleFontColor");
		this.varTitleScaleFontFactor = 1;
		b.push("varTitleScaleFontFactor");
		this.varLabelFontStyle = "";
		b.push("varLabelFontStyle");
		this.varLabelFontSize = 12;
		b.push("varLabelFontSize");
		this.varLabelFontColor = this.foreground;
		b.push("varLabelFontColor");
		this.varLabelScaleFontFactor = 1;
		b.push("varLabelScaleFontFactor");
		this.varLabelRotate = 0;
		b.push("varLabelRotate");
		this.varLabelInterval = 1;
		b.push("varLabelInterval");
		this.showVariableNames = true;
		b.push("showVariableNames");
		this.highlightVar = [];
		b.push("highlightVar");
		this.varHighlightColor = "rgb(255,0,0)";
		b.push("varHighlightColor");
		this.filterVarBy = [];
		b.push("filterVarBy");
		this.filterVarByOp = [];
		b.push("filterVarByOp");
		this.filterVarByValue = [];
		b.push("filterVarByValue");
		this.filterVarByCase = [];
		b.push("filterVarByCase");
		this.filteredVarIndices = [];
		b.push("filteredVarIndices");
		this.binConfigurations = {};
		b.push("binConfigurations");
		this.maxOverlayStringLen = 30;
		b.push("maxOverlayStringLen");
		this.overlaysThickness = 18;
		b.push("overlaysThickness");
		this.smpOverlays = [];
		b.push("smpOverlays");
		this.smpOverlayProperties = {};
		b.push("smpOverlayProperties");
		this.showSmpOverlaysLegend = false;
		b.push("showSmpOverlaysLegend");
		this.varOverlays = [];
		b.push("varOverlays");
		this.varOverlayProperties = {};
		b.push("varOverlayProperties");
		this.showVarOverlaysLegend = false;
		b.push("showVarOverlaysLegend");
		this.overlaysLegendPosition = "topRight";
		b.push("overlaysLegendPosition");
		this.showOverlays = true;
		b.push("showOverlays");
		this.showLevelOverlays = true;
		b.push("showLevelOverlays");
		this.overlayFontStyle = "";
		b.push("overlayFontStyle");
		this.overlayFontSize = 12;
		b.push("overlayFontSize");
		this.overlayFontColor = this.foreground;
		b.push("overlayFontColor");
		this.overlayScaleFontFactor = 1;
		b.push("overlayScaleFontFactor");
		this.showLegend = true;
		b.push("showLegend");
		this.legendColumns = 1;
		b.push("legendColumns");
		this.legendPosition = "right";
		b.push("legendPosition");
		this.legendInside = false;
		b.push("legendInside");
		this.legendColor = this.foreground;
		b.push("legendColor");
		this.legendBox = true;
		b.push("legendBox");
		this.legendBoxColor = "rgb(204,204,204)";
		b.push("legendBoxColor");
		this.legendBackgroundColor = this.background;
		b.push("legendBackgroundColor");
		this.legendFontStyle = "";
		b.push("legendFontStyle");
		this.legendFontSize = 12;
		b.push("legendFontSize");
		this.legendScaleFontFactor = 1;
		b.push("legendScaleFontFactor");
		this.legendOrder = false;
		b.push("legendOrder");
		this.showDecorations = true;
		b.push("showDecorations");
		this.showDecorationsLegend = true;
		b.push("showDecorationsLegend");
		this.decorationsPosition = "bottom";
		b.push("decorationsPosition");
		this.decorationsColor = this.foreground;
		b.push("decorationsColor");
		this.decorationsBox = true;
		b.push("decorationsBox");
		this.decorationsBoxColor = "rgb(204,204,204)";
		b.push("decorationsBoxColor");
		this.decorationsBackgroundColor = this.background;
		b.push("decorationsBackgroundColor");
		this.decorationFontStyle = "";
		b.push("decorationFontStyle");
		this.decorationFontSize = 12;
		b.push("decorationFontSize");
		this.decorationScaleFontFactor = 1;
		b.push("decorationScaleFontFactor");
		this.decorationsWidth = 10;
		b.push("decorationsWidth");
		this.decorationsHeight = 20;
		b.push("decorationsHeight");
		this.decorationsType = "bar";
		b.push("decorationsType");
		this.decorations = false;
		b.push("decorations");
		this.showDecorationsRegressionConfidence = true;
		b.push("showDecorationsRegressionConfidence");
		this.showDecorationsKaplanMeierConfidence = false;
		b.push("showDecorationsKaplanMeierConfidence");
		this.decorationsColors = [];
		b.push("decorationsColors");
		this.decorationsProperties = {};
		b.push("decorationsProperties");
		this.isGroupedData = false;
		this.isTransformedData = false;
		this.isBoxPlotCalc = false;
		this.isMarketDataFormated = false;
		this.isMarketSwitched = false;
		this.isGraphTime = false;
		b.push("isGraphTime");
		this.groupingFactors = [];
		b.push("groupingFactors");
		this.segregateSamplesBy = [];
		b.push("segregateSamplesBy");
		this.segregateVariablesBy = [];
		b.push("segregateVariablesBy");
		this.isLogData = false;
		b.push("isLogData");
		this.transformedData = false;
		b.push("transformedData");
		this.smpSort = -1;
		this.varSort = -1;
		this.tmpAsciiArray = [];
		this.sortDir = "ascending";
		b.push("sortDir");
		this.sortCaseSensitive = false;
		b.push("sortCaseSensitive");
		this.transformBase = 2;
		b.push("transformBase");
		this.transformType = false;
		b.push("transformType");
		this.summaryType = false;
		b.push("summaryType");
		this.transformCeilValue = false;
		b.push("transformCeilValue");
		this.transformFloorValue = false;
		b.push("transformFloorValue");
		this.ratioReference = 0;
		b.push("ratioReference");
		this.ratioSampleReference = false;
		b.push("ratioSampleReference");
		this.ratioGroupReference = false;
		b.push("ratioGroupReference");
		this.ratioLevelReference = "";
		b.push("ratioLevelReference");
		this.transformAxis = "samples";
		b.push("transformAxis");
		this.showErrorBars = true;
		b.push("showErrorBars");
		this.errorBarsType = "confidenceInterval95";
		b.push("errorBarsType");
		this.errorBarsWidth = 2;
		b.push("errorBarsWidth");
		this.standardDeviationType = "unbiased";
		b.push("standardDeviationType");
		this.errorEllipseConfidence = 0.99;
		b.push("errorEllipseConfidence");
		this.missingDataColor = "rgba(204,204,204,0.33)";
		b.push("missingDataColor");
		this.missingDataValue = "NA";
		b.push("missingDataValue");
		this.randomSeed = 8;
		b.push("randomSeed");
		this.pseudoRandom = true;
		b.push("pseudoRandom");
		this.randomData = false;
		this.randomDataUniform = false;
		b.push("randomDataUniform");
		this.randomDataSymmetrical = false;
		b.push("randomDataSymmetrical");
		this.randomDataMissing = false;
		b.push("randomDataMissing");
		this.randomDataMean = 0;
		b.push("randomDataMean");
		this.randomDataSigma = 1;
		b.push("randomDataSigma");
		this.randomDataVariables = 3;
		b.push("randomDataVariables");
		this.randomDataSamples = 36;
		b.push("randomDataSamples");
		this.randomDataVariableAnnotations = 2;
		b.push("randomDataVariableAnnotations");
		this.randomDataSampleAnnotations = 3;
		b.push("randomDataSampleAnnotations");
		this.randomDataVariableAnnotationRatio = 1;
		b.push("randomDataVariableAnnotationRatio");
		this.randomDataSampleAnnotationRatio = 6;
		b.push("randomDataSampleAnnotationRatio");
		this.randomMissingDataPercentage = 0;
		b.push("randomMissingDataPercentage");
		this.randomNetworkReduce = true;
		b.push("randomNetworkReduce");
		this.randomNetworkNodes = 50;
		b.push("randomNetworkNodes");
		this.randomNetworkNodeEdgesMax = 5;
		b.push("randomNetworkNodeEdgesMax");
		this.zoom = 1;
		b.push("zoom");
		this.zoomGlobal = 1;
		this.zoomStep = 0.2;
		b.push("zoomStep");
		this.zoomVariablesDisable = false;
		b.push("zoomVariablesDisable");
		this.zoomSamplesDisable = false;
		b.push("zoomSamplesDisable");
		this.panningX = 0;
		b.push("panningX");
		this.panningY = 0;
		b.push("panningY");
		this.panningGlobalX = 0;
		this.panningGlobalY = 0;
		this.panningStep = 0.2;
		b.push("panningStep");
		this.xAxisAbsMax = null;
		this.xAxisAbsMin = null;
		this.xAxisMaxStrLength = false;
		this.setMaxX = null;
		b.push("setMaxX");
		this.setMinX = null;
		b.push("setMinX");
		this.xAxisCurrent = 0;
		b.push("xAxisCurrent");
		this.xAxisTitle = false;
		b.push("xAxisTitle");
		this.xAxis = [];
		b.push("xAxis");
		this.xAxisTickStyle = "solid";
		b.push("xAxisTickStyle");
		this.xAxisTickFormat = false;
		b.push("xAxisTickFormat");
		this.xAxisTickColor = "rgb(204,204,204)";
		b.push("xAxisTickColor");
		this.xAxisExact = false;
		b.push("xAxisExact");
		this.xAxisValues = [];
		b.push("xAxisValues");
		this.xAxisValuesRaw = [];
		this.xAxisMinorValues = [];
		b.push("xAxisMinorValues");
		this.xAxisTransform = false;
		b.push("xAxisTransform");
		this.xAxisTransformCeilValue = false;
		b.push("xAxisTransformCeilValue");
		this.xAxisTransformFloorValue = false;
		b.push("xAxisTransformFloorValue");
		this.xAxisTransformTicks = true;
		b.push("xAxisTransformTicks");
		this.xAxisShow = true;
		b.push("xAxisShow");
		this.xAxisS2Show = false;
		b.push("xAxisS2Show");
		this.xAxisTicks = 5;
		b.push("xAxisTicks");
		this.xAxisMinorTicks = true;
		b.push("xAxisMinorTicks");
		this.xAxisMajorTicks = true;
		b.push("xAxisMajorTicks");
		this.xAxisLeftMajorTick = true;
		b.push("xAxisLeftMajorTick");
		this.xAxisRightMajorTick = true;
		b.push("xAxisRightMajorTick");
		this.xAxisLeftRightTickColor = "rgb(204,204,204)";
		b.push("xAxisLeftRightTickColor");
		this.xAxisHistogramShow = false;
		b.push("xAxisHistogramShow");
		this.xAxisHistogramHeight = 50;
		b.push("xAxisHistogramHeight");
		this.timeValues = [];
		b.push("timeValues");
		this.timeValueIndices = [];
		b.push("timeValueIndices");
		this.timeTicksFirst = false;
		b.push("timeTicksFirst");
		this.xAxis2AbsMax = null;
		this.xAxis2AbsMin = null;
		this.xAxis2MaxStrLength = false;
		this.setMaxX2 = null;
		b.push("setMaxX2");
		this.setMinX2 = null;
		b.push("setMinX2");
		this.xAxis2Title = false;
		b.push("xAxis2Title");
		this.xAxis2 = [];
		b.push("xAxis2");
		this.xAxis2TickFormat = false;
		b.push("xAxis2TickFormat");
		this.xAxis2Values = [];
		b.push("xAxis2Values");
		this.xAxis2ValuesRaw = [];
		this.xAxis2MinorValues = [];
		b.push("xAxis2MinorValues");
		this.xAxis2Show = true;
		b.push("xAxis2Show");
		this.xAxis2Ticks = null;
		this.yAxisAbsMax = null;
		this.yAxisAbsMin = null;
		this.yAxisMaxStrLength = false;
		this.setMaxY = null;
		b.push("setMaxY");
		this.setMinY = null;
		b.push("setMinY");
		this.yAxisCurrent = 0;
		b.push("yAxisCurrent");
		this.yAxisTitle = false;
		b.push("yAxisTitle");
		this.yAxis2Title = false;
		b.push("yAxis2Title");
		this.yAxis = [];
		b.push("yAxis");
		this.yAxisTickStyle = "solid";
		b.push("yAxisTickStyle");
		this.yAxisTickFormat = false;
		b.push("yAxisTickFormat");
		this.yAxisTickColor = "rgb(204,204,204)";
		b.push("yAxisTickColor");
		this.yAxisExact = false;
		b.push("yAxisExact");
		this.yAxisValues = [];
		b.push("yAxisValues");
		this.yAxisValuesRaw = [];
		this.yAxisMinorValues = [];
		b.push("yAxisMinorValues");
		this.yAxisTransform = false;
		b.push("yAxisTransform");
		this.yAxisTransformCeilValue = false;
		b.push("yAxisTransformCeilValue");
		this.yAxisTransformFloorValue = false;
		b.push("yAxisTransformFloorValue");
		this.yAxisTransformTicks = true;
		b.push("yAxisTransformTicks");
		this.yAxisShow = true;
		b.push("yAxisShow");
		this.yAxis2Show = false;
		b.push("yAxis2Show");
		this.yAxisTicks = 5;
		b.push("yAxisTicks");
		this.yAxisMinorTicks = true;
		b.push("yAxisMinorTicks");
		this.yAxisMajorTicks = true;
		b.push("yAxisMajorTicks");
		this.yAxisTopMajorTick = true;
		b.push("yAxisTopMajorTick");
		this.yAxisBottomMajorTick = true;
		b.push("yAxisBottomMajorTick");
		this.yAxisTopBottomTickColor = "rgb(204,204,204)";
		b.push("yAxisTopBottomTickColor");
		this.yAxisHistogramShow = false;
		b.push("yAxisHistogramShow");
		this.yAxisHistogramHeight = 50;
		b.push("yAxisHistogramHeight");
		this.zAxisAbsMax = null;
		this.zAxisAbsMin = null;
		this.zAxisMaxStrLength = false;
		this.setMaxZ = null;
		b.push("setMaxZ");
		this.setMinZ = null;
		b.push("setMinZ");
		this.zAxisCurrent = 0;
		b.push("zAxisCurrent");
		this.zAxisTitle = false;
		b.push("zAxisTitle");
		this.zAxis = [];
		b.push("zAxis");
		this.zAxisTickStyle = "solid";
		b.push("zAxisTickStyle");
		this.zAxisTickFormat = false;
		b.push("zAxisTickFormat");
		this.zAxisTickColor = "rgb(204,204,204)";
		b.push("zAxisTickColor");
		this.zAxisExact = false;
		b.push("zAxisExact");
		this.zAxisValues = [];
		b.push("zAxisValues");
		this.zAxisValuesRaw = [];
		this.zAxisMinorValues = [];
		b.push("zAxisMinorValues");
		this.zAxisShow = true;
		b.push("zAxisShow");
		this.zAxisTicks = 10;
		this.rAxisAbsMax = null;
		this.rAxisAbsMin = null;
		this.rAxisMaxStrLength = false;
		this.rAxisTickFormat = false;
		b.push("rAxisTickFormat");
		this.rAxisTickColor = this.foreground;
		b.push("rAxisTickColor");
		this.rAxisValues = [];
		b.push("rAxisValues");
		this.rAxisValuesRaw = [];
		this.rAxisMinorValues = [];
		b.push("rAxisMinorValues");
		this.rAxisPercentShow = true;
		b.push("rAxisPercentShow");
		this.rAxisShow = true;
		b.push("rAxisShow");
		this.rAxisLabelOrientation = "perpendicular";
		b.push("rAxisLabelOrientation");
		this.rAxisTicks = 5;
		b.push("rAxisTicks");
		this.rAxisMinorTicks = true;
		b.push("rAxisMinorTicks");
		this.rAxisMajorTicks = true;
		b.push("rAxisMajorTicks");
		this.axisTickColor = this.foreground;
		b.push("axisTickColor");
		this.axisTickWidth = 1;
		b.push("axisTickWidth");
		this.axisMinMaxTickWidth = 1;
		b.push("axisMinMaxTickTickWidth");
		this.axisTickFontStyle = "";
		b.push("axisTickFontStyle");
		this.axisTickFontSize = 12;
		b.push("axisTickFontSize");
		this.axisTickScaleFontFactor = 1;
		b.push("axisTickScaleFontFactor");
		this.axisTitleColor = this.foreground;
		b.push("axisTitleColor");
		this.axisTitleFontStyle = "";
		b.push("axisTitleFontStyle");
		this.axisTitleFontSize = 12;
		b.push("axisTitleFontSize");
		this.axisTitleScaleFontFactor = 1;
		b.push("axisTitleScaleFontFactor");
		this.axisExtension = 0.1;
		b.push("axisExtension");
		this.axisAlgorithm = "wilkinson";
		b.push("axisAlgorithm");
		this.axisWilkinsonLoose = false;
		b.push("axisWilkinsonLoose");
		this.axisTicksAutoAdjust = false;
		b.push("axisTicksAutoAdjust");
		this.setMax = null;
		this.setMin = null;
		this.guides = false;
		b.push("guides");
		this.guidesWidth = 0.3;
		b.push("guidesWidth");
		this.guidesColor = "rgb(204,204,204)";
		b.push("guidesColor");
		this.blockContrast = false;
		b.push("blockContrast");
		this.plotByVariable = false;
		b.push("plotByVariable");
		this.is3DPlot = false;
		b.push("is3DPlot");
		this.showDataValues = false;
		b.push("showDataValues");
		this.jitter = true;
		b.push("jitter");
		this.jitterColumns = 7;
		b.push("jitterColumns");
		this.objectBorderColor = "rgb(0,0,0)";
		b.push("objectBorderColor");
		this.lineDecoration = "symbol";
		b.push("lineDecoration");
		this.lineErrorType = "bar";
		b.push("lineErrorType");
		this.coordinateLineColor = false;
		b.push("coordinateLineColor");
		this.lineThickness = 1;
		b.push("lineThickness");
		this.lineType = "rect";
		b.push("lineType");
		this.tension = 0.3;
		b.push("tension");
		this.tensionSegments = 16;
		b.push("tensionSegments");
		this.hullScale = 1.25;
		b.push("hullScale");
		this.parallelCoordinates = [];
		this.boxPlotOutliersRatio = 8;
		b.push("boxPlotOutliersRatio");
		this.showBoxplotOriginalData = false;
		b.push("showBoxplotOriginalData");
		this.showViolinBoxplot = false;
		b.push("showViolinBoxplot");
		this.boxplotDataPointTransparency = 0.5;
		b.push("boxplotDataPointTransparency");
		this.boxplotMedianColor = "rgb(0,0,0)";
		b.push("boxplotMedianColor");
		this.boxplotMedianWidth = 1;
		b.push("boxplotMedianWidth");
		this.boxplotMean = false;
		b.push("boxplotMean");
		this.boxplotMeanColor = "rgb(255,215,0)";
		b.push("boxplotMeanColor");
		this.boxplotMeanColorBorder = "rgb(255,0,0)";
		b.push("boxplotMeanColorBorder");
		this.boxplotConnect = false;
		b.push("boxplotConnect");
		this.boxplotConnectWidth = 2;
		b.push("boxplotConnectWidth");
		this.areaType = "normal";
		b.push("areaType");
		this.dotplotType = "normal";
		b.push("dotplotType");
		this.barType = "normal";
		b.push("barType");
		this.barLollipopFactor = 3;
		b.push("barLollipopColor");
		this.sankeyNodeWidth = 20;
		b.push("sankeyNodeWidth");
		this.sankeyIterations = 32;
		b.push("sankeyIterations");
		this.sankeySource = false;
		b.push("sankeySource");
		this.sankeyTarget = false;
		b.push("sankeyTarget");
		this.sankeyColor = "rgba(150,150,150,0.5)";
		b.push("sankeyColor");
		this.sankeyCoordinateColor = false;
		b.push("sankeyCoordinateColor");
		this.hierarchy = [];
		b.push("hierarchy");
		this.hierarchyVar = false;
		b.push("hierarchyVar");
		this.hierarchyVarIndex = 0;
		this.treeNodeSize = 20;
		b.push("treeNodeSize");
		this.treeLinkColor = "rgb(150,150,150)";
		b.push("treeLinkColor");
		this.treeCoordinateColor = true;
		b.push("treeCoordinateColor");
		this.treeLinkWidth = 1;
		b.push("treeLinkWidth");
		this.treeCircular = false;
		b.push("treeCircular");
		this.treeInverted = false;
		b.push("treeInverted");
		this.treeVarIndex = 0;
		b.push("treeVarIndex");
		this.treeNodeId = 0;
		this.colorBy = false;
		b.push("colorBy");
		this.colorByShowLegend = true;
		b.push("colorByShowLegend");
		this.colorKey = false;
		b.push("colorKey");
		this.shapeBy = false;
		b.push("shapeBy");
		this.shapeByShowLegend = true;
		b.push("shapeByShowLegend");
		this.shapeKey = false;
		b.push("shapeKey");
		this.shapeByData = false;
		b.push("shapeByData");
		this.shapeByShape = false;
		b.push("shapeByShape");
		this.sizeBy = false;
		b.push("sizeBy");
		this.sizeByContinuous = false;
		b.push("sizeByContinuous");
		this.sizeByShowLegend = true;
		b.push("sizeByShowLegend");
		this.sizeKey = false;
		b.push("sizeKey");
		this.sizeByData = false;
		b.push("sizeByData");
		this.outlineBy = false;
		b.push("outlineBy");
		this.outlineByShowLegend = true;
		b.push("outlineByShowLegend");
		this.outlineByData = false;
		b.push("outlineByData");
		this.patternBy = false;
		b.push("patternBy");
		this.patternByShowLegend = true;
		b.push("patternByShowLegend");
		this.patternKey = false;
		b.push("patternKey");
		this.patternByData = false;
		b.push("patternByData");
		this.connectBy = false;
		b.push("connectBy");
		this.connectByColor = "rgb(204,204,204)";
		b.push("connectByColor");
		this.connectByWidth = 2;
		b.push("coonnectByWidth");
		this.connectByData = {};
		this.treemapBy = [];
		b.push("treemapBy");
		this.motionBy = false;
		b.push("motionBy");
		this.motionControlHeight = 50;
		b.push("motionControlHeight");
		this.motionTrails = true;
		b.push("motionTrails");
		this.ellipseBy = false;
		b.push("ellipseBy");
		this.scatterType = false;
		b.push("scatterType");
		this.scatterAxesEqual = false;
		b.push("scatterAxesEqual");
		this.scatterOutlineThreshold = 50000;
		b.push("scatterOutlineThreshold");
		this.functionIntervals = 25;
		b.push("functionIntervals");
		this.selectDataMode = "area";
		b.push("selectDataMode");
		this.selectDataModeDescription = false;
		b.push("selectDataModeDescription");
		this.selectDataPoint = [];
		this.hideDataPoint = [];
		this.isSelectDataPoints = 0;
		this.contourType = "overlay";
		b.push("contourType");
		this.contourXBinSize = false;
		b.push("contourXBinSize");
		this.contourYBinSize = false;
		b.push("contourYBinSize");
		this.contourZBinSize = false;
		b.push("contourZBinSize");
		this.isHistogram = false;
		b.push("isHistogram");
		this.histogramBarWidth = 0.5;
		b.push("histogramBarWidth");
		this.histogramBins = false;
		b.push("histogramBins");
		this.histogramStagger = false;
		b.push("histogramStagger");
		this.showHistogramDensity = false;
		b.push("showHistogramDensity");
		this.histogramDensityKernel = "epanechnikovKernel";
		b.push("histogramDensityKernel");
		this.isCreateHistogram = false;
		this.loessBandwidth = 0.3;
		b.push("loessBandwidth");
		this.loessIterations = 2;
		b.push("loessIterations");
		this.loessAccuracy = 1e-12;
		b.push("loessAccuracy");
		this.showLoessFit = false;
		b.push("showLoessFit");
		this.loessColor = "rgb(255,215,0)";
		b.push("loessColor");
		this.loessDrawOptimizer = 5;
		b.push("loessDrawOptimizer");
		this.maxDOENumber = 8;
		b.push("maxDOENumber");
		this.includeDOE = [];
		b.push("includeDOE");
		this.showDOEData = true;
		b.push("showDOEData");
		this.scatterPlotMatrix = false;
		b.push("scatterPlotMatrix");
		this.scatterPlotMatrixType = "completeBoth";
		b.push("scatterPlotMatrixType");
		this.xRotate = 45;
		b.push("xRotate");
		this.yRotate = 0;
		b.push("yRotate");
		this.zRotate = 0;
		b.push("zRotate");
		this.x3DRatio = 1;
		b.push("x3DRatio");
		this.y3DRatio = 1;
		b.push("y3DRatio");
		this.z3DRatio = 1;
		b.push("z3DRatio");
		this.bar3DInverseWeight = 1;
		b.push("bar3DInverseWeight");
		this.show3DGrid = true;
		b.push("show3DGrid");
		this.rotationDelay = 100;
		b.push("rotationDelay");
		this.rotationSensitivity = 450;
		b.push("rotationSensitivity");
		this.rotationStep = 2;
		b.push("rotationStep");
		this.perspectiveFactor = 2.2;
		b.push("perspectiveFactor");
		this.invMagnificationFactor = 4;
		b.push("invMagnificationFactor");
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		this.isMultidimensionalData = false;
		this.heatmapAutoAdjust = false;
		b.push("heatmapAutoAdjust");
		this.heatmapCellBox = true;
		b.push("heatmapCellBox");
		this.heatmapCellBoxColor = "rgb(220,220,220)";
		b.push("heatmapCellBoxColor");
		this.heatmapCellBoxWidth = 0.5;
		b.push("heatmapCellBoxWidth");
		this.heatmapCellBoxColorHighlight = "rgb(255,215,0)";
		b.push("heatmapCellBoxColorHighlight");
		this.heatmapCellBoxHighlightWidth = 1;
		b.push("heatmapCellBoxHighlightWidth");
		this.heatmapSmpSeparateBy = false;
		b.push("heatmapSmpSeparateBy");
		this.heatmapVarSeparateBy = false;
		b.push("heatmapVarSeparateBy");
		this.heatmapSeparatorWidth = 2.5;
		b.push("heatmapSeparatorWidth");
		this.varTitleLabelOverlayPosition = "bottom";
		b.push("varTitleLabelOverlayPosition");
		this.showHeatmapIndicator = true;
		b.push("showHeatmapIndicator");
		this.heatmapIndicatorHeight = 20;
		b.push("heatmapIndicatorHeight");
		this.heatmapIndicatorWidth = 160;
		b.push("heatmapIndicatorWidth");
		this.adjustAspectRatioHeatmapIndicator = true;
		b.push("adjustAspectRatioHeatmapIndicator");
		this.heatmapIndicatorPosition = "top";
		b.push("heatmapIndicatorPosition");
		this.heatmapIndicatorHistogram = false;
		b.push("heatmapIndicatorHistogram");
		this.heatmapIndicatorHistogramColor = "rgb(0,255,255)";
		b.push("heatmapIndicatorHistogramColor");
		this.isOncoprint = false;
		b.push("isOncoprint");
		this.oncoprintCode = false;
		b.push("oncoprintCode");
		this.oncoprintAmplification = 3;
		b.push("oncoprintAmplification");
		this.oncoprintDeletion = 1;
		b.push("oncoprintDeletion");
		this.treemapBorderWidth = 3;
		b.push("treemapBorderWidth");
		this.treemapBorderColor = "rgb(204,204,204)";
		b.push("treemapBorderColor");
		this.correlationAxis = "samples";
		b.push("correlationAxis");
		this.correlationAnchorLegend = false;
		b.push("correlationAnchorLegend");
		this.correlationAnchorLegendAlignWidth = 40;
		b.push("correlationAnchorLegendAlignWidth");
		this.correlationLabelInterval = 1;
		b.push("correlationLabelInterval");
		this.showVarDendrogram = true;
		b.push("showVarDendrogram");
		this.varDendrogramNewick = false;
		b.push("varDendrogramNewick");
		this.varDendrogramPosition = "top";
		b.push("varDendrogramPosition");
		this.colorVarDendrogramBy = false;
		b.push("colorVarDendrogramBy");
		this.showSmpDendrogram = true;
		b.push("showSmpDendrogram");
		this.smpDendrogramNewick = false;
		b.push("smpDendrogramNewick");
		this.smpDendrogramPosition = "left";
		b.push("smpDendrogramPosition");
		this.colorSmpDendrogramBy = false;
		b.push("colorSmpDendrogramBy");
		this.dendrogramHang = false;
		b.push("dendrogramHang");
		this.dendrogramHeight = 50;
		b.push("dendrogramHeight");
		this.dendrogramColor = "rgb(0,0,0)";
		b.push("dendrogramColor");
		this.distance = "euclidian";
		b.push("distance");
		this.linkage = "complete";
		b.push("linkage");
		this.clusterAxis = "samples";
		b.push("clusterAxis");
		this.kmeansVarClusters = 3;
		b.push("kmeansVarClusters");
		this.kmeansSmpClusters = 3;
		b.push("kmeansSmpClusters");
		this.maxIterations = 10;
		b.push("maxIterations");
		this.imputeMethod = "mean";
		b.push("imputeMethod");
		this.samplesClustered = false;
		b.push("samplesClustered");
		this.variablesClustered = false;
		b.push("variablesClustered");
		this.samplesKmeaned = false;
		b.push("samplesKmeaned");
		this.variablesKmeaned = false;
		b.push("variablesKmeaned");
		this.vennLegendColors = false;
		b.push("vennLegendColors");
		this.vennGroups = 4;
		b.push("vennGroups");
		this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
		b.push("vennCompartments");
		this.vennColors = [];
		b.push("vennColors");
		this.pieType = "separated";
		b.push("pieType");
		this.pieSegmentPrecision = 0;
		b.push("pieSegmentPrecision");
		this.pieSegmentSeparation = 1;
		b.push("pieSegmentSeparation");
		this.pieSegmentLabels = "inside";
		b.push("pieSegmentLabels");
		this.pieLabelType = "percentage";
		b.push("pieLabelType");
		this.maxPieSectors = 20;
		b.push("maxPieSectors");
		this.showPieGrid = true;
		b.push("showPieGrid");
		this.showPieValues = true;
		b.push("showPieValues");
		this.showPieSampleLabel = true;
		b.push("showPieSampleLabel");
		this.startPieSectors = 0;
		b.push("startPieSectors");
		this.pieInnerRadius = 0;
		b.push("pieInnerRadius");
		this.pieColors = [];
		b.push("pieColors");
		this.circularType = "normal";
		b.push("circularType");
		this.chordThickness = 28;
		b.push("chordThickness");
		this.chordColorOrigin = "source";
		b.push("chordColorOrigin");
		this.bubbleColor = "rgba(150,150,150,0.33)";
		b.push("bubbleColor");
		this.circularCenterProportion = 0.3;
		b.push("circularCenterProportion");
		this.arcSegmentsSeparation = 8;
		b.push("arcSegmentsSeparation");
		this.circularRotate = 0;
		b.push("circularRotate");
		this.circularArc = 360;
		b.push("circularArc");
		this.ringSeparation = 8;
		b.push("ringSeparation");
		this.ringsType = [];
		b.push("ringsType");
		this.ringsWeight = [];
		b.push("ringsWeight");
		this.rAxis = false;
		b.push("rAxis");
		this.rAxisZero = false;
		b.push("rAxisZero");
		this.showRingLegend = true;
		b.push("showRingLegend");
		this.showCircularConnections = true;
		b.push("showCircularConnections");
		this.connections = [];
		b.push("connections");
		this.circularLetterSeparationFactor = 1.5;
		b.push("circularLetterSeparationFactor");
		this.circularConnectionsTransparency = 0.5;
		b.push("circularConnectionsTransparency");
		this.smpLabelOrientation = "perpendicular";
		b.push("smpLabelOrientation");
		this.tagCloudTextWeightFactor = 1;
		b.push("tagCloudTextWeightFactor");
		this.tagCloudTextGridSize = 8;
		b.push("tagCloudTextGridSize");
		this.tagCloudTextEllipticity = 0.65;
		b.push("tagCloudTextEllipticity");
		this.tagCloudTextRotateRatio = 0.1;
		b.push("tagCloudTextRotateRatio");
		this.tagCloudGridPoints = [];
		this.showVolume = true;
		b.push("showVolume");
		this.stockIndicators = ["Sma5", "Sma10", "Sma25"];
		b.push("stockIndicators");
		this.sma5Color = "rgb(255,0,0)";
		b.push("sma5Color");
		this.sma10Color = "rgb(0,255,0)";
		b.push("sma10Color");
		this.sma20Color = "rgb(0,0,255)";
		b.push("sma20Color");
		this.sma25Color = "rgb(255,0,255)";
		b.push("sma25Color");
		this.sma50Color = "rgb(0,0,0)";
		b.push("sma50Color");
		this.calculateLayout = true;
		b.push("calculateLayout");
		this.networkFreeze = false;
		b.push("networkFreeze");
		this.networkFreezeOnLoad = false;
		b.push("networkFreezeOnLoad");
		this.networkStack = [];
		this.subNetworks = false;
		this.networkStackStates = 8;
		b.push("networkStackStates");
		this.networkStackIndex = 0;
		this.approximateNodePositions = false;
		b.push("approximateNodePositions");
		this.networkLayoutType = "forceDirected";
		b.push("networkLayoutType");
		this.networkForceConstant = 0;
		b.push("networkForceConstant");
		this.temperature = 0;
		b.push("temperature");
		this.initialTemperature = 0;
		b.push("initialTemperature");
		this.networkNodeMinDistance = 4;
		b.push("networkNodeMinDistance");
		this.attractiveForceFunction = "FruchtermanReingold";
		b.push("attractiveForceFunction");
		this.repulsiveForceFunction = "square";
		b.push("repulsiveForceFunction");
		this.networkRoot = false;
		b.push("networkRoot");
		this.showNetworkRadialLayout = false;
		b.push("showNetworkRadialLayout");
		this.networkDepth = 0;
		this.networkDivisions = 0;
		this.preScaleNetwork = false;
		b.push("preScaleNetwork");
		this.showNetworkNodesLegend = true;
		b.push("showNetworkNodesLegend");
		this.showNetworkEdgesLegend = true;
		b.push("showNetworkEdgesLegend");
		this.showNetworkTextLegend = true;
		b.push("showNetworkTextLegend");
		this.showNetworkDecorationsLegend = true;
		b.push("showNetworkDecorationsLegend");
		this.highlightNode = [];
		b.push("highlightNode");
		this.nodeHighlightColor = "rgb(255,0,0)";
		b.push("nodeHighlightColor");
		this.selectNode = {};
		this.isSelectNodes = 0;
		this.showNodeNameThreshold = 50;
		b.push("showNodeNameThreshold");
		this.showHiddenChildEdges = true;
		b.push("showHiddenChildEdges");
		this.nodeSize = this.preScaleNetwork ? 10 : 20;
		b.push("nodeSize");
		this.edgeWidth = 1;
		b.push("edgeWidth");
		this.layoutTime = 15;
		b.push("layoutTime");
		this.nodeFontStyle = "";
		b.push("nodeFontStyle");
		this.nodeFontSize = this.nodeSize;
		b.push("nodeFontSize");
		this.nodeFontColor = this.foreground;
		b.push("nodeFontColor");
		this.nodeScaleFontFactor = 1;
		b.push("nodeScaleFontFactor");
		this.labelNodePosition = "auto";
		b.push("labelNodePosition");
		this.colorNodeBy = false;
		b.push("colorNodeBy");
		this.shapeNodeBy = false;
		b.push("shapeNodeBy");
		this.sizeNodeBy = false;
		b.push("sizeNodeBy");
		this.colorEdgeBy = false;
		b.push("colorEdgeBy");
		this.shapeEdgeBy = false;
		b.push("shapeEdgeBy");
		this.sizeEdgeBy = false;
		b.push("sizeEdgeBy");
		this.sizeDecorationBy = false;
		b.push("sizeDecorationBy");
		this.is3DNetwork = false;
		b.push("is3DNetwork");
		this.isNetworkCommunities = false;
		b.push("isNetworkCommunities");
		this.calculateNetworkCommunities = true;
		b.push("calculateNetworkCommunities");
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		this.isNetworkConvexHull = false;
		this.isCoordinateNodeColorsNetworkConvexHull = false;
		b.push("isCoordinateNodeColorsNetworkConvexHull");
		this.network2DRotate = 0;
		this.skipClick = false;
		this.autoHideOnDecorationsCenter = false;
		b.push("autoHideOnDecorationsCenter");
		this.networkNodesOnTop = true;
		b.push("networkNodesOnTop");
		this.overrideEventlessNodes = false;
		b.push("overrideEventlessNodes");
		this.overrideAnchorNodes = false;
		b.push("overrideAnchorNodes");
		this.moveParentsWithChildren = false;
		b.push("moveParentsWithChildren");
		this.nodeConfigurableProperties = ["x", "y", "z", "parentNode", "shape", "color", "outline", "size", "width", "height", "pattern", "rotate", "outlineWidth", "imagePath", "zIndex", "eventless", "hide", "hideLabel", "anchor"];
		b.push("nodeConfigurableProperties");
		this.edgeConfigurableProperties = ["color", "width", "cap", "exact", "type"];
		b.push("edgeConfigurableProperties");
		this.filterNodeBy = [];
		b.push("filterNodeBy");
		this.filterNodeByOp = [];
		b.push("filterNodeByOp");
		this.filterNodeByValue = [];
		b.push("filterNodeByValue");
		this.filterNodeByCase = [];
		b.push("filterNodeByCase");
		this.filterEdgeBy = [];
		b.push("filterEdgeBy");
		this.filterEdgeByOp = [];
		b.push("filterEdgeByOp");
		this.filterEdgeByValue = [];
		b.push("filterEdgeByValue");
		this.filterEdgeByCase = [];
		b.push("filterEdgeByCase");
		this.genomeTicks = 50;
		b.push("genomeTicks");
		this.trackNameFontStyle = "";
		b.push("trackNameFontStyle");
		this.trackNameFontSize = 10;
		b.push("trackNameFontSize");
		this.trackNameFontColor = this.foreground;
		b.push("trackNameFontColor");
		this.trackFillColor = this.background;
		b.push("trackFillColor");
		this.trackDirColor = this.foreground;
		b.push("trackDirColor");
		this.subtracksMaxDefault = 8;
		b.push("subtracksMaxDefault");
		this.showFeatureNameThereshold = 20;
		b.push("showFeatureNameThereshold");
		this.featureNameFontStyle = "";
		b.push("featureNameFontStyle");
		this.featureNameFontSize = 10;
		b.push("featureNameFontSize");
		this.featureNameFontColor = this.foreground;
		b.push("featureNameFontColor");
		this.featureFillColor = this.background;
		b.push("featureFillColor");
		this.featureDirColor = this.foreground;
		b.push("featureDirColor");
		this.maxFeatureStringLen = 30;
		b.push("maxFeatureStringLen");
		this.featureWidthDefault = 3;
		b.push("featureWidthDefault");
		this.featureHeightDefault = 14;
		b.push("featureHeightDefault");
		this.featureTraceHeight = 40;
		b.push("featureTraceHeight");
		this.featureTraceTrim = 1;
		b.push("featureTraceTrim");
		this.featureTracesShow = true;
		b.push("featureTracesShow");
		this.featureQualityHeight = 12;
		b.push("featureQualityHeight");
		this.featureQualityValues = false;
		b.push("featureQualityValues");
		this.featureQualityShow = true;
		b.push("featureQualityShow");
		this.featureSignalToNoiseHeight = 12;
		b.push("featureSignalToNoiseHeight");
		this.featureSignalToNoiseValues = false;
		b.push("featureSignalToNoiseValues");
		this.featureSignalToNoiseShow = true;
		b.push("featureSignalToNoiseShow");
		this.featureCoordinateHeight = 12;
		b.push("featureCoordinateHeight");
		this.featureCoordinateShow = true;
		b.push("featureCoordinateShow");
		this.featureTranslateHeight = 12;
		b.push("featureTranslateHeight");
		this.featureTranslateShow = true;
		b.push("featureTranslateShow");
		this.featureTypeDefault = "line";
		b.push("featureTypeDefault");
		this.featureStaggered = false;
		b.push("featureStaggered");
		this.sequenceFontStyle = "";
		b.push("sequenceFontStyle");
		this.sequenceFontSize = 10;
		b.push("sequenceFontSize");
		this.sequenceFill = false;
		b.push("sequenceFill");
		this.sequenceGAPColor = "rgb(255,0,255)";
		b.push("sequenceGAPColor");
		this.sequenceAColor = "rgb(0,103,0)";
		b.push("sequenceAColor");
		this.sequenceBColor = "rgb(0,0,0)";
		b.push("sequenceBColor");
		this.sequenceCColor = "rgb(0,0,255)";
		b.push("sequenceCColor");
		this.sequenceDColor = "rgb(0,0,0)";
		b.push("sequenceDColor");
		this.sequenceEColor = "rgb(0,0,0)";
		b.push("sequenceEColor");
		this.sequenceFColor = "rgb(0,0,255)";
		b.push("sequenceFColor");
		this.sequenceGColor = "rgb(0,0,0)";
		b.push("sequenceGColor");
		this.sequenceHColor = "rgb(255,0,0)";
		b.push("sequenceHColor");
		this.sequenceIColor = "rgb(0,103,0)";
		b.push("sequenceIColor");
		this.sequenceKColor = "rgb(255,0,0)";
		b.push("sequenceKColor");
		this.sequenceLColor = "rgb(0,103,0)";
		b.push("sequenceLColor");
		this.sequenceMColor = "rgb(0,103,0)";
		b.push("sequenceMColor");
		this.sequenceNColor = "rgb(0,0,0)";
		b.push("sequenceNColor");
		this.sequencePColor = "rgb(255,165,0)";
		b.push("sequencePColor");
		this.sequenceQColor = "rgb(0,0,0)";
		b.push("sequenceQColor");
		this.sequenceRColor = "rgb(255,0,0)";
		b.push("sequenceRColor");
		this.sequenceSColor = "rgb(255,165,0)";
		b.push("sequenceSColor");
		this.sequenceTColor = "rgb(255,0,0)";
		b.push("sequenceTColor");
		this.sequenceUColor = "rgb(255,0,0)";
		b.push("sequenceUColor");
		this.sequenceVColor = "rgb(0,103,0)";
		b.push("sequenceVColor");
		this.sequenceWColor = "rgb(0,0,255)";
		b.push("sequenceWColor");
		this.sequenceXColor = "rgb(0,0,0)";
		b.push("sequenceXColor");
		this.sequenceYColor = "rgb(0,0,255)";
		b.push("sequenceYColor");
		this.sequenceZColor = "rgb(0,0,0)";
		b.push("sequenceZColor");
		this.sequenceStartColor = "rgb(0,204,0)";
		b.push("sequenceStartColor");
		this.sequenceEndColor = "rgb(255,0,0)";
		b.push("sequenceEndColor");
		this.wireColor = "rgba(204,204,204,0.1)";
		b.push("wireColor");
		this.periodTicksLabels = 5;
		b.push("periodTicksLabels");
		this.genomeResolution = "low";
		this.trackConfigurableProperties = ["name", "hideName", "hideFeatureNames", "type", "height", "fill", "outline", "hide", "connect", "subtracksMax", "highlight"];
		b.push("trackConfigurableProperties");
		this.featureConfigurableProperties = ["id", "name", "label", "hideName", "fill", "outline", "dir", "showDir", "connect", "offset", "data", "subtype", "quality", "signalToNoise", "coordinate", "sequence", "trace", "gaps", "translate", "hide", "counter"];
		b.push("featureConfigurableProperties");
		this.filterFeatureBy = [];
		b.push("filterFeatureBy");
		this.filterFeatureByOp = [];
		b.push("filterFeatureByOp");
		this.filterFeatureByValue = [];
		b.push("filterFeatureByValue");
		this.filterFeatureByCase = [];
		b.push("filterFeatureByCase");
		this.errors = [];
		this.debug = false;
		b.push("debug");
		this.showVersion = true;
		b.push("showVersion");
		this.showCode = false;
		b.push("showCode");
		this.codeType = "params";
		b.push("codeType");
		this.disableMenu = false;
		b.push("disableMenu");
		this.disableToolbar = false;
		b.push("disableToolbar");
		this.disableTouchToolbar = false;
		b.push("disableTouchToolbar");
		this.disableDataTable = false;
		b.push("disableDataTable");
		this.disableDataFilters = false;
		b.push("disableDataFilters");
		this.disableConfigurator = false;
		b.push("disableConfigurator");
		this.disableAxisResizer = false;
		b.push("disableAxisResizer");
		this.isLayoutConfigurator = false;
		b.push("isLayoutConfigurator");
		this.resizable = true;
		b.push("resizable");
		this.resizableX = true;
		b.push("resizableX");
		this.resizableY = true;
		b.push("resizableY");
		this.movable = true;
		b.push("movable");
		this.maxSubMenus = 20;
		b.push("maxSubMenus");
		this.maxItemMenuCheckbox = 10;
		b.push("maxItemMenuCheckbox");
		this.showAdvancedConfiguration = false;
		b.push("showAdvancedConfiguration");
		this.showFadeResizeMoveAnimation = true;
		b.push("showFadeResizeMoveAnimation");
		this.configuratorWidth = 250;
		b.push("configuratorWidth");
		this.configuratorExamplesSize = 400;
		b.push("configuratorExamplesSize");
		this.alignConfiguratorExamples = false;
		b.push("alignConfiguratorExamples");
		this.showConfiguratorExamplesOnSelect = false;
		b.push("showConfiguratorExamplesOnSelect");
		this.dataFilterWidth = 180;
		b.push("dataFilterWidth");
		this.resizeWidthOnLayout = true;
		b.push("resizeWidthOnLayout");
		this.resizeHeightOnLayout = true;
		b.push("resizeHeightOnLayout");
		this.disableEvents = false;
		b.push("disableEvents");
		this.eventKeys = true;
		b.push("eventKeys");
		this.eventArrowKeys = true;
		b.push("eventArrowKeys");
		this.eventPlusMinusKeys = false;
		b.push("eventPlusMinusKeys");
		this.helpKeyEvents = false;
		b.push("helpKeyEvents");
		this.maintainZoomOnDrag = false;
		b.push("maintainZoomOnDrag");
		this.infoTimeOut = 2000; // Baohong
		b.push("infoTimeOut");
		this.infoStartTime = new Date().getTime();
		this.infoTimeIn = 50;
		b.push("infoTimeIn");
		this.broadcast = true;
		b.push("broadcast");
		this.broadcastType = "var";
		b.push("broadcastType");
		this.resizerBackgroundColor = this.meta.system.isIE ? "rgb(204,204,204)" : "rgba(204,204,204,0.7)";
		b.push("resizerBackgroundColor");
		this.resizerBackgroundColorCurrent = "rgb(237,247,255)";
		b.push("resizerBackgroundColorCurrent");
		this.resizerBackgroundColorOutlineCurrent = "rgb(59,138,229)";
		b.push("resizerBackgroundColorOutlineCurrent");
		this.resizerTransparency = true;
		b.push("resizerTransparency");
		this.resizerType = false;
		b.push("resizerType");
		this.resizerDraw = false;
		b.push("resizerDraw");
		this.resizerPosition = "bottom";
		b.push("resizerPosition");
		this.resizerWidth = 50;
		b.push("resizerWidth");
		this.resizerBackgroundImage = false;
		b.push("resizerBackgroundImage");
		this.resizerDataIndex = 0;
		b.push("resizerDataIndex");
		this.resizerEventData = {};
		this.showAnimation = false;
		b.push("showAnimation");
		this.showTransition = false;
		b.push("showTransition");
		this.transitionTime = 1000;
		b.push("transitionTime");
		this.transitionStep = 10;
		b.push("transitionStep");
		this.transitionStaggering = 10;
		b.push("transitionStaggering");
		this.transitionFunction = "easeInOutQuad";
		b.push("transitionFunction");
		this.showAnimationFontStyle = "";
		b.push("showAnimationFontStyle");
		this.showAnimationFontSize = 10;
		b.push("showAnimationFontSize");
		this.showAnimationFontColor = this.background;
		b.push("showAnimationFontColor");
		this.animationTime = 30;
		b.push("animationTime");
		this.animationType = "grow";
		b.push("animationType");
		this.animationCycles = 20;
		b.push("animationCycles");
		this.snapshotCopyChangeOnly = true;
		b.push("snapshotCopyChangeOnly");
		this.snapshots = [];
		this.isAnimation = false;
		this.weight = 1;
		this.scaleX = 1;
		this.scaleY = 1;
		this.translateX = 0;
		this.translateY = 0;
		this.offsetX = 0;
		this.offsetY = 0;
		this.layoutWidth = 0;
		this.layoutHeight = 0;
		this.layout = "1X1";
		this.layoutTopology = false;
		b.push("layoutTopology");
		this.layoutComb = false;
		b.push("layoutComb");
		this.layoutAdjust = false;
		b.push("layoutAdjust");
		this.layoutCollapse = false;
		b.push("layoutCollapse");
		this.layoutRemoveEmpty = true;
		b.push("layoutRemoveEmpty");
		this.layoutCanvasCompartments = false;
		b.push("layoutCanvasCompartments");
		this.layoutBoxLabelColors = [];
		b.push("layoutBoxLabelColors");
		this.layoutBoxShow = true;
		b.push("layoutBoxShow");
		this.layoutCurrent = 0;
		this.layoutAxis = 3;
		this.imageDir = "";
		b.push("imageDir");
		this.loadingImage = "loading1";
		b.push("loadingImage");
		this.remoteService = false;
		b.push("remoteService");
		this.remoteServiceType = "webService";
		b.push("remoteServiceType");
		this.remoteParams = {};
		b.push("remoteParams");
		this.remoteDirection = "next";
		b.push("remoteDirection");
		this.remoteAutoPlay = false;
		b.push("remoteAutoPlay");
		this.remoteAutoPlayDelay = 3000;
		b.push("remoteAutoPlayDelay");
		this.remoteParamOverride = true;
		b.push("remoteParamOverride");
		this.remoteUpdate = false;
		b.push("remoteUpdate");
		this.remoteUpdateDelay = 10000;
		b.push("remoteUpdateDelay");
		this.remoteParentId = "";
		this.remoteDataIndex = 0;
		this.remoteIds = [];
		this.remoteData = [];
		this.remoteUpdating = false;
		this.RdatasetsURL = "https://raw.githubusercontent.com/neuhausi/Rdatasets/master/";
		this.loadRDatasets = false;
		b.push("loadRDatasets");
		this.skipConfigurableProperties = true;
		b.push("skipConfigurableProperties");
		this.nodesProperties = [];
		b.push("nodesProperties");
		this.edgesProperties = [];
		b.push("edgesProperties");
		this.featuresProperties = [];
		b.push("featuresProperties");
		this.filterType = "and";
		b.push("filterType");
		this.filterSkipNullKeys = false;
		b.push("filterSkipNullKeys");
		this.filterSkipNullValues = false;
		b.push("filterSkipNullValues");
		this.showDataTable = false;
		b.push("showDataTable");
		this.dataTableTransposed = true;
		b.push("dataTableTransposed");
		this.maxRows = 10;
		b.push("maxRows");
		this.maxCols = 6;
		b.push("maxCols");
		this.colWidth = 100;
		b.push("colWidth");
		this.rowHeight = 18;
		b.push("rowHeight");
		this.freezeColLeft = 0;
		b.push("freezeColLeft");
		this.freezeColRight = 0;
		b.push("freezeColRight");
		this.freezeRowTop = 0;
		b.push("freezeRowTop");
		this.freezeRowBottom = 0;
		b.push("freezeRowBottom");
		this.refresehDataTableOnDraw = false;
		b.push("refresehDataTableOnDraw");
		this.showDataTableOnSelect = false;
		b.push("showDataTableOnSelect");
		this.networkShowDataTable = "nodes";
		b.push("networkShowDataTable");
		this.startCol = 0;
		this.startRow = 0;
		this.dataTableColumnWidth = [];
		this.dataTableRowHeight = []
	};
	this.setTheme = function() {
		var b = this.meta.def;
		if (!b.colorNames) {
			b.colorNames = {
				aliceblue: "F0F8FF",
				antiquewhite1: "FFEFDB",
				antiquewhite2: "EEDFCC",
				antiquewhite3: "CDC0B0",
				antiquewhite4: "8B8378",
				antiquewhite: "FAEBD7",
				aqua: "00FFFF",
				aquamarine1: "7FFFD4",
				aquamarine2: "76EEC6",
				aquamarine4: "458B74",
				aquamarine: "7FFFD4",
				azure1: "F0FFFF",
				azure2: "E0EEEE",
				azure3: "C1CDCD",
				azure4: "838B8B",
				azure: "F0FFFF",
				beige: "F5F5DC",
				bisque1: "FFE4C4",
				bisque2: "EED5B7",
				bisque3: "CDB79E",
				bisque4: "8B7D6B",
				bisque: "FFE4C4",
				black: "000000",
				blanchedalmond: "FFEBCD",
				blue: "0000FF",
				blue1: "0000FF",
				blue2: "0000EE",
				blue3: "1874CD",
				blue4: "00008B",
				blueviolet: "8A2BE2",
				brown1: "FF4040",
				brown2: "EE3B3B",
				brown3: "CD3333",
				brown4: "8B2323",
				brown: "A52A2A",
				burlywood1: "FFD39B",
				burlywood2: "EEC591",
				burlywood3: "CDAA7D",
				burlywood4: "8B7355",
				burlywood: "DEB887",
				cadetblue1: "98F5FF",
				cadetblue2: "8EE5EE",
				cadetblue3: "7AC5CD",
				cadetblue4: "53868B",
				cadetblue: "5F9EA0",
				chartreuse1: "7FFF00",
				chartreuse2: "76EE00",
				chartreuse3: "66CD00",
				chartreuse4: "458B00",
				chartreuse: "7FFF00",
				chocolate1: "FF7F24",
				chocolate2: "EE7621",
				chocolate3: "CD661D",
				chocolate: "D2691E",
				coral1: "FF7256",
				coral2: "EE6A50",
				coral3: "CD5B45",
				coral4: "8B3E2F",
				coral: "FF7F50",
				cornflowerblue: "6495ED",
				cornsilk1: "FFF8DC",
				cornsilk2: "EEE8CD",
				cornsilk3: "CDC8B1",
				cornsilk4: "8B8878",
				cornsilk: "FFF8DC",
				crimson: "DC143C",
				cyan: "00FFFF",
				cyan1: "00FFFF",
				cyan2: "00EEEE",
				cyan3: "00CDCD",
				cyan4: "008B8B",
				darkblue: "00008B",
				darkcyan: "008B8B",
				darkgoldenrod1: "FFB90F",
				darkgoldenrod2: "EEAD0E",
				darkgoldenrod3: "CD950C",
				darkgoldenrod4: "8B6508",
				darkgoldenrod4: "8B6508",
				darkgoldenrod: "B8860B",
				darkgray: "A9A9A9",
				darkgreen: "006400",
				darkgrey: "A9A9A9",
				darkkhaki: "BDB76B",
				darkmagenta: "8B008B",
				darkolivegreen1: "CAFF70",
				darkolivegreen2: "BCEE68",
				darkolivegreen3: "A2CD5A",
				darkolivegreen4: "6E8B3D",
				darkolivegreen: "556B2F",
				darkorange1: "FF7F00",
				darkorange2: "EE7600",
				darkorange3: "CD6600",
				darkorange4: "8B4500",
				darkorange: "FF8C00",
				darkorchid1: "BF3EFF",
				darkorchid2: "B23AEE",
				darkorchid3: "9A32CD",
				darkorchid4: "68228B",
				darkorchid: "9932CC",
				darkred: "8B0000",
				darksalmon: "E9967A",
				darkseagreen1: "C1FFC1",
				darkseagreen2: "B4EEB4",
				darkseagreen3: "9BCD9B",
				darkseagreen4: "698B69",
				darkseagreen: "8FBC8F",
				darkslateblue: "483D8B",
				darkslategray1: "97FFFF",
				darkslategray2: "8DEEEE",
				darkslategray: "2F4F4F",
				darkslategray3: "79CDCD",
				darkslategray4: "528B8B",
				darkslategrey: "2F4F4F",
				darkturquoise: "00CED1",
				darkviolet: "9400D3",
				deeppink1: "FF1493",
				deeppink2: "EE1289",
				deeppink3: "CD1076",
				deeppink4: "8B0A50",
				deeppink: "FF1493",
				deepskyblue: "00BFFF",
				deepskyblue1: "00BFFF",
				deepskyblue2: "00B2EE",
				deepskyblue3: "009ACD",
				deepskyblue4: "00688B",
				dimgray: "696969",
				dimgrey: "696969",
				dodgerblue1: "1E90FF",
				dodgerblue: "1E90FF",
				dodgerblue2: "1C86EE",
				dodgerblue3: "1874CD",
				dodgerblue4: "104E8B",
				firebrick1: "FF3030",
				firebrick2: "EE2C2C",
				firebrick3: "CD2626",
				firebrick4: "8B1A1A",
				firebrick: "B22222",
				floralwhite: "FFFAF0",
				forestgreen: "228B22",
				fuchsia: "FF00FF",
				gainsboro: "DCDCDC",
				ghostwhite: "F8F8FF",
				gold1: "FFD700",
				gold2: "EEC900",
				gold3: "CDAD00",
				gold4: "8B7500",
				goldenrod1: "FFC125",
				goldenrod2: "EEB422",
				goldenrod3: "CD9B1D",
				goldenrod4: "8B6914",
				goldenrod: "DAA520",
				goldenrod: "DAA520",
				gold: "FFD700",
				gray10: "1A1A1A",
				gray1: "030303",
				gray11: "1C1C1C",
				gray12: "1F1F1F",
				gray13: "212121",
				gray14: "242424",
				gray15: "262626",
				gray16: "292929",
				gray17: "2B2B2B",
				gray18: "2E2E2E",
				gray19: "303030",
				gray20: "333333",
				gray2: "050505",
				gray21: "363636",
				gray22: "383838",
				gray23: "3B3B3B",
				gray24: "3D3D3D",
				gray25: "404040",
				gray26: "424242",
				gray27: "454545",
				gray28: "474747",
				gray29: "4A4A4A",
				gray30: "4D4D4D",
				gray3: "080808",
				gray31: "4F4F4F",
				gray32: "525252",
				gray33: "545454",
				gray34: "575757",
				gray35: "595959",
				gray36: "5C5C5C",
				gray37: "5E5E5E",
				gray38: "616161",
				gray39: "636363",
				gray40: "666666",
				gray4: "0A0A0A",
				gray41: "696969",
				gray42: "6B6B6B",
				gray43: "6E6E6E",
				gray44: "707070",
				gray45: "737373",
				gray46: "757575",
				gray47: "787878",
				gray48: "7A7A7A",
				gray49: "7D7D7D",
				gray50: "7F7F7F",
				gray5: "0D0D0D",
				gray51: "828282",
				gray52: "858585",
				gray53: "878787",
				gray54: "8A8A8A",
				gray55: "8C8C8C",
				gray56: "8F8F8F",
				gray57: "919191",
				gray58: "949494",
				gray59: "969696",
				gray60: "999999",
				gray6: "0F0F0F",
				gray61: "9C9C9C",
				gray62: "9E9E9E",
				gray63: "A1A1A1",
				gray64: "A3A3A3",
				gray65: "A6A6A6",
				gray66: "A8A8A8",
				gray67: "ABABAB",
				gray68: "ADADAD",
				gray69: "B0B0B0",
				gray70: "B3B3B3",
				gray7: "121212",
				gray71: "B5B5B5",
				gray72: "B8B8B8",
				gray73: "BABABA",
				gray74: "BDBDBD",
				gray75: "BFBFBF",
				gray76: "C2C2C2",
				gray77: "C4C4C4",
				gray78: "C7C7C7",
				gray79: "C9C9C9",
				gray: "808080",
				gray80: "CCCCCC",
				gray8: "141414",
				gray81: "CFCFCF",
				gray82: "D1D1D1",
				gray83: "D4D4D4",
				gray84: "D6D6D6",
				gray85: "D9D9D9",
				gray86: "DBDBDB",
				gray87: "DEDEDE",
				gray88: "E0E0E0",
				gray89: "E3E3E3",
				gray90: "E5E5E5",
				gray9: "171717",
				gray91: "E8E8E8",
				gray92: "EBEBEB",
				gray93: "EDEDED",
				gray94: "F0F0F0",
				gray95: "F2F2F2",
				gray97: "F7F7F7",
				gray98: "FAFAFA",
				gray99: "FCFCFC",
				gray: "BEBEBE",
				green: "008000",
				green1: "00FF00",
				green2: "00EE00",
				green3: "00CD00",
				green4: "008B00",
				greenyellow: "ADFF2F",
				grey: "808080",
				honeydew1: "F0FFF0",
				honeydew2: "E0EEE0",
				honeydew3: "C1CDC1",
				honeydew4: "838B83",
				honeydew: "F0FFF0",
				hotpink1: "FF6EB4",
				hotpink2: "EE6AA7",
				hotpink3: "CD6090",
				hotpink4: "8B3A62",
				hotpink: "FF69B4",
				indianred1: "FF6A6A",
				indianred2: "EE6363",
				indianred3: "CD5555",
				indianred4: "8B3A3A",
				indianred: "CD5C5C",
				indigo: "4B0082",
				ivory1: "FFFFF0",
				ivory2: "EEEEE0",
				ivory3: "CDCDC1",
				ivory4: "8B8B83",
				ivory: "FFFFF0",
				khaki1: "FFF68F",
				khaki2: "EEE685",
				khaki3: "CDC673",
				khaki4: "8B864E",
				khaki: "F0E68C",
				lavenderblush1: "FFF0F5",
				lavenderblush2: "EEE0E5",
				lavenderblush3: "CDC1C5",
				lavenderblush4: "8B8386",
				lavenderblush: "FFF0F5",
				lavender: "E6E6FA",
				lawngreen: "7CFC00",
				lemonchiffon1: "FFFACD",
				lemonchiffon2: "EEE9BF",
				lemonchiffon3: "CDC9A5",
				lemonchiffon4: "8B8970",
				lemonchiffon: "FFFACD",
				lightblue1: "BFEFFF",
				lightblue2: "B2DFEE",
				lightblue3: "9AC0CD",
				lightblue4: "68838B",
				lightblue: "ADD8E6",
				lightcoral: "F08080",
				lightcyan1: "E0FFFF",
				lightcyan2: "D1EEEE",
				lightcyan3: "B4CDCD",
				lightcyan4: "7A8B8B",
				lightcyan: "E0FFFF",
				light: "EEDD82",
				lightgoldenrod1: "FFEC8B",
				lightgoldenrod2: "EEDC82",
				lightgoldenrod3: "CDBE70",
				lightgoldenrod4: "8B814C",
				lightgoldenrodyellow: "FAFAD2",
				lightgray: "D3D3D3",
				lightgreen: "90EE90",
				lightgrey: "D3D3D3",
				lightpink1: "FFAEB9",
				lightpink2: "EEA2AD",
				lightpink3: "CD8C95",
				lightpink4: "8B5F65",
				lightpink: "FFB6C1",
				lightsalmon1: "FFA07A",
				lightsalmon2: "EE9572",
				lightsalmon3: "CD8162",
				lightsalmon4: "8B5742",
				lightsalmon: "FFA07A",
				lightseagreen: "20B2AA",
				lightskyblue1: "B0E2FF",
				lightskyblue2: "A4D3EE",
				lightskyblue3: "8DB6CD",
				lightskyblue4: "607B8B",
				lightskyblue: "87CEFA",
				lightslateblue: "8470FF",
				lightslategray: "778899",
				lightslategrey: "778899",
				lightsteelblue1: "CAE1FF",
				lightsteelblue2: "BCD2EE",
				lightsteelblue3: "A2B5CD",
				lightsteelblue4: "6E7B8B",
				lightsteelblue: "B0C4DE",
				lightyellow1: "FFFFE0",
				lightyellow2: "EEEED1",
				lightyellow3: "CDCDB4",
				lightyellow4: "8B8B7A",
				lightyellow: "FFFFE0",
				lime: "00FF00",
				limegreen: "32CD32",
				linen: "FAF0E6",
				magenta2: "EE00EE",
				magenta3: "CD00CD",
				magenta4: "8B008B",
				magenta: "FF00FF",
				maroon1: "FF34B3",
				maroon2: "EE30A7",
				maroon3: "CD2990",
				maroon4: "8B1C62",
				maroon: "800000",
				maroon: "B03060",
				medium: "66CDAA",
				mediumaquamarine: "66CDAA",
				mediumblue: "0000CD",
				mediumorchid1: "E066FF",
				mediumorchid2: "D15FEE",
				mediumorchid3: "B452CD",
				mediumorchid4: "7A378B",
				mediumorchid: "BA55D3",
				mediumpurple1: "AB82FF",
				mediumpurple2: "9F79EE",
				mediumpurple3: "8968CD",
				mediumpurple4: "5D478B",
				mediumpurple: "9370DB",
				mediumseagreen: "3CB371",
				mediumslateblue: "7B68EE",
				mediumspringgreen: "00FA9A",
				mediumturquoise: "48D1CC",
				mediumvioletred: "C71585",
				midnightblue: "191970",
				mintcream: "F5FFFA",
				mistyrose1: "FFE4E1",
				mistyrose2: "EED5D2",
				mistyrose3: "CDB7B5",
				mistyrose4: "8B7D7B",
				mistyrose: "FFE4E1",
				moccasin: "FFE4B5",
				navajowhite1: "FFDEAD",
				navajowhite2: "EECFA1",
				navajowhite3: "CDB38B",
				navajowhite4: "8B795E",
				navajowhite: "FFDEAD",
				navy: "000080",
				navyblue: "000080",
				oldlace: "FDF5E6",
				olive: "808000",
				olivedrab1: "C0FF3E",
				olivedrab2: "B3EE3A",
				olivedrab4: "698B22",
				olivedrab: "6B8E23",
				orange1: "FFA500",
				orange2: "EE9A00",
				orange3: "CD8500",
				orange4: "8B5A00",
				orange: "FFA500",
				orangered1: "FF4500",
				orangered2: "EE4000",
				orangered3: "CD3700",
				orangered4: "8B2500",
				orangered: "FF4500",
				orchid1: "FF83FA",
				orchid2: "EE7AE9",
				orchid3: "CD69C9",
				orchid4: "8B4789",
				orchid: "DA70D6",
				pale: "DB7093",
				palegoldenrod: "EEE8AA",
				palegreen1: "9AFF9A",
				palegreen2: "90EE90",
				palegreen3: "7CCD7C",
				palegreen4: "548B54",
				palegreen: "98FB98",
				paleturquoise1: "BBFFFF",
				paleturquoise2: "AEEEEE",
				paleturquoise3: "96CDCD",
				paleturquoise4: "668B8B",
				paleturquoise: "AFEEEE",
				palevioletred1: "FF82AB",
				palevioletred2: "EE799F",
				palevioletred3: "CD6889",
				palevioletred4: "8B475D",
				palevioletred: "DB7093",
				papayawhip: "FFEFD5",
				peachpuff1: "FFDAB9",
				peachpuff2: "EECBAD",
				peachpuff3: "CDAF95",
				peachpuff4: "8B7765",
				peachpuff: "FFDAB9",
				peru: "CD853F",
				pink1: "FFB5C5",
				pink2: "EEA9B8",
				pink3: "CD919E",
				pink4: "8B636C",
				pink: "FFC0CB",
				plum1: "FFBBFF",
				plum2: "EEAEEE",
				plum3: "CD96CD",
				plum4: "8B668B",
				plum: "DDA0DD",
				powderblue: "B0E0E6",
				purple1: "9B30FF",
				purple2: "912CEE",
				purple3: "7D26CD",
				purple4: "551A8B",
				purple: "800080",
				purple: "A020F0",
				rebeccapurple: "663399",
				red1: "FF0000",
				red2: "EE0000",
				red3: "CD0000",
				red4: "8B0000",
				red: "FF0000",
				rosybrown1: "FFC1C1",
				rosybrown2: "EEB4B4",
				rosybrown3: "CD9B9B",
				rosybrown4: "8B6969",
				rosybrown: "BC8F8F",
				royalblue1: "4876FF",
				royalblue2: "436EEE",
				royalblue3: "3A5FCD",
				royalblue: "4169E1",
				royalblue4: "27408B",
				saddlebrown: "8B4513",
				salmon1: "FF8C69",
				salmon2: "EE8262",
				salmon3: "CD7054",
				salmon4: "8B4C39",
				salmon: "FA8072",
				sandybrown: "F4A460",
				seagreen1: "54FF9F",
				seagreen2: "4EEE94",
				seagreen: "2E8B57",
				seagreen3: "43CD80",
				seagreen4: "2E8B57",
				seashell1: "FFF5EE",
				seashell2: "EEE5DE",
				seashell3: "CDC5BF",
				seashell4: "8B8682",
				seashell: "FFF5EE",
				sienna1: "FF8247",
				sienna2: "EE7942",
				sienna3: "CD6839",
				sienna4: "8B4726",
				sienna: "A0522D",
				silver: "C0C0C0",
				skyblue1: "87CEFF",
				skyblue2: "7EC0EE",
				skyblue3: "6CA6CD",
				skyblue4: "4A708B",
				skyblue: "87CEEB",
				slateblue1: "836FFF",
				slateblue2: "7A67EE",
				slateblue3: "6959CD",
				slateblue4: "473C8B",
				slateblue: "6A5ACD",
				slategray1: "C6E2FF",
				slategray2: "B9D3EE",
				slategray3: "9FB6CD",
				slategray4: "6C7B8B",
				slategray: "708090",
				slategrey: "708090",
				snow1: "FFFAFA",
				snow2: "EEE9E9",
				snow3: "CDC9C9",
				snow4: "8B8989",
				snow: "FFFAFA",
				springgreen: "00FF7F",
				springgreen1: "00FF7F",
				springgreen2: "00EE76",
				springgreen3: "00CD66",
				springgreen4: "008B45",
				steelblue1: "63B8FF",
				steelblue2: "5CACEE",
				steelblue3: "4F94CD",
				steelblue4: "36648B",
				steelblue: "4682B4",
				tan1: "FFA54F",
				tan2: "EE9A49",
				tan3: "CD853F",
				tan4: "8B5A2B",
				tan: "D2B48C",
				teal: "008080",
				thistle1: "FFE1FF",
				thistle2: "EED2EE",
				thistle3: "CDB5CD",
				thistle4: "8B7B8B",
				thistle: "D8BFD8",
				tomato1: "FF6347",
				tomato2: "EE5C42",
				tomato3: "CD4F39",
				tomato4: "8B3626",
				tomato: "FF6347",
				turquoise1: "00F5FF",
				turquoise2: "00E5EE",
				turquoise3: "00C5CD",
				turquoise4: "00868B",
				turquoise: "40E0D0",
				violet: "EE82EE",
				violetred1: "FF3E96",
				violetred2: "EE3A8C",
				violetred3: "CD3278",
				violetred4: "8B2252",
				violetred: "D02090",
				wheat1: "FFE7BA",
				wheat2: "EED8AE",
				wheat3: "CDBA96",
				wheat4: "8B7E66",
				wheat: "F5DEB3",
				white: "FFFFFF",
				whitesmoke: "F5F5F5",
				yellow1: "FFFF00",
				yellow2: "EEEE00",
				yellow3: "CDCD00",
				yellow4: "8B8B00",
				yellow: "FFFF00",
				yellowgreen: "9ACD32"
			}
		}
		if (!b.colorSchemes) {
			b.colorSchemes = {
				YlGn: {
					3: ["#f7fcb9", "#addd8e", "#31a354"],
					4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
					5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
					6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
					7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
					8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
					9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
				},
				YlGnBu: {
					3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
					4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
					5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
					6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
					7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
					8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
					9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
				},
				GnBu: {
					3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
					4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
					5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
					6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
					7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
					8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
					9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
				},
				BuGn: {
					3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
					4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
					5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
					6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
					7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
					8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
					9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
				},
				PuBuGn: {
					3: ["#ece2f0", "#a6bddb", "#1c9099"],
					4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
					5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
					6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
					7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
					8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
					9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
				},
				PuBu: {
					3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
					4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
					5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
					6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
					7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
					8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
					9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
				},
				BuPu: {
					3: ["#e0ecf4", "#9ebcda", "#8856a7"],
					4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
					5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
					6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
					7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
					8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
					9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
				},
				RdPu: {
					3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
					4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
					5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
					6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
					7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
					8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
					9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
				},
				PuRd: {
					3: ["#e7e1ef", "#c994c7", "#dd1c77"],
					4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
					5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
					6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
					7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
					8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
					9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
				},
				OrRd: {
					3: ["#fee8c8", "#fdbb84", "#e34a33"],
					4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
					5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
					6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
					7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
					8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
					9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
				},
				YlOrRd: {
					3: ["#ffeda0", "#feb24c", "#f03b20"],
					4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
					5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
					6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
					7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
					8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
					9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
				},
				YlOrBr: {
					3: ["#fff7bc", "#fec44f", "#d95f0e"],
					4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
					5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
					6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
					7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
					8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
					9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
				},
				Purples: {
					3: ["#efedf5", "#bcbddc", "#756bb1"],
					4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
					5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
					6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
					7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
					8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
					9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
				},
				Blues: {
					3: ["#deebf7", "#9ecae1", "#3182bd"],
					4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
					5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
					6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
					7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
					8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
					9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
				},
				Greens: {
					3: ["#e5f5e0", "#a1d99b", "#31a354"],
					4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
					5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
					6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
					7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
					8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
					9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
				},
				Oranges: {
					3: ["#fee6ce", "#fdae6b", "#e6550d"],
					4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
					5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
					6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
					7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
					8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
					9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
				},
				Reds: {
					3: ["#fee0d2", "#fc9272", "#de2d26"],
					4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
					5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
					6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
					7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
					8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
					9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
				},
				Greys: {
					3: ["#f0f0f0", "#bdbdbd", "#636363"],
					4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
					5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
					6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
					7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
					8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
					9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
				},
				PuOr: {
					3: ["#f1a340", "#f7f7f7", "#998ec3"],
					4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
					5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
					6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
					7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
					8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
					9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
					10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
					11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
				},
				BrBG: {
					3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
					4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
					5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
					6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
					7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
					8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
					9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
					10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
					11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
				},
				PRGn: {
					3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
					4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
					5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
					6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
					7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
					8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
					9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
					10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
					11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
				},
				PiYG: {
					3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
					4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
					5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
					6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
					7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
					8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
					9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
					10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
					11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
				},
				RdBu: {
					3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
					4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
					5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
					6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
					7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
					8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
					9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
					10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
					11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
				},
				RdGy: {
					3: ["#ef8a62", "#ffffff", "#999999"],
					4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
					5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
					6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
					7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
					8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
					9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
					10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
					11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
				},
				RdYlBu: {
					3: ["#fc8d59", "#ffffbf", "#91bfdb"],
					4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
					5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
					6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
					7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
					8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
					9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
					10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
					11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
				},
				Spectral: {
					3: ["#fc8d59", "#ffffbf", "#99d594"],
					4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
					5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
					6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
					7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
					8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
					9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
					10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
					11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
				},
				RdYlGn: {
					3: ["#fc8d59", "#ffffbf", "#91cf60"],
					4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
					5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
					6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
					7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
					8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
					9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
					10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
					11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
				},
				Accent: {
					3: ["#7fc97f", "#beaed4", "#fdc086"],
					4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
					5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
					6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
					7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
					8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
				},
				Dark2: {
					3: ["#1b9e77", "#d95f02", "#7570b3"],
					4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
					5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
					6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
					7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
					8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
				},
				Paired: {
					3: ["#a6cee3", "#1f78b4", "#b2df8a"],
					4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
					5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
					6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
					7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
					8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
					9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
					10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
					11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
					12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
				},
				Pastel1: {
					3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
					4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
					5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
					6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
					7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
					8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
					9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
				},
				Pastel2: {
					3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
					4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
					5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
					6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
					7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
					8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
				},
				Set1: {
					3: ["#e41a1c", "#377eb8", "#4daf4a"],
					4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
					5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
					6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
					7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
					8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
					9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
				},
				Set2: {
					3: ["#66c2a5", "#fc8d62", "#8da0cb"],
					4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
					5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
					6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
					7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
					8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
				},
				Set3: {
					3: ["#8dd3c7", "#ffffb3", "#bebada"],
					4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
					5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
					6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
					7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
					8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
					9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
					10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
					11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
					12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
				},
				Default: {
					36: ["#ff0000", "#0000ff", "#00ff00", "#ffff00", "#00ffff", "#ff00ff", "#993300", "#000080", "#808000", "#ff6600", "#008080", "#660066", "#ff99cc", "#666699", "#333300", "#ffcc99", "#ccffff", "#9999ff", "#ff8080", "#3366ff", "#339966", "#ffcc00", "#00ccff", "#d02090", "#993366", "#0066cc", "#99cc00", "#ff9900", "#33cccc", "#cc99ff", "#800000", "#333399", "#008000", "#ffffcc", "#99ccff", "#800080"]
				},
				Basic: {
					24: ["#0000ff", "#ff004d", "#ffbf00", "#74ff00", "#a400ff", "#ff7400", "#ffff00", "#00ffff", "#ff0000", "#ffd300", "#3d00ff", "#00ff00", "#ff00ff", "#ff9200", "#d3ff00", "#0090ff", "#6d00ff", "#ff4900", "#ffe800", "#00ff92", "#ff0090", "#ffaa00", "#aaff00", "#004dff"]
				},
				Light: {
					24: ["#6565ff", "#ff6593", "#ffd865", "#abff65", "#c865ff", "#ffab65", "#ffff65", "#65ffff", "#ff6565", "#ffe565", "#8965ff", "#65ff65", "#ff65ff", "#ffbd65", "#e5ff65", "#65bcff", "#a765ff", "#ff9165", "#fff165", "#65ffbd", "#ff65bc", "#ffcc65", "#ccff65", "#6593ff"]
				},
				Favorite: {
					1: ["#ff0000"],
					2: ["#ff0000", "#00ffff"],
					3: ["#ff0000", "#00ff00", "#0000ff"],
					4: ["#ff0000", "#80ff00", "#00ffff", "#8000ff"],
					5: ["#ff0000", "#bfff00", "#00ff80", "#0040ff", "#ff00ff"],
					6: ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff"],
					8: ["#ff0000", "#ffbf00", "#80ff00", "#00ff40", "#00ffff", "#0040ff", "#8000ff", "#ff00bf"],
					10: ["#ff0000", "#ff8000", "#ffff00", "#80ff00", "#00ff00", "#00ff80", "#00ffff", "#0080ff", "#0000ff", "#8000ff"],
					12: ["#ff0000", "#ff8000", "#ffff00", "#80ff00", "#00ff00", "#00ff80", "#00ffff", "#0080ff", "#0000ff", "#8000ff", "#ff00ff", "#ff0080"],
					24: ["#ff0000", "#ff4000", "#ff8000", "#ffbf00", "#ffff00", "#bfff00", "#80ff00", "#40ff00", "#00ff00", "#00ff40", "#00ff80", "#00ffbf", "#00ffff", "#00bfff", "#0080ff", "#0040ff", "#0000ff", "#4000ff", "#8000ff", "#bf00ff", "#ff00ff", "#ff00bf", "#ff0080", "#ff0040"]
				},
				Pastel: {
					24: ["#b5b5ff", "#ffb5cb", "#ffedb5", "#d7ffb5", "#e5b5ff", "#ffd7b5", "#ffffb5", "#b5ffff", "#ffb5b5", "#fff2b5", "#c7b5ff", "#b5ffb5", "#ffb5ff", "#ffdfb5", "#f2ffb5", "#b5dfff", "#d5b5ff", "#ffcab5", "#fff8b5", "#b5ffdf", "#ffb5df", "#ffe6b5", "#e6ffb5", "#b5cbff"]
				},
				Balanced: {
					20: ["#fe296c", "#487eb6", "#a7ce31", "#f8cc03", "#ff8c02", "#699696", "#b77844", "#83acd0", "#c2e076", "#fadc5a", "#ff549f", "#ffaf54", "#9ab8b7", "#d2a683", "#3d699b", "#87ac22", "#cda908", "#d02158", "#d07300", "#567676"]
				},
				Rpalette: {
					8: ["#000000", "#ff0000", "#00cd00", "#0000ff", "#00ffff", "#ff00ff", "#ffff00", "#bebebe"]
				},
				RlatticeBackground: {
					7: ["#ffe5cc", "#ccffcc", "#ccffff", "#cce6ff", "#ffccff", "#ffcccc", "#ffffcc"]
				},
				RlatticeShingle: {
					7: ["#ff7f00", "#00ff00", "#00ffff", "#0080ff", "#ff00ff", "#ff0000", "#ffff00"]
				},
				RlatticeLine: {
					7: ["#0080ff", "#ff00ff", "#006400", "#ff0000", "#ffa500", "#00ff00", "#a52a2a"]
				},
				RlatticePolygon: {
					7: ["#ccffff", "#ffccff", "#ccffcc", "#ffe5cc", "#cce6ff", "#ffffcc", "#ffcccc"]
				},
				Bootstrap: {
					1: ["#337ab7"],
					2: ["#337ab7", "#d9534f"],
					3: ["#337ab7", "#5cb85c", "#d9534f"],
					4: ["#337ab7", "#5cb85c", "#f0ad4e", "#d9534f"],
					5: ["#337ab7", "#5cb85c", "#5bc0de", "#f0ad4e", "#d9534f"],
					6: ["#337ab7", "#5cb85c", "#9370db", "#5bc0de", "#f0ad4e", "#d9534f"],
					7: ["#337ab7", "#5cb85c", "#d9534f", "#f0ad4e", "#5bc0de", "#84fe83", "#ff9976"],
					8: ["#337ab7", "#5cb85c", "#d9534f", "#f0ad4e", "#5bc0de", "#84fe83", "#ff9976", "#c86727"]
				},
				ColorSpectrum: {
					1: []
				},
				White: {
					1: ["#ffffff"]
				},
				Black: {
					1: ["#000000"]
				},
				Economist: {
					12: ["#6794A7", "#014D64", "#76C0C1", "#01A2D9", "#7AD2F6", "#00887D", "#ADADAD", "#7BD3F6", "#7C260B", "#EE8F71", "#76C0C1", "#A18376"]
				},
				EconomistBG: {
					5: ["#D5E4EB", "#C3D6DF", "#ED111A", "#EBEBEB", "#C9C9C9"]
				},
				Excel: {
					7: ["#FF00FF", "#FFFF00", "#00FFFF", "#800080", "#800000", "#008080", "#0000FF"]
				},
				Excel2: {
					7: ["#993366", "#FFFFCC", "#CCFFFF", "#660066", "#FF8080", "#0066CC", "#CCCCFF"]
				},
				Excel3: {
					10: ["#365E96", "#983334", "#77973D", "#5D437C", "#36869F", "#D1702F", "#8197C5", "#C47F80", "#ACC484", "#9887B0"]
				},
				GGPlot: {
					1: ["#F8766D"],
					2: ["#F8766D", "#00BFC4"],
					3: ["#F8766D", "#00BA38", "#619CFF"],
					4: ["#F8766D", "#7CAE00", "#00BFC4", "#C77CFF"],
					5: ["#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3"],
					6: ["#F8766D", "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"],
					7: ["#F8766D", "#C49A00", "#53B400", "#00C094", "#00B6EB", "#A58AFF", "#FB61D7"],
					8: ["#F8766D", "#CD9600", "#7CAE00", "#00BE67", "#00BFC4", "#00A9FF", "#C77CFF", "#FF61CC"],
					9: ["#F8766D", "#D39200", "#93AA00", "#00BA38", "#00C19F", "#00B9E3", "#619CFF", "#DB72FB", "#FF61C3"],
					10: ["#F8766D", "#D89000", "#A3A500", "#39B600", "#00BF7D", "#00BFC4", "#00B0F6", "#9590FF", "#E76BF3", "#FF62BC"],
					11: ["#F8766D", "#DB8E00", "#AEA200", "#64B200", "#00BD5C", "#00C1A7", "#00BADE", "#00A6FF", "#B385FF", "#EF67EB", "#FF63B6"],
					12: ["#F8766D", "#DE8C00", "#B79F00", "#7CAE00", "#00BA38", "#00C08B", "#00BFC4", "#00B4F0", "#619CFF", "#C77CFF", "#F564E3", "#FF64B0"],
					13: ["#F8766D", "#E18A00", "#BE9C00", "#8CAB00", "#24B700", "#00BE70", "#00C1AB", "#00BBDA", "#00ACFC", "#8B93FF", "#D575FE", "#F962DD", "#FF65AC"],
					14: ["#F8766D", "#E38900", "#C49A00", "#99A800", "#53B400", "#00BC56", "#00C094", "#00BFC4", "#00B6EB", "#06A4FF", "#A58AFF", "#DF70F8", "#FB61D7", "#FF66A8"],
					15: ["#F8766D", "#E58700", "#C99800", "#A3A500", "#6BB100", "#00BA38", "#00BF7D", "#00C0AF", "#00BCD8", "#00B0F6", "#619CFF", "#B983FF", "#E76BF3", "#FD61D1", "#FF67A4"],
					16: ["#F8766D", "#E68613", "#CD9600", "#ABA300", "#7CAE00", "#0CB702", "#00BE67", "#00C19A", "#00BFC4", "#00B8E7", "#00A9FF", "#8494FF", "#C77CFF", "#ED68ED", "#FF61CC", "#FF68A1"],
					17: ["#F8766D", "#E7851E", "#D09400", "#B2A100", "#89AC00", "#45B500", "#00BC51", "#00C087", "#00C0B2", "#00BCD6", "#00B3F2", "#29A3FF", "#9C8DFF", "#D277FF", "#F166E8", "#FF61C7", "#FF689E"],
					18: ["#F8766D", "#E88526", "#D39200", "#B79F00", "#93AA00", "#5EB300", "#00BA38", "#00BF74", "#00C19F", "#00BFC4", "#00B9E3", "#00ADFA", "#619CFF", "#AE87FF", "#DB72FB", "#F564E3", "#FF61C3", "#FF699C"]
				},
				Solarized: {
					1: ["#B58900"],
					2: ["#B58900", "#859900"],
					3: ["#B58900", "#C671C4", "#859900"],
					4: ["#B58900", "#DC322F", "#268BD2", "#859900"],
					5: ["#B58900", "#DC322F", "#6C71C4", "#268BD2", "#859900"],
					6: ["#B58900", "#CB4B16", "#D33682", "#6C71C4", "#2AA198", "#859900"],
					7: ["#B58900", "#CB4B16", "#DC322F", "#6C71C4", "#268BD2", "#2AA198", "#859900"],
					8: ["#B58900", "#CB4B16", "#DC322F", "#D33682", "#6C71C4", "#268BD2", "#2AA198", , "#859900"]
				},
				SolarizedBase: {
					7: ["#002B36", "#073642", "#586E75", "#839496", "#93A1A1", "#EEE8D5", "#FDF6E3"],
					8: ["#002B36", "#073642", "#586E75", "#657B83", "#839496", "#93A1A1", "#EEE8D5", "#FDF6E3"]
				},
				PaulTol: {
					1: ["#4477AA"],
					2: ["#4477AA", "#CC6677"],
					3: ["#4477AA", "#DDCC77", "#CC6677"],
					4: ["#4477AA", "#117733", "#DDCC77", "#CC6677"],
					5: ["#4477AA", "#88CCEE", "#117733", "#DDCC77", "#CC6677"],
					6: ["#4477AA", "#88CCEE", "#117733", "#DDCC77", "#CC6677", "#AA4499"],
					7: ["#332288", "#88CCEE", "#44AA99", "#117733", "#DDCC77", "#CC6677", "#AA4499"],
					8: ["#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#CC6677", "#AA4499"],
					9: ["#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#CC6677", "#882255", "#AA4499"],
					10: ["#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#882255", "#AA4499"],
					11: ["#332288", "#6699CC", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#882255", "#AA4499"],
					12: ["#332288", "#6699CC", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#AA4466", "#882255", "#AA4499"]
				},
				ColorBlind: {
					8: ["#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7"]
				},
				Tableau: {
					20: ["#1F77B4", "#AEC7E8", "#FF7F0E", "#FFBB78", "#2CA02C", "#98DF8A", "#D62728", "#FF9896", "#9467BD", "#C5B0D5", "#8C564B", "#C49C94", "#E377C2", "#F7B6D2", "#7F7F7F", "#C7C7C7", "#BCBD22", "#DBDB8D", "#17BECF", "#9EDAE5"],
					10: ["#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B", "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF"]
				},
				TableauMedium: {
					10: ["#729ECE", "#FF9E4A", "#67BF5C", "#ED665D", "#AD8BC9", "#A8786E", "#ED97CA", "#A2A2A2", "#CDCC5D", "#6DCCDA"]
				},
				TableauLight: {
					10: ["#AEC7E8", "#FFBB78", "#98DF8A", "#FF9896", "#C5B0D5", "#C49C94", "#F7B6D2", "#C7C7C7", "#DBDB8D", "#9EDAE5"]
				},
				TableauGrey: {
					5: ["#60636A", "#A5ACAF", "#414451", "#8F8782", "#CFCFCF"]
				},
				TableauColorBlind: {
					10: ["#006BA4", "#FF800E", "#ABABAB", "#595959", "#5F9ED1", "#C85200", "#898989", "#A2C8EC", "#FFBC79", "#CFCFCF"]
				},
				TableauTrafficLight: {
					9: ["#B10318", "#DBA13A", "#309343", "#D82526", "#FFC156", "#69B764", "#F26C64", "#FFDD71", "#9FCD99"]
				},
				TableauPurpleGrey: {
					12: ["#7B66D2", "#A699E8", "#DC5FBD", "#FFC0DA", "#5F5A41", "#B4B19B", "#995688", "#D898BA", "#AB6AD5", "#D098EE", "#8B7C6E", "#DBD4C5"]
				},
				TableauBlueRed: {
					12: ["#2C69B0", "#B5C8E2", "#F02720", "#FFB6B0", "#AC613C", "#E9C39B", "#6BA3D6", "#B5DFFD", "#AC8763", "#DDC9B4", "#BD0A36", "#F4737A"]
				},
				TableauGreenOrange: {
					12: ["#32A251", "#ACD98D", "#FF7F0F", "#FFB977", "#3CB7CC", "#98D9E4", "#B85A0D", "#FFD94A", "#39737C", "#86B4A9", "#82853B", "#CCC94D"]
				},
				TableauCyclic: {
					20: ["#1F83B4", "#1696AC", "#18A188", "#29A03C", "#54A338", "#82A93F", "#ADB828", "#D8BD35", "#FFBD4C", "#FFB022", "#FF9C0E", "#FF810E", "#E75727", "#D23E4E", "#C94D8C", "#C04AA7", "#B446B3", "#9658B1", "#8061B4", "#6F63BB"]
				},
				TableauPairSequential: {
					32: ["#BCCFB4", "#9C0824", "#BCCFB4", "#09622A", "#B4D4DA", "#26456E", "#F0C294", "#7B3014", "#C3C3C3", "#1E1E1E", "#E5E5E5", "#FFB2B6", "#E5E5E5", "#B7E6A7", "#E5E5E5", "#C4D8F3", "#E5E5E5", "#FFCC9E", "#F5CAC7", "#BD1100", "#DBE8B4", "#3C8200", "#F3E0C2", "#BB5137", "#FEFFD9", "#41B7C4", "#F7E4C6", "#BB5137", "#EFEDF5", "#807DBA", "#F0F0F0", "#737373"]
				},
				TableauTripleDiverging: {
					48: ["#9C0824", "#CACACA", "#26456E", "#9C0824", "#CACACA", "#09622A", "#9C0824", "#FFFFFF", "#09622A", "#9C0824", "#CACACA", "#1E1E1E", "#9C0824", "#FFFFFF", "#1E1E1E", "#09622A", "#CACACA", "#26456E", "#7B3014", "#CACACA", "#26456E", "#7B3014", "#FFFFFF", "#26456E", "#FFB2B6", "#E5E5E5", "#B7E6A7", "#FFB2B6", "#FFFFFF", "#B7E6A7", "#FFB2B6", "#FFFFFF", "#C6C6C6", "#FFCC9E", "#E5E5E5", "#C4D8F3", "#FFCC9E", "#FFFFFF", "#C4D8F3", "#E0AD30", "#E4E4E2", "#7492AA", "#EDA389", "#CDE1D3", "#5C8B70", "#529985", "#DBCF47", "#C26B51"]
				},
				WallStreetJournal: {
					4: ["#EFEFEF", "#E9F3EA", "#D4DEE7", "#F8F2E4"]
				},
				WallStreetJournal2: {
					4: ["#D3BA68", "#D5695D", "#5D8CA8", "#65A479"]
				},
				WallStreetJournalRedGreen: {
					2: ["#088158", "#BA2F2A"]
				},
				WallStreetJournalBlackGreen: {
					4: ["#000000", "#595959", "#59A77F", "#008856"]
				},
				WallStreetJournalDemRep: {
					3: ["#006A8E", "#B1283A", "#A8A6A7"]
				},
				WallStreetJournal3: {
					6: ["#C72E29", "#016392", "#BE9C2E", "#098154", "#FB832D", "#000000"]
				},
				Stata: {
					15: ["#1A476F", "#90353B", "#55752F", "#E37E00", "#6E8E84", "#C10534", "#938DD2", "#CAC27E", "#A0522D", "#7B92A8", "#2D6D66", "#9C8847", "#BFA19C", "#FFD200", "#D9E6EB"]
				},
				Stata2: {
					15: ["#FFFF00", "#00FF00", "#0080FF", "#FF00FF", "#FF7F00", "#FF0000", "#ADD8E6", "#FFE474", "#00FF80", "#C0DCC0", "#FF4500", "#0000FF", "#FF0080", "#6E8E84", "#A0522D"]
				},
				Stata3: {
					15: ["#006000", "#ff4500", "#1a476f", "#90353b", "#6e8e84", "#a0522d", "#ff7f00", "#ff00ff", "#00ffff", "#ff0000", "#00ff00", "#9c8847", "#800080", "#c0dcc0", "#add8e6"]
				},
				StataMono: {
					15: ["#606060", "#A0A0A0", "#808080", "#404040", "#000000", "#E0E0E0", "#202020", "#707070", "#909090", "#B0B0B0", "#D0D0D0", "#F0F0F0", "#303030", "#C0C0C0", "#505050"]
				},
				BlackAndWhite: {
					3: ["#f0f0f0", "#bdbdbd", "#636363"],
					4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
					5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
					6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
					7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
					8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
					9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
				},
				CanvasXpress: {
					1: ["#f2000d"],
					2: ["#f2000d", "#000df2"],
					3: ["#f2000d", "#000df2", "#0df200"],
					4: ["#f2000d", "#000df2", "#0df200", "#f2f20d"],
					5: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2"],
					6: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2"],
					7: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2"],
					8: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3"],
					9: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe"],
					10: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b"],
					11: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016"],
					12: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d"],
					13: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00"],
					14: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00", "#080808"],
					15: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00", "#080808", "#fed38b"],
					16: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00", "#080808", "#fed38b", "#d38bfe"],
					17: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00", "#080808", "#fed38b", "#d38bfe", "#8bfed3"],
					18: ["#f2000d", "#000df2", "#0df200", "#f2f20d", "#f20df2", "#0df2f2", "#f2f2f2", "#fe8bd3", "#8bd3fe", "#d3fe8b", "#5d0016", "#00165d", "#165d00", "#080808", "#fed38b", "#d38bfe", "#8bfed3", "#404040"]
				},
				CanvasXpressT: {
					1: ["rgba(242,0,13,0.5)"],
					2: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)"],
					3: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)"],
					4: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)"],
					5: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)"],
					6: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)"],
					7: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)"],
					8: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)"],
					9: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)"],
					10: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)"],
					11: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)"],
					12: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)"],
					13: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)"],
					14: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)", "rgba(8,8,8,0.5)"],
					15: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)", "rgba(8,8,8,0.5)", "rgba(254,211,139,0.5)"],
					16: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)", "rgba(8,8,8,0.5)", "rgba(254,211,139,0.5)", "rgba(211,139,254,0.5)"],
					17: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)", "rgba(8,8,8,0.5)", "rgba(254,211,139,0.5)", "rgba(211,139,254,0.5)", "rgba(139,254,211,0.5)"],
					18: ["rgba(242,0,13,0.5)", "rgba(0,13,242,0.5)", "rgba(13,242,0,0.5)", "rgba(242,242,13,0.5)", "rgba(242,13,242,0.5)", "rgba(13,242,242,0.5)", "rgba(242,242,242,0.5)", "rgba(254,139,211,0.5)", "rgba(139,211,254,0.5)", "rgba(211,254,139,0.5)", "rgba(93,0,22,0.5)", "rgba(0,22,93,0.5)", "rgba(22,93,0,0.5)", "rgba(8,8,8,0.5)", "rgba(254,211,139,0.5)", "rgba(211,139,254,0.5)", "rgba(139,254,211,0.5)", "rgba(64,64,64,0.5)"]
				}
			}
		}
		if (!b.themes) {
			b.themes = {
				economist: {
					backgroundType: "solid",
					backgroundWindow: "#D5E4EB",
					background: "#D5E4EB",
					colorScheme: "Economist",
					legendColor: "#000000",
					legendBox: false,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#D5E4EB",
					legendColumns: 4,
					legendInside: true,
					legendPosition: "top",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 2,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: false,
					xAxisTickColor: "#000000",
					xAxisLeftMajorTick: false,
					xAxisRightMajorTick: false,
					xAxisTickStyle: "line",
					xAxisLeftRightTickColor: "#000000",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: false,
					yAxis2Show: true,
					yAxisTickStyle: "line",
					yAxisTickColor: "#FFFFFF",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#000000",
					titleAlign: "left",
					titleColor: "#000000",
					subtitleAlign: "left",
					subtitleColor: "#000000"
				},
				excel: {
					backgroundType: "window",
					backgroundWindow: "#C0C0C0",
					background: "#FFFFFF",
					colorScheme: "Excel",
					legendColor: "#000000",
					legendBox: true,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: false,
					xAxisTickColor: "#000000",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: true,
					xAxisTickStyle: "line",
					xAxisLeftRightTickColor: "#000000",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#000000",
					yAxisTopMajorTick: true,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#000000",
					titleAlign: "left",
					titleColor: "#000000",
					subtitleAlign: "left",
					subtitleColor: "#000000"
				},
				tableau: {
					backgroundType: "window",
					backgroundWindow: "#FFFFFF",
					background: "#E5E5E5",
					colorScheme: "TableauMedium",
					legendColor: "#000000",
					legendBox: true,
					legendBoxColor: "#E5E5E5",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#E5E5E5",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: true,
					xAxisLeftRightTickColor: "#E5E5E5",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#E5E5E5",
					yAxisTopMajorTick: true,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#E5E5E5",
					titleAlign: "left",
					titleColor: "#000000",
					subtitleAlign: "left",
					subtitleColor: "#000000"
				},
				stata: {
					backgroundType: "window",
					backgroundWindow: "#FFFFFF",
					background: "#EAF2F3",
					colorScheme: "Stata",
					legendColor: "#000000",
					legendBox: true,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 4,
					legendInside: false,
					legendPosition: "bottom",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 2,
					xAxisMinorTicks: false,
					xAxisMajorTicks: false,
					xAxisTickStyle: "line",
					xAxisTickColor: "#000000",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#000000",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#EAF2F3",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#000000",
					titleAlign: "center",
					titleColor: "#000000",
					subtitleAlign: "center",
					subtitleColor: "#000000"
				},
				igray: {
					backgroundType: "window",
					backgroundWindow: "#FFFFFF",
					background: "#E5E5E5",
					colorScheme: "GGPlot",
					legendColor: "#000000",
					legendBox: false,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#E5E5E5",
					xAxisLeftMajorTick: false,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#000000",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#E5E5E5",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: false,
					yAxisTopBottomTickColor: "#000000",
					titleAlign: "center",
					titleColor: "#000000",
					subtitleAlign: "center",
					subtitleColor: "#000000"
				},
				solarized: {
					backgroundType: "solid",
					backgroundWindow: "#FDF6E3",
					background: "#FDF6E3",
					colorScheme: "Solarized",
					legendColor: "#93A1A1",
					legendBox: true,
					legendBoxColor: "#93A1A1",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#93A1A1",
					axisTitleColor: "#93A1A1",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 2,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#93A1A1",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#93A1A1",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#93A1A1",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#93A1A1",
					titleAlign: "left",
					titleColor: "#93A1A1",
					subtitleAlign: "left",
					subtitleColor: "#93A1A1"
				},
				paulTol: {
					backgroundType: "solid",
					backgroundWindow: "#FFFFFF",
					background: "#FFFFFF",
					colorScheme: "PaulTol",
					legendColor: "#000000",
					legendBox: false,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#FFFFFF",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#E5E5E5",
					xAxisLeftMajorTick: false,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#E5E5E5",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#E5E5E5",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: false,
					yAxisTopBottomTickColor: "#E5E5E5",
					titleAlign: "left",
					titleColor: "#000000",
					subtitleAlign: "left",
					subtitleColor: "#000000"
				},
				ggplot: {
					backgroundType: "window",
					backgroundWindow: "#E5E5E5",
					background: "#FFFFFF",
					colorScheme: "GGPlot",
					legendColor: "#000000",
					legendBox: true,
					legendBoxColor: "#FFFFFF",
					legendBackgroundColor: "#E5E5E5",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#FFFFFF",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#FFFFFF",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#FFFFFF",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#FFFFFF",
					titleAlign: "center",
					titleColor: "#000000",
					subtitleAlign: "center",
					subtitleColor: "#000000"
				},
				wallStreetJournal: {
					backgroundType: "solid",
					backgroundWindow: "#F8F2E4",
					background: "#F8F2E4",
					colorScheme: "WallStreetJournal3",
					legendColor: "#000000",
					legendBox: false,
					legendBoxColor: "#000000",
					legendBackgroundColor: "#F8F2E4",
					legendColumns: 4,
					legendInside: true,
					legendPosition: "top",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 2,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: false,
					xAxisTickStyle: "dotted",
					xAxisTickColor: "#000000",
					xAxisLeftMajorTick: false,
					xAxisRightMajorTick: false,
					xAxisLeftRightTickColor: "#000000",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "dotted",
					yAxisTickColor: "#000000",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#000000",
					titleAlign: "left",
					titleColor: "#000000",
					subtitleAlign: "left",
					subtitleColor: "#000000"
				},
				cx: {
					backgroundType: "window",
					backgroundWindow: "#E8E8E8",
					background: "#FFFFFF",
					colorScheme: "CanvasXpressT",
					legendColor: "#000000",
					legendBox: true,
					legendBoxColor: "#FFFFFF",
					legendBackgroundColor: "#E8E8E8",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "#000000",
					axisTitleColor: "#000000",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: false,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "#FFFFFF",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: true,
					xAxisLeftRightTickColor: "#337AB7",
					yAxisMajorTicks: true,
					yAxisMinorTicks: false,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "#FFFFFF",
					yAxisTopMajorTick: true,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "#337AB7",
					titleAlign: "center",
					titleColor: "#000000",
					subtitleAlign: "center",
					subtitleColor: "#000000"
				},
				none: {
					backgroundType: "solid",
					backgroundWindow: "rgb(244,244,244)",
					background: "rgb(255,255,255)",
					colorScheme: "User",
					legendColor: "rgb(0,0,0)",
					legendBox: true,
					legendBoxColor: "rgb(204,204,204)",
					legendBackgroundColor: "rgb(255,255,255)",
					legendColumns: 1,
					legendInside: false,
					legendPosition: "right",
					legendScaleFontFactor: 1,
					axisTickScaleFontFactor: 1,
					axisTitleScaleFontFactor: 1,
					axisTickColor: "rgb(0,0,0)",
					axisTitleColor: "rgb(0,0,0)",
					axisTickWidth: 1,
					axisMinMaxTickWidth: 1,
					xAxisMinorTicks: true,
					xAxisMajorTicks: true,
					xAxisTickStyle: "line",
					xAxisTickColor: "rgb(204,204,204)",
					xAxisLeftMajorTick: true,
					xAxisRightMajorTick: true,
					xAxisLeftRightTickColor: "rgb(204,204,204)",
					yAxisMajorTicks: true,
					yAxisMinorTicks: true,
					yAxisShow: true,
					yAxis2Show: false,
					yAxisTickStyle: "line",
					yAxisTickColor: "rgb(204,204,204)",
					yAxisTopMajorTick: false,
					yAxisBottomMajorTick: true,
					yAxisTopBottomTickColor: "rgb(204,204,204)",
					titleAlign: "center",
					titleColor: "rgb(0,0,0)",
					subtitleAlign: "center",
					subtitleColor: "rgb(0,0,0)"
				}
			}
		}
		if (a && a.hasOwnProperty("theme") && a.theme && b.themes.hasOwnProperty(a.theme)) {
			var c = b.themes[a.theme];
			for (var d in c) {
				this[d] = c[d]
			}
		}
	};
	this.resetInitialFontSize = function() {
		var b = ["fontSize", "titleFontSize", "subtitleFontSize", "citationFontSize", "smpTitleFontSize", "smpLabelFontSize", "varTitleFontSize", "varLabelFontSize", "overlayFontSize", "legendFontSize", "decorationFontSize", "axisTickFontSize", "axisTitleFontSize", "nodeFontSize", "trackNameFontSize", "featureNameFontSize", "sequenceFontSize", "showAnimationFontSize"];
		for (var c = 0; c < b.length; c++) {
			this[b[c]] = Number(CanvasXpress.doc.P[b[c]].D)
		}
		this.setInitialFonts()
	};
	this.setInitialFonts = function() {
		this.font = this.fontStyle + " " + this.fontSize + "px " + this.fontName;
		this.titleFont = this.titleFontStyle + " " + this.titleFontSize + "px " + this.fontName;
		this.subtitleFont = this.subtitleFontStyle + " " + this.subtitleFontSize + "px " + this.fontName;
		this.citationFont = this.citationFontStyle + " " + this.citationFontSize + "px " + this.fontName;
		this.smpTitleFont = this.smpTitleFontStyle + " " + this.smpTitleFontSize + "px " + this.fontName;
		this.smpLabelFont = this.smpLabelFontStyle + " " + this.smpLabelFontSize + "px " + this.fontName;
		this.varTitleFont = this.varTitleFontStyle + " " + this.varTitleFontSize + "px " + this.fontName;
		this.varLabelFont = this.varLabelFontStyle + " " + this.varLabelFontSize + "px " + this.fontName;
		this.overlayFont = this.overlayFontStyle + " " + this.overlayFontSize + "px " + this.fontName;
		this.legendFont = this.legendFontStyle + " " + this.legendFontSize + "px " + this.fontName;
		this.decorationFont = this.decorationFontStyle + " " + this.decorationFontSize + "px " + this.fontName;
		this.axisTickFont = this.axisTickFontStyle + " " + this.axisTickFontSize + "px " + this.fontName;
		this.axisTitleFont = this.axisTitleFontStyle + " " + this.axisTitleFontSize + "px " + this.fontName;
		this.nodeFont = this.nodeFontStyle + " " + this.nodeFontSize + "px " + this.fontName;
		this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "px " + this.fontName;
		this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "px " + this.fontName;
		this.sequenceFont = this.sequenceFontStyle + " " + this.sequenceFontSize + "px " + this.fontName;
		this.showAnimationFont = this.showAnimationFontStyle + " " + this.showAnimationFontSize + "px " + this.fontName
	};
	this.setInitialConfig = function() {
		if (this.meta.config.user) {
			for (var b in this.meta.config.user) {
				this[b] = this.meta.config.user[b]
			}
		}
	};
	this.resetConfig = function(b) {
		var d = {};
		if (b) {
			for (var c = 0; c < b.length; c++) {
				d[b[c]] = this[b[c]]
			}
		}
		this.setConfigDefaults();
		for (var c in d) {
			this[c] = d[c]
		}
	};
	this.updateConfig = function(c) {
		if (c) {
			this.meta.config.user = c;
			for (var b in c) {
				this[b] = c[b]
			}
		}
	};
	this.getConfig = function() {
		var l = {};
		var c = this.meta.config.keys.sort();
		var g = {
			colors: true,
			images: true,
			xAxisValues: true,
			xAxisValuesRaw: true,
			xAxisMinorValues: true,
			yAxisValues: true,
			yAxisValuesRaw: true,
			yAxisMinorValues: true,
			zAxisValues: true,
			zAxisValuesRaw: true,
			zAxisMinorValues: true,
			nodeConfigurableProperties: true,
			edgeConfigurableProperties: true,
			trackConfigurableProperties: true,
			featureConfigurableProperties: true
		};
		if (this.isTransformedData) {
			l.isTransformedData = this.isTransformedData
		}
		for (var f = 0; f < c.length; f++) {
			var e = c[f];
			if (CanvasXpress.doc.P[e] && CanvasXpress.doc.P[e].hasOwnProperty("D")) {
				var h = CanvasXpress.doc.P[e].D;
				if (g[e]) {
					continue
				}
				var b = this[e] === undefined ? false : this[e];
				if (typeof(b) == "object") {
					if (h == "[]") {
						h = []
					}
					if (h == "{}") {
						h = {}
					}
					if (b === null) {
						if (h != "null") {
							l[e] = b
						}
					} else {
						if (!this.isSameObject(b, h)) {
							l[e] = b
						}
					}
				} else {
					if (h.match(/false|true|null/)) {
						if (b.toString() != h) {
							l[e] = b
						}
					} else {
						if (b != h) {
							l[e] = b
						}
					}
				}
			}
		}
		return l
	};
	this.getUserConfig = function() {
		return this.meta.config.user
	};
	this.getNewCanvasContext = function(d) {
		var b = this.$(d);
		if (!b || b.tagName.toLowerCase() != "canvas") {
			b = this.$cX("canvas", {
				id: d
			});
			document.body.appendChild(b)
		}
		return b.getContext("2d")
	};
	this.setCanvasPixelRatio = function() {
		var b = document.createElement("canvas").getContext("2d");
		var c = window.devicePixelRatio || 1;
		var d = b.webkitBackingStorePixelRatio || b.mozBackingStorePixelRatio || b.msBackingStorePixelRatio || b.oBackingStorePixelRatio || b.backingStorePixelRatio || 1;
		this.meta.canvas.canvasPixelRatio = c / d
	};
	this.setDPI = function(c, d) {
		c.style.width = c.style.width || c.width + "px";
		c.style.height = c.style.height || c.height + "px";
		var h = d / 96;
		var b = parseFloat(c.style.width);
		var i = parseFloat(c.style.height);
		var e = c.width / b;
		var g = h / e;
		var f = c.cloneNode(false);
		f.getContext("2d").drawImage(c, 0, 0);
		var j = c.getContext("2d");
		c.width = Math.ceil(b * h);
		c.height = Math.ceil(i * h);
		j.setTransform(g, 0, 0, g, 0, 0);
		j.drawImage(f, 0, 0);
		j.setTransform(h, 0, 0, h, 0, 0)
	};
	this.setCanvas = function() {
		var g = this.$(this.target);
		if (g) {
			this.setCanvasPixelRatio();
			this.checkCanvasXpressOrgSite();
			this.meta.canvas.ctx = g.getContext("2d");
			this.meta.canvas.ctx.setTransform(this.meta.canvas.canvasPixelRatio, 0, 0, this.meta.canvas.canvasPixelRatio, 0, 0);
			if ((this.backgroundType == "video" || this.graphType == "Video") && this.backgroundVideo) {
				if (this.graphType == "Video") {
					this.backgroundType = "video"
				}
				this.isVideo = true;
				var f = this.$cX("script", {
					type: "text/javascript",
					src: "../js/video.js"
				});
				var e = this.$cX("link", {
					type: "text/css",
					rel: "stylesheet",
					href: "../css/video-js.css"
				});
				var d = document.getElementsByTagName("head")[0];
				d.appendChild(e);
				d.appendChild(f);
				this.background = "rgba(255,255,255,0)";
				this.legendBackgroundColor = "rgba(255,255,255,0)";
				this.disableToolbar = true
			} else {
				if (this.graphType == "Map") {
					this.isMap = true;
					var d = [];
					if (this.topoJSON) {
						for (var b in this.topoJSON) {
							this.leafletJS.unshift(this.topoJSON[b])
						}
					}
					for (var b = 0; b < this.leafletJS.length; b++) {
						d.push(this.$cX("script", {
							type: "text/javascript",
							src: this.leafletJS[b]
						}))
					}
					for (var b = 0; b < this.leafletCSS.length; b++) {
						d.push(this.$cX("link", {
							type: "text/css",
							rel: "stylesheet",
							href: this.leafletCSS[b]
						}))
					}
					this.initLeaflet();
					CanvasXpress.loadScripts(d, this.leafletInit || this.leafletInitString || this.initializeLeaflet, this)
				} else {
					this.isVideo = false;
					this.isMap = false
				}
			}
		}
	};
	this.getCanvasContext = function() {
		var b;
		if (this.isSVG) {
			b = this.meta.canvas.ctx5
		} else {
			if (this.isTransitionCanvas) {
				b = this.transitionIter % 2 ? this.meta.canvas.ctx3 : this.meta.canvas.ctx4
			} else {
				b = this.isHighlightCanvas ? this.meta.canvas.ctx2 : this.isMapCanvas ? this.meta.leaflet.ctx : this.meta.canvas.ctx
			}
		}
		this.currentCanvasContext = b.canvas.id;
		return b
	};
	this.checkCanvasXpressOrgSite = function() {
		var g = new RegExp("https://canvasxpress.org/js/");
		var d = document.getElementsByTagName("head")[0];
		for (var b = 0; b < d.childNodes.length; b++) {
			var f = d.childNodes[b];
			if (f.type == "text/javascript" && g.test(f.src)) {
				this.meta.factory.siteSrc = true
			}
		}
	};
	this.inititalizeConfig = function() {
		this.setConfigDefaults();
		this.setTheme();
		if (a) {
			for (var b = 0; b < this.meta.config.keys.length; b++) {
				var c = this.meta.config.keys[b];
				if (a.hasOwnProperty(c)) {
					this[c] = a[c]
				}
			}
		}
		this.setInitialFonts();
		this.setCanvas()
	};
	this.inititalizeConfig()
};
CanvasXpress.prototype.initText = function() {
	this.setTextShadow = function(a) {
		if (this.showTextShadow) {
			if (a) {
				this.meta.canvas.ctx.shadowOffsetX = this.shadowOffsetX;
				this.meta.canvas.ctx.shadowOffsetY = this.shadowOffsetY;
				this.meta.canvas.ctx.shadowBlur = this.shadowBlur;
				this.meta.canvas.ctx.shadowColor = this.shadowColor
			} else {
				this.meta.canvas.ctx.shadowOffsetX = 0;
				this.meta.canvas.ctx.shadowOffsetY = 0;
				this.meta.canvas.ctx.shadowBlur = 0;
				this.meta.canvas.ctx.shadowColor = this.background
			}
		}
	};
	this.getArcTextArea = function(B, A, z, a, C, u, p, v, j, w, d, g) {
		if (B == undefined) {
			B = ""
		}
		var q = ["poly"];
		var o = this.getFontPt(p);
		var j = this.measureText(B, p) * (Math.PI * 0.5) / a;
		C = (C + (u / 2)) - (j / 2) % (Math.PI * 2);
		u = C + j;
		var n = this.traceArc(A, z, a, C, u, true);
		for (var k = 0; k < n.length; k++) {
			q.push(n[k][0], n[k][1])
		}
		n = this.traceArc(A, z, a - o, C, u);
		for (var k = 0; k < n.length; k++) {
			q.push(n[k][0], n[k][1])
		}
		if (this.graphType == "Network") {
			return this.preScaleNetwork && !this.isAnimation ? q : this.adjustNetworkObjects(q)
		} else {
			return q
		}
	};
	this.drawArcText = function(B, z, w, a, C, p, o, q, j, v, g, h) {
		this.functionCallerDraw = "drawArcText";
		if (B == undefined) {
			B = ""
		}
		var A = this.getCanvasContext();
		if (B == null) {
			return
		}
		if (!A) {
			if (this.debug) {
				alert("Dude, there is no canvas")
			}
			return
		}
		if (isNaN(z) || isNaN(w)) {
			if (this.debug) {
				alert("Not a valid coordinate (" + z + ", " + w + ") to draw " + B)
			}
			return
		}
		if (!h && !isNaN(B)) {
			B = this.formatNumber(B)
		}
		if (!z) {
			z = 0
		}
		if (!w) {
			w = 0
		}
		if (!o) {
			o = this.font
		}
		if (!q) {
			q = this.foreground
		}
		if (!j) {
			j = this.align
		}
		if (!v) {
			v = this.baseline
		}
		this.saveCanvas();
		A.strokeStyle = q;
		A.fillStyle = q;
		A.font = o;
		A.textAlign = j;
		A.textBaseline = v;
		this.setTextShadow(true);
		var d = j == "right" ? 1 : -1;
		var u = this.getFontPt(o);
		if (((["left", "center"].indexOf(j) > -1) && g) || (j == "right" && !g)) {
			B = B.split("").reverse().join("")
		}
		A.translate(z, w);
		C += (Math.PI * !g);
		C += (Math.PI / 2) + (p / 2);
		if (j == "center") {
			for (var k = 0; k < B.length; k++) {
				var n = this.measureText(B[k], o);
				C += ((n + (k == B.length - 1 ? 0 : this.circularLetterSeparationFactor)) / (a - u)) / 2 * -d
			}
		}
		p = C;
		this.rotateCanvas(C);
		for (var k = 0; k < B.length; k++) {
			var n = this.measureText(B[k], o);
			p += (n / 2) / (a - u) * d;
			this.rotateCanvas((n / 2) / (a - u) * d);
			A.fillText(B[k], 0, (g ? 1 : -1) * (0 - a + u / 2));
			p += (n / 2 + this.circularLetterSeparationFactor) / (a - u) * d;
			this.rotateCanvas((n / 2 + this.circularLetterSeparationFactor) / (a - u) * d)
		}
		this.restoreCanvas();
		this.setTextShadow(false)
	};
	this.getTextMultipleArea = function(o, n, k, A, B, E, D, g, q, p, j) {
		if (o == undefined) {
			o = ""
		}
		var r = o.split(/\n/);
		var w = this.getFontPt(A);
		var C = [];
		var F = k;
		for (var u = 0; u < r.length; u++) {
			C.push(this.getTextArea(r[u], n, F, A, B, E, D, g, q, p, j));
			F += w + this.margin
		}
		var z = C[0][1];
		var e = C[0][2];
		var v = C[0][3];
		var d = C[0][4];
		for (var u = 1; u < C.length; u++) {
			z = Math.min(z, C[u][1]);
			e = Math.min(e, C[u][2]);
			v = Math.max(v, C[u][3]);
			d = Math.max(d, C[u][4])
		}
		return [C[0][0], z, e, v, d]
	};
	this.drawTextMultiple = function(B, z, u, p, r, w, v, e, h, C, A) {
		this.functionCaller = "drawTextMultiple";
		var j = B.split(/\n/);
		var d = p;
		var n = [];
		if (!d) {
			d = this.font
		}
		var o = this.getFontPt(d);
		var q = u;
		for (var k = 0; k < j.length; k++) {
			this.drawText(j[k], z, q, d, r, w, v, e, h, C, A);
			q += o + this.margin
		}
	};
	this.getTextArea = function(q, o, n, B, D, F, E, g, u, r, k) {
		var j = this;
		var v = function(b) {
			b.shift();
			var a = ["poly"];
			a = a.concat(j.rotatePoint(b[0], b[1], o, n, g));
			a = a.concat(j.rotatePoint(b[2], b[1], o, n, g));
			a = a.concat(j.rotatePoint(b[2], b[3], o, n, g));
			a = a.concat(j.rotatePoint(b[0], b[3], o, n, g));
			return a
		};
		if (q == undefined) {
			q = ""
		}
		if (k) {
			if (o < this.marginLeft + this.offsetX + this.left || o > this.marginLeft + this.offsetX + this.left + this.x) {
				return
			}
			if (n < this.marginTop + this.offsetY + this.top || n > this.marginTop + this.offsetY + this.top + this.y) {
				return
			}
		}
		if (this.isMultipleLines(q)) {
			return this.getTextMultipleArea(q, o, n, B, D, F, E, g, u, r, k)
		}
		var G = [];
		var p = this.measureText(q, B);
		var z = this.getFontPt(B);
		var C, e, A, d;
		var i = 0;
		if (u) {
			while (p > u && i < 10) {
				q = q.substring(0, q.length - 1);
				p = this.measureText(q, B);
				i++
			}
		}
		if (F == "left") {
			C = o;
			A = C + p
		} else {
			if (F == "right") {
				C = o - p;
				A = o
			} else {
				C = o - (p / 2);
				A = o + (p / 2)
			}
		}
		if (E == "top") {
			e = n;
			d = e + z
		} else {
			if (E == "bottom") {
				e = n - z;
				d = n
			} else {
				e = n - (z / 2);
				d = n + (z / 2)
			}
		}
		G = ["rect", C, e, A, d];
		G = g ? v(G) : G;
		if (this.graphType == "Network") {
			return this.preScaleNetwork && !this.isAnimation ? G : this.adjustNetworkObjects(G)
		} else {
			return G
		}
	};
	this.drawText = function(z, q, n, j, k, p, o, d, e, A, u) {
		this.functionCallerDraw = "drawText";
		if (z == undefined) {
			z = ""
		}
		var v = this.getCanvasContext();
		var i = 0;
		if (z == null) {
			return
		}
		if (this.isMultipleLines(z)) {
			return this.drawTextMultiple(z, q, n, j, k, p, o, d, e, A, u)
		}
		if (!v) {
			if (this.debug) {
				alert("Dude, there is no canvas")
			}
			return
		}
		if (isNaN(q) || isNaN(n)) {
			if (this.debug) {
				alert("Not a valid coordinate (" + q + ", " + n + ") to draw " + z)
			}
			return
		}
		if (u) {
			if (q < this.marginLeft + this.offsetX + this.left || q > this.marginLeft + this.offsetX + this.left + this.x) {
				return
			}
			if (n < this.marginTop + this.offsetY + this.top || n > this.marginTop + this.offsetY + this.top + this.y) {
				return
			}
		}
		if (!q) {
			q = 0
		}
		if (!n) {
			n = 0
		}
		if (!j) {
			j = this.font
		}
		if (!k) {
			k = this.foreground
		}
		if (!p) {
			p = this.align
		}
		if (!o) {
			o = this.baseline
		}
		var r = this.measureText(z, j);
		var g = this.getFontPt(j);
		if (e) {
			while (r > e && i < 10) {
				z = z.substring(0, z.length - 1);
				r = this.measureText(z, j);
				i++
			}
		}
		this.saveCanvas();
		v.strokeStyle = k;
		v.fillStyle = k;
		v.font = j;
		this.translateCanvas(q, n);
		v.textAlign = p;
		v.textBaseline = o;
		this.setTextShadow(true);
		if (d) {
			this.rotateCanvas(d)
		}
		if (A) {
			v.strokeText(z, 0, 0)
		} else {
			v.fillText(z, 0, 0)
		}
		this.restoreCanvas();
		this.setTextShadow(false)
	};
	this.isMultipleLines = function(b) {
		var a = b.toString().split(/\n/);
		return a.length - 1
	};
	this.capitalize = function(a) {
		if (a) {
			return a.charAt(0).toUpperCase() + a.slice(1)
		}
	};
	this.measureTextMultiple = function(e, g) {
		var c = e.split(/\n/);
		var a = 0;
		var b = this.getCanvasContext();
		if (!b) {
			return 0
		}
		if (!g) {
			g = this.font
		}
		b.font = g;
		for (var d = 0; d < c.length; d++) {
			a = Math.max(a, b.measureText(c[d]).width)
		}
		return a
	};
	this.measureText = function(b, c) {
		var a = this.getCanvasContext();
		if (!b || !a) {
			return 0
		}
		b = b.toString();
		if (!c) {
			c = this.font
		}
		if (!CanvasXpress.cacheText[c]) {
			CanvasXpress.cacheText[c] = {}
		}
		if (!CanvasXpress.cacheText[c][b]) {
			a.font = c;
			if (this.isMultipleLines(b)) {
				CanvasXpress.cacheText[c][b] = this.measureTextMultiple(b, c)
			} else {
				CanvasXpress.cacheText[c][b] = a.measureText(b).width
			}
		}
		return CanvasXpress.cacheText[c][b]
	};
	this.measureTextWidth = function(a, b) {
		l = this.isMultipleLines(a);
		if (l > 0) {
			return (this.getFontPt(b) + this.margin) * (l + 1)
		} else {
			return this.getFontPt(b)
		}
	};
	this.scaleTextToFont = function(b, d, a) {
		var c = this.fontStyle + " " + d + "px " + this.fontName;
		if (b) {
			while (this.measureText(b, c) > a && d >= this.minTextSize) {
				d -= 2;
				c = this.fontStyle + " " + d + "px " + this.fontName
			}
		}
		return c
	};
	this.getFontPt = function(a) {
		return a ? Math.max(1, parseInt(a.toString().match(/[\-\d]+/)[0])) : 1
	};
	this.scaleTextToSize = function(a) {
		var d = this.scaleTextConstantMult;
		if (!a) {
			a = 1
		}
		return Math.ceil(1 / Math.sqrt(a) * d)
	};
	this.correctPrecisionBug = function(b) {
		var a = b.toString();
		if (a.match(/\.\d+00000+\d+$/)) {
			a = a.replace(/00000+\d+$/, "")
		} else {
			if (a.match(/\.\d+99999+\d+$/)) {
				a = a.replace(/99999+\d+$/, "9")
			}
		}
		return Number(a)
	};
	this.formatNumber = function(b, a) {
		if (a && Math.abs(b) < 99999) {
			return sprintf("%." + a + "f", Number(b)).toString()
		} else {
			if (Math.abs(b) < 0.0001 || Math.abs(b) > 99999 || b.toString().length >= 8) {
				return Number(b).toExponential(2).toString().replace("e+0", "").replace(".00", "")
			} else {
				return b.toString()
			}
		}
	};
	this.bestFormatNumber = function(b, a) {
		if (typeof b === "number" && b % 1 == 0) {
			return b
		} else {
			if (a != null && a < 1) {
				return sprintf("%.0f", Number(b))
			} else {
				if (Math.abs(b) < 0.001) {
					return sprintf("%.2e", Number(b))
				} else {
					return sprintf("%.3f", Number(b))
				}
			}
		}
	};
	this.getMaxtTextBySampling = function(b, h) {
		var c = {};
		var f = [];
		var g = [];
		for (var e = 0; e < b.length; e++) {
			var d = b[e] != null ? b[e].toString() : "";
			if (!c.hasOwnProperty(d)) {
				c[d] = true;
				f.push([d, d.length])
			}
		}
		f.sort(function(j, i) {
			return j[1] < i[1] ? -1 : j[1] > i[1] ? 1 : 0
		});
		if (!h) {
			h = 10
		}
		if (f.length < h) {
			h = f.length
		}
		for (var e = 0; e < h; e++) {
			g.push(f[e][0])
		}
		return this.getMaxText(g)
	};
	this.getMaxText = function(d) {
		var f = "";
		var b = 0;
		if (d && d.length > 0) {
			for (var e = 0; e < d.length; e++) {
				if (d[e]) {
					var g = this.measureText(d[e].toString(), this.font);
					if (g > b) {
						f = d[e].toString();
						b = g
					}
				}
			}
		}
		return f
	};
	this.shortenText = function(c, b, a) {
		if (!c) {
			return ""
		}
		c = c.toString();
		if (a && c.length > b) {
			return c.substring(0, Math.max(parseInt(a / b) - 2, 1)) + ".."
		} else {
			if (c.length <= b) {
				return c
			} else {
				return c.substring(0, b - 3) + "..."
			}
		}
	};
	this.convertToNumber = function(a) {
		if (!isNaN(a)) {
			return parseFloat(a)
		} else {
			return a
		}
	};
	this.stringToHex = function(c) {
		var b = "";
		for (var a = 0; a < c.length; a++) {
			b += "" + c.charCodeAt(a).toString(16)
		}
		return b
	};
	this.hexToString = function(b) {
		var c = "";
		for (var a = 0; a < b.length; a += 2) {
			c += String.fromCharCode(parseInt(b.substr(a, 2), 16))
		}
		return c
	}
};
CanvasXpress.prototype.initTime = function() {
	Date.prototype.getWeek = function() {
		var a = new Date(this.getFullYear(), 0, 1);
		return Math.ceil((((this - a) / 86400000) + a.getDay() + 1) / 7)
	};
	Date.prototype.getDayYear = function() {
		var a = new Date(this.getFullYear(), 0, 1);
		return Math.ceil((this - a) / 86400000)
	};
	this.getMillisecond = function(a) {
		return a.getMilliseconds()
	};
	this.getSecond = function(a) {
		return a.getSeconds()
	};
	this.getMinuteSecond = function(a) {
		return a.getMinutes() + ":" + a.getSeconds()
	};
	this.getMinute = function(a) {
		return a.getMinutes()
	};
	this.getHourMinute = function(a) {
		return a.getHours() + ":" + a.getMinutes()
	};
	this.getHour = function(a) {
		return a.getHours()
	};
	this.getYearWeek = function(a) {
		return a.getFullYear() + "-" + a.getWeek()
	};
	this.getYearMonth = function(a) {
		return a.getFullYear() + "-" + a.getMonth()
	};
	this.getYear = function(a) {
		return a.getFullYear()
	};
	this.times = {
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 86400000,
		week: 604800000,
		month: 2592000000,
		year: 31556952000
	};
	this.parseDate = function(j) {
		var f = 0;
		var c = 0;
		var e = 0;
		var k = parseInt(j.toString().substring(0, 4));
		var a = parseInt(j.toString().substring(4, 6).replace(/^0/, ""));
		var g = parseInt(j.toString().substring(6, 8).replace(/^0/, ""));
		var b = j.toString().match(/\:/) ? j.toString().substring(10).split(":") : false;
		if (b) {
			f = b[0] ? parseInt(b[0].replace(/^0/, "")) : 0;
			c = b[1] ? parseInt(b[1].replace(/^0/, "")) : 0;
			e = b[2] ? parseInt(b[2].replace(/^0/, "")) : 0
		}
		return new Date(k, a - 1, g, f, c, e)
	};
	this.setTimeAxis = function() {
		var h = this.validateTimeAxis();
		if (h) {
			var g = Date.parse(h[h.length - 1]) - Date.parse(h[0]);
			var d;
			var b = {};
			var c = [];
			this.timeValues = [];
			this.timeValueIndices = [];
			if (g > this.times.year * 2) {
				d = "getYear"
			} else {
				if (g > this.times.month * 2) {
					d = "getYearMonth"
				} else {
					if (g > this.times.week * 2) {
						d = "getYearWeek"
					} else {
						if (g < this.times.second) {
							d = "getMillisecond"
						} else {
							if (g < this.times.minute) {
								d = "getSecond"
							} else {
								if (g < this.times.hour / 4) {
									d = "getMinuteSecond"
								} else {
									if (g < this.times.hour) {
										d = "getMinute"
									} else {
										if (g < this.times.day / 4) {
											d = "getHourMinute"
										} else {
											if (g < this.times.day) {
												d = "getHour"
											} else {
												d = false
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (d) {
				if (this.timeTicksFirst) {
					for (var a = 0; a < h.length; a++) {
						var e = this[d](h[a]);
						if (!b.hasOwnProperty(e)) {
							c.push(h[a]);
							this.timeValueIndices.push(a);
							b[e] = true
						}
					}
				} else {
					for (var a = h.length - 1; a >= 0; a--) {
						var e = this[d](h[a]);
						if (!b.hasOwnProperty(e)) {
							c.unshift(h[a]);
							this.timeValueIndices.unshift(a);
							b[e] = true
						}
					}
				}
			} else {
				for (var a = 0; a < h.length; a++) {
					this.timeValues.push(dateFormat(h[a], this.timeFormat));
					this.timeValueIndices.push(a)
				}
			}
			var g = Date.parse(c[c.length - 1]) - Date.parse(c[c.length - 2]);
			if (d == "getYear" && g < this.times.month * 3) {
				this.timeValues.pop();
				this.timeValueIndices.pop()
			} else {
				if (d == "getYearMonth" && g < this.times.week * 4) {
					this.timeValues.pop();
					this.timeValueIndices.pop()
				} else {
					if (d == "getYearWeek" && g < this.times.day * 7) {
						this.timeValues.pop();
						this.timeValueIndices.pop()
					}
				}
			}
			for (var a = 0; a < c.length; a++) {
				this.timeValues.push(dateFormat(c[a], this.timeFormat))
			}
		}
	};
	this.createRandomTimes = function(b) {
		var e;
		var g = new Date();
		var a = g.getTime();
		var f = [new Date(a)];
		var h = this.isGroupedData ? this.data.w : this.data.y;
		if (!b || !this.times[b]) {
			b = "day"
		}
		for (var c = 0; c < h.smps.length; c++) {
			e = Date.parse(h.smps[c]);
			if (!isNaN(e)) {
				a = e
			} else {
				a -= this.times[b]
			}
			f.unshift(new Date(a))
		}
		return f
	};
	this.validateTimeAxis = function() {
		var f = this.isGroupedData ? this.data.w : this.data.y;
		var a = false;
		var e = [];
		for (var b = 0; b < this.smpIndices.length; b++) {
			var c = this.smpIndices.length != f.smps.length ? Date.parse(f.smps[this.smpIndices[b]]) : Date.parse(f.smps[b]);
			if (isNaN(c)) {
				if (this.isExample) {
					e = this.createRandomTimes();
					return e
				} else {
					a = true;
					break
				}
			} else {
				e.push(new Date(c))
			}
		}
		return a ? false : e
	}
};
CanvasXpress.prototype.initColor = function() {
	this.validateColor = function(g, d, e) {
		if (g) {
			g = g.toString();
			g = g.replace(/\s/g, "");
			var a = (/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/).exec(g);
			var b = (/rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),([0-9\.]+)\)/).exec(g);
			var f = (/^#?([0-9abcdef]{6})/i).exec(g);
			if (this.meta.def.colorNames.hasOwnProperty(g)) {
				g = this.hexToRgb(this.meta.def.colorNames[g])
			} else {
				if (a != null) {
					g = a[0]
				} else {
					if (b != null) {
						g = b[0]
					} else {
						if (f != null) {
							g = this.hexToRgb(f[0])
						} else {
							g = false
						}
					}
				}
			}
		}
		g = g && d != null ? this.addColorTransparency(g, d) : g;
		return g && e ? this.rgbToHex(g) : g
	};
	this.darkenLightenColor = function(j, e) {
		j = this.rgbToHex(j).substring(1, 7);
		var i = parseInt(j, 16);
		var h = (i >> 16) + e;
		h = h > 255 ? 255 : h < 0 ? 0 : h;
		var f = ((i >> 8) & 255) + e;
		f = f > 255 ? 255 : f < 0 ? 0 : f;
		var d = (i & 255) + e;
		d = d > 255 ? 255 : d < 0 ? 0 : d;
		j = d | (f << 8) | (h << 16);
		return this.hexToRgb(j.toString(16))
	};
	this.rgbToHex = function(b) {
		var a = function(c) {
			c = parseInt(c, 10);
			if (isNaN(c)) {
				return "00"
			}
			c = Math.max(0, Math.min(c, 255));
			return "0123456789ABCDEF".charAt((c - c % 16) / 16) + "0123456789ABCDEF".charAt(c % 16)
		};
		if (b && b.substr(0, 1) === "#") {
			return b
		}
		if (b && b.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/)) {
			return "#" + a(RegExp.$1) + a(RegExp.$2) + a(RegExp.$3)
		} else {
			return b
		}
	};
	this.complementaryColor = function(j, e) {
		var d = this.validateColor(j.toString());
		if (d.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
			var i = parseInt(255 - RegExp.$1);
			var f = parseInt(255 - RegExp.$2);
			var a = parseInt(255 - RegExp.$3);
			if (i == f && f == a) {
				if (i >= 127) {
					d = "rgb(255,255,255)"
				} else {
					d = "rgb(0,0,0)"
				}
			} else {
				d = "rgb(" + i + "," + f + "," + a + ")"
			}
			return e ? this.rgbToHex(d) : d
		} else {
			return j
		}
	};
	this.hexToRgb = function(c) {
		var b = function() {
			return parseInt(c.substring(0, 2), 16)
		};
		var a = function() {
			return parseInt(c.substring(2, 4), 16)
		};
		var d = function() {
			return parseInt(c.substring(4, 6), 16)
		};
		c = c.charAt(0) == "#" ? c.substring(1, 7) : c;
		return "rgb(" + b() + "," + a() + "," + d() + ")"
	};
	this.addColorTransparency = function(e, d, b) {
		if (!b) {
			e = this.validateColor(e)
		}
		if (e) {
			var a = e.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i);
			return "rgba(" + a[1] + "," + d + ")"
		} else {
			return false
		}
	};
	this.removeColorTransparency = function(d, b) {
		if (!b) {
			d = this.validateColor(d)
		}
		if (d) {
			var a = d.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i);
			return "rgb(" + a[1] + ")"
		} else {
			return false
		}
	};
	this.isColorTransparency = function(b) {
		b = this.validateColor(b);
		if (b) {
			var a = b.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i);
			return a[2] != null ? Number(a[2]) : null
		}
	};
	this.isColorTransparent = function(d) {
		d = this.validateColor(d);
		var b;
		if (d && d.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/)) {
			return false
		} else {
			if (d) {
				var a = d.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i);
				return a[2] != null && a[2] == 0 ? true : false
			} else {
				return false
			}
		}
	};
	this.combineColors = function(j) {
		var e = [];
		var d = [];
		var n = [];
		var k = [];
		for (var f = 0; f < j.length; f++) {
			j[f] = this.validateColor(j[f])
		}
		for (var f = 0; f < j.length; f++) {
			var l = j[f];
			if (l && l.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
				e.push(parseInt(RegExp.$1));
				d.push(parseInt(RegExp.$2));
				n.push(parseInt(RegExp.$3));
				if (RegExp.$4) {
					k.push(parseFloat(RegExp.$4))
				}
			}
		}
		if (e.length > 0) {
			var a = parseInt(this.mean(e));
			var h = parseInt(this.mean(d));
			var m = parseInt(this.mean(n));
			if (k.length > 0) {
				var o = parseFloat(this.mean(k));
				return "rgba(" + a + "," + h + "," + m + "," + o + ")"
			} else {
				return "rgb(" + a + "," + h + "," + m + ")"
			}
		}
		return false
	};
	this.colorAsArray = function(f) {
		f = this.validateColor(f);
		var b = [];
		if (f) {
			var d = (/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/).exec(f);
			var e = (/rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),([0-9\.]+)\)/).exec(f);
			if (d != null) {
				b = [parseInt(d[1]), parseInt(d[2]), parseInt(d[3])]
			} else {
				if (e != null) {
					b = [parseInt(e[1]), parseInt(e[2]), parseInt(e[3]), Number(e[4])]
				}
			}
		}
		return b
	};
	this.disableGradientTransparencyShadow = function() {
		if (!this.gradientTemp) {
			this.gradientTemp = this.gradient
		}
		if (this.transparencyTemp == null) {
			this.transparencyTemp = this.transparency
		}
		if (!this.showShadowTemp) {
			this.showShadowTemp = this.showShadow
		}
		this.gradient = false;
		this.transparency = null;
		this.showShadow = false
	};
	this.enableGradientTransparencyShadow = function() {
		this.gradient = this.gradientTemp;
		this.transparency = this.transparencyTemp;
		this.showShadow = this.showShadowTemp
	};
	this.resetGradientTransparencyShadow = function() {
		delete(this.gradientTemp);
		delete(this.transparencyTemp);
		delete(this.showShadowTemp)
	};
	this.getGradientColor = function(h) {
		if (h.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
			var f = Math.floor(parseInt(RegExp.$1) / this.gradientRatio);
			var e = Math.floor(parseInt(RegExp.$2) / this.gradientRatio);
			var a = Math.floor(parseInt(RegExp.$3) / this.gradientRatio);
			var d = RegExp.$4 ? parseFloat(RegExp.$4) : false;
			if (d) {
				return "rgba(" + f + "," + e + "," + a + "," + d + ")"
			} else {
				return "rgb(" + f + "," + e + "," + a + ")"
			}
		} else {
			return false
		}
	};
	this.getGradient = function(e, d, c, b, a) {
		if (this.gradientType == "radial") {
			return this.getRadialGradient(e, d, c, b, false, false, true)
		} else {
			return this.getLinearGradient(e, d, c, b, a, false, true)
		}
	};
	this.getLinearGradient = function(b, i, a, h, d, c, f) {
		if (!f) {
			this.saveCanvas()
		}
		var j = this.getCanvasContext();
		var e = j.createLinearGradient(b, i, a, h);
		if (!d) {
			d = this.foreground
		}
		if (!c) {
			c = this.getGradientColor(d);
			e.addColorStop(0, c);
			e.addColorStop(0.6, d);
			e.addColorStop(1, d)
		} else {
			e.addColorStop(0, d);
			e.addColorStop(0.5, c)
		}
		return e
	};
	this.getRadialGradient = function(j, h, a, e, d, c, i) {
		if (!i) {
			this.saveCanvas()
		}
		var b = a / 5.5;
		var k = this.getCanvasContext();
		var f = k.createRadialGradient(j - b, h - b, 1, j, h, a);
		if (!e) {
			e = this.foreground
		}
		if (!d) {
			if (this.transparency != null) {
				d = "rgba(0,0,0," + this.transparency + ")"
			} else {
				d = "rgb(0,0,0)"
			}
		}
		if (!c) {
			c = "rgba(0,0,0,0)"
		}
		f.addColorStop(0, e);
		f.addColorStop(1, d);
		f.addColorStop(1, c);
		return f
	};
	this.colorRGBfromString = function(b) {
		var a = b.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
		if (a) {
			if (a[1].length === 6) {
				this.colorFromRgb(parseInt(a[1].substr(0, 2), 16) / 255, parseInt(a[1].substr(2, 2), 16) / 255, parseInt(a[1].substr(4, 2), 16) / 255)
			} else {
				this.colorFromRgb(parseInt(a[1].charAt(0) + a[1].charAt(0), 16) / 255, parseInt(a[1].charAt(1) + a[1].charAt(1), 16) / 255, parseInt(a[1].charAt(2) + a[1].charAt(2), 16) / 255)
			}
		}
	};
	this.colorFromRgb = function(e, d, a) {
		if (this.colorRGB) {
			if (e != null) {
				this.colorRGB[0] = Math.min(Math.max(0, e), 1)
			}
			if (d != null) {
				this.colorRGB[1] = Math.min(Math.max(0, d), 1)
			}
			if (a != null) {
				this.colorRGB[2] = Math.min(Math.max(0, a), 1)
			}
			var c = this.rgbFromHsv(this.colorRGB[0], this.colorRGB[1], this.colorRGB[2]);
			if (c[0] != null) {
				this.colorHSV[0] = c[0]
			}
			if (c[2] != 0) {
				this.colorHSV[1] = c[1]
			}
			this.colorHSV[2] = c[2]
		}
	};
	this.rgbFromHsv = function(i, f, c) {
		var j = Math.min(Math.min(i, f), c);
		var d = Math.max(Math.max(i, f), c);
		var a = d - j;
		if (a == 0) {
			return [null, 0, d]
		} else {
			var e = i == j ? 3 + (c - f) / a : (f == j ? 5 + (i - c) / a : 1 + (f - i) / a);
			return [e == 6 ? 0 : e, a / d, d]
		}
	};
	this.colorFromHsv = function(c, b, a) {
		if (c != null) {
			this.colorHSV[0] = Math.min(Math.max(0, c), 6)
		}
		if (b != null) {
			this.colorHSV[1] = Math.min(Math.max(0, b), 1)
		}
		if (a != null) {
			this.colorHSV[2] = Math.min(Math.max(0, a), 1)
		}
		this.colorRGB = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], this.colorHSV[2])
	};
	this.hsvFromRgb = function(e, d, b) {
		if (e == null) {
			return [b, b, b]
		}
		var c = Math.floor(e);
		var g = c % 2 ? e - c : 1 - (e - c);
		var a = b * (1 - d);
		var j = b * (1 - d * g);
		switch (c) {
			case 0:
				return [b, j, a];
			case 1:
				return [j, b, a];
			case 2:
				return [a, b, j];
			case 3:
				return [a, j, b];
			case 4:
				return [j, a, b];
			case 5:
				return [b, a, j];
			case 6:
				return [b, a, j]
		}
	};
	this.colorRGBToString = function() {
		if (this.colorRGB) {
			return (256 | Math.round(255 * this.colorRGB[0])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[1])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[2])).toString(16).substr(1)
		}
	};
	this.getColorNames = function() {
		return this.sortObject(this.meta.def.colorNames)
	};
	this.getColorSchemes = function() {
		return this.sortObject(this.meta.def.colorSchemes)
	};
	this.getHexColor = function(a) {
		var b = /^#?[0-9a-fA-F]{6}$/i;
		if (b.test(a)) {
			return a.substring(a.length - 6, a.length)
		} else {
			var c = a.toLowerCase();
			if (this.meta.def.colorNames.hasOwnProperty(c)) {
				return this.meta.def.colorNames[c]
			} else {
				throw new Error(a + " is not a valid color.")
			}
		}
	};
	this.getColorForValue = function(a, c) {
		if (!a) {
			a = this.meta.def.colorBrew
		}
		for (var d = 0; d < a.breaks.length; d++) {
			if (a.breaks[d] >= c) {
				return a.colors[d]
			}
		}
		return a.colors[a.colors.length - 1]
	};
	this.setColorForValues = function(a, d) {
		var g = this;
		var c = function(l) {
			var j = function(t, q) {
				var n = a.grads[l];
				var s = n.min;
				var y = n.max;
				var p = n.scol.substring(t, q);
				var z = n.ecol.substring(t, q);
				var v = d < s ? s : d > y ? y : d;
				var i = y - s;
				var w = parseInt(p, 16);
				var m = parseInt(z, 16);
				var u = (m - w) / i;
				var o = Math.round(u * (v - s) + w);
				var x = o.toString(16);
				return x.length == 1 ? "0" + x : x
			};
			var k = j(0, 2);
			var h = j(2, 4);
			var b = j(4, 6);
			return g.hexToRgb("#" + k + h + b)
		};
		if (!a) {
			a = this.meta.def.colorBrew
		}
		if (a.length == 1) {
			return c(0)
		} else {
			var f = (a.max - a.min) / a.grads.length;
			var e = Math.min(Math.floor((Math.max(d, a.min) - a.min) / f), a.grads.length - 1);
			return c(e)
		}
	};
	this.getColorBrew = function(K, B, E, f, e) {
		var g = K || this.colorSpectrum;
		if (B != null && E != null && B == E) {
			E += 0.1
		}
		var F = B != null ? B : this.minData != null ? this.minData : 0;
		var q = E != null ? E : this.maxData != null ? this.maxData : 100;
		var I = this.setMinX != null ? this.setMinX : null;
		var w = this.setMaxX != null ? this.setMaxX : null;
		var C, u;
		var L = [];
		if (f == null) {
			zero = (F + q) / 2
		} else {
			zero = f;
			var C = f - F;
			var u = q - f;
			if (C > u) {
				q = f + C
			} else {
				F = f - u
			}
		}
		var t = this[this.axisAlgorithm](Math.min(I || F, w || q), Math.max(I || F, w || q), 5, this.axisWilkinsonLoose);
		var G = (t[t.length - 1] - t[0]) / (g.length - 1);
		var a = this.getAxisDecimals(t[1] - t[0]);
		var c = this.getMaxText(t);
		var H = this.measureText(c.toString(), this.font);
		var o = t[t.length - 1] - t[0];
		var d = o / this.colorSpectrumNumber;
		if (e && e.length > 1 && e.length == g.length) {
			for (var D = 0; D < e.length; D++) {
				e[D] = Number(e[D])
			}
			e = e.sort(function(l, i) {
				return l - i
			});
			var x = t[0];
			var A = Math.ceil((this.colorSpectrumNumber - 1) / g.length);
			for (var D = 0; D < e.length; D++) {
				var m = e[D];
				var J = this.seq(x, m, false, A);
				L = L.concat(J);
				var k = L.length - 1;
				x = m + (L[k] - L[k - 1])
			}
		} else {
			L = this.seq(t[0], t[t.length - 1], false, this.colorSpectrumNumber)
		}
		while (L.length < this.colorSpectrumNumber) {
			L.push(t[t.length - 1])
		}
		var y = {
			scol: this.getHexColor(g[0]),
			ecol: this.getHexColor(g[1]),
			min: t[0],
			max: t[0] + G
		};
		var j = {
			spectrum: g,
			stops: e,
			z: f,
			colors: [],
			legend: [],
			grads: [y],
			rmin: F,
			rmax: q,
			min: t[0],
			max: t[t.length - 1],
			range: o,
			zero: zero,
			vals: t,
			incr: G,
			decs: a,
			breaks: L,
			maxLevLen: H,
			maxLevChr: c.toString().length,
			maxLevStr: c
		};
		for (var D = 1; D < g.length - 1; D++) {
			y = {
				scol: this.getHexColor(g[D]),
				ecol: this.getHexColor(g[D + 1]),
				min: t[0] + (G * D),
				max: t[0] + (G * (D + 1))
			};
			j.grads.push(y)
		}
		var h = t[0];
		for (var D = 0; D < this.colorSpectrumNumber; D++) {
			j.colors.push(this.setColorForValues(j, h));
			h += d
		}
		for (var D = 0; D < this.colorSpectrumNumber; D++) {
			h = L[D];
			j.legend.push(this.setColorForValues(j, h))
		}
		return j
	};
	this.setColorBrew = function(b) {
		if (!this.meta.def.colorBrew || b) {
			if (this.meta.vals.colors) {
				this.meta.vals.colors = {}
			}
			if (this.graphType.match(/Stacked/)) {
				this.meta.def.colorBrew = this.getColorBrew(this.colorSpectrum, this.minDataStacked, this.maxDataStacked, this.colorSpectrumZeroValue, this.colorSpectrumBreaks)
			} else {
				if (this.heatmapAutoAdjust || !this.meta.def.colorBrew) {
					this.meta.def.colorBrew = this.getColorBrew(this.colorSpectrum, this.minData, this.maxData, this.colorSpectrumZeroValue, this.colorSpectrumBreaks)
				} else {
					var a = this.meta.def.colorBrew;
					this.meta.def.colorBrew = this.getColorBrew(this.colorSpectrum, a.rmin, a.rmax, a.z, a.stops)
				}
			}
		}
	};
	this.validateUserColors = function() {
		var a = [];
		for (var b = 0; b < this.colors.length; b++) {
			a.push(this.validateColor(this.colors[b]))
		}
		if (a.length > 0) {
			this.colors = a
		}
	};
	this.validateUserColors()
};
CanvasXpress.prototype.initAttributes = function() {
	this.setStyle = function(c, b, d) {
		var a = this.getCanvasContext();
		c = this.validateColor(c);
		if (this.transparency != null) {
			c = this.addColorTransparency(c, this.transparency)
		}
		a.fillStyle = c;
		a.strokeStyle = c;
		a.lineWidth = b ? b : this.outlineWidth;
		a.lineCap = d ? d : this.capType;
		this.setShadow(true)
	};
	this.setClipBoundaries = function(c) {
		var b, d, a, e;
		if (c && c.length == 4) {
			b = c[0];
			d = c[1];
			a = c[2];
			e = c[3]
		} else {
			b = this.marginLeft + this.offsetX + this.left;
			d = this.marginTop + this.offsetY + this.top;
			a = this.x;
			e = this.y
		}
		return [b, d, a, e]
	};
	this.setClipArea = function(a) {
		var e = this.getCanvasContext();
		this.saveCanvas();
		e.strokeStyle = "rgba(255,255,255,0)";
		var d, f, c, g;
		if (a) {
			d = a[0];
			f = a[1];
			c = a[2];
			g = a[3]
		} else {
			d = this.marginLeft + this.offsetX + this.left;
			f = this.marginTop + this.offsetY + this.top;
			c = this.x + 1;
			g = this.y + 1
		}
		e.rect(d, f, c, g);
		e.clip();
		this.meta.state.clip = true
	};
	this.resetClipArea = function() {
		this.restoreCanvas();
		this.meta.state.clip = false
	};
	this.resetStyle = function() {
		this.setShadow(false)
	};
	this.drawArrowHead = function(D, e, B, c, C, p, d, b, l, j) {
		var x = this.getCanvasContext();
		var z = function(F, I, f, J) {
			var w = [];
			for (var G = 0; G < F.length; G++) {
				w.push([(F[G][0] * Math.cos(I)) - (F[G][1] * Math.sin(I)), (F[G][0] * Math.sin(I)) + (F[G][1] * Math.cos(I))])
			}
			var H = [];
			for (var G = 0; G < w.length; G++) {
				H.push([w[G][0] + f, w[G][1] + J])
			}
			return H
		};
		var t = this.arrowPointSize;
		var g = Math.max((t / 2) - 1, 1);
		var r = p ? p / 2 : this.outlineWidth / 2;
		var s = l ? [
			[0, -t],
			[0, t]
		] : [
			[Math.floor((t / 2.5)), 0],
			[-t, -g * p],
			[-t, g * p]
		];
		var q = B - D;
		var o = c - e;
		if (d) {
			if (d == "Y") {
				if (Math.abs(o) > Math.abs(q)) {
					q = 0
				} else {
					q = B > D ? this.arrowPointSize : -this.arrowPointSize
				}
			} else {
				if (Math.abs(q) > Math.abs(o)) {
					o = 0
				} else {
					o = c > e ? this.arrowPointSize : -this.arrowPointSize
				}
			}
		} else {
			if (b) {
				var n = this.lineLength(D, e, B, c);
				var E = this.shortenLine(D, e, B, c, 0, n / 2, "line");
				var m = E[2];
				var A = E[3];
				var v = n / 2;
				var h = b / v;
				var u = B > D ? Math.asin((A - e) / v) : Math.asin(-(A - e) / v);
				var a = j ? u + (Math.PI / 20) : u - (Math.PI / 20);
				if (B > D) {
					D = m + v * Math.cos(a - h);
					e = A + v * Math.sin(a - h);
					B = m + v * Math.cos(u - h);
					c = A + v * Math.sin(u - h)
				} else {
					D = m + v * Math.cos((a - h) + Math.PI);
					e = A + v * Math.sin((a - h) + Math.PI);
					B = m + v * Math.cos((u - h) + Math.PI);
					c = A + v * Math.sin((u - h) + Math.PI)
				}
				q = B - D;
				o = c - e
			}
		}
		var k = z(s, Math.atan2(o, q), B, c);
		this.setStyle(C, p);
		x.beginPath();
		x.moveTo(k[0][0], k[0][1]);
		for (var y = 1; y < k.length; y++) {
			if (!isNaN(k[y][0]) && !isNaN(k[y][1])) {
				x.lineTo(k[y][0], k[y][1])
			}
		}
		if (!l) {
			if (!isNaN(k[0][0]) && !isNaN(k[0][1])) {
				x.lineTo(k[0][0], k[0][1])
			}
			x.closePath();
			x.fill()
		} else {
			x.closePath();
			x.stroke()
		}
		this.resetStyle()
	};
	this.setShadow = function(c) {
		if (this.showShadow) {
			var a = this.getCanvasContext();
			var b = "rgba(255,255,255,0)";
			if (c) {
				a.shadowOffsetX = this.shadowOffsetX;
				a.shadowOffsetY = this.shadowOffsetY;
				a.shadowBlur = this.shadowBlur;
				a.shadowColor = this.shadowColor
			} else {
				a.shadowOffsetX = 0;
				a.shadowOffsetY = 0;
				a.shadowBlur = 0;
				a.shadowColor = this.background;
				a.strokeStyle = "rgba(255,255,255,0)";
				a.fillStyle = "rgba(255,255,255,0)"
			}
		}
	};
	this.drawCurve = function(e, a) {
		var b = this.getCanvasContext();
		var c = this.tension;
		var d = this.tensionSegments;
		var g = function(j) {
			b.moveTo(j[0], j[1]);
			for (var h = 2; h < j.length - 1; h += 2) {
				b.lineTo(j[h], j[h + 1]);
				b.stroke()
			}
		};
		var f = function(B, h) {
			var u, t, A, r, w, q, p, n, l, k, z;
			var v = [];
			var s = [];
			h = h ? h : false;
			v = B.slice(0);
			if (h) {
				v.unshift(B[B.length - 1]);
				v.unshift(B[B.length - 2]);
				v.unshift(B[B.length - 1]);
				v.unshift(B[B.length - 2]);
				v.push(B[0]);
				v.push(B[1])
			} else {
				v.unshift(B[1]);
				v.unshift(B[0]);
				v.push(B[B.length - 2]);
				v.push(B[B.length - 1])
			}
			for (var o = 2; o < (v.length - 4); o += 2) {
				for (var m = 0; m <= d; m++) {
					A = (v[o + 2] - v[o - 2]) * c;
					r = (v[o + 4] - v[o]) * c;
					w = (v[o + 3] - v[o - 1]) * c;
					q = (v[o + 5] - v[o + 1]) * c;
					z = m / d;
					p = 2 * Math.pow(z, 3) - 3 * Math.pow(z, 2) + 1;
					n = -(2 * Math.pow(z, 3)) + 3 * Math.pow(z, 2);
					l = Math.pow(z, 3) - 2 * Math.pow(z, 2) + z;
					k = Math.pow(z, 3) - Math.pow(z, 2);
					u = p * v[o] + n * v[o + 2] + l * A + k * r;
					t = p * v[o + 1] + n * v[o + 3] + l * w + k * q;
					s.push(u);
					s.push(t)
				}
			}
			return s
		};
		g(f(e, a))
	};
	this.lineTo = function(c, e, b, d) {
		if (c == b) {
			c = (((c + 0.5) << 1) >> 1) + 0.5;
			b = c
		} else {
			if (e == d) {
				e = (((e + 0.5) << 1) >> 1) + 0.5;
				d = e
			}
		}
		var a = this.getCanvasContext();
		a.moveTo(c, e);
		a.lineTo(b, d);
		a.stroke()
	};
	this.bitCode = function(b, c) {
		var a = 0;
		if (b[0] < c[0]) {
			a |= 1
		} else {
			if (b[0] > c[2]) {
				a |= 2
			}
		}
		if (b[1] < c[1]) {
			a |= 4
		} else {
			if (b[1] > c[3]) {
				a |= 8
			}
		}
		return a
	};
	this.intersect = function(d, c, e, f) {
		return e & 8 ? [d[0] + (c[0] - d[0]) * (f[3] - d[1]) / (c[1] - d[1]), f[3]] : e & 4 ? [d[0] + (c[0] - d[0]) * (f[1] - d[1]) / (c[1] - d[1]), f[1]] : e & 2 ? [f[2], d[1] + (c[1] - d[1]) * (f[2] - d[0]) / (c[0] - d[0])] : e & 1 ? [f[0], d[1] + (c[1] - d[1]) * (f[0] - d[0]) / (c[0] - d[0])] : null
	};
	this.lineClip = function(n, l, h) {
		var k, j, d, m;
		var g = n.length;
		var e = this.bitCode(n[0], l);
		var c = [];
		if (!l) {
			l = this.setClipBoundaries()
		}
		for (var f = 1; f < g; f++) {
			k = n[f - 1];
			j = n[f];
			d = m = this.bitCode(j, l);
			while (true) {
				if (!(e | d)) {
					c.push(k);
					if (d !== m) {
						c.push(j);
						if (f < g - 1) {
							result.push(c);
							c = []
						}
					} else {
						if (f === g - 1) {
							c.push(j)
						}
					}
					break
				} else {
					if (e & d) {
						break
					} else {
						if (e) {
							k = this.intersect(k, j, e, l);
							e = this.bitCode(k, l)
						} else {
							j = this.intersect(k, j, d, l);
							d = this.bitCode(j, l)
						}
					}
				}
			}
			e = m
		}
		if (c.length) {
			h.push(c)
		}
		return h
	};
	this.polygonClip = function(j, h) {
		var g, c, f, a, d;
		if (!h) {
			h = this.setClipBoundaries()
		}
		for (var b = 1; b <= 8; b *= 2) {
			g = [];
			c = j[j.length - 1];
			f = !(this.bitCode(c, h) & b);
			for (var e = 0; e < j.length; e++) {
				a = j[e];
				d = !(this.bitCode(a, h) & b);
				if (d !== f) {
					g.push(this.intersect(c, a, b, h))
				}
				if (d) {
					g.push(a)
				}
				c = a;
				f = d
			}
			j = g;
			if (!j.length) {
				break
			}
		}
		return g
	};
	this.clip = function(v, f, k) {
		var d, c, p, n, j, o, v;
		var q, e, a, m;
		var u = [];
		if (!k) {
			k = this.setClipBoundaries()
		}
		var e = k[0];
		var q = k[1];
		var a = k[2];
		var m = k[3];
		switch (v) {
			case "path":
				u[0] = [];
				u[1] = [];
				for (var g = 0; g < f[0].length; g++) {
					c = f[0][g];
					n = f[1][g];
					if (c < e || c > a) {
						c = null
					}
					if (n < q || n > m) {
						n = null
					}
					u[0].push(c);
					u[1].push(n)
				}
				break;
			case "box":
			case "rect":
			case "rectangle":
			case "rect2":
			case "rect3":
			case "roundrect":
				d = this.parseInt(f[0] - (f[2] / 2));
				p = this.parseInt(f[1] - (f[3] / 2));
				c = this.parseInt(d + f[2]);
				n = this.parseInt(p + f[3]);
				if (c > d) {
					if (n > p) {
						if (d > a + this.outlineWidth || p > m + this.outlineWidth || c < e || n < q) {
							return false
						}
						if (d < e) {
							d = e
						}
						if (c > a) {
							c = a
						}
						if (p < q) {
							p = q
						}
						if (n > m) {
							n = m
						}
					} else {
						if (d > a + this.outlineWidth || n > m + this.outlineWidth || c < e || p < q) {
							return false
						}
						if (d < e) {
							d = e
						}
						if (c > a) {
							c = a
						}
						if (p > m) {
							p = m
						}
						if (n < q) {
							n = q
						}
					}
				} else {
					if (n > p) {
						if (c > a + this.outlineWidth || p > m + this.outlineWidth || d < e || n < q) {
							return false
						}
						if (d > a) {
							d = a
						}
						if (c < e) {
							c = e
						}
						if (p < q) {
							p = q
						}
						if (n > m) {
							n = m
						}
					} else {
						if (c > a + this.outlineWidth || n > m + this.outlineWidth || d < e || p < q) {
							return false
						}
						if (d > a) {
							d = a
						}
						if (c < e) {
							c = e
						}
						if (p > m) {
							p = m
						}
						if (n < q) {
							n = q
						}
					}
				}
				u = [d, p, c - d, n - p];
				break;
			case "poly":
				break;
			case "circle":
			case "sphere":
			case "square":
			case "triangle":
			case "triangle2":
			case "equilateral":
			case "equilateral2":
			case "diamond":
			case "rhombus":
			case "hexagon":
			case "octagon":
			case "oval":
			case "oval2":
			case "oval3":
			case "arc":
			case "arc2":
			case "arc3":
			case "ellipse":
			case "ellipse2":
			case "ellipse3":
			case "plus":
			case "minus":
			case "mdavid":
			case "star":
			case "pie":
			case "pie0":
			case "pie1":
			case "pie2":
			case "pie3":
			case "pie4":
			case "pie5":
			case "pie6":
			case "pie7":
			case "pie8":
			case "pie9":
			case "pacman":
			case "pacman2":
				d = parseInt(f[0]);
				p = parseInt(f[1]);
				if (d > a || d < e || p < q || p > m) {
					return false
				}
				u = [d, p];
				break;
			case "line":
				d = parseFloat(f[0]);
				p = parseFloat(f[1]);
				c = parseFloat(f[2]);
				n = parseFloat(f[3]);
				if (d == c) {
					if (d < e || d > a) {
						return false
					} else {
						if (p > n) {
							if (p < q) {
								return false
							} else {
								if (p > m) {
									p = m
								}
							}
							if (n > m) {
								return false
							} else {
								if (n < q) {
									n = q
								}
							}
						} else {
							if (p > m) {
								return false
							} else {
								if (p < q) {
									p = q
								}
							}
							if (n < q) {
								return false
							} else {
								if (n > m) {
									n = m
								}
							}
						}
					}
				} else {
					if (p == n) {
						if (p < q || p > m) {
							return false
						} else {
							if (d > c) {
								if (d < e) {
									return false
								} else {
									if (d > a) {
										d = a
									}
								}
								if (c > a) {
									return false
								} else {
									if (c < e) {
										c = e
									}
								}
							} else {
								if (d > a) {
									return false
								} else {
									if (d < e) {
										d = e
									}
								}
								if (c < e) {
									return false
								} else {
									if (c > a) {
										c = a
									}
								}
							}
						}
					} else {
						if (d > c) {
							if (d < e || c > a) {
								return false
							} else {
								if (p > n) {
									if (p < q || n > m) {
										return false
									} else {
										j = p - n;
										o = d - c;
										if (d > a) {
											p -= (d - a) * j / o;
											d = a
										}
										if (p > m) {
											d -= (p - m) * o / j;
											p = m
										}
										if (c < e) {
											n += (e - c) * j / o;
											c = e
										}
										if (n < q) {
											c += (q - n) * o / j;
											n = q
										}
									}
								} else {
									if (n < q || p > m) {
										return false
									} else {
										j = n - p;
										o = d - c;
										if (d > a) {
											p += (d - a) * j / o;
											d = a
										}
										if (p < q) {
											d -= (q - p) * o / j;
											p = q
										}
										if (c < e) {
											n -= (e - c) * j / o;
											c = e
										}
										if (n > m) {
											c += (n - m) * o / j;
											n = m
										}
									}
								}
							}
						} else {
							if (c < e || d > a) {
								return false
							} else {
								if (p > n) {
									if (p < q || n > m) {
										return false
									} else {
										j = p - n;
										o = c - d;
										if (d < e) {
											p -= (e - d) * j / o;
											d = e
										}
										if (p > m) {
											d += (p - m) * o / j;
											p = m
										}
										if (c > a) {
											n += (c - a) * j / o;
											c = a
										}
										if (n < q) {
											c -= (q - n) * o / j;
											n = q
										}
									}
								} else {
									if (n < q || p > m) {
										return false
									} else {
										j = n - p;
										o = c - d;
										if (d < e) {
											p += (e - d) * j / o;
											d = e
										}
										if (p < q) {
											d += (q - p) * o / j;
											p = q
										}
										if (c > a) {
											n -= (c - a) * j / o;
											c = a
										}
										if (n > m) {
											c -= (n - m) * o / j;
											n = m
										}
									}
								}
							}
						}
					}
				}
				u = [d, p, c, n];
				break;
			default:
				return false
		}
		return u
	};
	this.drawErrorLine = function(r, h, n, g, m, i, o, d, u, j, k, l, a) {
		this.functionCaller = "drawErrorLine";
		if (this.showErrorBars && this.isNumeric([o])) {
			h = Math.ceil(h);
			g = Math.ceil(g);
			n = Math.ceil(n);
			m = Math.ceil(m);
			o = Math.ceil(o);
			this.drawLine("line", h, n, g, m, i, false, "butt", false, false, k, l);
			if (Math.abs(o) > this.errorBarsWidth) {
				if (o > 0) {
					this.drawLine("line", g, m - o / 2, g, m + o / 2, i, false, "butt", false, false, k, l)
				} else {
					this.drawLine("line", g - o / 2, m, g + o / 2, m, i, false, "butt", false, false, k, l)
				}
			}
		}
	};
	this.drawMedianLine = function(r, h, n, g, m, i, o, d, u, j, k, l, a) {
		this.functionCaller = "drawMedianLine";
		this.drawLine("line", h, n, g, m, i, o, d, u, j, k, l, a)
	};
	this.drawElbowLine = function(m, y, g, v, d, x, k, r, n, z, A, B, o) {
		this.functionCaller = "drawElbowLine";
		if (o && this.isArray(o) && o.length > 0) {
			var l = 2;
			var a, h, j;
			if (m.match(/^arrowheadsquaretail/i)) {
				a = m.replace(/arrowhead/i, "");
				h = m.replace(/arrowheadsquaretail/i, "");
				j = m.replace(/squaretail/i, "")
			} else {
				if (m.match(/^squaretailarrowhead/i)) {
					a = m.replace(/squaretail/i, "");
					h = m.replace(/squaretailarrowhead/i, "");
					j = m.replace(/arrowhead/i, "")
				} else {
					if (m.match(/^arrowtailsquarehead/i)) {
						a = m.replace(/arrowtail/i, "");
						h = m.replace(/arrowtailsquarehead/i, "");
						j = m.replace(/squarehead/i, "")
					} else {
						if (m.match(/^squareheadarrowtail/i)) {
							a = m.replace(/squarehead/i, "");
							h = m.replace(/squareheadarrowtail/i, "");
							j = m.replace(/arrowtail/i, "")
						} else {
							if (m.match(/^arrowhead/i)) {
								a = m.replace(/arrowhead/i, "");
								h = a;
								j = m
							} else {
								if (m.match(/^squarehead/i)) {
									a = m.replace(/squarehead/i, "");
									h = a;
									j = m
								} else {
									if (m.match(/^arrowtail/i)) {
										a = m;
										h = m.replace(/arrowtail/i, "");
										j = h
									} else {
										if (m.match(/^squaretail/i)) {
											a = m;
											h = m.replace(/squaretail/i, "");
											j = h
										} else {
											if (m.match(/^arrow/i)) {
												a = m.replace(/arrow/i, "arrowHead");
												h = m.replace(/arrow/i, "");
												j = m.replace(/arrow/i, "arrowTail")
											} else {
												if (m.match(/^square/i)) {
													a = m.replace(/square/i, "squareHead");
													h = m.replace(/square/i, "");
													j = m.replace(/square/i, "squareTail")
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.drawLine(a, y, g, o[0][0], o[0][1], x, k, r, n, false, A, B);
			for (var u = 1; u < o.length; u++) {
				this.drawLine(h, o[u - 1][0], o[u - 1][1], o[u][0], o[u][1], x, k, r, false, false, A, B)
			}
			this.drawLine(j, o[o.length - 1][0], o[o.length - 1][1], v, d, x, k, r, false, z, A, B)
		} else {
			return this.drawLine(m, y, g, v, d, x, k, r, false, z, A, B)
		}
	};
	this.getLineArea = function(J, x, a, u, U, Q, I, N, K, R, S, T, L) {
		var O = Math.max(I, this.lineWidthEvent);
		var M = [];
		var D = ["poly"];
		var d = function(e, i, c, f) {
			if (e == c && i != f) {
				return [
					[e - O, i],
					[e + O, i],
					[c + O, f],
					[c - O, f]
				]
			} else {
				if (a == U && x != u) {
					return [
						[e, i - O],
						[c, i - O],
						[c, f + O],
						[e, f + O]
					]
				} else {
					var b = this.parallelLinePoints(e, i, c, f, O);
					return [
						[b[0], b[1]],
						[b[2], b[3]],
						[b[6], b[7]],
						[b[4], b[5]]
					]
				}
			}
		};
		if (!T) {
			T = this.setClipBoundaries()
		}
		if ((K || R)) {
			var A = this.shortenLine(x, a, u, U, K, R, J);
			x = A[0];
			a = A[1];
			u = A[2];
			U = A[3]
		}
		if (J == "spline" || J == "cardinalSpline") {
			if (x.length < 3) {
				return x.length < 2 ? false : this.getLineArea("line", x[0], a[0], x[1], a[1], Q, I, N, K, R, S, T, L)
			}
			for (var P = 0; P < x.length; P++) {
				D.push(x[P], a[P] - O);
				M.push(a[P] + O, x[P])
			}
			D = D.concat(M.reverse())
		} else {
			if (J == "arch") {
				if (x.length != 3 || a.length != 3) {
					return this.getLineArea("line", x[0], a[0], x[x.length - 1], a[a.length - 1], Q, I, N, K, R, S, T, L)
				}
				M = this.traceQuadraticCurve(x[0], a[0], x[1], a[1], x[2], a[2], 0.25, true);
				for (var P = 0; P < M.length; P++) {
					D.push(M[P][0], M[P][1])
				}
				M = this.traceQuadraticCurve(x[0], a[0], x[1], a[1], x[2], a[2], 0.25);
				for (var P = 0; P < M.length; P++) {
					D.push(M[P][0], M[P][1])
				}
			} else {
				if (J.match(/bezier/i)) {
					if (x == u || a == U) {
						return this.getLineArea("line", x, a, u, U, Q, I, N, K, R, S, T, L)
					}
					if (K || R) {
						if (u > x) {
							if (x + K > u - R) {
								J = J.replace(/bezier[x]?/i, "")
							} else {
								if (x - K < u + R) {
									J = J.replace(/bezier[x]?/i, "")
								}
							}
						}
					}
					var k = (x + u) / 2;
					var j = (a + U) / 2;
					if (J.match(/beziery/i)) {
						M = this.traceBezierCurve(x, a - O, x, j - O, u, j - O, u, U - O, 0.25, true)
					} else {
						M = this.traceBezierCurve(x, a - O, k, a - O, k, U - O, u, U - O, 0.25, true)
					}
					for (var P = 0; P < M.length; P++) {
						D.push(M[P][0], M[P][1])
					}
					if (J.match(/beziery/i)) {
						M = this.traceBezierCurve(x, a + O, x, j + O, u, j + O, u, U + O, 0.25)
					} else {
						M = this.traceBezierCurve(x, a + O, k, a + O, k, U + O, u, U + O, 0.25)
					}
					for (var P = 0; P < M.length; P++) {
						D.push(M[P][0], M[P][1])
					}
				} else {
					if (J.match(/curved/i)) {
						var k = 12;
						var m = 1;
						var C = this.lineLength(x, a, u, U);
						var v = this.shortenLine(x, a, u, U, 0, C / 2, "line");
						var F = v[2];
						var y = v[3];
						var H = C / 2;
						var E = K / H;
						var z = R / H;
						var h = (F - x);
						var g = (y - a);
						var l = u >= x ? Math.asin(g / H) : Math.asin(-g / H);
						var o = Math.PI / k;
						var n = u >= x ? 0 : Math.PI;
						D = ["poly"];
						for (var P = m; P <= k - m; P++) {
							D.push(F - (H + 2) * Math.cos(l + ((o * P)) - n));
							D.push(y - (H + 2) * Math.sin(l + ((o * P)) - n))
						}
						for (var P = k - m; P >= m; P--) {
							D.push(F - (H - 2) * Math.cos(l + ((o * P)) - n));
							D.push(y - (H - 2) * Math.sin(l + ((o * P)) - n))
						}
					} else {
						if (L) {
							D = ["poly"];
							var G = d(x, a, L[0][0], L[0][1]);
							var B = G.splice(2).reverse().shift();
							for (var P = 1; P < L.length; P++) {
								var M = d(L[P - 1][0], L[P - 1][1], L[P][0], L[P][1]);
								G.push(M[1]);
								B.push(M[2])
							}
							D = D.concat(G).concat(B.reverse())
						} else {
							if (J == "error" && Math.abs(I) > this.errorBarsWidth) {
								var O = this.lineWidthEvent;
								if (I > 0) {
									D = ["poly", x, a - O, u - O, U - O, u - O, U - I / 2, u + O, U - I / 2, u + O, U + I / 2, u - O, U + I / 2, u - O, U + O, x, a + O]
								} else {
									D = ["poly", u - O, U + O, u - I / 2, U + O, u - I / 2, U - O, u + I / 2, U - O, u + I / 2, U + O, u + O, U + O, x + O, a, x - O, a]
								}
							} else {
								if (x == u && a != U) {
									D = ["poly", x - O, a, x + O, a, u + O, U, u - O, U]
								} else {
									if (a == U && x != u) {
										D = ["poly", x, a - O, u, a - O, u, U + O, x, U + O]
									} else {
										var r = this.parallelLinePoints(x, a, u, U, O);
										D = ["poly", r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]]
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.graphType == "Network") {
			return this.preScaleNetwork && !this.isAnimation ? D : this.adjustNetworkObjects(D)
		} else {
			return D
		}
	};
	this.drawLine = function(P, D, a, A, af, aa, O, T, R, ab, ac, ae, S) {
		this.functionCallerDraw = "drawLine";
		var E = this.getCanvasContext();
		var W;
		var M = false;
		var v = false;
		var u = false;
		var X = this.lineWidthEvent;
		var L = this;
		var j = T;
		var d = function() {
			var b;
			b = D;
			D = A;
			A = b;
			b = a;
			a = af;
			af = b
		};
		var k = function() {
			var b = [];
			if (P.match(/dashed/i)) {
				b = [L.dashLength, L.dashLength]
			} else {
				if (P.match(/dotted/i)) {
					T = "round";
					b = [L.dotLength, L.dotLength + 3]
				}
			}
			E.setLineDash(b)
		};
		var J = function() {
			T = j;
			E.setLineDash([])
		};
		if (S && this.isArray(S) && S.length > 0) {
			this.drawElbowLine(P, D, a, A, af, aa, O, T, R, ab, ac, ae, S)
		} else {
			if (P == "error") {
				this.drawErrorLine(P, D, a, A, af, aa, O, T, R, ab, ac, ae, S)
			} else {
				if (P == "median") {
					this.drawMedianLine(P, D, a, A, af, aa, O, T, R, ab, ac, ae, S)
				} else {
					if (P == "spline") {
						if (D.length < 3) {
							return D.length < 2 ? false : this.drawLine("line", D[0], a[0], D[1], a[1], aa, O, T, R, ab, ac, ae)
						}
						var Q = [];
						var ad = [];
						var V = 0;
						for (var Z = 0; Z < D.length; Z++) {
							if (this.isNumeric([D[Z], a[Z]])) {
								ad.push(D[Z], a[Z]);
								V += 2
							} else {
								return
							}
						}
						this.setStyle(aa, O, T);
						if (!this.isColorTransparent(aa)) {
							for (var Z = 0; Z < V - 4; Z += 2) {
								Q = Q.concat(this.splineControlPoint(ad[Z], ad[Z + 1], ad[Z + 2], ad[Z + 3], ad[Z + 4], ad[Z + 5]))
							}
							E.beginPath();
							E.moveTo(ad[0], ad[1]);
							E.quadraticCurveTo(Q[0], Q[1], ad[2], ad[3]);
							for (var Z = 2; Z < V - 5; Z += 2) {
								E.bezierCurveTo(Q[2 * Z - 2], Q[2 * Z - 1], Q[2 * Z], Q[2 * Z + 1], ad[Z + 2], ad[Z + 3])
							}
							E.moveTo(ad[V - 2], ad[V - 1]);
							E.quadraticCurveTo(Q[2 * V - 10], Q[2 * V - 9], ad[V - 4], ad[V - 3]);
							E.stroke()
						}
						this.resetStyle()
					} else {
						if (P == "cardinalSpline") {
							if (D.length < 3) {
								return D.length < 2 ? false : this.drawLine("line", D[0], a[0], D[1], a[1], aa, O, T, R, ab, ac, ae)
							}
							var ad = [];
							for (var Z = 0; Z < D.length; Z++) {
								if (this.isNumeric([D[Z], a[Z]])) {
									ad.push(D[Z], a[Z])
								} else {
									return
								}
							}
							this.setStyle(aa, O, T);
							if (!this.isColorTransparent(aa)) {
								this.drawCurve(ad)
							}
							this.resetStyle()
						} else {
							if (P == "arch") {
								if (D.length != 3 || a.length != 3) {
									return
								}
								for (var Z = 0; Z < D.length; Z++) {
									if (!this.isNumeric([D[Z], a[Z]])) {
										return
									}
								}
								this.setStyle(aa, O, T);
								if (!this.isColorTransparent(aa)) {
									E.beginPath();
									E.moveTo(D[0], a[0]);
									E.quadraticCurveTo(D[1], a[1], D[2], a[2]);
									E.stroke()
								}
								this.resetStyle()
							} else {
								if (this.isNumeric([D, a, A, af])) {
									if (!R) {
										R = 0
									}
									if (!ab) {
										ab = 0
									}
									if (P.match(/bezier/i)) {
										if (P.match(/beziery/i)) {
											W = "bezierLine";
											v = "Y";
											M = "Y";
											if (R || ab) {
												if (af > a) {
													if (a + R > af - ab) {
														P = P.replace(/beziery/i, "");
														W = "line";
														v = false;
														M = false
													}
												} else {
													if (a - R < af + ab) {
														P = P.replace(/beziery/i, "");
														W = "line";
														v = false;
														M = false
													}
												}
											}
										} else {
											W = "bezierLine";
											v = "X";
											M = "X";
											if (R || ab) {
												if (A > D) {
													if (D + R > A - ab) {
														P = P.replace(/bezier[x]?/i, "");
														W = "line";
														v = false;
														M = false
													}
												} else {
													if (D - R < A + ab) {
														P = P.replace(/bezier[x]?/i, "");
														W = "line";
														v = false;
														M = false
													}
												}
											}
										}
									} else {
										if (P.match(/curved/i)) {
											if (P.match(/curvedc/i)) {
												W = "curvedLine";
												u = true;
												M = true
											} else {
												W = "curvedLine";
												u = true;
												M = false
											}
										} else {
											W = "line"
										}
									}
									if ((R || ab)) {
										var U = this.shortenLine(D, a, A, af, R, ab, P);
										D = U[0];
										a = U[1];
										A = U[2];
										af = U[3]
									}
									if (ac) {
										var G = this.clip("line", [D, a, A, af], ae);
										if (G) {
											D = G[0];
											a = G[1];
											A = G[2];
											af = G[3]
										} else {
											return false
										}
									}
									k();
									switch (W) {
										case "bezierLine":
											if (D == A || a == af) {
												return this.drawLine("line", D, a, A, af, aa, O, T, R, ab, ac, ae)
											}
											M = M == "Y" ? "Y" : "X";
											var m = (D + A) / 2;
											var l = (a + af) / 2;
											this.setStyle(aa, O, T);
											if (!this.isColorTransparent(aa)) {
												E.moveTo(D, a);
												if (M == "Y") {
													E.bezierCurveTo(D, l, A, l, A, af)
												} else {
													E.bezierCurveTo(m, a, m, af, A, af)
												}
											}
											E.stroke();
											this.resetStyle();
											break;
										case "curvedLine":
											var m = 12;
											var r = 1;
											var H = this.lineLength(D, a, A, af);
											var C = this.shortenLine(D, a, A, af, 0, H / 2, "line");
											var K = C[2];
											var B = C[3];
											var N = H / 2;
											var I = R / N;
											var F = ab / N;
											var h = (K - D);
											var g = (B - a);
											var z = M && D > A ? false : !M && A >= D ? true : M;
											var o = A >= D ? Math.asin(g / N) : Math.asin(-g / N);
											var Y = o + Math.PI;
											var y = Math.PI / m;
											var x = A >= D ? 0 : Math.PI;
											this.setStyle(aa, O, T);
											if (!this.isColorTransparent(aa)) {
												E.beginPath();
												if (A >= D) {
													E.arc(K, B, N, o - F, Y + I, z)
												} else {
													E.arc(K, B, N, o + I, Y - F, z)
												}
												E.stroke()
											}
											this.resetStyle();
											break;
										case "line":
											this.setStyle(aa, O, T);
											if (!this.isColorTransparent(aa)) {
												E.beginPath();
												this.lineTo(D, a, A, af)
											}
											this.resetStyle();
											break
									}
									J();
									if (P.match(/arrowheadsquaretail|squaretailarrowhead/i)) {
										u = u ? ab : false;
										this.drawArrowHead(D, a, A, af, aa, O, v, u);
										d();
										if (P.match(/curve/i)) {
											u = -R
										}
										this.drawArrowHead(D, a, A, af, aa, O, v, u, true)
									} else {
										if (P.match(/arrowtailsquarehead|squareheadarrowtail/i)) {
											u = u ? ab : false;
											this.drawArrowHead(D, a, A, af, aa, O, v, u, true);
											d();
											if (P.match(/curve/i)) {
												u = -R
											}
											this.drawArrowHead(D, a, A, af, aa, O, v, u, false, true)
										} else {
											if (P.match(/arrowhead/i)) {
												u = u ? ab : false;
												this.drawArrowHead(D, a, A, af, aa, O, v, u)
											} else {
												if (P.match(/squarehead/i)) {
													u = u ? ab : false;
													this.drawArrowHead(D, a, A, af, aa, O, v, u, true)
												} else {
													if (P.match(/arrowtail/i)) {
														d();
														if (P.match(/curve/i)) {
															u = -R
														}
														this.drawArrowHead(D, a, A, af, aa, O, v, u, false, true)
													} else {
														if (P.match(/squaretail/i)) {
															d();
															if (P.match(/curve/i)) {
																u = -R
															}
															this.drawArrowHead(D, a, A, af, aa, O, v, u, true, true)
														} else {
															if (P.match(/arrow/i)) {
																u = u ? ab : false;
																this.drawArrowHead(D, a, A, af, aa, O, v, u);
																d();
																if (P.match(/curve/i)) {
																	u = -R
																}
																this.drawArrowHead(D, a, A, af, aa, O, v, u, false, true)
															} else {
																if (P.match(/square/i)) {
																	u = u ? ab : false;
																	this.drawArrowHead(D, a, A, af, aa, O, v, u, true);
																	d();
																	if (P.match(/curve/i)) {
																		u = -R
																	}
																	this.drawArrowHead(D, a, A, af, aa, O, v, u, true, true)
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.createPatterns = function() {
		var b = this.getCanvasContext();
		var d;
		var e = document.createElement("canvas");
		e.width = 5;
		e.height = 5;
		var a = e.getContext("2d");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(5, 5);
		a.stroke();
		CanvasXpress.cachePatterns.hatchForward = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(5, 0);
		a.lineTo(0, 5);
		a.stroke();
		CanvasXpress.cachePatterns.hatchReverse = b.createPattern(e, "repeat");
		e.width = 3;
		e.height = 3;
		a.clearRect(0, 0, 3, 3);
		a.beginPath();
		a.moveTo(1.5, 0);
		a.lineTo(1.5, 3);
		a.stroke();
		CanvasXpress.cachePatterns.stripeVertical = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 3, 3);
		a.beginPath();
		a.moveTo(0, 1.5);
		a.lineTo(3, 1.5);
		a.stroke();
		CanvasXpress.cachePatterns.stripeHorizontal = b.createPattern(e, "repeat");
		e.width = 5;
		e.height = 5;
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.arc(2.5, 2.5, 2, 0, Math.PI * 2);
		a.fill();
		CanvasXpress.cachePatterns.polkaDot = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(5, 5);
		a.stroke();
		a.beginPath();
		a.moveTo(5, 0);
		a.lineTo(0, 5);
		a.stroke();
		CanvasXpress.cachePatterns.crossHatch = b.createPattern(e, "repeat");
		e.width = 3;
		e.height = 3;
		a.clearRect(0, 0, 3, 3);
		a.beginPath();
		a.moveTo(1.5, 0);
		a.lineTo(1.5, 3);
		a.stroke();
		a.beginPath();
		a.moveTo(0, 1.5);
		a.lineTo(3, 1.5);
		a.stroke();
		CanvasXpress.cachePatterns.crossStripe = b.createPattern(e, "repeat");
		e.width = 5;
		e.height = 5;
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.strokeRect(1, 1, 4, 4);
		a.stroke();
		CanvasXpress.cachePatterns.squares = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.arc(2.5, 2.5, 1, 0, Math.PI * 2);
		a.stroke();
		CanvasXpress.cachePatterns.circles = b.createPattern(e, "repeat");
		e.width = 7;
		e.height = 7;
		a.clearRect(0, 0, 7, 7);
		a.beginPath();
		a.moveTo(3.5, 1);
		a.lineTo(3.5, 6);
		a.stroke();
		a.beginPath();
		a.moveTo(1, 3.5);
		a.lineTo(6, 3.5);
		a.stroke();
		CanvasXpress.cachePatterns.plus = b.createPattern(e, "repeat");
		e.width = 7;
		e.height = 7;
		a.clearRect(0, 0, 7, 7);
		a.beginPath();
		a.moveTo(1, 3.5);
		a.lineTo(6, 3.5);
		a.stroke();
		CanvasXpress.cachePatterns.minus = b.createPattern(e, "repeat");
		e.width = 7;
		e.height = 7;
		a.clearRect(0, 0, 7, 7);
		a.beginPath();
		a.moveTo(3.5, 1);
		a.lineTo(3.5, 6);
		a.stroke();
		CanvasXpress.cachePatterns.bars = b.createPattern(e, "repeat");
		e.width = 5;
		e.height = 5;
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(0, 5);
		a.lineTo(2.5, 0);
		a.lineTo(5, 5);
		a.stroke();
		CanvasXpress.cachePatterns.squiglesHorizontal = b.createPattern(e, "repeat");
		e.width = 5;
		e.height = 5;
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(5, 2.5);
		a.lineTo(0, 5);
		a.stroke();
		CanvasXpress.cachePatterns.squiglesVertical = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(3, 0);
		a.lineTo(0, 3);
		a.closePath();
		a.stroke();
		a.fill();
		a.beginPath();
		a.moveTo(2, 5);
		a.lineTo(5, 2);
		a.lineTo(5, 5);
		a.closePath();
		a.stroke();
		a.fill();
		CanvasXpress.cachePatterns.brickForward = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(5, 0);
		a.lineTo(2, 0);
		a.lineTo(5, 3);
		a.closePath();
		a.stroke();
		a.fill();
		a.beginPath();
		a.moveTo(0, 5);
		a.lineTo(0, 2);
		a.lineTo(3, 5);
		a.closePath();
		a.stroke();
		a.fill();
		CanvasXpress.cachePatterns.brickReverse = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.arc(2.5, 2.5, 2, 0, Math.PI * 2);
		a.moveTo(0, 5);
		a.lineTo(5, 0);
		a.stroke();
		CanvasXpress.cachePatterns.art = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 5);
		a.beginPath();
		a.moveTo(2, 0);
		a.lineTo(0, 0);
		a.lineTo(0, 3);
		a.lineTo(2, 3);
		a.stroke();
		a.beginPath();
		a.moveTo(3, 3);
		a.lineTo(5, 5);
		a.stroke();
		a.beginPath();
		a.moveTo(5, 3);
		a.lineTo(3, 5);
		a.stroke();
		CanvasXpress.cachePatterns.pcx = b.createPattern(e, "repeat");
		e.width = 5;
		e.height = 3;
		a.clearRect(0, 0, 5, 3);
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(5, 3);
		a.stroke();
		CanvasXpress.cachePatterns.hatchForward3 = b.createPattern(e, "repeat");
		a.clearRect(0, 0, 5, 3);
		a.beginPath();
		a.moveTo(5, 0);
		a.lineTo(0, 3);
		a.stroke();
		CanvasXpress.cachePatterns.hatchReverse3 = b.createPattern(e, "repeat")
	};
	this.sphere = function(f, e, d, m, h, g, F, E, D) {
		var c = Math.sin(F);
		var A = Math.cos(F);
		var b = Math.sin(E);
		var x = Math.cos(E);
		var a = Math.sin(D);
		var v = Math.cos(D);
		var C = function(j) {
			var k = j.y;
			j.y = (k * A) + (j.z * c * -1);
			j.z = (k * c) + (j.z * A);
			var i = j.x;
			j.x = (i * x) + (j.z * b * -1);
			j.z = (i * b) + (j.z * x);
			var i = j.x;
			j.x = (i * v) + (j.y * a * -1);
			j.y = (i * a) + (j.y * v)
		};
		var l = [];
		var n = Math.PI / 12;
		var t = Math.PI * 2;
		var r = Math.PI / 2;
		for (var B = 1; B >= -1; B -= 2) {
			for (var z = 0; z < r; z += n) {
				var u = Math.cos(z) * m;
				var o = Math.cos(z) * g;
				var q = Math.sin(z) * h * B * -1;
				for (var w = 0; w < t; w += n) {
					var s = {
						x: (Math.cos(w) * u),
						y: q,
						z: (Math.sin(w) * o)
					};
					C(s);
					s.x += f;
					s.y += e;
					s.z += d;
					if (B > 0) {
						l.push([s.x, s.y, s.z])
					} else {
						l.unshift([s.x, s.y, s.z])
					}
				}
			}
		}
		return l
	};
	this.drawShapeSetShapeStyle = function(j, i, k, d, e, c, b, a, g) {
		var l = this.getCanvasContext();
		this.saveCanvas();
		this.translateCanvas(j, i);
		if (a) {
			this.rotateCanvas(a)
		}
		if (this.transparency != null) {
			e = this.addColorTransparency(e, this.transparency)
		}
		if (this.gradient) {
			if (this.gradientType == "radial") {
				l.fillStyle = this.getGradient(0, 0, Math.max(Math.abs(k), Math.abs(d)), e)
			} else {
				l.fillStyle = this.getGradient(0, 0, k, d, e)
			}
		} else {
			if (b) {
				switch (b) {
					case "closed":
					case "solid":
						l.fillStyle = e;
						break;
					case "open":
						break;
					default:
						l.fillStyle = CanvasXpress.cachePatterns[b] ? CanvasXpress.cachePatterns[b] : e;
						break
				}
			} else {
				l.fillStyle = e
			}
		}
		l.strokeStyle = c ? c : this.foreground;
		l.lineWidth = g ? g : this.outlineWidth;
		l.lineJoin = this.joinType;
		if ((k && l.lineWidth >= k) || (d && l.lineWidth >= d)) {
			l.strokeStyle = e
		}
		this.setShadow(true)
	};
	this.drawShapeDraw = function(d, c) {
		var b = this.getCanvasContext();
		if (d && d.length > 1) {
			var a = d.shift();
			while (a[0] == null || a[1] == null) {
				a = d.shift()
			}
			b.beginPath();
			b.moveTo(a[0] + 0.5, a[1] + 0.5);
			while (d.length > 0) {
				a = d.shift();
				while (a[0] == null || a[1] == null) {
					a = d.shift()
				}
				b.lineTo(a[0] + 0.5, a[1] + 0.5)
			}
			if (!c) {
				b.closePath()
			}
		}
	};
	this.drawShapeFillStroke = function(b, d, c) {
		var a = this.getCanvasContext();
		if (c && c == "open") {
			a.stroke()
		} else {
			if (d == b || a.strokeStyle == a.fillStyle) {
				a.fill()
			} else {
				a.fill();
				a.stroke()
			}
		}
	};
	this.drawShapeRestore = function(a, d, c) {
		var b = this.getCanvasContext();
		this.setShadow(false);
		if (c) {
			this.rotateCanvas(-c)
		}
		this.translateCanvas(-a, -d);
		this.restoreCanvas()
	};
	this.getShapeArea = function(v, m, l, n, G, H, D, C, B, k, L, M, A, I, q, J) {
		var j = this;
		var F = function(d) {
			d.shift();
			var b = ["poly"];
			var f = Math.cos(B);
			var c = Math.sin(B);
			for (var e = 0; e < d.length; e += 2) {
				b.push((f * (m - d[e])) + (c * (l - d[e + 1])) + d[e]);
				b.push((f * (l - d[e + 1])) - (c * (m - d[e])) + d[e + 1])
			}
			return b
		};
		var g, a;
		var N = ["poly"];
		var K = [];
		if (!M) {
			M = this.setClipBoundaries()
		}
		switch (v) {
			case "arc2":
				K = this.traceArc(m, l, G, A, I, true);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				K = this.traceArc(m, l, G - n, A, I);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				break;
			case "pie":
				N.push(m, l);
				K = this.traceArc(m, l, G, A, I, true);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				break;
			case "confidence":
				for (var E = 0; E < m.length; E++) {
					N.push(m[E][0], l[E][0]);
					K.push(l[E][1], m[E][1])
				}
				N = N.concat(K.reverse());
				break;
			case "violin":
				for (var E = 0; E < m[0].length; E++) {
					N.push(m[0][E], l[0][E]);
					K.push(l[1][E], m[1][E])
				}
				N = N.concat(K.reverse());
				break;
			case "bezier":
				K = this.traceBezierCurve(m[0], l[0], m[1], l[1], m[2], l[2], m[3], l[3], 0.25, true);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				K = this.traceBezierCurve(m[0], l[0] + G, m[1], l[1] + G, m[2], l[2] + G, m[3], l[3] + G, 0.25);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				break;
			case "arch":
				K = this.traceQuadraticCurve(m[0], l[0], m[1], l[1], m[2], l[2], 0.25, true);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				K = this.traceArc(m[4], l[4], G, n[2], n[3]);
				for (var E = 1; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				if (m[0] == m[3] && l[0] == l[3] && m[1] == m[4] && l[1] == l[4] && m[2] == m[5] && l[2] == l[5]) {
					break
				}
				K = this.traceQuadraticCurve(m[3], l[3], m[4], l[4], m[5], l[5], 0.25, true);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				K = this.traceArc(m[1], l[1], G, n[0], n[1]);
				for (var E = 0; E < K.length; E++) {
					N.push(K[E][0], K[E][1])
				}
				break;
			case "polygon":
			case "path":
			case "spline":
			case "hull":
				for (var E = 0; E < m.length; E++) {
					if (v == "spline") {
						N.push(m[E], l[E] - 2);
						K.push(l[E] + 2, m[E])
					} else {
						N.push(m[E], l[E])
					}
				}
				break;
			default:
				g = n / 2;
				a = G / 2;
				break
		}
		switch (v) {
			case "image":
				N = ["rect", m - (g * this.zoom), l - (a * this.zoom), m + (g * this.zoom), l + (a * this.zoom)];
				break;
			case "mdavid":
			case "star":
			case "circle":
			case "sphere":
				N = ["circle", m, l, n];
				break;
			case "diamond":
			case "rhombus":
				N = ["poly", m, l - a, m + g, l, m, l + a, m - g, l];
				break;
			case "box":
			case "rect":
			case "rectangle":
			case "roundrect":
			case "square":
			case "hexagon":
			case "octagon":
			case "oval":
			case "arc":
			case "arc3":
			case "ellipse":
			case "plus":
			case "minus":
				N = ["rect", m - g, l - a, m + g, l + a];
				break;
			case "rect2":
				return this.getShapeArea("rectangle", m, l, n, n / 2, H, D, C, B, k, L, M, A, I, q, J);
			case "rect3":
				return this.getShapeArea("rectangle", m, l, n, n / 3, H, D, C, B, k, L, M, A, I, q, J);
			case "triangle":
			case "equilateral":
				N = ["poly", m, l - a, m + g, l + a, m - g, l + a];
				break;
			case "triangle2":
			case "equilateral2":
				N = ["poly", m, l + a, m + g, l - a, m - g, l - a];
				break;
			case "oval2":
				return this.getShapeArea("oval", m, l, n, n / 2, H, D, C, B, k, L, M, A, I, q, J);
			case "oval3":
				return this.getShapeArea("oval", m, l, n, n / 3, H, D, C, B, k, L, M, A, I, q, J);
			case "ellipse2":
				return this.getShapeArea("ellipse", m, l, n, n / 2, H, D, C, B, k, L, M, A, I, q, J);
			case "ellipse3":
				return this.getShapeArea("ellipse", m, l, n, n / 3, H, D, C, B, k, L, M, A, I, q, J);
			case "pie0":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI / 5, q, J);
			case "pie1":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI / 3.5, q, J);
			case "pie2":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI / 2, q, J);
			case "pie3":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI / 1.5, q, J);
			case "pie4":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI, q, J);
			case "pie5":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI * 1.2, q, J);
			case "pie6":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI * 1.4, q, J);
			case "pie7":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI * 1.6, q, J);
			case "pie8":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI * 1.8, q, J);
			case "pie9":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, 0, Math.PI * 2, q, J);
			case "pacman":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, Math.PI * 1 / 4, Math.PI * 7 / 4, q, J);
			case "pacman2":
				return this.getShapeArea("pie", m, l, n, n / 2, H, D, C, B, k, L, M, Math.PI * 5 / 4, Math.PI * 3 / 4, q, J)
		}
		N = B ? F(N) : N;
		if (this.graphType == "Network") {
			return this.preScaleNetwork && !this.isAnimation ? N : this.adjustNetworkObjects(N)
		} else {
			return N
		}
	};
	this.drawShape = function(U, P, O, R, ai, aj, Z, Y, W, N, ao, aq, V, al, S, am) {
		this.functionCallerDraw = "drawShape";
		var M, ap, j, ar, X, ac;
		var I = this.getCanvasContext();
		if (Y) {
			switch (Y) {
				case "closed":
				case "solid":
				case "open":
					break;
				default:
					var at = Y;
					Y = "closed";
					this.drawShape(U, P, O, R, ai, aj, aj, Y, W, N, ao, aq, V, al, S, am);
					Y = at;
					break
			}
		}
		switch (U) {
			case "polygon":
			case "path":
			case "spline":
			case "arch":
			case "hull":
			case "confidence":
			case "violin":
			case "bezier":
				var ae = Number.MAX_VALUE;
				var L = Number.MAX_VALUE * -1;
				var ad = Number.MAX_VALUE;
				var J = Number.MAX_VALUE * -1;
				ap = [];
				M = [];
				if (P.length == O.length) {
					if (U == "spline" && P.length < 5) {
						return this.drawShape("polygon", P, O, R, ai, aj, Z, Y, W, N, ao, aq, V, al, S, am)
					}
					if (U == "arch" && (P.length != 6 || O.length != 6 || R.length != 4 || ai == null)) {
						return false
					}
					if (U == "bezier") {
						if (this.isNumeric(P) && this.isNumeric(O) && this.isNumeric(ai)) {
							for (var ah = 0; ah < P.length; ah++) {
								ae = Math.min(ae, P[ah]);
								L = Math.max(L, P[ah]);
								ad = Math.min(ad, O[ah]);
								J = Math.max(J, O[ah]);
								M.push([P[ah], O[ah]])
							}
							P = (ae + L) / 2;
							O = (ad + J) / 2;
							for (var ah = 0; ah < M.length; ah++) {
								M[ah][0] -= P;
								M[ah][1] -= O;
								ap.push(M[ah][0], M[ah][1])
							}
						} else {
							return false
						}
					} else {
						if (U == "confidence") {
							for (var ah = 0; ah < P.length; ah++) {
								if (P[ah][0] != null && P[ah][1] != null && O[ah][0] != null && O[ah][1] != null && this.isNumeric([P[ah][0], P[ah][1], O[ah][0], O[ah][1]])) {
									ae = Math.min(ae, Math.min(P[ah][0], P[ah][1]));
									L = Math.max(L, Math.max(P[ah][0], P[ah][1]));
									ad = Math.min(ad, Math.min(O[ah][0], O[ah][1]));
									J = Math.max(J, Math.max(O[ah][0], O[ah][1]));
									M.push([
										[P[ah][0], P[ah][1]],
										[O[ah][0], O[ah][1]]
									])
								}
							}
							P = (ae + L) / 2;
							O = (ad + J) / 2;
							for (var ah = 0; ah < M.length; ah++) {
								M[ah][0][0] -= P;
								M[ah][0][1] -= P;
								M[ah][1][0] -= O;
								M[ah][1][1] -= O;
								ap.push([M[ah][0][0], M[ah][0][1]], [M[ah][1][0], M[ah][1][1]])
							}
						} else {
							if (U == "violin") {
								if (P[0].length == O[0].length && P[1].length == O[1].length && P[0].length == P[1].length) {
									for (var ah = 0; ah < P[0].length; ah++) {
										if (this.isNumeric([P[0][ah], P[1][ah], O[0][ah], O[1][ah]])) {
											ae = Math.min(ae, Math.min(P[0][ah], P[1][ah]));
											L = Math.max(L, Math.max(P[0][ah], P[1][ah]));
											ad = Math.min(ad, Math.min(O[0][ah], O[1][ah]));
											J = Math.max(J, Math.max(O[0][ah], O[1][ah]));
											M.push([
												[P[0][ah], P[1][ah]],
												[O[0][ah], O[1][ah]]
											])
										}
									}
									P = (ae + L) / 2;
									O = (ad + J) / 2;
									for (var ah = 0; ah < M.length; ah++) {
										M[ah][0][0] -= P;
										M[ah][0][1] -= P;
										M[ah][1][0] -= O;
										M[ah][1][1] -= O;
										ap.push([M[ah][0][0], M[ah][0][1]], [M[ah][1][0], M[ah][1][1]])
									}
								} else {
									return false
								}
							} else {
								for (var ah = 0; ah < P.length; ah++) {
									if (P[ah] && O[ah] && this.isNumeric([P[ah], O[ah]])) {
										ae = Math.min(ae, P[ah]);
										L = Math.max(L, P[ah]);
										ad = Math.min(ad, O[ah]);
										J = Math.max(J, O[ah]);
										M.push([P[ah], O[ah]])
									}
								}
								P = U == "arch" ? P[1] : (ae + L) / 2;
								O = U == "arch" ? O[1] : (ad + J) / 2;
								for (var ah = 0; ah < M.length; ah++) {
									M[ah][0] -= P;
									M[ah][1] -= O;
									ap.push(M[ah][0], M[ah][1])
								}
							}
						}
					}
				} else {
					return false
				}
				break;
			default:
				if (this.isNumeric([P, O, R, ai])) {
					if (ao) {
						M = this.clip(U, [P, O, R, ai], aq);
						if (M) {
							if (M.length == 4) {
								R = Math.max(1, M[2]);
								ai = Math.max(1, M[3]);
								P = M[0] + (R / 2);
								O = M[1] + (ai / 2)
							} else {
								if (M.length == 2) {
									P = M[0];
									O = M[1]
								}
							}
						} else {
							return false
						}
					} else {
						R = Math.max(1, R);
						ai = Math.max(1, ai)
					}
					j = R / 2;
					ar = ai / 2;
					X = ai / R;
					ac = 1.5
				} else {
					return false
				}
				break
		}
		switch (U) {
			case "image":
				if (S && (CanvasXpress.cacheImages[this.getFileName(S)] || CanvasXpress.images[S])) {
					this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
					if (CanvasXpress.images[S]) {
						this.drawImage(CanvasXpress.images[S], -j * this.zoom, -ar * this.zoom, R * this.zoom, ai * this.zoom)
					} else {
						this.drawImage(CanvasXpress.cacheImages[this.getFileName(S)], -j * this.zoom, -ar * this.zoom, R * this.zoom, ai * this.zoom)
					}
				} else {
					return this.drawShape("rectangle", P, O, R, ai, "rgba(0,0,0,0.5)", "rgba(0,0,0,0.5)", Y, W, N, ao, aq, V, al, S, am)
				}
				break;
			case "circle":
			case "sphere":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				if (!this.isColorTransparent(aj) || !this.isColorTransparent(Z)) {
					I.beginPath();
					I.arc(0, 0, R / 2, 0, Math.PI * 2, true);
					I.closePath();
					this.drawShapeFillStroke(aj, Z, Y)
				}
				break;
			case "box":
			case "rect":
			case "rectangle":
				M = [
					[-j, -ar],
					[j, -ar],
					[j, ar],
					[-j, ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				j = j + 0.5;
				ar = ar + 0.5;
				I.beginPath();
				I.moveTo(-j, -ar);
				I.lineTo(j, -ar);
				I.lineTo(j, ar);
				I.lineTo(-j, ar);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "rect2":
				return this.drawShape("rectangle", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "rect3":
				return this.drawShape("rectangle", P, O, R, R / 3, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "roundrect":
				var Q = R > ai ? ai / 4 : R / 4;
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(-j, -ar + Q);
				I.lineTo(-j, ar - Q);
				I.quadraticCurveTo(-j, ar, -j + Q, ar);
				I.lineTo(j - Q, ar);
				I.quadraticCurveTo(j, ar, j, ar - Q);
				I.lineTo(j, -ar + Q);
				I.quadraticCurveTo(j, -ar, j - Q, -ar);
				I.lineTo(-j + Q, -ar);
				I.quadraticCurveTo(-j, -ar, -j, -ar + Q);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "square":
				M = [
					[-j, -j],
					[j, -j],
					[j, j],
					[-j, j]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "triangle":
				if (R == ai) {
					return this.drawShape("equilateral", P, O, R, ai, aj, Z, Y, W, N, ao, aq, V, al, S, am)
				}
				M = [
					[0, -ar],
					[j, ar],
					[-j, ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "triangle2":
				if (R == ai) {
					return this.drawShape("equilateral2", P, O, R, ai, aj, Z, Y, W, N, ao, aq, V, al, S, am)
				}
				M = [
					[0, ar],
					[j, -ar],
					[-j, -ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "equilateral":
				var Q = R * Math.sqrt(3) / 6;
				var g = Q / 2;
				var C = Math.sqrt((Q * Q) - (g * g));
				M = [
					[0, -ar],
					[j, ar],
					[-j, ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "equilateral2":
				var Q = R * Math.sqrt(3) / 6;
				var g = Q / 2;
				var C = Math.sqrt((Q * Q) - (g * g));
				M = [
					[0, ar],
					[j, -ar],
					[-j, -ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "diamond":
			case "rhombus":
				M = [
					[0, -ar],
					[j, 0],
					[0, ar],
					[-j, 0]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "hexagon":
				var an = R / 3;
				var q = an - j;
				M = [
					[q, -ar],
					[-q, -ar],
					[j, 0],
					[-q, ar],
					[q, ar],
					[-j, 0]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "octagon":
				var au = R / 4;
				var ag = ai / 4;
				M = [
					[-au, -ar],
					[au, -ar],
					[j, -ag],
					[j, ag],
					[au, ar],
					[-au, ar],
					[-j, ag],
					[-j, -ag]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "oval":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.saveCanvas();
				this.scaleCanvas(1, X);
				I.beginPath();
				I.arc(0, 0, R / 2, 0, Math.PI * 2, true);
				I.closePath();
				this.restoreCanvas();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "oval2":
				return this.drawShape("oval", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "oval3":
				return this.drawShape("oval", P, O, R, R / 3, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "arc":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.saveCanvas();
				this.scaleCanvas(1, X);
				I.beginPath();
				I.arc(0, 0, R / 2, 0, Math.PI, true);
				if (Y != "open") {
					I.closePath()
				}
				this.restoreCanvas();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "arc2":
				var E = ai * Math.cos(V);
				var ax = ai * Math.sin(V);
				var D = ai * Math.cos(al);
				var av = ai * Math.sin(al);
				var B = this.shortenLine(0, 0, E, ax, 0, R, "line");
				var v = this.shortenLine(0, 0, D, av, 0, R, "line");
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(B[2], B[3]);
				I.lineTo(E, ax);
				I.arc(0, 0, ai, V, al, false);
				I.lineTo(v[2], v[3]);
				I.arc(0, 0, ai - R, al, V, true);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "arc3":
				Y = "open";
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.arc(0, 0, R, V, al, false);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "arch":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(M[0][0], M[0][1]);
				I.quadraticCurveTo(M[1][0], M[1][1], M[2][0], M[2][1]);
				I.arc(0, 0, ai, R[3], R[2], true);
				I.quadraticCurveTo(M[4][0], M[4][1], M[5][0], M[5][1]);
				I.arc(0, 0, ai, R[1], R[0], true);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "path":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M, open);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "polygon":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "spline":
				var T = [];
				var ab = [];
				var F = [];
				ab.push(ap.shift());
				ab.push(ap.shift());
				F.push(ap.pop());
				F.unshift(ap.pop());
				var aa = ap.length;
				for (var ah = 0; ah < aa - 4; ah += 2) {
					T = T.concat(this.splineControlPoint(ap[ah], ap[ah + 1], ap[ah + 2], ap[ah + 3], ap[ah + 4], ap[ah + 5]))
				}
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(ab[0], ab[1]);
				I.lineTo(ap[0], ap[1]);
				I.quadraticCurveTo(T[0], T[1], ap[2], ap[3]);
				for (var ah = 2; ah < aa - 5; ah += 2) {
					I.bezierCurveTo(T[2 * ah - 2], T[2 * ah - 1], T[2 * ah], T[2 * ah + 1], ap[ah + 2], ap[ah + 3])
				}
				I.quadraticCurveTo(T[2 * aa - 10], T[2 * aa - 9], ap[aa - 2], ap[aa - 1]);
				I.lineTo(F[0], F[1]);
				I.lineTo(ab[0], ab[1]);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "hull":
				var af;
				var aa = 1;
				var G = [];
				while (ap.length > 1) {
					G.push([ap.shift(), ap.shift()])
				}
				var T = this.hullControlPoints(G);
				var m = [
					[G[0][0], G[0][1], T[T.length - 1][0], T[T.length - 1][1], T[0][0], T[0][1], G[1][0], G[1][1]]
				];
				for (var ah = 1; ah < G.length - 1; ah++) {
					m.push([G[ah][0], G[ah][1], T[aa][0], T[aa][1], T[aa + 1][0], T[aa + 1][1], G[ah + 1][0], G[ah + 1][1]]);
					aa += 2
				}
				m.push([G[ah][0], G[ah][1], T[aa][0], T[aa][1], T[aa + 1][0], T[aa + 1][1], G[0][0], G[0][1]]);
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(m[0][0], m[0][1]);
				for (var ah = 0; ah < m.length; ah++) {
					I.bezierCurveTo(m[ah][2], m[ah][3], m[ah][4], m[ah][5], m[ah][6], m[ah][7])
				}
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "violin":
				var aa = ap.length;
				var T = [];
				var K = [];
				for (var ah = 0; ah < aa - 4; ah += 2) {
					var aw = (aa - 1) - ah;
					T = T.concat(this.splineControlPoint(ap[ah][0], ap[ah + 1][0], ap[ah + 2][0], ap[ah + 3][0], ap[ah + 4][0], ap[ah + 5][0]));
					K = K.concat(this.splineControlPoint(ap[aw - 1][1], ap[aw][1], ap[aw - 3][1], ap[aw - 2][1], ap[aw - 5][1], ap[aw - 4][1]))
				}
				if (this.graphOrientation == "vertical") {
					for (var ah = 0; ah < T.length - 1; ah += 2) {
						if (T[ah] > 0) {
							T[ah] = 0
						}
						if (K[ah] < 0) {
							K[ah] = 0
						}
					}
				} else {
					for (var ah = 1; ah < T.length; ah += 2) {
						if (T[ah] > 0) {
							T[ah] = 0
						}
						if (K[ah] < 0) {
							K[ah] = 0
						}
					}
				}
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(ap[0][0], ap[1][0]);
				I.quadraticCurveTo(T[0], T[1], ap[2][0], ap[3][0]);
				for (var ah = 2; ah < aa - 5; ah += 2) {
					I.bezierCurveTo(T[2 * ah - 2], T[2 * ah - 1], T[2 * ah], T[2 * ah + 1], ap[ah + 2][0], ap[ah + 3][0])
				}
				I.quadraticCurveTo(T[2 * aa - 10], T[2 * aa - 9], ap[aa - 2][0], ap[aa - 1][0]);
				I.lineTo(ap[aa - 2][1], ap[aa - 1][1]);
				I.quadraticCurveTo(K[0], K[1], ap[aa - 4][1], ap[aa - 3][1]);
				for (var ah = 2; ah < aa - 5; ah += 2) {
					var aw = (aa - 1) - ah;
					I.bezierCurveTo(K[2 * ah - 2], K[2 * ah - 1], K[2 * ah], K[2 * ah + 1], ap[aw - 3][1], ap[aw - 2][1])
				}
				I.quadraticCurveTo(K[2 * aa - 10], K[2 * aa - 9], ap[0][1], ap[1][1]);
				I.lineTo(ap[0][0], ap[1][0]);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "confidence":
				var aa = ap.length;
				var T = [];
				var K = [];
				for (var ah = 0; ah < aa - 4; ah += 2) {
					var aw = (aa - 1) - ah;
					T = T.concat(this.splineControlPoint(ap[ah][0], ap[ah + 1][0], ap[ah + 2][0], ap[ah + 3][0], ap[ah + 4][0], ap[ah + 5][0]));
					K = K.concat(this.splineControlPoint(ap[aw - 1][1], ap[aw][1], ap[aw - 3][1], ap[aw - 2][1], ap[aw - 5][1], ap[aw - 4][1]))
				}
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(ap[0][0], ap[1][0]);
				I.quadraticCurveTo(T[0], T[1], ap[2][0], ap[3][0]);
				for (var ah = 2; ah < aa - 5; ah += 2) {
					I.bezierCurveTo(T[2 * ah - 2], T[2 * ah - 1], T[2 * ah], T[2 * ah + 1], ap[ah + 2][0], ap[ah + 3][0])
				}
				I.quadraticCurveTo(T[2 * aa - 10], T[2 * aa - 9], ap[aa - 2][0], ap[aa - 1][0]);
				I.lineTo(ap[aa - 2][1], ap[aa - 1][1]);
				I.quadraticCurveTo(K[0], K[1], ap[aa - 4][1], ap[aa - 3][1]);
				for (var ah = 2; ah < aa - 5; ah += 2) {
					var aw = (aa - 1) - ah;
					I.bezierCurveTo(K[2 * ah - 2], K[2 * ah - 1], K[2 * ah], K[2 * ah + 1], ap[aw - 3][1], ap[aw - 2][1])
				}
				I.quadraticCurveTo(K[2 * aa - 10], K[2 * aa - 9], ap[0][1], ap[1][1]);
				I.lineTo(ap[0][0], ap[1][0]);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "bezier":
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(ap[0], ap[1]);
				I.bezierCurveTo(ap[2], ap[3], ap[4], ap[5], ap[6], ap[7]);
				I.lineTo(ap[6], ap[7] + ai);
				I.bezierCurveTo(ap[4], ap[5] + ai, ap[2], ap[3] + ai, ap[0], ap[1] + ai);
				I.lineTo(ap[0], ap[1]);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "ellipse":
				var a = j * 0.5522848;
				var ak = ar * 0.5522848;
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.moveTo(0, ar);
				I.bezierCurveTo(0, ar - ak, j - a, 0, j, 0);
				I.bezierCurveTo(j + a, 0, R, ar - ak, R, ar);
				I.bezierCurveTo(R, ar + ak, j + a, ai, j, ai);
				I.bezierCurveTo(j - a, ai, 0, ar + ak, 0, ar);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "ellipse2":
				return this.drawShape("ellipse", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "ellipse3":
				return this.drawShape("ellipse", P, O, R, R / 3, aj, Z, Y, W, N, ao, aq, V, al, S, am);
				break;
			case "plus":
				M = [
					[-ac, -ar],
					[ac, -ar],
					[ac, -ac],
					[j, -ac],
					[j, ac],
					[ac, ac],
					[ac, ar],
					[-ac, ar],
					[-ac, ac],
					[-j, ac],
					[-j, -ac],
					[-ac, -ac],
					[-ac, -ar]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "minus":
				M = [
					[-j, -ac],
					[j, -ac],
					[j, ac],
					[-j, ac],
					[-j, -ac]
				];
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "mdavid":
				var an = R / 3;
				var A = Math.PI / 6;
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.saveCanvas();
				this.scaleCanvas(0.8, 0.8);
				this.rotateCanvas(H * 0.45);
				I.beginPath();
				I.moveTo(an, 0);
				for (var ah = 0; ah < 11; ah++) {
					this.rotateCanvas(A);
					if (ah % 2 == 0) {
						I.lineTo((an / 0.55), 0)
					} else {
						I.lineTo(an, 0)
					}
				}
				I.closePath();
				this.restoreCanvas();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "star":
				var k = (R / 4);
				var H = Math.PI / 5;
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				this.saveCanvas();
				this.scaleCanvas(0.7, 0.7);
				this.rotateCanvas(H * 0.45);
				I.beginPath();
				I.moveTo(k, 0);
				for (var ah = 0; ah < 9; ah++) {
					this.rotateCanvas(H);
					if (ah % 2 == 0) {
						I.lineTo((k / 0.35), 0)
					} else {
						I.lineTo(k, 0)
					}
				}
				I.closePath();
				this.restoreCanvas();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "pie":
				if (typeof(V) == "undefined") {
					V = 0
				}
				if (typeof(al) == "undefined") {
					al = Math.PI * 2
				}
				this.drawShapeSetShapeStyle(P, O, R, ai, aj, Z, Y, W, N);
				I.beginPath();
				I.arc(0, 0, R / 2, V, al, false);
				I.lineTo(0, 0);
				I.closePath();
				this.drawShapeFillStroke(aj, Z, Y);
				break;
			case "pie0":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI / 5, S, am);
				break;
			case "pie1":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI / 3.5, S, am);
				break;
			case "pie2":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI / 2, S, am);
				break;
			case "pie3":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI / 1.5, S, am);
				break;
			case "pie4":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI, S, am);
				break;
			case "pie5":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI * 1.2, S, am);
				break;
			case "pie6":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI * 1.4, S, am);
				break;
			case "pie7":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI * 1.6, S, am);
				break;
			case "pie8":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI * 1.8, S, am);
				break;
			case "pie9":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, 0, Math.PI * 2, S, am);
				break;
			case "pacman":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, Math.PI * 1 / 4, Math.PI * 7 / 4, S, am);
				break;
			case "pacman2":
				return this.drawShape("pie", P, O, R, R / 2, aj, Z, Y, W, N, ao, aq, Math.PI * 5 / 4, Math.PI * 3 / 4, S, am);
				break
		}
		this.drawShapeRestore(P, O, W)
	};
	this.drawImage = function(b, a, j, g, c, m) {
		var k = this.getCanvasContext();
		try {
			k.drawImage(b, a, j, g, c)
		} catch (f) {
			var d = this;
			setTimeout(function() {
				d.draw()
			}, 100)
		}
	};
	this.drawVideo = function(c, b, d) {
		var e = this;
		var a = this.getCanvasContext();
		if (c.paused || c.ended) {
			return false
		}
		a.drawImage(c, 0, 0, b, d);
		this.videoUpdate();
		setTimeout(function() {
			e.drawVideo(c, b, d)
		}, 50)
	};
	this.setGlobalCompositionOperation = function(b) {
		if (!this.meta.system.isIE && b) {
			var a = this.getCanvasContext();
			a.globalCompositeOperation = b;
			this.meta.state.globalCompositeOperation = b
		}
	};
	this.rectangleClear = function(a, e, c, d) {
		var b = this.getCanvasContext();
		b.clearRect(a, e, c, d)
	};
	this.translateCanvas = function(a, c) {
		var b = this.getCanvasContext();
		b.translate(a, c);
		this.meta.state.translate[0] += a;
		this.meta.state.translate[1] += c
	};
	this.rotateCanvas = function(b) {
		var a = this.getCanvasContext();
		a.rotate(b);
		this.meta.state.rotate[0] += b
	};
	this.scaleCanvas = function(a, c) {
		var b = this.getCanvasContext();
		b.scale(a, c);
		this.meta.state.scale[0] *= a;
		this.meta.state.scale[1] *= c
	};
	this.saveCanvas = function() {
		var a = this.getCanvasContext();
		a.save();
		this.meta.state.save++
	};
	this.restoreCanvas = function() {
		var a = this.getCanvasContext();
		a.restore();
		this.meta.state.save--
	};
	this.setLineTypes = function() {
		var e = ["line"];
		var c = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
		var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
		for (var d = 0; d < a.length; d++) {
			e.push(a[d] + "Line")
		}
		for (var d = 1; d < c.length; d++) {
			for (var b = 0; b < a.length; b++) {
				e.push(c[d] + this.capitalize(a[b]) + "Line")
			}
		}
		this.lines = e
	};
	this.setAmbiguityCodes = function() {
		this.ambiguityCodes = {
			"-": ["-"],
			A: ["A"],
			C: ["C"],
			G: ["G"],
			T: ["T"],
			M: ["A", "C"],
			R: ["A", "G"],
			W: ["A", "T"],
			S: ["C", "G"],
			Y: ["C", "T"],
			K: ["G", "T"],
			V: ["A", "C", "G"],
			H: ["A", "C", "T"],
			D: ["A", "G", "T"],
			B: ["C", "G", "T"],
			N: ["A", "C", "G", "T"],
			X: ["A", "C", "G", "T"]
		}
	};
	this.setCodonTable = function() {
		this.codon = {
			TTT: ["F", "Phe", "Phenylalanine"],
			TCT: ["S", "Ser", "Serine"],
			TAT: ["Y", "Tyr", "Tyrosine"],
			TGT: ["C", "Cys", "Cysteine"],
			TTC: ["F", "Phe", "Phenylalanine"],
			TCC: ["S", "Ser", "Serine"],
			TAC: ["Y", "Tyr", "Tyrosine"],
			TGC: ["C", "Cys", "Cysteine"],
			TTA: ["L", "Leu", "Leucine"],
			TCA: ["S", "Ser", "Serine"],
			TAA: ["*", "Stop", "Ochre"],
			TGA: ["*", "Stop", "Opal"],
			TTG: ["L", "Leu", "Leucine"],
			TCG: ["S", "Ser", "Serine"],
			TAG: ["*", "Stop", "Amber"],
			TGG: ["W", "Trp", "Tryptophan"],
			CTT: ["L", "Leu", "Leucine"],
			CCT: ["P", "Pro", "Proline"],
			CAT: ["H", "His", "Histidine"],
			CGT: ["R", "Arg", "Arginine"],
			CTC: ["L", "Leu", "Leucine"],
			CCC: ["P", "Pro", "Proline"],
			CAC: ["H", "His", "Histidine"],
			CGC: ["R", "Arg", "Arginine"],
			CTA: ["L", "Leu", "Leucine"],
			CCA: ["P", "Pro", "Proline"],
			CAA: ["Q", "Gln", "Glutamine"],
			CGA: ["R", "Arg", "Arginine"],
			CTG: ["L", "Leu", "Leucine"],
			CCG: ["P", "Pro", "Proline"],
			CAG: ["Q", "Gln", "Glutamine"],
			CGG: ["R", "Arg", "Arginine"],
			ATT: ["I", "Ile", "Isoleucine"],
			ACT: ["T", "Thr", "Threonine"],
			AAT: ["N", "Asn", "Asparagine"],
			AGT: ["S", "Ser", "Serine"],
			ATC: ["I", "Ile", "Isoleucine"],
			ACC: ["T", "Thr", "Threonine"],
			AAC: ["N", "Asn", "Asparagine"],
			AGC: ["S", "Ser", "Serine"],
			ATA: ["I", "Ile", "Isoleucine"],
			ACA: ["T", "Thr", "Threonine"],
			AAA: ["K", "Lys", "Lysine"],
			AGA: ["R", "Arg", "Arginine"],
			ATG: ["M", "Met", "Methionine"],
			ACG: ["T", "Thr", "Threonine"],
			AAG: ["K", "Lys", "Lysine"],
			AGG: ["R", "Arg", "Arginine"],
			GTT: ["V", "Val", "Valine"],
			GCT: ["A", "Ala", "Alanine"],
			GAT: ["D", "Asp", "Aspartic acid"],
			GGT: ["G", "Gly", "Glycine"],
			GTC: ["V", "Val", "Valine"],
			GCC: ["A", "Ala", "Alanine"],
			GAC: ["D", "Asp", "Aspartic acid"],
			GGC: ["G", "Gly", "Glycine"],
			GTA: ["V", "Val", "Valine"],
			GCA: ["A", "Ala", "Alanine"],
			GAA: ["E", "Glu", "Glutamic acid"],
			GGA: ["G", "Gly", "Glycine"],
			GTG: ["V", "Val", "Valine"],
			GCG: ["A", "Ala", "Alanine"],
			GAG: ["E", "Glu", "Glutamic acid"],
			GGG: ["G", "Gly", "Glycine"]
		}
	};
	this.setReverseComplement = function() {
		this.reverseComplement = {
			A: "T",
			C: "G",
			G: "C",
			T: "A",
			U: "A",
			Y: "R",
			R: "Y",
			W: "W",
			S: "S",
			K: "M",
			M: "K",
			B: "V",
			V: "B",
			D: "H",
			H: "D",
			X: "X",
			N: "N",
			a: "t",
			c: "g",
			g: "c",
			t: "a",
			u: "a",
			y: "r",
			r: "y",
			w: "w",
			s: "s",
			k: "m",
			m: "k",
			b: "v",
			v: "b",
			d: "h",
			h: "d",
			x: "x",
			n: "n",
			" ": " ",
			"-": "-",
			"/": "/",
			"[": "[",
			"]": "]"
		}
	};
	this.initializeAttributes = function() {
		this.setLineTypes();
		this.setCodonTable();
		this.setReverseComplement()
	};
	this.initializeAttributes()
};
CanvasXpress.prototype.initRangeAlgorithms = function() {
	this.heckbert = function(d, j, a) {
		var c = function(i, l) {
			var n;
			var o = Math.floor(Math.log(i) / Math.LN10);
			var m = i / Math.pow(10, o);
			if (l) {
				if (m < 1.5) {
					n = 1
				} else {
					if (m < 3) {
						n = 2
					} else {
						if (m < 7) {
							n = 5
						} else {
							n = 10
						}
					}
				}
			} else {
				if (m < 1) {
					n = 1
				} else {
					if (m < 2) {
						n = 2
					} else {
						if (m < 5) {
							n = 5
						} else {
							n = 10
						}
					}
				}
			}
			return n * Math.pow(10, o)
		};
		var h = [];
		var f = c(j - d, false);
		var k = c(f / (a - 1), true);
		var b = Math.floor(d / k) * k;
		var g = Math.ceil(j / k) * k;
		for (var e = b; e <= g; e += k) {
			h.push(this.correctPrecisionBug(e))
		}
		return h
	};
	this.wilkinson = function(c, g, a) {
		var b = function(z, B, A, y) {
			var u = [10, 1, 5, 2, 2.5, 3, 4, 1.5, 7, 6, 8, 9];
			var w = B - z;
			var r = A - 1;
			var o = 1 - Math.abs(A - y) / y;
			var D = w / r;
			var t = Math.floor(Math.log(D) / Math.LN10);
			var E = Math.pow(10, t);
			var p = null;
			for (var C = 0; C < u.length; C++) {
				var s = u[C] * E;
				var F = Math.floor(z / s) * s;
				var n = F + r * s;
				if (F <= z && n >= B) {
					var v = 1 - (C - (F <= 0 && n >= 0 ? 1 : 0)) / u.length;
					var q = (B - z) / (n - F);
					if (q > 0.8) {
						var x = o + v + q;
						if (p == null || x > p.score) {
							p = {
								lmin: F,
								lmax: n,
								lstep: s,
								score: x
							}
						}
					}
				}
			}
			return p
		};
		var h = [];
		var e = null;
		var j = [];
		for (var f = Math.max(Math.floor(a / 2), 2); f <= Math.ceil(6 * a); f++) {
			j.push(f)
		}
		for (var f = 0; f < j.length; f++) {
			var d = j[f];
			var l = b(c, g, d, a);
			if ((l != null && e == null) || (l && e && l.score > e.score)) {
				e = l
			}
		}
		for (var f = e.lmin; f <= e.lmax; f += e.lstep) {
			h.push(this.correctPrecisionBug(f))
		}
		return h
	};
	this.wilkinsonExtended = function(a, y, R, C) {
		var A = 2.22e-14;
		var f = function(j, g) {
			for (var c = 0; c < g.length; c++) {
				if (j == g[c]) {
					return c
				}
			}
		};
		var J = function(c, w, m, g, z, Y) {
			var k = w.length;
			var s = f(c, w);
			var Z = (g % Y < A || Y - (g % Y) < A) && g <= 0 && z >= 0 ? 1 : 0;
			return 1 - s / (k - 1) - m + Z
		};
		var K = function(s, m, g) {
			var w = m.length;
			var k = f(s, m);
			var c = 1;
			return 1 - k / (w - 1) - g + c
		};
		var h = function(c, i, j, g) {
			return 1 - 0.5 * (Math.pow(i - g, 2) + Math.pow(c - j, 2)) / Math.pow(0.1 * (i - c), 2)
		};
		var r = function(c, k, i) {
			var g = k - c;
			if (i > g) {
				var j = (i - g) / 2;
				return 1 - 0.5 * (Math.pow(j, 2) + Math.pow(j, 2)) / Math.pow(0.1 * g, 2)
			} else {
				return 1
			}
		};
		var o = function(j, c, i, s, w, q) {
			var n = (j - 1) / (q - w);
			var g = (c - 1) / (Math.max(q, s) - Math.min(i, w));
			return 2 - Math.max(n / g, g / n)
		};
		var X = function(g, c) {
			return g >= c ? 2 - (g - 1) / (c - 1) : 1
		};
		var e = [1, 5, 2, 2.5, 4, 3];
		var G = [0.25, 0.2, 0.5, 0.05];
		var P = e.length;
		var L = {
			score: -2
		};
		var H = [];
		if (a > y) {
			var l = a;
			a = y;
			y = l
		}
		if (y - a < A) {
			for (var U = 0; U <= R; U++) {
				H.push(a)
			}
			return H
		}
		var T = 1;
		while (T < Number.POSITIVE_INFINITY) {
			for (var U = 0; U < P; U++) {
				var N = e[U];
				var u = K(N, e, T);
				if ((G[0] * u + G[1] + G[2] + G[3] < L.score)) {
					T = Number.POSITIVE_INFINITY;
					break
				}
				var S = 2;
				while (S < Number.POSITIVE_INFINITY) {
					var p = X(S, R);
					if ((G[0] * u + G[1] + G[2] * p + G[3] < L.score)) {
						break
					}
					var E = (y - a) / (S + 1) / T / N;
					var F = Math.ceil(Math.log(E) / Math.LN10);
					while (F < Number.POSITIVE_INFINITY) {
						var D = T * N * Math.pow(10, F);
						var B = r(a, y, D * (S - 1));
						if ((G[0] * u + G[1] * B + G[2] * p + G[3] < L.score)) {
							break
						}
						var v = Math.floor(y / D) * T - (S - 1) * T;
						var O = Math.ceil(a / D) * T;
						if (v > O) {
							F++;
							continue
						}
						for (var x = v; x <= O; x++) {
							var t = x * (D / T);
							var M = t + D * (S - 1);
							var d = D;
							var I = J(N, e, T, t, M, d);
							var W = h(a, y, t, M);
							var V = o(S, R, a, y, t, M);
							var b = G[0] * I + G[1] * W + G[2] * V + G[3];
							if (b > L.score && (!C || (t <= a && M >= y))) {
								L = {
									lmin: t,
									lmax: M,
									lstep: d,
									score: b
								}
							}
						}
						F++
					}
					S++
				}
			}
			T++
		}
		for (var U = L.lmin; U <= L.lmax; U += L.lstep) {
			H.push(this.correctPrecisionBug(U))
		}
		return H
	};
	this.rPretty = function(o, p, r) {
		var a, e, b;
		var l = [];
		var q = Math.floor(r) - 1;
		var s = Math.floor(q % 3);
		var g = 0.75;
		var v = 1.5;
		var d = 0.5 + 1.5 * v;
		var f = p - o;
		if (f == 0 && p == 0) {
			a = 1;
			e = true;
			b = 1
		} else {
			a = Math.max(Math.abs(o), Math.abs(p));
			b = 1 + d >= 1.5 * v + 0.5 ? 1 / (1 + v) : 1.5 / 1 + d;
			e = f < (a * b * Math.max(1, q) * 1e-7 * 3)
		}
		if (e) {
			if (a > 10) {
				a = 9 + a / 10
			}
			a = a * g;
			if (s > 1) {
				a /= s
			}
		} else {
			a = f;
			if (q > 1) {
				a /= q
			}
		}
		if (a < 20 * 1e-7) {
			a = 20 * 1e-7
		}
		var c = Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
		var j = c;
		if ((2 * c) - a < v * (a - j)) {
			j = 2 * c;
			if ((5 * c) - a < d * (a - j)) {
				j = 5 * c;
				if ((10 * c) - a < v * (a - j)) {
					j = 10 * c
				}
			}
		}
		var x = Math.floor(o / j + 1e-7);
		var w = Math.ceil(p / j - 1e-7);
		while (x * j > o + (1e-7 * j)) {
			x--
		}
		while (w * j < p - (1e-7 * j)) {
			w++
		}
		var t = Math.floor(0.5 + w - x);
		if (t < s) {
			t = s - t;
			if (x >= 0) {
				w += t / 2;
				x = x - t / 2 + t % 2
			} else {
				x -= t / 2;
				w = w + t / 2 + t % 2
			}
			q = s
		} else {
			q = t
		}
		for (var u = x * j; u <= w * j; u += j) {
			l.push(this.correctPrecisionBug(u))
		}
		return l
	};
	this.getAxisDecimals1 = function(a) {
		return a === 0 ? 0 : a.toExponential().replace(/e[\+\-0-9]*$/, "").replace(/^0\.0*|\./, "").length
	};
	this.getAxisDecimals2 = function(b) {
		var a = 1000000;
		var c = (((b * a) - (parseInt(b) * a)) / a).toString().replace(/\./, "").length - 1;
		return c
	};
	this.getAxisDecimals = function(a) {
		a = this.correctPrecisionBug(a);
		var b = a === 0 || a % 1 === 0 ? 0 : a.toExponential().replace(/e[\+\-0-9]+$/, "").replace(/^0\.0+|\./, "").length;
		return Math.min(b, 20)
	}
};
CanvasXpress.prototype.initPrimitives = function() {
	this.initText();
	this.initTime();
	this.initColor();
	this.initAttributes();
	this.initRangeAlgorithms()
};
CanvasXpress.prototype.initGeneralUtils = function() {
	this.modifyObjectArray = function(b, f, g, e, h) {
		this.functionCaller = "modifyObjectArray";
		if (this.isTransition()) {
			return
		}
		var d = this[g];
		if (e) {
			var a = {};
			if (this.isArray(b)) {
				for (var c = 0; c < b.length; c++) {
					a[b[c]] = true
				}
			} else {
				a[b] = true
			}
			for (var c in a) {
				if (this.isInArray(c, d)) {
					d = this.removeFromArray(c, d);
					delete(a[c])
				}
			}
			for (var c in a) {
				d.push(c)
			}
			this[g] = d
		} else {
			if (f) {
				var a = {};
				var j = [];
				if (this.isArray(b)) {
					for (var c = 0; c < b.length; c++) {
						a[b[c]] = 1
					}
				} else {
					a[b] = 1
				}
				for (var c = 0; c < d.length; c++) {
					if (!a.hasOwnProperty(d[c])) {
						j.push(d[c])
					}
				}
				this[g] = j
			} else {
				if (this.isArray(b)) {
					for (var c = 0; c < b.length; c++) {
						d.push(b[c])
					}
				} else {
					d.push(b)
				}
			}
		}
		if (h) {
			this.draw()
		}
	};
	this.getObjectArray = function(b) {
		var d = {};
		if (b && this.isArray(b)) {
			for (var c = 0; c < b.length; c++) {
				d[b[c]] = true
			}
		}
		return d
	};
	this.isInArray = function(c, b) {
		return this.isArray(b) ? b.indexOf(c) > -1 : false
	};
	this.removeFromArray = function(e, b) {
		if (this.isArray(b)) {
			var d = [];
			for (var c = 0; c < b.length; c++) {
				if (b[c] != e) {
					d.push(b[c])
				}
			}
		}
		return d
	};
	this.isFunction = function(a) {
		var b = {};
		return a && b.toString.call(a) === "[object Function]"
	};
	this.isArray = function(a) {
		return Array.isArray(a)
	};
	this.isObject = function(a) {
		return a instanceof Object
	};
	this.isUnique = function(b) {
		return this.getUniqueEls(b).length == b.length
	};
	this.toArray = function(a) {
		return this.isArray(a) ? a : [a]
	};
	this.getKeys = function(a) {
		return this.isObject(a) ? Object.keys(a) : []
	};
	this.unique = function(a) {
		if (this.isArray(a)) {
			return this.getUniqueEls(a)
		} else {
			if (this.isObject(a)) {
				return this.getUniqueEls(this.getKeys(a))
			} else {
				return [a]
			}
		}
	};
	this.getUniqueEls = function(b) {
		return b.filter(function(a, c) {
			return b.indexOf(a) === c
		})
	};
	this.getUniqueKeys = function(a) {
		if (this.isArray(a)) {
			return this.getUniqueEls(a)
		} else {
			if (this.isObject(a)) {
				return this.getUniqueEls(this.getKeys(a))
			} else {
				return [a]
			}
		}
	};
	this.shuffleArray = function(b) {
		for (var d = b.length; d > 0; d--) {
			var c = Math.floor(this.random() * d);
			var a = b[--d];
			b[d] = b[c];
			b[c] = a
		}
		return b
	};
	this.toNumber = function(b) {
		var e = [];
		var c = this.isArray(b);
		b = this.toArray(b);
		for (var d = 0; d < b.length; d++) {
			e.push(Number(b[d]))
		}
		return c ? e : e[0]
	};
	this.cloneObject = function(b, a) {
		if (b == null || typeof(b) != "object") {
			return b
		}
		if (a && !this.isR) {
			return this.isArray(b) ? Object.assign([], b) : Object.assign({}, b)
		} else {
			return JSON.parse(JSON.stringify(b))
		}
	};
	this.isSameObject = function(d, c) {
		if (d === c) {
			return true
		}
		if (typeof(d) != "object" || typeof(c) != "object") {
			return false
		}
		return JSON.stringify(d) == JSON.stringify(c)
	};
	this.isNumber = function(a) {
		return a === null || a === undefined ? true : !isNaN(parseFloat(a)) && isFinite(a)
	};
	this.isNumeric2DArray = function(a) {
		for (var c = 0; c < a.length; c++) {
			for (var b = 0; b < a[c].length; b++) {
				if (!this.isNumber(a[c][b])) {
					return false
				}
			}
		}
		return true
	};
	this.isNumeric = function(b, a, e) {
		if (a) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var c = this.smpIndices[d];
				if (!this.isNumber(b[c])) {
					return false
				}
			}
		} else {
			if (e) {
				for (var d = 0; d < this.varIndices.length; d++) {
					var c = this.varIndices[d];
					if (!this.isNumber(b[c])) {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (!this.isNumber(b[c])) {
						return false
					}
				}
			}
		}
		return true
	};
	this.isEmpty = function(b, a, e) {
		if (a) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var c = this.smpIndices[d];
				if (b[c] != "") {
					return false
				}
			}
		} else {
			if (e) {
				for (var d = 0; d < this.varIndices.length; d++) {
					var c = this.varIndices[d];
					if (b[c] != "") {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (b[c] != "") {
						return false
					}
				}
			}
		}
		return true
	};
	this.isDate = function(b, a, f) {
		var d = function(g) {
			if (toString.call(g) === "[object Date]") {
				return true
			}
			if (typeof g.replace === "function") {
				g.replace(/^\s+|\s+$/gm, "")
			}
			var h = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/;
			return h.test(g)
		};
		if (a) {
			for (var e = 0; e < this.smpIndices.length; e++) {
				var c = this.smpIndices[e];
				if (b[c] && !d(b[c])) {
					return false
				}
			}
		} else {
			if (f) {
				for (var e = 0; e < this.varIndices.length; e++) {
					var c = this.varIndices[e];
					if (b[c] && !d(b[c])) {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (b[c] && !d(b[c])) {
						return false
					}
				}
			}
		}
		return true
	};
	this.padNumber = function(b, a) {
		if (!a) {
			a = 4
		}
		b = b + "";
		return b.length >= a ? b : new Array(a - b.length + 1).join("0") + b
	};
	this.isPivotable = function() {
		var b = this.data.y.vars.length;
		var c = this.data.x ? this.getKeys(this.data.x) : [];
		var a = c.length;
		return b + a == 3
	};
	this.pivotMatrix = function(h, f, k, c) {
		var a = {};
		var e = [];
		var d = [];
		for (var b = 0; b < h.length; b++) {
			if (!a[h[b][f]]) {
				a[h[b][f]] = {}
			}
			a[h[b][f]][h[b][k]] = h[b][c];
			if (e.indexOf(h[b][k]) == -1) {
				e.push(h[b][k])
			}
		}
		e = this.stringRangeSort(e);
		var j = [];
		j.push("Vars");
		j.push.apply(j, e);
		d.push(j);
		for (var g in a) {
			j = [];
			j.push(g);
			for (var b = 0; b < e.length; b++) {
				j.push(a[g][e[b]] || "")
			}
			d.push(j)
		}
		return d
	};
	this.transposeMatrix = function(a) {
		return a[0].map(function(b, d) {
			return a.map(function(c) {
				return c[d]
			})
		})
	};
	this.filterNumbers = function(a) {
		var c = [];
		for (var b = 0; b < a.length; b++) {
			if (this.isNumber(a[b])) {
				c.push(a[b])
			}
		}
		return c
	};
	this.cleanArray = function(b, a, e) {
		var d = [];
		if (a) {
			for (var c = 0; c < this.smpIndices.length; c++) {
				d.push(b[this.smpIndices[c]])
			}
			d = this.filterNumbers(d)
		} else {
			if (e) {
				for (var c = 0; c < this.varIndices.length; c++) {
					d.push(b[this.varIndices[c]])
				}
				d = this.filterNumbers(d)
			} else {
				d = this.filterNumbers(b)
			}
		}
		return d
	};
	this.cleanArrays = function(e, d, b, j) {
		var h = [];
		var g = [];
		if (b) {
			for (var f = 0; f < this.smpIndices.length; f++) {
				var c = this.filterNumbers([e[this.smpIndices[f]], d[this.smpIndices[f]]]);
				if (c.length == 2) {
					h.push(e[this.smpIndices[f]]);
					g.push(d[this.smpIndices[f]])
				}
			}
		} else {
			if (j) {
				for (var f = 0; f < this.varIndices.length; f++) {
					var c = this.filterNumbers([e[this.varIndices[f]], d[this.varIndices[f]]]);
					if (c.length == 2) {
						h.push(e[this.varIndices[f]]);
						g.push(d[this.varIndices[f]])
					}
				}
			} else {
				for (var f = 0; f < e.length; f++) {
					var c = this.filterNumbers([e[f], d[f]]);
					if (c.length == 2) {
						h.push(e[f]);
						g.push(d[f])
					}
				}
			}
		}
		return [h, g]
	};
	this.reverseArray = function(a) {
		tmp = a.reverse();
		return tmp
	};
	this.parseInt = function(a) {
		return ((a + 0.5) << 1) >> 1
	};
	this.resetStagingDrawingBuffer = function() {
		this.stagingDrawingBuffer = {
			len: 0,
			map: [],
			keys: {},
			data: []
		}
	};
	this.addKeyStagingDrawingBuffer = function(f, c, j, d, g) {
		var e = this.parseInt(c) + ":" + this.parseInt(j) + ":" + this.parseInt(d) + ":" + this.parseInt(g);
		var a = this.stagingDrawingBuffer;
		if (!a.keys.hasOwnProperty(e)) {
			a.keys[e] = []
		}
		a.keys[e].push(f);
		a.map.push(e);
		a.data[f] = []
	};
	this.addDataStagingDrawingBuffer = function(e, g, h, d) {
		var c = this.stagingDrawingBuffer;
		c.len = e;
		c.data[e].push([g, h, d])
	};
	this.drawDataStagingDrawingBuffer = function(p) {
		var o = this;
		var h = function(c) {
			var b = c.split(":");
			b[0] = this.parseInt(b[0]);
			b[1] = this.parseInt(b[1]);
			b[2] = this.parseInt(b[2]);
			b[3] = this.parseInt(b[3]);
			return b[0] + b[2] > 0 && b[1] + b[3] > 0 && b[0] - b[2] < o.width && b[1] - b[3] < o.height
		};
		var a = 0;
		var s = this.stagingDrawingBuffer;
		for (var m = 0; m <= s.len; m++) {
			var f = s.map[m];
			var e = s.keys[f].length - 1;
			if (m == s.keys[f][e] && h(f)) {
				a++;
				var q = s.data[m];
				for (var g = 0; g < q.length; g++) {
					var r = q[g];
					if (r[0].match(/drawSelected/)) {
						this[r[0]].apply(this, r[1])
					} else {
						r[1].unshift(r[0]);
						if (r[2]) {
							this.addToRender(r[1], r[2], false, null, false, p)
						} else {
							this.addToRender(r[1], false, false, null, false, p)
						}
					}
				}
			}
		}
		this.resetStagingDrawingBuffer()
	}
};
CanvasXpress.prototype.initPlotUtils = function() {
	this.setVideoControls = function() {
		if (this.isVideo) {
			var b = this;
			if (typeof _V_ == "undefined" || !_V_.autoSetupTimeout) {
				setTimeout(function() {
					b.setVideoControls()
				}, 100)
			} else {
				var e = _V_(this.target + "-cX-Video");
				var a = this.$(this.target + "-cX-Video");
				if (e && a) {
					a.style.position = "absolute";
					a.style.background = "transparent";
					this.video = a.childNodes[0];
					this.video.style.display = "none";
					this.video.style.zIndex = -1;
					this.video.playbackRate = this.videoPlaybackRate;
					b.addEvtListener(this.video, "loadeddata", function() {
						b.addEvtListener(b.video, "play", b.videoPlay, false)
					}, false);
					if (this.videoAutoplay) {
						e.play();
						var c = function() {
							this.play = function() {
								if (b.video.readyState == 4) {
									b.drawVideo(b.video, b.width, b.height);
									clearInterval(d)
								}
							};
							var d = this.setInterval(this.play, 30)
						};
						c.call()
					}
				}
			}
		}
	};
	this.drawLayoutCanvasCompartments = function() {
		this.functionCaller = "drawLayoutCanvasCompartments";
		var p = this.canvasBoxColor;
		var n = this.height;
		var v = this.width;
		var i = this.left;
		var d = this.right;
		var s = this.bottom;
		var x = this.top;
		var k = this.marginLeft;
		var e = this.marginRight;
		var u = this.marginBottom;
		var a = this.marginTop;
		var q = this.layoutLeft;
		var m = this.layoutRight;
		var g = this.layoutBottom;
		var j = this.layoutTop;
		var o = this.drawLine;
		this.addToRender(["drawShape", "rectangle", (k + this.offsetX) + (this.layoutWidth / 2), (a + this.offsetY) + (this.layoutHeight / 2), this.layoutWidth, this.layoutHeight, false, p, "open"]);
		o("line", k, 0, k, n, p);
		o("line", q + k, 0, q + k, n, p);
		o("line", 0, a, v, a, p);
		o("line", 0, a + j, v, a + j, p);
		o("line", v - e, 0, v - e, n, p);
		o("line", v - (e + m), 0, v - (e + m), n, p);
		o("line", 0, n - u, v, n - u, p);
		o("line", 0, n - (u + g), v, n - (u + g), p);
		o("line", q + k + i, 0, q + k + i, n, p);
		o("line", 0, a + j + x, v, a + j + x, p);
		o("line", v - (e + m + d), 0, v - (e + m + d), n, p);
		o("line", 0, n - (u + g + s), v, n - (u + g + s), p)
	};
	this.drawCanvasBox = function(a) {
		this.functionCaller = "drawCanvasBox";
		if (this.canvasBox && (this.graphType != "Network" || a)) {
			this.addToRender(["disableGradientTransparencyShadow"]);
			this.addToRender(["drawShape", "rectangle", 0 + ((this.width - 1) / 2), 0 + ((this.height - 1) / 2), this.width - 1, this.height - 1, false, this.canvasBoxColor, "open"]);
			this.addToRender(["enableGradientTransparencyShadow"])
		}
	};
	this.drawPlotWindow = function() {
		this.functionCaller = "drawPlotWindow";
		if (this.backgroundType.match("window")) {
			this.addToRender(["disableGradientTransparencyShadow"]);
			var a = this.marginLeft + this.offsetX;
			var b = this.marginTop + this.offsetY;
			if (this.backgroundType == "windowGradient2" || this.backgroundType == "windowSolidGradient") {
				var c;
				if (this.backgroundWindowGradientOrientation == "horizontal") {
					c = this.getLinearGradient(a + this.left, b, a + this.left + this.x, b, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
				} else {
					c = this.getLinearGradient(a, b + this.top, a, b + this.top + this.y, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
				}
				this.addToRender(["drawShape", "rectangle", (a + this.left) + (this.x / 2), (b + this.top) + (this.y / 2), this.x, this.y, c, c])
			} else {
				this.addToRender(["drawShape", "rectangle", (a + this.left) + (this.x / 2), (b + this.top) + (this.y / 2), this.x, this.y, this.backgroundWindow, this.backgroundWindow])
			}
			this.addToRender(["enableGradientTransparencyShadow"])
		}
	};
	this.validateSegregation = function() {
		var e = "";
		var b = this.segregateVariablesBy;
		var d = this.segregateSamplesBy;
		if (b.length > 0) {
			var a = [];
			for (var c = 0; c < b.length; c++) {
				if ((this.data.z && this.data.z.hasOwnProperty(b[c])) || b[c] == "variable") {
					a.push(b[c])
				}
			}
			b = a
		}
		if (d.length > 0) {
			var a = [];
			for (var c = 0; c < d.length; c++) {
				if ((this.data.x && this.data.x.hasOwnProperty(d[c])) || d[c] == "sample") {
					a.push(d[c])
				}
			}
			d = a
		}
		if (b.length > 0 && d.length > 0) {
			if (d.length > 1) {
				while (d.length > 1) {
					d.pop()
				}
				e += "Only one sample segregation when variable segregation is selected\n";
				e += "segregateSamplesBy was set to: " + d[0] + "\n"
			}
			if (b.length > 1) {
				while (b.length > 1) {
					b.pop()
				}
				e += "Only one variable segregation when sample segregation is selected\n";
				e += "segregateVariblesBy was set to: " + b[0] + "\n"
			}
		} else {
			if (d.length > 0) {
				if (d.length > 2) {
					while (d.length > 2) {
						d.pop()
					}
					e += "Maximum of two sample segregations\n";
					e += "segregateSamplesBy was set to: " + d[0] + "," + d[1] + "\n"
				}
			} else {
				if (b.length > 0) {
					if (b.length > 2) {
						while (b.length > 2) {
							b.pop()
						}
						e += "Maximum of two variable segregations\n";
						e += "segregateVariablesBy was set to: " + b[0] + "," + b[1] + "\n"
					}
				}
			}
		}
		if (e != "") {
			this.removeMenus();
			alert(e);
			return false
		}
		return true
	};
	this.validateOverlays = function() {
		if (this.smpOverlays.length > 0) {
			var a = [];
			for (var b = 0; b < this.smpOverlays.length; b++) {
				if (this.smpOverlays[b] == "-" || (this.data.x && this.data.x.hasOwnProperty(this.smpOverlays[b]))) {
					a.push(this.smpOverlays[b])
				}
			}
			this.smpOverlays = a
		}
		if (this.varOverlays.length > 0) {
			var a = [];
			for (var b = 0; b < this.varOverlays.length; b++) {
				if (this.varOverlays[b] == "-" || (this.data.z && this.data.z.hasOwnProperty(this.varOverlays[b]))) {
					a.push(this.varOverlays[b])
				}
			}
			this.varOverlays = a
		}
	};
	this.isDotplotGraph = function() {
		if (this.graphType.match(/Dotplot/)) {
			return true
		} else {
			if (this.graphType == "Boxplot" && (this.showBoxplotOriginalData || this.showViolinBoxplot)) {
				return true
			} else {
				return false
			}
		}
	}
};
CanvasXpress.prototype.initConfigUtils = function() {
	this.setPixelImage = function() {
		this.beaconImage = this.$cX("img", {
			id: this.target + "-cX-Beacon-Image",
			src: navigator.onLine && this.protocol != "file" ? "https://canvasxpress.org/cgi-bin/services.pl?beacon=" + this.meta.factory.client : CanvasXpress.images.canvasXpress
		})
	};
	this.encode = function(a) {
		return btoa(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, function(b, c) {
			return String.fromCharCode("0x" + c)
		}))
	};
	this.decode = function(a) {
		return decodeURIComponent(Array.prototype.map.call(atob(a), function(b) {
			return "%" + ("00" + b.charCodeAt(0).toString(16)).slice(-2)
		}).join(""))
	};
	this.getFileName = function(a) {
		return a.substring(a.lastIndexOf("/") + 1)
	};
	this.getTitleSubtitleHeight = function() {
		var b = 0;
		var a;
		this.setTitleSubtitleFont();
		if (this.title) {
			a = this.title.split(/\n/);
			b += (this.margin + this.getFontPt(this.titleFont)) * a.length;
			if (this.subtitle) {
				a = this.subtitle.split(/\n/);
				b += (this.margin + this.getFontPt(this.subtitleFont)) * a.length
			}
			b += this.margin
		}
		return b
	};
	this.setTitleSubtitleFont = function() {
		this.setPropertyFontSize(this.width, "titleFont");
		this.adjustFont(this.title, "titleFont", this.width);
		this.setPropertyFontSize(this.width, "subtitleFont");
		this.adjustFont(this.subtitle, "subtitleFont", this.width)
	};
	this.drawTitle = function() {
		this.functionCaller = "drawTitle";
		this.setTitleSubtitleFont();
		if (this.title) {
			var a = this.titleAlign == "left" ? this.marginLeft + this.left : this.titleAlign == "right" ? this.width - (this.marginRight + this.right) : this.width / 2;
			var b = this.marginTop + (this.getFontPt(this.titleFont) / 2);
			if (this.isMap) {
				a += parseInt(this.meta.canvas.ctx2.canvas.style.left);
				b += parseInt(this.meta.canvas.ctx2.canvas.style.top)
			}
			this.addToRender(["drawText", this.title, a, b, this.titleFont, this.titleColor, this.titleAlign == "left" ? "left" : this.titleAlign == "right" ? "right" : "center", "middle"]);
			if (this.subtitle) {
				a = this.subtitleAlign == "left" ? this.marginLeft + this.left : this.subtitleAlign == "right" ? this.width - (this.marginRight + this.right) : this.width / 2;
				this.addToRender(["drawText", this.subtitle, a, b + (this.getFontPt(this.titleFont) / 2) + this.margin + (this.getFontPt(this.subtitleFont) / 2), this.subtitleFont, this.subtitleColor, this.titleAlign == "left" ? "left" : this.titleAlign == "right" ? "right" : "center", "middle"])
			}
		}
	};
	this.getFontHeight = function() {
		this.setFont();
		return this.getFontPt(this.font)
	};
	this.setFont = function() {
		var b;
		if (this.autoScaleFont) {
			var c = 1 - this.percentAspectRatioPlotArea;
			var a = this.layoutComb ? (this.width / this.layoutCols) * c * 2.5 : this.width * c;
			var e = this.layoutComb ? (this.height / this.layoutRows) * c * 2.5 : this.height * c;
			b = Math.min(Math.max(parseInt((Math.max(a, e) / 30) * this.fontScaleFontFactor), this.minTextSize), this.maxTextSize)
		} else {
			b = Math.min(Math.max(parseInt(this.fontSize * this.fontScaleFontFactor), this.minTextSize), this.maxTextSize)
		}
		this.font = this.fontStyle + " " + b + "px " + this.fontName
	};
	this.setPropertyFontSize = function(i, g, c) {
		if (!i || !g) {
			return
		}
		var a = 1;
		var e = {
			titleFont: a + 4,
			subtitleFont: a + 2,
			decorationFont: a,
			axisTickFont: a,
			axisTitleFont: a,
			smpLabelFont: a,
			smpTitleFont: a,
			varLabelFont: a,
			varTitleFont: a,
			legendFont: a,
			citationFont: a - 10
		};
		var h = g.replace("Font", "ScaleFontFactor");
		this[g + "Size"] = Math.min(Math.max(parseInt((i / 30) * this[h]) + e[g], this.minTextSize), c || this.maxTextSize);
		this[g] = this[g + "Style"] + " " + this[g + "Size"] + "px " + this.fontName
	};
	this.setOverlayFont = function() {
		var a = parseInt(Math.max(Math.min(this.overlayScaleFontFactor * this.overlayFontSize, this.maxTextSize), this.minTextSize));
		this.overlayFontSize = parseInt(Math.max(1, Math.min(this.overlaysThickness - 1, a)));
		this.overlayFont = this.overlayFontStyle + " " + this.overlayFontSize + "px " + this.fontName
	};
	this.adjustFont = function(b, c, g) {
		if (b && c && g) {
			var e = this.getFontPt(this[c]);
			var a = this.measureText(b, this[c]);
			while (a > g && e > this.minTextSize) {
				e--;
				this[c] = this[c + "Style"] + " " + e + "px " + this.fontName;
				a = this.measureText(b, this[c])
			}
		}
	};
	this.setAspectRatioProperties = function() {
		if (this.adjustAspectRatio) {
			var b = this.meta.config.orig;
			var h = Math.min(this.width, this.height);
			var e = ["margin", "marginLeft", "marginTop", "marginRight", "marginBottom", "overlaysThickness", "dendrogramHeight", "heatmapSeparatorWidth"];
			if (this.adjustAspectRatioHeatmapIndicator) {
				e.push("heatmapIndicatorHeight");
				e.push("heatmapIndicatorWidth")
			}
			for (var c = 0; c < e.length; c++) {
				if (!b[e[c]]) {
					b[e[c]] = this[e[c]]
				}
			}
			if (!b.sizes) {
				b.sizes = this.cloneObject(this.sizes);
				if (this.sizes.length < 10) {
					var a = this.max(this.sizes);
					var g = this.sizes.length;
					for (var c = g; c < 10 - g; c++) {
						this.sizes.push(a + ((c + 1) * 2))
					}
				}
				for (var c = 0; c < this.sizes.length; c++) {
					this.sizes[c] = Number(Math.max(0.5, h * this.sizes[c] / 833).toFixed(1))
				}
			}
			for (var c = 0; c < e.length; c++) {
				this[e[c]] = Number(Math.max(0.5, h * this[e[c]] / 833).toFixed(1))
			}
		}
	};
	this.resetAspectRatioProperties = function() {
		if (this.adjustAspectRatio) {
			var a = this.meta.config.orig;
			var c = ["margin", "marginLeft", "marginTop", "marginRight", "marginBottom", "overlaysThickness", "dendrogramHeight", "heatmapSeparatorWidth", "sizes"];
			if (this.adjustAspectRatioHeatmapIndicator) {
				c.push("heatmapIndicatorHeight");
				c.push("heatmapIndicatorWidth")
			}
			for (var b = 0; b < c.length; b++) {
				if (a[c[b]]) {
					this[c[b]] = a[c[b]];
					delete(a[c[b]])
				}
			}
		}
	};
	this.drawCitation = function() {
		this.functionCaller = "drawCitation";
		if (this.citation) {
			var a = this.width - this.margin;
			var b = this.height - this.margin;
			if (this.isMap) {
				a += parseInt(this.meta.canvas.ctx2.canvas.style.left);
				b += parseInt(this.meta.canvas.ctx2.canvas.style.top)
			}
			this.setPropertyFontSize(this.width, "citationFont", 20);
			this.addToRender(["drawText", this.citation, a, b, this.citationFont, this.citationColor, "right", "bottom"])
		}
	};
	this.drawCx = function() {
		var b = this.hexToString("686578546f537472696e67");
		var e = this[b]("6472617754657874");
		var c = this[b]("6d657461");
		if (this[c][this[b]("76616c696463")] != null) {
			switch (this[c][this[b]("76616c696463")]) {
				case 0:
					return;
				case 1:
					var a = this[b]("4e6f7420612076616c696420636f7079206f662063616e766173587072657373");
					this[e](a, this.width / 2, this.height / 2, this.font, "rgba(0,0,0,0.5)", "center", "middle");
					return;
				case 2:
					return;
				case 3:
					var a = this[b]("63616e76617358707265737320522076657273696f6e206f6e6c79");
					this[e](a, this.width / 2, this.height / 2, this.font, "rgba(0,0,0,0.5)", "center", "middle");
					return;
				default:
					return
			}
		}
	};
	this.getGroupColor = function(b, e) {
		if (this.isGroupedData) {
			var a = this.data.w.grps[e];
			this.isGroupedData = false;
			var j = this.getPropertyValue(b, a[0], "colorBy");
			for (var d = 1; d < a.length; d++) {
				var h = this.getPropertyValue(b, a[d], "colorBy");
				if (h != j) {
					this.isGroupedData = true;
					return this.foreground
				}
			}
			this.isGroupedData = true;
			return j
		} else {
			return this.getPropertyValue(b, e, "colorBy")
		}
	};
	this.drawSelectedBackgroundLabel = function(b, c, a, d) {
		this.functionCaller = "drawSelectedBackgroundLabel";
		if (this.isInSelectedDataPoints(b, c)) {
			if (this.selectDataMode == "name") {
				if (this.selectDataModeDescription && this.data.z && this.data.z[this.selectDataModeDescription]) {
					lab = this.data.z[this.selectDataModeDescription][b] || this.data.y.vars[b]
				} else {
					lab = this.data.y.vars[b]
				}
				this.addToRender(["drawText", lab, a, d, this.varLabelFont, this.foreground, "center", "middle"])
			}
			return true
		}
		return false
	};
	this.drawSelectedBackground = function(j, l, m, b, g, i, d, a, k, e, c) {
		this.functionCaller = "drawSelectedBackground";
		if (this.isInSelectedDataPoints(j, l)) {
			if (this.selectDataMode == "area") {
				this.addToRender(["drawShape", m, b, g, i + 5, d + 5, this.selectedBackgroundColor, this.foreground, "closed", a, 1, k, false, e, c])
			}
			return true
		}
		return false
	};
	this.isInSelectedDataPoints = function(a, c) {
		if (this.isSelectDataPoints) {
			if (this.graphType == "Scatter2D" && this.isHistogram) {
				if (this.data.y.histogram[a][c] && this.data.y.histogram[a][c].length > 0) {
					for (var b = 0; b < this.data.y.histogram[a][c].length; b++) {
						var d = this.data.y.histogram[a][c][b];
						if (this.selectDataPoint[d]) {
							if (this.broadcastType == "var") {
								return true
							} else {
								if (this.selectDataPoint[d].hasOwnProperty(c)) {
									return true
								}
							}
						}
					}
				}
			} else {
				if (this.selectDataPoint[a]) {
					if (this.broadcastType == "var") {
						return true
					} else {
						if (this.selectDataPoint[a].hasOwnProperty(c)) {
							return true
						}
					}
				}
			}
		}
		return false
	};
	this.isVisibleSelectedDataPoint = function(a, b) {
		if (this.isSelectDataPoints) {
			if (this.hideDataPoint.length > 0 && this.hideDataPoint[a]) {
				if (this.broadcastType == "var") {
					return false
				} else {
					if (this.hideDataPoint[a].hasOwnProperty(b)) {
						return false
					}
				}
			}
		}
		return true
	};
	this.getVarColor = function(a, c) {
		if (this.isArray(this.highlightVar)) {
			for (var b = 0; b < this.highlightVar.length; b++) {
				if (this.highlightVar[b] == a) {
					return this.varHighlightColor
				}
			}
		} else {
			if (this.highlightVar == a) {
				return this.varHighlightColor
			}
		}
		return c ? this.dendrogramColor : this.varLabelFontColor
	};
	this.getSmpColor = function(c, b) {
		if (this.isArray(this.highlightSmp)) {
			for (var a = 0; a < this.highlightSmp.length; a++) {
				if (this.highlightSmp[a] == c) {
					return this.smpHighlightColor
				}
			}
		} else {
			if (this.highlightSmp == c) {
				return this.smpHighlightColor
			}
		}
		return b ? this.dendrogramColor : this.smpLabelFontColor
	};
	this.getNodeColor = function(c, a) {
		if (this.isArray(this.highlightNode)) {
			for (var b = 0; b < this.highlightNode.length; b++) {
				if (this.highlightNode[b] == c) {
					return this.nodeHighlightColor
				}
			}
		} else {
			if (this.highlightNode == c) {
				return this.nodeHighlightColor
			}
		}
		return this.selectNode.hasOwnProperty(c) ? this.nodeHighlightColor : a ? a : this.nodeFontColor
	};
	this.getTechnicalIndicatorColor = function(a) {
		return this[a.toLowerCase() + "Color"] ? this[a.toLowerCase() + "Color"] : "rgb(255,255,0)"
	};
	this.getDendrogramColor = function(a, c) {
		if (a) {
			if (this.colorVarDendrogramBy && this.data.z && this.data.z.hasOwnProperty(this.colorVarDendrogramBy)) {
				var b = this.getVariableIndices(a);
				if (b > -1) {
					return this.getPropertyValue(b, false, "colorVarDendrogramBy")
				}
			}
			return this.getVarColor(a, true)
		} else {
			if (this.colorSmpDendrogramBy && this.data.x && this.data.x.hasOwnProperty(this.colorSmpDendrogramBy)) {
				var b = this.getSampleIndices(c);
				if (b > -1) {
					return this.getPropertyValue(false, b, "colorSmpDendrogramBy")
				}
			}
			return this.getSmpColor(c, true)
		}
	};
	this.isStringOverlays = function(c) {
		var a = this.meta.data;
		if ((!c || c == "v") && a.z && this.varOverlays.length > 0) {
			for (var b = 0; b < this.varOverlays.length; b++) {
				var d = this.varOverlays[b];
				if (a.z[d].type != "Numeric") {
					return true
				}
			}
		}
		if ((!c || c == "s") && a.x && this.smpOverlays.length > 0) {
			for (var b = 0; b < this.smpOverlays.length; b++) {
				var d = this.smpOverlays[b];
				if (a.x[d].type != "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.isUniqueFactor = function(b) {
		var a = this.meta.data;
		if ((!b || b == "v") && a.z) {
			for (var c in a.z) {
				if (a.z[c].unique) {
					return true
				}
			}
		}
		if ((!b || b == "s") && a.x) {
			for (var c in a.x) {
				if (a.x[c].unique) {
					return true
				}
			}
		}
		return false
	};
	this.isNumericFactor = function(b) {
		var a = this.meta.data;
		if ((!b || b == "v") && a.z) {
			for (var c in a.z) {
				if (a.z[c].type == "Numeric") {
					return true
				}
			}
		}
		if ((!b || b == "s") && a.x) {
			for (var c in a.x) {
				if (a.x[c].type == "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.isStringFactor = function(b) {
		var a = this.meta.data;
		if ((!b || b == "v") && a.z) {
			for (var c in a.z) {
				if (a.z[c].type != "Numeric") {
					return true
				}
			}
		}
		if ((!b || b == "s") && a.x) {
			for (var c in a.x) {
				if (a.x[c].type != "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.getBestSizes = function(d) {
		if (d > this.sizes.length) {
			return this.cloneObject(this.sizes)
		} else {
			var c = [];
			var a = Math.floor(this.sizes.length / d);
			for (var b = 0; b < d; b++) {
				c.push(this.sizes[b * a])
			}
			return c
		}
	};
	this.isBinConfigurations = function() {
		for (var a in this.binConfigurations) {
			return true
		}
		return false
	};
	this.initValidity = function() {
		var y = this.hexToString("686578546f537472696e67");
		var C = this[y]("6d657461");
		var n = this[y]("666163746f7279");
		var k = this[y]("636c69656e74");
		var e = this[y]("656e636f6465");
		var A = this[y]("76616c6964");
		var d = this[y]("74696d65");
		var D = this[y]("7374617274");
		var a = this[y]("73697465537263");
		var B = this[y]("757365724964");
		var a = this[y]("76657273696f6e");
		var i = this[y]("68726566");
		var p = new RegExp(this[y]("63616e7661737870726573732e6f7267"));
		var j = new RegExp(this[y]("5e66696c653a"));
		var o = new RegExp(this[y]("626d732e636f6d"));
		var g = new RegExp(this[y]("6c6f63616c686f7374"));
		this[C][n][k] = this[e]([this[C][d][D], this[B], this[C][n][a], this[i]].join("::"));
		if (this[B] == 1) {
			if (navigator.onLine) {
				if (this[i] && this[C][n][a]) {
					this[C][n][A] = 0
				} else {
					if (this[i] && j.test(this[i])) {
						this[C][n][A] = 0
					} else {
						if (this[i] && g.test(this[i])) {
							this[C][n][A] = 0
						} else {
							if (this[i] && !p.test(this[i])) {
								this[C][n][A] = 1
							} else {
								this[C][n][A] = 0
							}
						}
					}
				}
			} else {
				this[C][n][A] = 0
			}
		} else {
			if (this[B] == 2 && !this.isR) {
				this[C][n][A] = 3
			} else {
				if (this[B] == 3 && !o.test(this[i]) && !g.test(this[i]) && !j.test(this[i])) {
					this[C][n][A] = 1
				} else {
					this[C][n][A] = 0
				}
			}
		}
	};
	this.getWorstAspectRatio = function(l, k) {
		if (!l || l.length == 0) {
			return Number.MAX_VALUE
		} else {
			var e = 0;
			var g = 0;
			var b = Number.MAX_VALUE;
			for (var c = 0; c < l.length; c++) {
				var h = l[c].area;
				e += h;
				b = (b < h) ? b : h;
				g = (g > h) ? g : h
			}
			var d = k * k;
			var j = e * e;
			return Math.max(d * g / j, j / (d * b))
		}
	};
	this.adjustTreemapCoords = function(g, e) {
		if (g) {
			var c = this.treemapBorderWidth ? 1 : 0;
			var a = this.treemapBorderWidth;
			var b = a * 2;
			var d = this.smpLabelFontSize * c;
			e.left += a;
			if (e.height > d + b) {
				e.top += d + a;
				e.height -= (d + b);
				e.border = 2
			} else {
				if (e.height > b) {
					e.top += a;
					e.height -= b;
					e.border = 1
				} else {
					if (e.height > a) {
						e.height -= a;
						e.border = 0
					} else {
						e.border = -1
					}
				}
			}
			e.width -= b
		}
	};
	this.setTreemapRowVerticalLayout = function(l, j, h, g) {
		var c = 0;
		for (var b = 0; b < l.length; b++) {
			c += l[b].area
		}
		var a = c / j;
		var e = 0;
		for (var b = 0; b < l.length; b++) {
			var k = l[b].area / a;
			l[b].coords = {
				width: a,
				height: k,
				left: h.left,
				top: h.top + e
			};
			this.adjustTreemapCoords(g, l[b].coords);
			e += k
		}
		var d = {
			width: h.width - a,
			height: h.height,
			left: h.left + a,
			top: h.top
		};
		d.orientation = Math.min(d.width, d.height);
		if (d.orientation != d.height) {
			this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
		}
		return d
	};
	this.setTreemapRowHorizontalLayout = function(m, k, j, h) {
		var d = 0;
		for (var c = 0; c < m.length; c++) {
			d += m[c].area
		}
		var l = d / k;
		var g = j.top;
		var b = 0;
		for (var c = 0; c < m.length; c++) {
			var a = m[c].area / l;
			m[c].coords = {
				width: a,
				height: l,
				left: j.left + b,
				top: g
			};
			this.adjustTreemapCoords(h, m[c].coords);
			b += a
		}
		var e = {
			width: j.width,
			height: j.height - l,
			left: j.left,
			top: j.top + l
		};
		e.orientation = Math.min(e.width, e.height);
		if (e.orientation != e.width) {
			this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
		}
		return e
	};
	this.setTreemapRowLayout = function(a, b, c, d) {
		if (this.treemapOrientation == "horizontal") {
			return this.setTreemapRowVerticalLayout(a, b, c, d)
		} else {
			return this.setTreemapRowHorizontalLayout(a, b, c, d)
		}
	};
	this.computeTreemapDimensions = function(a, c, b, g, i) {
		if (a.length + c.length == 1) {
			var e = (a.length == 1) ? a : c;
			e[0].coords = g;
			this.adjustTreemapCoords(i, e[0].coords);
			return
		}
		if (a.length >= 2 && c.length == 0) {
			c = [a.shift()]
		}
		if (a.length == 0) {
			if (c.length > 0) {
				this.setTreemapRowLayout(c, b, g, i)
			}
			return
		}
		var d = a[0];
		if (this.getWorstAspectRatio(c, b) >= this.getWorstAspectRatio([d].concat(c), b)) {
			this.computeTreemapDimensions(a.slice(1), c.concat([d]), b, g, d.title)
		} else {
			var h = this.setTreemapRowLayout(c, b, g, i);
			this.computeTreemapDimensions(a, [], h.orientation, h, d.title)
		}
	};
	this.squarifyTreemap = function(a, h) {
		var g = h.width * h.height;
		var e = 0;
		var b = [];
		for (var d = 0; d < a.length; d++) {
			b[d] = parseFloat(a[d].area);
			e += b[d]
		}
		for (var d = 0; d < b.length; d++) {
			a[d].area = g * b[d] / e
		}
		var c = this.treemapOrientation == "horizontal" ? h.height : h.width;
		a.sort(function(j, i) {
			return i.area - j.area
		});
		this.computeTreemapDimensions(a.slice(1), [a[0]], c, h, a[0].title)
	};
	this.processTreemap = function(b, d) {
		if (!this.treemapOrientation) {
			this.treemapOrientation = "horizontal"
		}
		if (d.width >= d.height) {
			this.treemapOrientation = "horizontal"
		} else {
			this.treemapOrientation = "vertical"
		}
		if (b.length) {
			this.squarifyTreemap(b, d);
			for (var c = 0; c < b.length; c++) {
				var a = b[c].children ? b[c].children : b[c];
				var d = {
					width: b[c].coords.width,
					height: b[c].coords.height,
					left: b[c].coords.left,
					top: b[c].coords.top
				};
				this.processTreemap(a, d)
			}
		}
		return b
	};
	this.getCloudPointsAtRadius = function(a) {
		if (this.tagCloudGridPoints[a]) {
			return this.tagCloudGridPoints[a]
		}
		var b = a * 8;
		var c = b;
		var d = [];
		if (a == 0) {
			d.push([this.tagCloudGridCenter[0], this.tagCloudGridCenter[1], 0])
		}
		while (c--) {
			d.push([this.tagCloudGridCenter[0] + a * Math.cos(-c / b * 2 * Math.PI), this.tagCloudGridCenter[1] + a * Math.sin(-c / b * 2 * Math.PI) * this.tagCloudTextEllipticity, c / b * 2 * Math.PI])
		}
		this.tagCloudGridPoints[a] = d;
		return d
	};
	this.getCloudRotateDeg = function() {
		if (this.tagCloudTextRotateRatio == 0) {
			return 0
		}
		if (this.random() > this.tagCloudTextRotateRatio) {
			return 0
		}
		return (-Math.PI / 2) + (this.random() * Math.PI)
	};
	this.getCloudTextInfo = function(A, o, p) {
		var a = Math.min(500, Math.floor(this.tagCloudTextWeightFactor * o));
		var t = document.createElement("canvas");
		var B = t.getContext("2d", {
			willReadFrequently: true
		});
		var q = a + "px " + this.fontName;
		B.font = q;
		var b = this.measureText(A, q);
		var n = a;
		var j = b + n * 2;
		var h = n * 3;
		var C = Math.ceil(j / this.tagCloudTextGridSize);
		var c = Math.ceil(h / this.tagCloudTextGridSize);
		j = C * this.tagCloudTextGridSize;
		h = c * this.tagCloudTextGridSize;
		var u = -b * 0.5;
		var r = -n * 0.5;
		var v = Math.ceil((j * Math.abs(Math.sin(p)) + h * Math.abs(Math.cos(p))) / this.tagCloudTextGridSize);
		var d = Math.ceil((j * Math.abs(Math.cos(p)) + h * Math.abs(Math.sin(p))) / this.tagCloudTextGridSize);
		var w = d * this.tagCloudTextGridSize;
		var s = v * this.tagCloudTextGridSize;
		if (w < 1 || s < 1) {
			return {
				occupied: [],
				bounds: [0, 0, 0, 0],
				gw: d,
				gh: v,
				fillTextOffsetX: u,
				fillTextOffsetY: r,
				fillTextWidth: b,
				fillTextHeight: n,
				fontSize: a
			}
		}
		t.setAttribute("width", w);
		t.setAttribute("height", s);
		B.save();
		B.translate(w / 2, s / 2);
		B.rotate(-p);
		B.font = a + "px " + this.fontName;
		B.fillStyle = "#000";
		B.textBaseline = "middle";
		B.fillText(A, u, r + a * 0.5);
		B.restore();
		var z = B.getImageData(0, 0, w, s).data;
		var g = [];
		var m = d,
			l, k, i;
		var e = [v / 2, d / 2, v / 2, d / 2];
		while (m--) {
			l = v;
			while (l--) {
				i = this.tagCloudTextGridSize;
				singleGridLoop: {
					while (i--) {
						k = this.tagCloudTextGridSize;
						while (k--) {
							if (z[((l * this.tagCloudTextGridSize + i) * w + (m * this.tagCloudTextGridSize + k)) * 4 + 3]) {
								g.push([m, l]);
								if (m < e[3]) {
									e[3] = m
								}
								if (m > e[1]) {
									e[1] = m
								}
								if (l < e[0]) {
									e[0] = l
								}
								if (l > e[2]) {
									e[2] = l
								}
								break singleGridLoop
							}
						}
					}
				}
			}
		}
		return {
			occupied: g,
			bounds: e,
			gw: d,
			gh: v,
			fillTextOffsetX: u,
			fillTextOffsetY: r,
			fillTextWidth: b,
			fillTextHeight: n,
			fontSize: a
		}
	};
	this.canFitCloudText = function(h, g, j, b, a) {
		var e = a.length;
		while (e--) {
			var d = h + a[e][0];
			var c = g + a[e][1];
			if (d >= this.tagCloudGridWidth || c >= this.tagCloudGridHeight || d < 0 || c < 0 || !this.tagCloudGrid[d][c]) {
				return false
			}
		}
		return true
	};
	this.fillCloudGridAt = function(a, b) {
		if (a >= this.tagCloudGridWidth || b >= this.tagCloudGridHeight || a < 0 || b < 0) {
			return
		}
		this.tagCloudGrid[a][b] = false
	};
	this.updateCloudGrid = function(e, c, d) {
		var a = d.occupied;
		var b = a.length;
		while (b--) {
			this.fillCloudGridAt(e + a[b][0], c + a[b][1])
		}
	};
	this.drawCloudTag = function(c, i, g, d) {
		this.functionCaller = "drawCloudTag";
		var j = this;
		var k = this.getCloudRotateDeg();
		var e = this.getCloudTextInfo(c, i, k);
		if (!e) {
			return false
		}
		var b = e.bounds;
		if ((b[1] - b[3] + 1) > this.tagCloudGridWidth || (b[2] - b[0] + 1) > this.tagCloudGridHeight) {
			return false
		}
		var a = this.tagCloudGridMaxRadius + 1;
		while (a--) {
			var l = this.getCloudPointsAtRadius(this.tagCloudGridMaxRadius - a);
			l = [].concat(l);
			this.shuffleArray(l);
			var h = l.some(function m(o) {
				var u = Math.floor(o[0] - e.gw / 2);
				var t = Math.floor(o[1] - e.gh / 2);
				var v = e.gw;
				var q = e.gh;
				var p = e.fontSize + "px " + j.fontName;
				var n = "1px " + j.fontName;
				if (!j.canFitCloudText(u, t, v, q, e.occupied)) {
					return false
				}
				var s = ((u + e.gw / 2) * j.tagCloudTextGridSize);
				var r = ((t + e.gh / 2) * j.tagCloudTextGridSize);
				j.addToRender(["drawText", c, s, r, p, g, "center", "middle", -k], d, false, null, false, [j.width / 2, j.height / 2, n, -Math.PI * 2]);
				j.updateCloudGrid(u, t, e);
				return true
			});
			if (h) {
				return true
			}
		}
		return false
	};
	this.setTagCloud = function(b) {
		this.tagCloudTextGridSize = Math.max(this.tagCloudTextGridSize, 4);
		if (this.colorBy && this.legendColorsN) {
			this.tagCloudGridWidth = Math.floor(this.x / this.tagCloudTextGridSize);
			this.tagCloudGridHeight = Math.floor(this.y / this.tagCloudTextGridSize)
		} else {
			this.tagCloudGridWidth = Math.floor(this.width / this.tagCloudTextGridSize);
			this.tagCloudGridHeight = Math.floor(this.height / this.tagCloudTextGridSize)
		}
		this.tagCloudGridCenter = [this.tagCloudGridWidth / 2, this.tagCloudGridHeight / 2];
		this.tagCloudGridMaxRadius = Math.floor(Math.sqrt(this.tagCloudGridWidth * this.tagCloudGridWidth + this.tagCloudGridHeight * this.tagCloudGridHeight));
		this.tagCloudGridPoints = [];
		if (!b) {
			this.setTagCloudTextWeightFactor()
		} else {
			this.tagCloudTextWeightFactor *= b
		}
		this.tagCloudGrid = [];
		var c = this.tagCloudGridWidth;
		var a;
		while (c--) {
			this.tagCloudGrid[c] = [];
			a = this.tagCloudGridHeight;
			while (a--) {
				this.tagCloudGrid[c][a] = true
			}
		}
	};
	this.setTagCloudTextWeightFactor = function() {
		var j = 0;
		var b = 0;
		var n = this.varIndices[0];
		for (var h = 0; h < this.smpIndices.length; h++) {
			var g = this.smpIndices[h];
			var k = this.getDataAtPos(n, g);
			var e = this.data.y.smps[g].length;
			var c = e * k * 0.5 * k;
			b = Math.max(c, b);
			j += c
		}
		if (!this.tagCloudTries) {
			this.tagCloudTries = 1
		}
		b = parseInt(Math.max(this.width, this.height));
		if (j > b) {
			this.tagCloudTextWeightFactor = (this.width * this.height) / (j * this.tagCloudTries)
		} else {
			this.tagCloudTextWeightFactor = (this.width * this.height) / (j * this.tagCloudTries * (b / j))
		}
		this.tagCloudTries += 1
	};
	this.getVariableColor = function(a) {
		for (var b = 0; b < this.data.y.vars.length; b++) {
			if (this.data.y.vars[b] == a) {
				return this.colors[b % this.colors.length]
			}
		}
		return this.colors[0]
	};
	this.getOutlineColor = function() {
		if (this.graphType.match(/Bar/) && this.barType == "lollipop" && !this.isGroupedData) {
			return false
		} else {
			return this.backgroundType.match(/window/i) ? this.foregroundWindow : this.objectBorderColor ? this.objectBorderColor : this.foreground
		}
	};
	this.getDefaultMetaDataObject = function() {
		var a = this.meta.def.colorBrew;
		return {
			rmin: a.rmin,
			rmax: a.rmax,
			min: a.min,
			max: a.max,
			decs: a.decs,
			vals: a.vals,
			maxLevLen: a.maxLevLen,
			maxLevChr: a.maxLevChr,
			maxLevStr: a.maxLevStr,
			colorBrew: a
		}
	};
	this.setPieData = function(m, o, l) {
		if (!this.cacheColors) {
			this.cacheColors = {
				PIE: {}
			}
		} else {
			if (!this.cacheColors.PIE) {
				this.cacheColors.PIE = {}
			}
		}
		var b = {
			no: 0,
			idso: [],
			ids: [],
			cols: [],
			data: {},
			raw: {},
			oprc: 0,
			tot: this.sum(m)
		};
		for (var h = 0; h < m.length; h++) {
			var g = o ? this.varIndices[h] : h;
			var a = m[g] / b.tot;
			var e = o ? this.data.y.vars[g] : h;
			var n;
			if (l && l[h % l.length]) {
				n = l[h % l.length]
			} else {
				if (this.cacheColors.PIE.hasOwnProperty(e)) {
					n = this.cacheColors.PIE[e]
				} else {
					n = this.pieColors[h % this.pieColors.length] ? this.pieColors[h % this.pieColors.length] : this.colors[h % this.colors.length];
					this.cacheColors.PIE[e] = n
				}
			}
			if (!isNaN(a)) {
				b.data[g] = a;
				b.raw[g] = m[g];
				if (h >= this.maxPieSectors - 1) {
					b.oprc += a;
					b.idso.push(g);
					b.no++
				} else {
					b.ids.push(g)
				}
				b.cols.push(n)
			}
		}
		if (b.no) {
			b.ids.push(-1)
		}
		return b
	};
	this.drawPie = function(u, h, g, t, I, w) {
		this.functionCaller = "drawPie";
		var q = function() {
			for (var a = 0; a < u.ids.length; a++) {
				if (u.data[u.ids[a]] && u.data[u.ids[a]] > -1 && isNaN(u.data[u.ids[a]])) {
					return false
				}
			}
			return true
		};
		if (q()) {
			var z, d, o;
			var m = this.startPieSectors != null ? (this.startPieSectors * Math.PI / 180) % 360 : 0;
			var A = this.pieSegmentLabels == "inside" ? t - (t / 3) : t + (t / 6);
			var G = 0;
			var C = this.layoutComb ? this.smpIndices[0] : this.xAxisIndices ? this.xAxisIndices[0] : 0;
			for (var E = 0; E < u.ids.length; E++) {
				var k = u.ids[E];
				var v = k > -1 ? u.data[k] : u.oprc;
				var e = u.cols[E];
				z = d != null ? parseFloat(d) : parseFloat((Math.PI * (2 * G)) - m);
				d = parseFloat(z + (Math.PI * (2 * (v))));
				var H = (z + d) / 2;
				var B = (d - z) / 32;
				var D = this.pieType == "separated" ? this.background : this.pieType == "solid" ? this.foreground : this.foreground;
				this.drawSelectedBackground(k > -1 ? k : u.idso[0], C, "pie", h, g, (t * 2) + 10, t + 10, false, true, z, d);
				if (this.graphType == "Network") {
					this.addToRender(["drawShape", "pie", h, g, (t * 2), t, e, e, "closed", false, 1, false, false, z, d], I[E], w)
				} else {
					if (this.graphType != "Pie") {
						this.addToRender(["drawShape", "pie", h, g, (t * 2), t, e, e, "closed", false, 1, false, false, z, d], I[E], w)
					} else {
						if (k > -1) {
							this.addToRender(["drawShape", "pie", h, g, (t * 2), t, e, e, "closed", false, 1, false, false, z, d], [k, C])
						} else {
							this.addToRender(["drawShape", "pie", h, g, (t * 2), t, e, e, "closed", false, 1, false, false, z, d], u.idso)
						}
					}
				}
				var F = u.ids.length > 1 ? h - Math.sin(H - (Math.PI / 2)) * A : h;
				var b = u.ids.length > 1 ? g + Math.cos(H - (Math.PI / 2)) * A : g;
				if (this.graphType != "Network" && this.showPieValues && (d - z) > 0.05) {
					if (this.pieLabelType == "value") {
						this.addToRender(["drawText", u.raw[k], F, b, this.axisTickFont, this.axisTickColor, "center", "middle"])
					} else {
						this.addToRender(["drawText", sprintf("%." + this.pieSegmentPrecision + "f", v * 100) + "%", F, b, this.axisTickFont, this.axisTickColor, "center", "middle"])
					}
				}
				G += v
			}
			G = 0;
			d = null;
			if (u.ids.length > 1) {
				for (var E = 0; E < u.ids.length; E++) {
					var k = u.ids[E];
					var v = k > -1 ? u.data[k] : u.oprc;
					z = d != null ? parseFloat(d) : parseFloat((Math.PI * (2 * G)) - m);
					d = parseFloat(z + (Math.PI * (2 * (v))));
					var D = this.pieType == "separated" ? this.background : this.pieType == "solid" ? this.foreground : this.foreground;
					this.addToRender(["drawShape", "pie", h, g, (t * 2), t, false, D, "open", false, this.pieSegmentSeparation, false, false, z, d], false, false, null, true);
					G += v
				}
			}
			if (this.pieInnerRadius > 0 && this.pieInnerRadius < 1) {
				this.addToRender(["drawShape", "circle", h, g, t * this.pieInnerRadius * 2, t * this.pieInnerRadius * 2, this.background, this.background, "closed"])
			}
		}
	};
	this.drawBarPlot = function(U, T, N, E, B, I, D, x, M, K, V, J, X, L, R, O) {
		this.functionCaller = "drawBarPlot";
		var C, A, S, H;
		var j = this;
		var W = this.getOutlineColor();
		var F = this.variableSeparationFactor / 2;
		var Q = B / 2;
		if (K == "vertical" || this.graphType == "Network") {
			for (var P = 0; P < U.length; P++) {
				C = ((U[P] - M) * D) - x;
				var G;
				if (!isNaN(C)) {
					if (C < 0) {
						G = this.addToRender(["drawShape", "rectangle", (N + F) + ((B - this.variableSeparationFactor) / 2), E + (-C / 2), B - this.variableSeparationFactor, -C, V[P], W || V[P], J[P], false, false, R], X[P], L)
					} else {
						G = this.addToRender(["drawShape", "rectangle", (N + F) + ((B - this.variableSeparationFactor) / 2), E - (C / 2), B - this.variableSeparationFactor, C, V[P], W || V[P], J[P], false, false, R], X[P], L)
					}
					S = E - C;
					H = N + Q;
					if (T[P] && !isNaN(T[P])) {
						A = (T[P] / 2) * D;
						this.addToRender(["drawLine", "error", H, S, H, S - A, W || this.objectBorderColor, -Q, "butt"], false, false, G);
						this.addToRender(["drawLine", "error", H, S, H, S + A, W || this.objectBorderColor, -Q, "butt"], false, false, G)
					}
					if (this.showDataValues) {
						this.addToRender(["drawText", this.correctPrecisionBug(U[P]), H, E - (C + this.overlayFontSize), this.overlayFont, V[P], "center", "bottom"], false, false, G)
					}
				}
				N += I
			}
		} else {
			for (var P = 0; P < U.length; P++) {
				C = ((U[P] - M) * D) - x;
				var G;
				if (!isNaN(C)) {
					if (C < 0) {
						if (O) {
							G = this.addToRender(["drawShape", "rectangle", ((N + O) - x) + (-C / 2), (E + F) + ((B - this.variableSeparationFactor) / 2), -C, B - this.variableSeparationFactor, V[P], W || V[P], J[P], false, false, R], X[P], L)
						} else {
							G = this.addToRender(["drawShape", "rectangle", (N + C) + (-C / 2), (E + F) + ((B - this.variableSeparationFactor) / 2), -C, B - this.variableSeparationFactor, V[P], W || V[P], J[P], false, false, R], X[P], L)
						}
					} else {
						if (O) {
							G = this.addToRender(["drawShape", "rectangle", ((N + O) - (C + x)) + (C / 2), (E + F) + ((B - this.variableSeparationFactor) / 2), C, B - this.variableSeparationFactor, V[P], W || V[P], J[P], false, false, R], X[P], L)
						} else {
							G = this.addToRender(["drawShape", "rectangle", N + (C / 2), (E + F) + ((B - this.variableSeparationFactor) / 2), C, B - this.variableSeparationFactor, V[P], W || V[P], J[P], false, false, R], X[P], L)
						}
					}
					S = O ? (N + O) - (C + x) : N + C;
					H = E + Q;
					if (T[P] && !isNaN(T[P])) {
						A = (T[P] / 2) * D;
						this.addToRender(["drawLine", "error", S, H, S + A, H, W || this.objectBorderColor, Q, "butt"], false, false, G);
						this.addToRender(["drawLine", "error", S, H, S - A, H, W || this.objectBorderColor, Q, "butt"], false, false, G)
					}
					if (this.showDataValues) {
						this.addToRender(["drawText", this.correctPrecisionBug(U[P]), S + this.overlayFontSize, H, this.overlayFont, V[P], "left", "middle"], false, false, G)
					}
				}
				E += I
			}
		}
	};
	this.drawLinePlot = function(ab, aa, T, M, K, X, L, S, Q, ad, O, N, af, Z, Y, U, D) {
		this.functionCaller = "drawLinePlot";
		var G = function() {
			var b = [
				[],
				[]
			];
			if (Q == "vertical") {
				for (var a = 0; a < r[0].length; a++) {
					b[0].push(r[0][a]);
					b[1].push(r[1][a][0])
				}
				for (var a = r[0].length - 1; a >= 0; a--) {
					b[0].push(r[0][a]);
					b[1].push(r[1][a][1])
				}
			} else {
				for (var a = 0; a < r[1].length; a++) {
					b[0].push(r[0][a][0]);
					b[1].push(r[1][a])
				}
				for (var a = r[1].length - 1; a >= 0; a--) {
					b[0].push(r[0][a][1]);
					b[1].push(r[1][a])
				}
			}
			return b
		};
		var P, A, y, x, j, ah, ag, D, ac, H;
		var J = null;
		var B = null;
		var F = K / 2;
		var E = 12;
		var ae = O == "open" ? ad : this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var R = ab.length - 1;
		var I = [
			[],
			[]
		];
		var r = [
			[],
			[]
		];
		var V = [];
		if (Q == "vertical") {
			A = T;
			y = T + X;
			if (J == null) {
				J = A
			}
			for (var W = 1; W < ab.length; W++) {
				P = W - 1;
				if (this.isObject(L)) {
					j = M - ((ab[P] - L[P].min) * L[P].units);
					ah = M - ((ab[W] - L[W].min) * L[W].units)
				} else {
					j = M - ((ab[P] - S) * L);
					ah = M - ((ab[W] - S) * L)
				}
				if (B == null) {
					B = j
				}
				if (!isNaN(j)) {
					if (this.lineDecoration && N) {
						this.addToRender(["drawShape", N, A, j, E, E, ad, ae, O[P], false, false, Y], af[P], Z, H, false, [J, B])
					} else {
						this.addToRender(["drawShape", "sphere", A, j, E, E, this.addColorTransparency(ad, 0), "rgba(0,0,0,0)", O[P], false, false, Y], af[P], Z, H, false, [J, B])
					}
					if (aa[P] != null && !isNaN(aa[P])) {
						ag = (aa[P] / 2) * this.isObject(L) ? L[P].units : L;
						if (this.lineErrorType == "bar") {
							this.addToRender(["drawLine", "error", A, j, A, j + ag, ad, -F, "butt"], false, false, H, false, [J, B]);
							this.addToRender(["drawLine", "error", A, j, A, j - ag, ad, -F, "butt"], false, false, H, false, [J, B])
						} else {
							r[0].push([A, A]);
							r[1].push([j + ag, j - ag]);
							V.push([A, j])
						}
					}
					if (this.lineType == "spline") {
						I[0].push(A);
						I[1].push(j)
					}
				}
				if ((this.lineType != "spline" && !isNaN(j) && !isNaN(ah)) || ab.length < 3) {
					ac = this.addToRender(["drawLine", "line", A, j, y, ah, ad, this.lineThickness, "butt", false, false, Y], ["Line:" + D + ":" + W], false, H, false, [J, B])
				} else {
					if (this.lineType == "spline" && isNaN(ah)) {
						ac = this.addToRender(["drawLine", "spline", I[0], I[1], false, false, ad, this.lineThickness, false, false, false, Y], ["Line:" + D], false, H, false, [J, B]);
						I = [
							[],
							[]
						];
						J = null;
						B = null
					}
				}
				if (!H) {
					H = ac
				}
				if (r[0].length > 0 && isNaN(ah)) {
					var v = this.addColorTransparency(ad, 0.3);
					if (this.lineType == "spline") {
						this.addToRender(["drawShape", "confidence", r[0], r[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
					} else {
						var C = G();
						this.addToRender(["drawShape", "path", C[0], C[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
					}
					r = [
						[],
						[]
					];
					V = []
				}
				A += X;
				y += X
			}
			if (!isNaN(ah)) {
				if (this.lineDecoration && N) {
					this.addToRender(["drawShape", N, A, ah, E, E, ad, ae, O[R], false, false, Y], af[R], Z, H, false, [J, B])
				} else {
					this.addToRender(["drawShape", "sphere", A, ah, E, E, this.addColorTransparency(ad, 0), "rgba(0,0,0,0)", O[R], false, false, Y], af[R], Z, H, false, [J, B])
				}
				if (aa[R] != null && !isNaN(aa[R])) {
					ag = (aa[R] / 2) * this.isObject(L) ? L[R].units : L;
					if (this.lineErrorType == "bar") {
						this.addToRender(["drawLine", "error", A, ah, A, ah + ag, ad, -F, "butt"], false, false, H);
						this.addToRender(["drawLine", "error", A, ah, A, ah - ag, ad, -F, "butt"], false, false, H)
					} else {
						if (W == ab.length) {
							r[0].push([A, A]);
							r[1].push([ah + ag, ah - ag]);
							V.push([A, ah])
						}
					}
				}
				if (this.lineType == "spline") {
					I[0].push(A);
					I[1].push(ah)
				}
			}
			if (this.lineType == "spline") {
				this.addToRender(["drawLine", "spline", I[0], I[1], false, false, ad, this.lineThickness, false, false, false, Y], ["Line:" + D], false, null, false, [J, B])
			}
			if (r[0].length > 0) {
				var v = this.addColorTransparency(ad, 0.3);
				if (this.lineType == "spline") {
					this.addToRender(["drawShape", "confidence", r[0], r[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
				} else {
					var C = G();
					this.addToRender(["drawShape", "path", C[0], C[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
				}
			}
		} else {
			j = M;
			ah = M + X;
			if (B == null) {
				B = j
			}
			for (var W = 1; W < ab.length; W++) {
				P = W - 1;
				if (this.isObject(L)) {
					A = U ? T + U - ((ab[P] - L[P].min) * L[P].units) : T + ((ab[P] - L[P].min) * L[P].units);
					y = U ? T + U - ((ab[W] - L[W].min) * L[W].units) : T + ((ab[W] - L[W].min) * L[W].units)
				} else {
					A = U ? T + U - ((ab[P] - S) * L) : T + ((ab[P] - S) * L);
					y = U ? T + U - ((ab[W] - S) * L) : T + ((ab[W] - S) * L)
				}
				if (J == null) {
					J = A
				}
				if (!isNaN(A)) {
					if (this.lineDecoration && N) {
						this.addToRender(["drawShape", N, A, j, E, E, ad, ae, O[P], false, false, Y], af[P], Z, H, false, [J, B])
					} else {
						this.addToRender(["drawShape", "sphere", A, j, E, E, this.addColorTransparency(ad, 0), "rgba(0,0,0,0)", O[P], false, false, Y], af[P], Z, H, false, [J, B])
					}
					if (aa[P] != null && !isNaN(aa[P])) {
						x = (aa[P] / 2) * this.isObject(L) ? L[P].units : L;
						if (this.lineErrorType == "bar") {
							this.addToRender(["drawLine", "error", A, j, A + x, j, ad, F, "butt"], false, false, H);
							this.addToRender(["drawLine", "error", A, j, A - x, j, ad, F, "butt"], false, false, H)
						} else {
							r[0].push([A + x, A - x]);
							r[1].push([j, j]);
							V.push([A, j])
						}
					}
					if (this.lineType == "spline") {
						I[0].push(A);
						I[1].push(j)
					}
				}
				if ((this.lineType != "spline" && !isNaN(A) && !isNaN(y)) || ab.length < 3) {
					ac = this.addToRender(["drawLine", "line", A, j, y, ah, ad, this.lineThickness, "butt", false, false, Y], ["Line:" + D + ":" + W], false, H, false, [J, B])
				} else {
					if (this.lineType == "spline" && isNaN(y)) {
						ac = this.addToRender(["drawLine", "spline", I[0], I[1], false, false, ad, this.lineThickness, false, false, false, Y], ["Line:" + D], false, H, false, [J, B]);
						I = [
							[],
							[]
						];
						J = null;
						B = null
					}
				}
				if (!H) {
					H = ac
				}
				if (r[1].length > 0 && isNaN(y)) {
					var v = this.addColorTransparency(ad, 0.3);
					if (this.lineType == "spline") {
						this.addToRender(["drawShape", "confidence", r[0], r[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
					} else {
						var C = G();
						this.addToRender(["drawShape", "path", C[0], C[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
					}
					r = [
						[],
						[]
					];
					V = []
				}
				j += X;
				ah += X
			}
			if (!isNaN(y)) {
				if (this.lineDecoration && N) {
					this.addToRender(["drawShape", N, y, j, E, E, ad, ae, O[R], false, false, Y], af[R], Z, H, false, [J, B])
				} else {
					this.addToRender(["drawShape", "sphere", y, j, E, E, this.addColorTransparency(ad, 0), "rgba(0,0,0,0)", O[R], false, false, Y], af[R], Z, H, false, [J, B])
				}
				if (aa[R] != null && !isNaN(aa[R])) {
					x = (aa[R] / 2) * this.isObject(L) ? L[R].units : L;
					if (this.lineErrorType == "bar") {
						this.addToRender(["drawLine", "error", y, j, y + x, j, ad, -F, "butt"], false, false, H);
						this.addToRender(["drawLine", "error", y, j, y - x, j, ad, -F, "butt"], false, false, H)
					} else {
						r[0].push([y + x, y - x]);
						r[1].push([j, j]);
						V.push([y, j])
					}
				}
				if (this.lineType == "spline") {
					I[0].push(y);
					I[1].push(j)
				}
			}
			if (this.lineType == "spline") {
				this.addToRender(["drawLine", "spline", I[0], I[1], false, false, ad, this.lineThickness, false, false, false, Y], ["Line:" + D], false, null, false, [J, B])
			}
			if (r[1].length > 0) {
				var v = this.addColorTransparency(ad, 0.3);
				if (this.lineType == "spline") {
					this.addToRender(["drawShape", "confidence", r[0], r[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
				} else {
					var C = G();
					this.addToRender(["drawShape", "path", C[0], C[1], false, false, v, v, "closed"], ["Line-Error:" + D], false, null, false, V)
				}
			}
		}
	};
	this.drawStackedPlot = function(N, G, A, s, P, C, K, y, m, D, O, B, Q, F, H, L) {
		this.functionCaller = "drawStackedPlot";
		var h = A;
		var r = G;
		var j = this;
		var J = function(c, e, b, d, a) {
			return j.processTreemap(c, {
				width: d,
				height: a,
				left: e,
				top: b
			})
		};
		if (D == "vertical") {
			A = h - m;
			for (var I = 0; I < N.length; I++) {
				if (N[I] > 0) {
					var x = C ? (N[I] * 100 / K[0]) * y : N[I] * y;
					if (this.graphType == "Network") {
						this.addToRender(["drawShape", "rectangle", G + (s / 2), A - (x / 2), s, x, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
					} else {
						if (P) {
							var E = J(P[I], G, A - x, s, x);
							this.drawTreemap(E, 0, 0)
						} else {
							this.addToRender(["drawShape", "rectangle", G + (s / 2), A - (x / 2), s, x, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
						}
					}
					A -= x
				}
			}
			A = h - m;
			for (var I = N.length - 1; I >= 0; I--) {
				if (N[I] < 0) {
					var x = C ? (N[I] * 100 / -K[1]) * y : N[I] * y;
					if (this.graphType == "Network") {
						this.addToRender(["drawShape", "rectangle", G + (s / 2), A - (x / 2), s, -x, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
					} else {
						if (P) {
							var E = J(P[I], G, A - x, s, -x);
							this.drawTreemap(E, 0, 0)
						} else {
							this.addToRender(["drawShape", "rectangle", G + (s / 2), A - (x / 2), s, -x, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
						}
					}
					A -= x
				}
			}
		} else {
			G = r + m;
			for (var I = 0; I < N.length; I++) {
				if (N[I] > 0) {
					var x = C ? (N[I] * 100 / K[0]) * y : N[I] * y;
					if (H) {
						if (this.graphType == "Network") {
							this.addToRender(["drawShape", "rectangle", G + H - (x / 2), A + (s / 2), x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
						} else {
							if (P) {
								var E = J(P[I], G + H - x, A, x, s);
								this.drawTreemap(E, 0, 0)
							} else {
								this.addToRender(["drawShape", "rectangle", G + H - (x / 2), A + (s / 2), x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
							}
						}
						G -= x
					} else {
						if (this.graphType == "Network") {
							this.addToRender(["drawShape", "rectangle", G + (x / 2), A + (s / 2), x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
						} else {
							if (P) {
								var M = J(P[I], G, A, x, s);
								this.drawTreemap(M, 0, 0)
							} else {
								this.addToRender(["drawShape", "rectangle", G + (x / 2), A + (s / 2), x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
							}
						}
						G += x
					}
				}
			}
			G = r + m;
			for (var I = N.length - 1; I >= 0; I--) {
				if (N[I] < 0) {
					var x = C ? (N[I] * 100 / -K[1]) * y : N[I] * y;
					if (H) {
						if (this.graphType == "Network") {
							this.addToRender(["drawShape", "rectangle", G + H - (x / 2), A + (s / 2), -x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
						} else {
							if (P) {
								var E = J(P[I], G + H - x, A, -x, s);
								this.drawTreemap(E, 0, 0)
							} else {
								this.addToRender(["drawShape", "rectangle", G + H - (x / 2), A + (s / 2), -x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
							}
						}
						G -= x
					} else {
						if (this.graphType == "Network") {
							this.addToRender(["drawShape", "rectangle", G + (x / 2), A + (s / 2), -x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F)
						} else {
							if (P) {
								var M = J(P[I], G, A, -x, s);
								this.drawTreemap(M, 0, 0)
							} else {
								this.addToRender(["drawShape", "rectangle", G + (x / 2), A + (s / 2), -x, s, O[I], this.objectBorderColor ? this.objectBorderColor : this.foreground, B[I]], Q[I], F, null, false, L)
							}
						}
						G += x
					}
				}
			}
		}
	};
	this.drawAreaPlot = function(ag, Y, R, P, ac, S, ae, U, I, C, g, W, ad, ai, V, ak, aj, L, F) {
		this.functionCaller = "drawAreaPlot";
		var X = ag.length - 1;
		var Z = ad && this.lineType == "rect" ? "path" : this.lineType == "rect" ? "polygon" : "spline";
		var u = [];
		var A = [];
		var T = [];
		var al = -C * I;
		var B = g * I;
		var K = function(b, a) {
			for (var c = a + 1; c < ag[b].length; c++) {
				if (ag[b][c] > 0) {
					return 1
				} else {
					if (ag[b][c] < 0) {
						return -1
					}
				}
			}
			return 0
		};
		if (W == "vertical") {
			for (var ab = 0; ab < ag[0].length; ab++) {
				u[ab] = ae == "stacked" && C < 0 ? R - B : R;
				A[ab] = R - B
			}
			for (var ab = 0; ab < ag.length; ab++) {
				var af = Y;
				var O = ad ? [] : [Y];
				var M = ad ? [] : [R - al];
				var G = 0;
				var ah, J;
				for (var aa = 0; aa < ag[0].length; aa++) {
					if (isNaN(ag[ab][aa])) {
						if (!ad) {
							O.push(af - S);
							M.push(R - al)
						}
						if (ad && this.lineType == "spline") {
							this.addToRender(["drawLine", Z, O, M, false, false, ai[ab], this.lineThickness], ak[ab], aj, null, false, R - al)
						} else {
							if (C >= 0 && X > 0 && ae != "normal") {
								var D = T[T.length - 1][1];
								O.shift();
								var E = [];
								var am = [];
								for (var ab = 1; ab < M.length; ab++) {
									E.push([O[ab - 1], O[ab - 1]]);
									am.push([M[ab], D[ab]])
								}
								this.addToRender(["drawShape", "confidence", E, am, this.width, this.height, ai[X], this.objectBorderColor ? this.objectBorderColor : ai[X], V[X]], ak[X], aj, null, false, R - al)
							} else {
								this.addToRender(["drawShape", Z, O, M, this.width, this.height, ai[ab], this.objectBorderColor ? this.objectBorderColor : ai[ab], V[ab]], ak[ab], aj, null, false, R - al)
							}
						}
						if (F) {
							var m = this.addColorTransparency(ai[ab], 0);
							for (var H = 0; H < O.length; H++) {
								ah = this.addToRender(["drawShape", "sphere", O[H], M[H], S, S, m, "rgba(0,0,0,0)", V[ab]], [ak[ab][0], F[H]], false, null, true);
								if (!ad) {
									this.addToRender(["drawLine", "line", O[H], M[H] + S, O[H], M[0], m, S], [ak[ab][0], F[H]], false, ah, true)
								}
							}
						}
						O = ad ? [] : [af + S];
						M = ad ? [] : [R - al]
					} else {
						var Q = ae == "percent" ? ((ag[ab][aa] - C) * 100 / U[aa]) * I : (ag[ab][aa] - (ae == "stacked" && C < 0 ? 0 : C)) * I;
						O.push(af);
						if (ae && (ae == "stacked" || ae == "percent")) {
							if (ag[ab][aa] > 0 || G > 0) {
								M.push(u[aa] - Q);
								u[aa] -= Q;
								G = 1
							} else {
								if (ag[ab][aa] < 0 || G < 0) {
									M.push(A[aa] - Q);
									A[aa] -= Q;
									G = -1
								} else {
									var N = K(ab, aa);
									if (N < 0) {
										M.push(A[aa] - Q);
										A[aa] -= Q;
										G = -1
									} else {
										if (N > 0) {
											M.push(u[aa] - Q);
											u[aa] -= Q;
											G = 1
										} else {
											M.push(al)
										}
									}
								}
							}
						} else {
							M.push(R - Q)
						}
					}
					af += S
				}
				if (!ad) {
					O.push(Y + P);
					M.push(R - al)
				}
				T.push([O, M, ai[ab], V[ab], ak[ab]])
			}
		} else {
			for (var ab = 0; ab < ag[0].length; ab++) {
				u[ab] = L ? Y + L : ae == "stacked" && C < 0 ? Y + B : Y;
				A[ab] = Y + B
			}
			for (var ab = 0; ab < ag.length; ab++) {
				var af = R;
				var O = ad ? [] : L ? [Y + L] : [Y + al];
				var M = ad ? [] : [R];
				var G = 0;
				var ah, J;
				for (var aa = 0; aa < ag[0].length; aa++) {
					if (isNaN(ag[ab][aa])) {
						if (!ad) {
							O.push(L ? Y + L : Y + al);
							M.push(af - S)
						}
						if (ad && this.lineType == "spline") {
							this.addToRender(["drawLine", Z, O, M, false, false, ai[ab], this.lineThickness], ak[ab], aj, null, false, Y + al)
						} else {
							var D = T[T.length - 1][0];
							if (C >= 0 && X > 0 && ae != "normal") {
								M.shift();
								var E = [];
								var am = [];
								for (var ab = 1; ab < O.length; ab++) {
									E.push([O[ab], D[ab]]);
									am.push([M[ab - 1], M[ab - 1]])
								}
								this.addToRender(["drawShape", "confidence", E, am, this.width, this.height, ai[X], this.objectBorderColor ? this.objectBorderColor : ai[X], V[X]], ak[X], aj, null, false, Y + al)
							} else {
								this.addToRender(["drawShape", Z, O, M, this.width, this.height, ai[ab], this.objectBorderColor ? this.objectBorderColor : ai[ab], V[ab]], ak[ab], aj, null, false, Y + al)
							}
						}
						if (F) {
							var m = this.addColorTransparency(ai[ab], 0);
							for (var H = 0; H < O.length; H++) {
								ah = this.addToRender(["drawShape", "sphere", O[H], M[H], S, S, m, "rgba(0,0,0,0)", V[ab]], [ak[ab][0], F[H]], false, null, true);
								if (!ad) {
									this.addToRender(["drawLine", "line", O[H] - S, M[H], O[0], M[H], m, S], [ak[ab][0], F[H]], false, ah, true)
								}
							}
						}
						O = ad ? [] : [L ? Y + L : Y + al];
						M = ad ? [] : [af + S]
					} else {
						var Q = ae == "percent" ? ((ag[ab][aa] - C) * 100 / U[aa]) * I : (ag[ab][aa] - (ae == "stacked" && C < 0 ? 0 : C)) * I;
						M.push(af);
						if (ae && (ae == "stacked" || ae == "percent")) {
							if (L) {
								O.push(u[aa] - Q);
								u[aa] -= Q
							} else {
								if (ag[ab][aa] > 0 || G > 0) {
									O.push(u[aa] + Q);
									u[aa] += Q;
									G = 1
								} else {
									if (ag[ab][aa] < 0 || G < 0) {
										O.push(A[aa] + Q);
										A[aa] += Q;
										G = -1
									} else {
										var N = K(ab, aa);
										if (N < 0) {
											O.push(A[aa] + Q);
											A[aa] += Q;
											G = -1
										} else {
											if (N > 0) {
												O.push(u[aa] + Q);
												u[aa] += Q;
												G = 1
											} else {
												M.push(al)
											}
										}
									}
								}
							}
						} else {
							O.push(L ? Y + L - Q : Y + Q)
						}
					}
					af += S
				}
				if (!ad) {
					O.push(L ? Y + L : Y + al);
					M.push(R + ac)
				}
				T.push([O, M, ai[ab], V[ab], ak[ab]])
			}
		}
		while (X >= 0) {
			var ah, J;
			var aa = T.pop();
			if (ad && this.lineType == "spline") {
				this.addToRender(["drawLine", Z, aa[0], aa[1], false, false, aa[2], this.lineThickness], aa[4], aj, null, false, W == "vertical" ? R - al : Y + al)
			} else {
				if (C >= 0 && X > 0 && ae != "normal") {
					var D = W == "vertical" ? T[T.length - 1][1] : T[T.length - 1][0];
					if (W == "vertical") {
						aa[0].shift();
						aa[0].pop();
						var E = [];
						var am = [];
						for (var ab = 1; ab < aa[1].length - 1; ab++) {
							E.push([aa[0][ab - 1], aa[0][ab - 1]]);
							am.push([aa[1][ab], D[ab]])
						}
						aa[1].shift();
						aa[1].pop();
						this.addToRender(["drawShape", "confidence", E, am, this.width, this.height, aa[2], this.objectBorderColor ? this.objectBorderColor : aa[2], aa[3]], aa[4], aj, null, false, R - al)
					} else {
						aa[1].shift();
						aa[1].pop();
						var E = [];
						var am = [];
						for (var ab = 1; ab < aa[0].length - 1; ab++) {
							E.push([aa[0][ab], D[ab]]);
							am.push([aa[1][ab - 1], aa[1][ab - 1]])
						}
						aa[0].shift();
						aa[0].pop();
						this.addToRender(["drawShape", "confidence", E, am, this.width, this.height, aa[2], this.objectBorderColor ? this.objectBorderColor : aa[2], aa[3]], aa[4], aj, null, false, Y + al)
					}
				} else {
					this.addToRender(["drawShape", Z, aa[0], aa[1], this.width, this.height, aa[2], this.objectBorderColor ? this.objectBorderColor : aa[2], aa[3]], aa[4], aj, null, false, W == "vertical" ? R - al : Y + al)
				}
			}
			if (F) {
				var m = this.addColorTransparency(aa[2], 0);
				for (var ab = 0; ab < aa[0].length; ab++) {
					ah = this.addToRender(["drawShape", "sphere", aa[0][ab], aa[1][ab], S, S, m, "rgba(0,0,0,0)", aa[3]], [aa[4][0], F[ab]], false, null, true);
					if (!ad) {
						if (W == "vertical") {
							this.addToRender(["drawLine", "line", aa[0][ab], aa[1][ab] + S, aa[0][ab], aa[1][0], m, S], [aa[4][0], F[ab]], false, ah, true)
						} else {
							this.addToRender(["drawLine", "line", aa[0][ab] - S, aa[1][ab], aa[0][0], aa[1][ab], m, S], [aa[4][0], F[ab]], false, ah, true)
						}
					}
				}
			}
			X--
		}
	};
	this.drawBoxPlot = function(S, L, D, A, H, C, K, J, T, I, V, Q) {
		this.functionCaller = "drawBoxPlot";
		var y = function(a) {
			return J == "vertical" ? D - ((a - K) * C) : L + ((a - K) * C)
		};
		var U = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var E = this.variableSeparationFactor / 2;
		var O = A / 2;
		var n = O / 2;
		var k = n / 2;
		var R = A / this.boxPlotOutliersRatio;
		var x = {};
		if (J == "vertical") {
			for (var N = 0; N < S.length; N++) {
				var G = L + O;
				var B = [];
				var P = [];
				var e = this.showBoxplotOriginalData || this.showViolinBoxplot ? Q[N] : T[N];
				for (var M = 0; M < 5; M++) {
					B.push(y(S[N][M]));
					P.push(B[B.length - 1].toString())
				}
				var F = this.addToRender(["drawShape", "rectangle", (L + E) + ((A - this.variableSeparationFactor) / 2), B[3] + ((B[2] - B[3]) / 2), A - this.variableSeparationFactor, B[2] - B[3], T[N], this.objectBorderColor ? this.objectBorderColor : T[N], I[N]], V[N], false, null, false, D);
				if (this.unique(P).length != 1) {
					this.addToRender(["drawLine", "median", L + E, B[4], L + (A - E), B[4], this.boxplotMedianColor, this.boxplotMedianWidth, "butt"], false, false, F);
					this.addToRender(["drawLine", "error", G, B[2], G, B[0], U, -O, "butt"], false, false, F);
					this.addToRender(["drawLine", "error", G, B[3], G, B[1], U, -O, "butt"], false, false, F)
				}
				if (this.boxplotMean) {
					this.addToRender(["drawShape", "rectangle", G, y(S[N][6]), n, n, this.boxplotMeanColor, this.boxplotMeanColorBorder], false, false, F, false, D)
				}
				if (S[N][5]) {
					for (var M = 0; M < S[N][5].length; M++) {
						this.addToRender(["drawShape", "sphere", G, y(S[N][5][M]), R, R, T[N], U, I[N]], ["Outlier:" + S[N][5][M]], false, F, false, D)
					}
				}
				if (!x.hasOwnProperty(e)) {
					x[e] = []
				}
				x[e].push([L + E + (A / 2), B[4]]);
				L += H
			}
		} else {
			for (var N = 0; N < S.length; N++) {
				var G = D + O;
				var B = [];
				var P = [];
				var e = this.showBoxplotOriginalData || this.showViolinBoxplot ? Q[N] : T[N];
				for (var M = 0; M < 5; M++) {
					B.push(y(S[N][M]));
					P.push(B[B.length - 1].toString())
				}
				var F = this.addToRender(["drawShape", "rectangle", B[2] + ((B[3] - B[2]) / 2), (D + E) + ((A - this.variableSeparationFactor) / 2), B[3] - B[2], A - this.variableSeparationFactor, T[N], this.objectBorderColor ? this.objectBorderColor : T[N], I[N]], V[N], false, null, false, L);
				if (this.unique(P).length != 1) {
					this.addToRender(["drawLine", "median", B[4], D + E, B[4], D + (A - E), this.boxplotMedianColor, this.boxplotMedianWidth, "butt"], false, false, F);
					this.addToRender(["drawLine", "error", B[2], G, B[0], G, U, O, "butt"], false, false, F);
					this.addToRender(["drawLine", "error", B[3], G, B[1], G, U, O, "butt"], false, false, F)
				}
				if (this.boxplotMean) {
					this.addToRender(["drawShape", "rectangle", y(S[N][6]), G, n, n, this.boxplotMeanColor, this.boxplotMeanColorBorder], false, false, F, false, L)
				}
				if (S[N][5]) {
					for (var M = 0; M < S[N][5].length; M++) {
						this.addToRender(["drawShape", "sphere", y(S[N][5][M]), G, R, R, T[N], U, I[N]], ["Outlier:" + S[N][5][M]], false, F, false, L)
					}
				}
				if (!x.hasOwnProperty(e)) {
					x[e] = []
				}
				x[e].push([B[4], D + E + (A / 2)]);
				D += H
			}
		}
		if (this.boxplotConnect) {
			for (var e in x) {
				if (x[e].length > 1) {
					var F = this.addToRender(["drawLine", "line", x[e][0][0], x[e][0][1], x[e][1][0], x[e][1][1], e, this.boxplotConnectWidth, "butt"], ["Line:"], false);
					for (var N = 1; N < x[e].length - 1; N++) {
						this.addToRender(["drawLine", "line", x[e][N][0], x[e][N][1], x[e][N + 1][0], x[e][N + 1][1], e, this.boxplotConnectWidth, "butt"], ["Line:"], false, F)
					}
				}
			}
		}
	};
	this.drawCandlestickPlot = function(M, H, B, q, L, A, G, E, F, N, P) {
		this.functionCaller = "drawCandlestickPlot";
		var e = function(a) {
			return F == "vertical" ? B - ((a - G) * A) : H + ((a - G) * A)
		};
		var O = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var K = q / 2;
		if (F == "vertical") {
			for (var J = 0; J < M.length; J++) {
				var D = H + K;
				var s = [];
				for (var I = 0; I < M[J].length; I++) {
					s.push(e(M[J][I]))
				}
				if (E) {
					if (s[0] > s[1]) {
						var n = H + (q / 2);
						var k = s[1] + ((s[0] - s[1]) / 2);
						var C = this.addToRender(["drawShape", "rectangle", n, k, q, s[0] - s[1], false, N, "open"], P[J]);
						this.addToRender(["drawLine", "line", D, s[1], D, s[2], N, false, "butt"], false, false, C, false, B);
						this.addToRender(["drawLine", "line", D, s[3], D, s[0], N, false, "butt"], false, false, C, false, B)
					} else {
						var n = H + (q / 2);
						var k = s[0] + ((s[1] - s[0]) / 2);
						var C = this.addToRender(["drawShape", "rectangle", n, k, q, s[1] - s[0], N, N, "closed"], P[J]);
						this.addToRender(["drawLine", "line", D, s[3], D, s[1], N, false, "butt"], false, false, C, false, B);
						this.addToRender(["drawLine", "line", D, s[0], D, s[2], N, false, "butt"], false, false, C, false, B)
					}
				} else {
					this.addToRender(["drawShape", "rectangle", H + (q / 2), s[0] + ((B - s[0]) / 2), q, B - s[0], N, N, "closed"], P[J])
				}
				H += L
			}
		} else {
			for (var J = 0; J < M.length; J++) {
				var D = B + K;
				var s = [];
				for (var I = 0; I < M[J].length; I++) {
					s.push(e(M[J][I]))
				}
				if (E) {
					if (s[1] > s[0]) {
						var n = s[0] + ((s[1] - s[0]) / 2);
						var k = B + (q / 2);
						var C = this.addToRender(["drawShape", "rectangle", n, k, s[1] - s[0], q, false, N, "open"], P[J]);
						this.addToRender(["drawLine", "line", s[1], D, s[2], D, N, false, "butt"], false, false, C, false, H);
						this.addToRender(["drawLine", "line", s[3], D, s[0], D, N, false, "butt"], false, false, C, false, H)
					} else {
						var n = s[1] + ((s[0] - s[1]) / 2);
						var k = B + (q / 2);
						var C = this.addToRender(["drawShape", "rectangle", n, k, s[0] - s[1], q, N, N, "closed"], P[J]);
						this.addToRender(["drawLine", "line", s[3], D, s[1], D, N, false, "butt"], false, false, C, false, H);
						this.addToRender(["drawLine", "line", s[0], D, s[2], D, N, false, "butt"], false, false, C, false, H)
					}
				} else {
					this.addToRender(["drawShape", "rectangle", H + ((s[0] - H) / 2), B + (q / 2), s[0] - H, q, N, N, "closed"], P[J])
				}
				B += L
			}
		}
	};
	this.drawViolin = function(J, E, s, I, r, C, A, K, z, w) {
		this.functionCaller = "drawViolin";
		var e = J.kde;
		var j = [];
		var F = [];
		var g = [];
		var B = [];
		var b = [
			[],
			[]
		];
		var n, k;
		var a = [];
		if (e.length < 3) {
			e.splice(1, 0, [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2])
		}
		for (var H = 0; H < e.length; H++) {
			a.push(e[H][1])
		}
		var G = this.max(a);
		if (G == 0) {
			for (var H = 1; H < e.length - 1; H++) {
				e[H][1] = 0.000001
			}
			G = 0.000001
		}
		var D = (I / 2.2) / (G);
		var v = this.addColorTransparency(K, 0.25);
		if (A == "vertical") {
			for (var H = 0; H < e.length; H++) {
				n = (e[H][1] * D);
				k = ((e[H][0] - C) * r);
				j.push(E - n);
				F.push(s - k);
				g.push(E + n);
				B.push(s - k);
				b[0].push(E);
				b[1].push(s - k)
			}
		} else {
			for (var H = 0; H < e.length; H++) {
				n = ((e[H][0] - C) * r);
				k = (e[H][1] * D);
				j.push(E + n);
				F.push(s - k);
				g.push(E + n);
				B.push(s + k);
				b[0].push(E + n);
				b[1].push(s)
			}
		}
		this.addToRender(["drawShape", "violin", [j, g],
			[F, B], false, false, v, this.foreground, z
		], ["Violin:" + w], false, null, false, b)
	};
	this.drawDotPlot = function(ae, ad, W, O, aa, R, N, V, P, T, ag, X, S, ai, L, Q, K, G, F) {
		this.functionCaller = "drawDotPlot";
		var J = this;
		var g = function() {
			var e = J.jitterColumns % 2 ? J.jitterColumns : J.jitterColumns + 1;
			var b = Math.max(aa - J.sizes[0], J.sizes[0]) / (e - 1);
			var a = [0];
			var c = 1;
			for (var d = 0; d < e / 2; d += 2) {
				a.push(c * -b);
				a.push(c * b);
				c++
			}
			return a
		};
		var C = [];
		var E = g();
		var ah = this.getOutlineColor();
		if (T == "vertical") {
			for (var Z = 0; Z < ae.length; Z++) {
				if (this.showViolinBoxplot && this.isRawData && ae[Z].length > 1) {
					this.drawViolin(this.getViolin(ae[Z]), W, O, aa, N, V, T, ag[Z][0], X[Z][0], G + ":" + Z)
				}
				if ((this.showBoxplotOriginalData && this.isRawData) || this.graphType.match(/Dot/) || (this.graphType.match(/Bar/) && this.barType == "lollipop" && !this.isGroupedData)) {
					for (var Y = 0; Y < ae[Z].length; Y++) {
						var U = this.jitter ? E[Y % E.length] : 0;
						var x = ai ? ai[Z][Y] : false;
						var M = O - ((ae[Z][Y] - V) * N);
						if (!isNaN(M)) {
							var af = this.addToRender(["drawShape", S[Z][Y], W + U, M, P[Z][Y], P[Z][Y], ag[Z][Y], ah || ag[Z][Y], X[Z][Y], false, false, Q], x, L, null, false, O);
							C.push([W + U, M, P[Z][Y] / 2, x]);
							if (!this.isGroupedData) {
								if (ad[Z] && ad[Z][Y] && !isNaN(ad[Z][Y])) {
									var aj = (ad[Z][Y] / 2) * N;
									this.addToRender(["drawLine", "error", W + U, M, W + U, M + aj, ag[Z][Y], -aa, "butt", false, false, true], false, false, af);
									this.addToRender(["drawLine", "error", W + U, M, W + U, M - aj, ag[Z][Y], -aa, "butt", false, false, true], false, false, af)
								}
							}
						} else {
							C.push([W + U, Number.NaN, P[Z][Y] / 2, x])
						}
					}
					if (this.showErrorBars && this.isGroupedData && ad[Z] && ad[Z] && !isNaN(ad[Z][0]) && !isNaN(ad[Z][1])) {
						var M = O - ((ad[Z][0] - V) * N);
						var aj = (ad[Z][1] / 2) * N;
						this.addToRender(["drawShape", "diamond", W, M, this.margin * 2, this.margin * 2, this.foreground, this.foreground, "closed", false, false, Q]);
						this.addToRender(["drawLine", "line", W, M - aj, W, M + aj, this.foreground, this.lineThickness * 2, "butt", false, false, Q])
					}
				}
				W += R
			}
		} else {
			for (var Z = 0; Z < ae.length; Z++) {
				if (this.showViolinBoxplot && this.isRawData && ae[Z].length > 1) {
					this.drawViolin(this.getViolin(ae[Z]), W, this.jitter ? O + (f / 2) : O, aa, N, V, T, ag[Z][0], X[Z][0], G + ":" + Z)
				}
				if ((this.showBoxplotOriginalData && this.isRawData) || this.graphType.match(/Dot/) || (this.graphType.match(/Bar/) && this.barType == "lollipop" && !this.isGroupedData)) {
					for (var Y = 0; Y < ae[Z].length; Y++) {
						var U = this.jitter ? E[Y % E.length] : 0;
						var x = ai ? ai[Z][Y] : false;
						var M = K ? W + K - ((ae[Z][Y] - V) * N) : W + ((ae[Z][Y] - V) * N);
						if (!isNaN(M)) {
							var af = this.addToRender(["drawShape", S[Z][Y], M, O + U, P[Z][Y], P[Z][Y], ag[Z][Y], ah || ag[Z][Y], X[Z][Y], false, false, Q], x, L, null, false, W);
							C.push([M, O + U, P[Z][Y] / 2, x]);
							if (!this.isGroupedData) {
								if (ad[Z] && ad[Z][Y] && !isNaN(ad[Z][Y])) {
									var aj = (ad[Z][Y] / 2) * N;
									this.addToRender(["drawLine", "error", M, O + U, M + aj, O + U, ag[Z][Y], aa, "butt", false, false, true], false, false, af);
									this.addToRender(["drawLine", "error", M, O + U, M - aj, O + U, ag[Z][Y], aa, "butt", false, false, true], false, false, af)
								}
							}
						} else {
							C.push([Number.NaN, O + U, P[Z][Y] / 2, x])
						}
					}
				}
				if (this.showErrorBars && this.isGroupedData && ad[Z] && ad[Z] && !isNaN(ad[Z][0]) && !isNaN(ad[Z][1])) {
					var M = W + ((ad[Z][0] - V) * N);
					var aj = (ad[Z][1] / 2) * N;
					this.addToRender(["drawShape", "diamond", M, O, this.margin * 2, this.margin * 2, this.foreground, this.foreground, "closed", false, false, Q]);
					this.addToRender(["drawLine", "line", M - aj, O, M + aj, O, this.foreground, this.lineThickness * 2, "butt", false, false, Q])
				}
				O += R
			}
		}
		if (this.connectBy && this.data.x && this.data.x.hasOwnProperty(this.connectBy) && this.isRawData) {
			var z = this.connectBy == this.colorBy ? this.meta.data.x[this.colorBy] : false;
			for (var Z in this.connectByData) {
				var af;
				var I = null;
				var ae = this.connectByData[Z];
				var H = z && z.type != "Numeric" ? z.colors[z.order[Z] % z.colors.length] : this.getColorForValue(z.colorBrew, Z);
				if (ae.length > 1) {
					for (var Y = 1; Y < ae.length; Y++) {
						var M = C[ae[Y - 1]];
						var aj = C[ae[Y]];
						af = this.addToRender(["drawLine", "line", M[0], M[1], aj[0], aj[1], H, this.connectByWidth, "butt", M[2], aj[2], Q], ["Line:" + this.connectBy + " " + Z], false, I);
						if (I == null) {
							I = af
						}
					}
				}
			}
		} else {
			if (this.connectBy && this.data.z && this.data.z.hasOwnProperty(this.connectBy) && this.isRawData) {
				this.connectByDataVar.push(C);
				if (F) {
					var z = this.connectBy == this.colorBy ? this.meta.data.z[this.colorBy] : false;
					for (var Z in this.connectByData) {
						var ae = this.connectByData[Z];
						if (ae.length > 1) {
							for (var X = 0; X < this.connectByDataVar[0].length; X++) {
								for (var Y = 1; Y < ae.length; Y++) {
									var M = this.connectByDataVar[ae[Y - 1]][X];
									var aj = this.connectByDataVar[ae[Y]][X];
									var ac = Z;
									if (M && aj) {
										var D = this.data.y.vars[M[3][0]];
										var ab = this.data.y.vars[aj[3][0]];
										var B = this.data.y.smps[M[3][(this.isGroupedData ? 2 : 1)]];
										var A = this.data.y.smps[aj[3][(this.isGroupedData ? 2 : 1)]];
										if (B == A) {
											ac = D + " - " + ab + " (" + B + ")"
										} else {
											ac = D + " (" + B + ") - " + ab + " (" + A + ")"
										}
									}
									this.addToRender(["drawLine", "line", M[0], M[1], aj[0], aj[1], this.connectByColor, this.connectByWidth, "butt", M[2], aj[2], Q], ["Line:" + this.connectBy + " " + ac])
								}
							}
						}
					}
				}
			}
		}
	};
	this.drawHeatmap = function(F, A, q, j, C, E, I, D, x, H) {
		this.functionCaller = "drawHeatmap";
		var n = 0;
		var g = A;
		var s = 0.5;
		var z = this.meta.vals;
		if (!z.colors) {
			z.colors = {}
		}
		for (var B = 0; B < F.length; B++) {
			var k = F[B];
			var G = isNaN(k) ? this.missingDataColor : z.colors[k.toString()] ? z.colors[k.toString()] : this.getColorForValue(H, k);
			var y = E ? G : this.heatmapCellBoxColor;
			z.colors[k.toString()] = G;
			if (this.graphType == "Network") {
				if (this.shapeByShape) {
					this.addToRender(["drawShape", this.shapeByShape, A + (j / 2), q + (C / 2), j / 2, C / 2, G, y, x[B]], I[B], D)
				} else {
					this.addToRender(["drawShape", "rectangle", A + (j / 2), q + (C / 2), j, C, G, G, x[B]], I[B], D)
				}
			} else {
				if (this.shapeByShape) {
					this.addToRender(["drawShape", this.shapeByShape, A + (j / 2), q + (C / 2), j / 2, C / 2, G, y, x ? x[B] : false], I[B], D)
				} else {
					if (B > 0 && B < F.length - 1) {
						if (n >= 0.5) {
							this.addToRender(["drawShape", "rect", A + ((j + s) / 2), q + ((C + s) / 2), j + s, C + s, G, G, x ? x[B] : false], I[B], D, null, false, [g, q + ((C + s) / 2), 0, C + s]);
							n = 0
						}
					} else {
						this.addToRender(["drawShape", "rect", A + ((j + s) / 2), q + ((C + s) / 2), j + s, C + s, G, G, x ? x[B] : false], I[B], D, null, false, [g, q + ((C + s) / 2), 0, C + s])
					}
				}
			}
			if (this.showDataValues) {
				this.addToRender(["drawText", this.correctPrecisionBug(k), (A + j) - 2, (q + C) - 2, this.overlayFont, this.foreground, "right", "bottom"])
			}
			A += j;
			n += j
		}
	};
	this.drawTreemap = function(C, v, q, D, E) {
		this.functionCaller = "drawTreemap";
		var g = this;
		var s = this.graphOrientation == "vertical" ? this.top + this.y : this.left;
		var m = function(d, c) {
			g.functionCaller = "drawTreemap";
			if (c) {
				g.addToRender(["drawShape", "rectangle", (d.coords.left + v) + (d.coords.width / 2), (d.coords.top + q) + (d.coords.height / 2), d.coords.width, d.coords.height, false, g.objectBorderColor ? g.objectBorderColor : false, "open", false, d.outline, D, E], false, false, null, false, s)
			} else {
				g.addToRender(["drawShape", "rectangle", (d.coords.left + v) + (d.coords.width / 2), (d.coords.top + q) + (d.coords.height / 2), d.coords.width, d.coords.height, d.color, g.objectBorderColor ? g.objectBorderColor : false, "closed", false, false, D, E], d.index, false, null, false, s)
			}
			if (d.label) {
				var b = g.measureText(d.label, g.overlayFont);
				if (b + g.margin < d.coords.width && g.overlayFontSize + g.margin < d.coords.height) {
					if (c) {
						g.addToRender(["drawText", d.label, d.coords.left + v + (d.coords.width / 2), d.coords.top + q + (d.coords.height / 2), g.overlayFont, g.addColorTransparency(g.foreground, 0.5), "center", "middle"])
					} else {
						g.addToRender(["drawText", d.label, d.coords.left + v + g.margin, d.coords.top + q + g.margin, g.overlayFont, g.foreground, "left", "top"])
					}
				} else {
					if (b + g.margin < d.coords.height && g.overlayFontSize + g.margin < d.coords.width) {
						if (c) {
							g.addToRender(["drawText", d.label, d.coords.left + v + (d.coords.width / 2), d.coords.top + q + (d.coords.height / 2), g.overlayFont, g.addColorTransparency(g.foreground, 0.5), "center", "middle", -Math.PI / 2])
						} else {
							g.addToRender(["drawText", d.label, d.coords.left + v + g.margin, d.coords.top + q + g.margin, g.overlayFont, g.foreground, "right", "top", -Math.PI / 2])
						}
					}
				}
			}
		};
		var u = function(c) {
			for (var b = 0; b < c.length; b++) {
				if (c[b].children) {
					u(c[b].children);
					m(c[b], true)
				} else {
					m(c[b])
				}
			}
		};
		for (var z = 0; z < C.length; z++) {
			var a = C[z];
			var r = this.treemapBorderWidth ? 1 : 0;
			var F = this.treemapBorderWidth;
			var p = F * 2;
			var e = this.smpLabelFontSize * r;
			var j = this.treemapBorderColor;
			var n = v + a.coords.left - F;
			var k = q + a.coords.top - (e + F);
			var o = a.coords.width + p;
			var B = a.coords.height + e + p;
			if (a.title) {
				this.addToRender(["disableGradientTransparencyShadow"]);
				if (a.coords.border > 1) {
					this.addToRender(["drawShape", "rectangle", n + (o / 2), k + ((e + (F / 2)) / 2), o, e + (F / 2), j, j, "close", false, F, D, E]);
					this.addToRender(["drawShape", "rectangle", n + (o / 2), k + (B / 2), o, B, false, j, "open", false, F, D, E])
				} else {
					if (a.coords.border > 0) {
						this.addToRender(["drawShape", "rectangle", n + (o / 2), (k + (e + F)) + ((B - (e + F)) / 2), o, B - (e + F), false, j, "open", false, F, D, E])
					} else {
						if (a.coords.border > -1) {
							this.addToRender(["drawShape", "rectangle", n + (o / 2), (k + (e + F)) + ((B - (e + F)) / 2), o, B - (e + F), false, j, "open", false, F, D, E])
						}
					}
				}
				var A = this.measureText(a.title, this.smpLabelFont);
				if (A + this.margin < o && this.smpLabelFontSize <= e && a.coords.height > e + (F / 2)) {
					this.addToRender(["drawText", a.title, n + this.margin, k + (this.smpLabelFontSize / 2), this.smpLabelFont, this.foreground, "left", "middle"])
				}
				this.addToRender(["enableGradientTransparencyShadow"])
			}
			if (a.children) {
				u(a.children)
			} else {
				m(a)
			}
		}
	};
	this.drawSankey = function(b) {
		this.functionCaller = "drawSankey";
		var g = b.links[0].target.x - b.links[0].source.x;
		for (var a = 0; a < b.links.length; a++) {
			var c = b.links[a];
			this.addToRender(["drawShape", "bezier", c.plotX, c.plotY, g, c.dy, c.color, c.color, false, c.colors], c.tooltip, false, null, false, [this.left, this.top + this.y / 2, g, c.dy])
		}
		for (var a = 0; a < b.nodes.length; a++) {
			var e = b.nodes[a];
			this.addToRender(["drawShape", "rectangle", e.plotX + (e.dx / 2), e.plotY + (e.dy / 2), e.dx, e.dy, e.color, this.foreground], e.tooltip, false, null, false, [this.left, this.top + this.y / 2, e.dx, e.dy]);
			this.addToRender(["drawText", e.name, e.plotX + (e.dx / 2), e.plotY + (e.dy / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2], [e.tooltip[0] + ":T"])
		}
	};
	this.drawTree = function(a, g) {
		this.functionCaller = "drawTree";
		if (this.data.tree && this.data.tree.plot) {
			var l = this.data.tree.plot;
			var d = this.treeNodeSize / 2;
			var i = this.treeNodeSize / 4;
			var e = a == "vertical" ? true : false;
			var h = this;
			var k = function(q) {
				var m = e ? q.x0 : q.y0;
				var p = e ? q.y0 : q.x0;
				if (q.children) {
					for (var o = 0; o < q.children.length; o++) {
						k(q.children[o])
					}
					if (e) {
						if (q.parent) {
							h.addToRender(["drawText", q.data.name, m, p - ((h.treeNodeSize / 2) + h.margin), h.smpLabelFont, h.smpLabelFontColor, "right", "middle", Math.PI / 2], ["Tree-Text:" + q.id], false, null, false, [b, j])
						} else {
							h.addToRender(["drawText", q.data.name, m, p - ((h.treeNodeSize / 2) + h.margin), h.smpLabelFont, h.smpLabelFontColor, "center", "bottom"], ["Tree-Text:" + q.id], false, null, false, [b, j])
						}
					} else {
						h.addToRender(["drawText", q.data.name, m - ((h.treeNodeSize / 2) + h.margin), p, h.smpLabelFont, h.smpLabelFontColor, "right", "middle"], ["Tree-Text:" + q.id], false, null, false, [b, j])
					}
				} else {
					if (e) {
						h.addToRender(["drawText", q.data.name, m, p + (h.treeNodeSize / 2) + h.margin, h.smpLabelFont, h.smpLabelFontColor, "left", "middle", Math.PI / 2], ["Tree-Text-:" + q.id], false, null, false, [b, j])
					} else {
						h.addToRender(["drawText", q.data.name, m + (h.treeNodeSize / 2) + h.margin, p, h.smpLabelFont, h.smpLabelFontColor, "left", "middle"], ["Tree-Text:" + q.id], false, null, false, [b, j])
					}
				}
				h.addToRender(["drawShape", q.data.shape, m, p, q.data.size, q.data.size, q.data.color, h.treeLinkColor, q.data.pattern, false, h.treeLinkWidth], ["Tree-Node:" + q.id], false, null, false, [b, j]);
				if (q._children) {
					h.addToRender(["drawLine", "line", m - i, p, m + i, p, h.foreground], ["Tree-Line1:" + q.id], false, null, false, [b, j]);
					h.addToRender(["drawLine", "line", m, p - i, m, p + i, h.foreground], ["Tree-Line2:" + q.id], false, null, true, [b, j])
				} else {
					if (q.children) {
						h.addToRender(["drawLine", "line", m - i, p, m + i, p, h.foreground], ["Tree-Line1:" + q.id], false, null, false, [b, j])
					}
				}
			};
			var c = function(t) {
				if (t.children) {
					for (var o = 0; o < t.children.length; o++) {
						c(t.children[o])
					}
				}
				if (t.parent) {
					var m = e ? t.x0 : t.y0;
					var s = e ? t.y0 : t.x0;
					var p = e ? t.parent.x0 : t.parent.y0;
					var r = e ? t.parent.y0 : t.parent.x0;
					var q = t._clicked ? [p, r, p, r] : [b, j, b, j];
					h.addToRender(["drawLine", "bezier", p, r, m, s, h.treeLinkColor, h.treeLinkWidth, false], [t.parent.id + ":" + t.id], false, null, false, q);
					t._clicked = false
				}
			};
			var b = e ? l.x0 : l.y0;
			var j = e ? l.y0 : l.x0;
			c(l);
			if (!g) {
				k(l)
			}
		}
	};
	this.zoomOncoprintVariables = function(c) {
		this.functionCaller = "zoomOncoprintVariables";
		if (this.isTransition()) {
			return
		}
		var b = [];
		this.setOriginalIndices(false, this.varIndices, this.smpIndices);
		this.varIndicesStart = 0;
		for (var a = 0; a < Math.min(c, this.varIndices.length); a++) {
			b.push(this.varIndices[a])
		}
		this.varIndices = b;
		this.draw()
	}
};
CanvasXpress.prototype.init3dUtils = function() {
	this.setTrigonometry = function() {
		if (!this.meta.math) {
			this.meta.math = {
				sin: [0],
				cos: [1]
			};
			for (var b = 1; b <= 360; b++) {
				var a = Math.PI / (180 / b);
				this.meta.math.sin[b] = Math.sin(a);
				this.meta.math.cos[b] = Math.cos(a)
			}
		}
	};
	this.set3DRotation = function() {
		this.setTrigonometry();
		var a = ["xRotate", "yRotate", "zRotate"];
		for (var b = 0; b < a.length; b++) {
			if (this[a[b]] > 360) {
				this[a[b]] -= 360
			}
			if (this[a[b]] < 0) {
				this[a[b]] = 360
			}
		}
	};
	this.set3DParams = function() {
		var b = this.invMagnificationFactor;
		var c = this.zoom;
		var a = this.x;
		this.perspective = a * this.perspectiveFactor;
		this.lenX = a / b * c * this.x3DRatio;
		this.lenY = a / b * c * this.y3DRatio;
		this.lenZ = a / b * c * this.z3DRatio;
		this.padX = a / 2;
		this.padY = this.y / 2;
		this.padZ = this.padY
	};
	this.get3DTransfrom = function(g, a, k) {
		var f, e, b;
		var h = [];
		var n = this.meta.math.sin;
		var j = this.meta.math.cos;
		var d = this.perspective;
		var m = this.xRotate;
		var l = this.yRotate;
		var i = this.zRotate;
		e = a;
		b = k;
		a = e * j[parseInt(l)] - b * n[parseInt(l)];
		k = e * n[parseInt(l)] + b * j[parseInt(l)];
		f = g;
		b = k;
		g = b * n[parseInt(m)] + f * j[parseInt(m)];
		k = b * j[parseInt(m)] - f * n[parseInt(m)];
		f = g;
		e = a;
		g = f * j[parseInt(i)] - e * n[parseInt(i)];
		a = f * n[parseInt(i)] + e * j[parseInt(i)];
		if (this.perspective) {
			g = g * (d / (k + d));
			a = a * (d / (k + d));
			k = k * (d / (k + d))
		}
		h.push(g + this.padX);
		h.push(a + this.padY);
		h.push(k + this.padZ);
		return h
	}
};
CanvasXpress.prototype.initApiUtils = function() {
	this.getValidGraphTypes = function() {
		return this.validGraphTypes
	};
	this.setHeatmapScheme = function() {
		this.initializeAttributes()
	};
	this.hasIndicator = function() {
		if (this.graphType.match(/Scatter/) || this.graphType == "Bar") {
			return true
		} else {
			return false
		}
	};
	this.hasLegend = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap") {
			return true
		} else {
			return false
		}
	};
	this.hasLegendProperties = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap" && this.graphType != "Pie") {
			return true
		} else {
			return false
		}
	};
	this.hasData = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
			return true
		} else {
			return false
		}
	};
	this.hasDataSamples = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
			if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.hasDataGroups = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
			if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
				return false
			}
			if (this.data.x) {
				return true
			} else {
				return false
			}
		} else {
			return false
		}
	};
	this.hasDataVariables = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
			if (this.graphType == "Correlation" && this.correlationAxis != "variables") {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.hasDataProperties = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Heatmap" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation") {
			return true
		} else {
			return false
		}
	};
	this.hasOrientation = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && this.graphType != "Circular" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.hasOverlays = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.hasDendrograms = function() {
		if (this.graphType != "Heatmap" && (this.smpDendrogramNewick || this.varDendrogramNewick)) {
			return true
		} else {
			return false
		}
	};
	this.hasDecorations = function() {
		return this.decorations && (this.decorations.nlfit || this.decorations.line || this.decorations.reg || this.decorations.nor || this.decorations.area) ? true : false
	};
	this.isSegregable = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.getLineTypes = function() {
		var e = ["line"];
		var c = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
		var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
		for (var d = 0; d < a.length; d++) {
			e.push(a[d] + "Line")
		}
		for (var d = 1; d < c.length; d++) {
			for (var b = 0; b < a.length; b++) {
				e.push(c[d] + this.capitalize(a[b]) + "Line")
			}
		}
		return e
	};
	this.isValidShape = function(b) {
		for (var a = 0; a < this.shapes.length; a++) {
			if (this.shapes[a] == b) {
				return true
			}
		}
		return false
	};
	this.getHeatmapSchemes = function() {
		var c = [];
		var d = ["blue", "red", "green", "yellow", "cyan", "purple", "white", "black"];
		for (var b = 0; b < d.length; b++) {
			c.push(d[b]);
			for (var a = 0; a < d.length; a++) {
				if (d[b] != d[a]) {
					c.push(d[b] + "-" + d[a])
				}
			}
		}
		return c
	};
	this.isCompatibleGraphType = function(b, a) {
		if (b.match(/^Bar$|^Line$|Boxplot|Dotplot/)) {
			return a.match(/^Bar$|^Line$|Boxplot|Dotplot/) ? true : false
		} else {
			return false
		}
	};
	this.isOneDimensionalGraph = function() {
		return !this.graphType.match(/Scatter|Network|Venn|Genome|Circular|Correlation/)
	};
	this.modifyHighlights = function(c, b, d) {
		var a = d ? "highlightVar" : "highlightSmp";
		this.modifyObjectArray(c, b, a)
	};
	this.getHighlights = function(a) {
		return this.getObjectArray(a ? this.highlightVar : this.highlightSmp)
	};
	this.modifyOverlaysProperties = function(h) {
		this.functionCaller = "modifyOverlaysProperties";
		if (this.isTransition()) {
			return
		}
		var e = this;
		var b, a, g;
		var f = false;
		if (!this.isArray(h)) {
			var d = [];
			for (var c = 0; c < arguments.length; c++) {
				d.push(arguments[c])
			}
			h = d;
			f = true
		}
		a = h.shift();
		g = this.cloneObject(h);
		while (g.length > 1) {
			b = g.shift();
			if (!e[b]) {
				e[b] = {}
			}
			e = e[b]
		}
		b = g.shift();
		e[b] = isNaN(a) ? a : Number(a);
		if (!f) {
			h.unshift(a)
		}
		this.draw()
	};
	this.modifySmpOverlays = function(b, a) {
		this.modifyObjectArray(b, a, "smpOverlays")
	};
	this.modifyVarOverlays = function(b, a) {
		this.modifyObjectArray(b, a, "varOverlays")
	};
	this.getSmpOverlays = function() {
		return this.getObjectArray(this.smpOverlays)
	};
	this.getVarOverlays = function() {
		return this.getObjectArray(this.varOverlays)
	};
	this.getXData = function() {
		var b = [];
		if (this.data.x) {
			for (var a in this.data.x) {
				b.push(a)
			}
		}
		return b
	};
	this.getZData = function() {
		var b = [];
		if (this.data.z) {
			for (var a in this.data.z) {
				b.push(a)
			}
		}
		return b
	};
	this.getXZData = function() {
		return this.graphType.match(/Scatter/) ? this.getZData() : this.getXData()
	};
	this.getSamplesVariablesAsArray = function() {
		return this.graphType.match(/scatter/i) ? this.getSamplesAsArray() : this.getVariablesAsArray
	};
	this.getSamplesAsArray = function() {
		var d = this.getSamples();
		var b = [];
		for (var c = 0; c < d.length; c++) {
			b.push(d[c].name)
		}
		return b
	};
	this.getVariablesAsArray = function() {
		var d = this.getVariables();
		var b = [];
		for (var c = 0; c < d.length; c++) {
			b.push(d[c].name)
		}
		return b
	};
	this.getNodeData = function(a) {
		return this.getNetworkData("nodes", a)
	};
	this.getEdgeData = function(a) {
		return this.getNetworkData("edges", a)
	};
	this.getSampleVariableData = function(g, j) {
		var f = {
			smps: {
				idx: "smpIndices",
				spc: "x"
			},
			vars: {
				idx: "varIndices",
				spc: "z"
			}
		};
		var b = {};
		b[g] = {
			o: {},
			t: "string"
		};
		if (j) {
			b[g]["o"] = this.getObjectArray(this.data.y[g])
		} else {
			for (var d = 0; d < this[f[g]["idx"]].length; d++) {
				b[g]["o"][this.data.y[g][this[f[g]["idx"]][d]]] = true
			}
		}
		if (this.data[f[g]["spc"]]) {
			for (var h in this.data[f[g]["spc"]]) {
				b[h] = {
					o: {},
					t: "numeric"
				};
				if (j) {
					if (this.isNumeric(this.data[f[g]["spc"]][h])) {
						b[h]["t"] = "numeric";
						var a = this.range(this.data[f[g]["spc"]][h]);
						b[h]["o"] = {
							min: a[0],
							max: a[1]
						}
					} else {
						b[h]["t"] = "string";
						b[h]["o"] = this.getObjectArray(this.unique(this.data[f[g]["spc"]][h]))
					}
				} else {
					for (var d = 0; d < this[f[g]["idx"]].length; d++) {
						var c = this.data[f[g]["spc"]][h][this[f[g]["idx"]][d]];
						if (b[h]["o"].hasOwnProperty(c)) {
							b[h]["o"][c]++
						} else {
							b[h]["o"][c] = 1
						}
						if (isNaN(c)) {
							b[h]["t"] = "string"
						}
					}
					if (b[h]["t"] == "numeric") {
						var e = [];
						for (var c in b[h]["o"]) {
							for (var d = 0; d < b[h]["o"][c]; d++) {
								e.push(c)
							}
						}
						var a = this.range(e);
						b[h]["o"] = {
							min: a[0],
							max: a[1]
						}
					}
				}
			}
		}
		return b
	};
	this.getNetworkData = function(d, a) {
		if (this.graphType == "Network" && !this[d + "Data"]) {
			this[d + "Data"] = {};
			var f = this.skipConfigurableProperties ? this.getObjectArray(this[d.replace("s", "") + "ConfigurableProperties"]) : {};
			for (var c = 0; c < this.data[d].length; c++) {
				var e = this.data[d][c];
				for (var b in e) {
					if (!f[b]) {
						if (typeof(e[b]) != "object") {
							if (this[d + "Data"].hasOwnProperty(b)) {
								if (this[d + "Data"][b]["o"].hasOwnProperty(e[b])) {
									this[d + "Data"][b]["o"][e[b]]++
								} else {
									this[d + "Data"][b]["o"][e[b]] = 1
								}
								if (isNaN(e[b])) {
									this[d + "Data"][b]["t"] = "string"
								}
							} else {
								this[d + "Data"][b] = {
									o: {},
									t: isNaN(e[b]) ? "string" : "numeric"
								};
								this[d + "Data"][b]["o"][e[b]] = 1
							}
						}
					}
				}
				if (this[d + "Properties"].length > 0) {
					this.getAdditionalData(e, this[d + "Data"], this[d + "Properties"])
				}
			}
		}
		if (this.graphType == "Network") {
			return a ? this[d + "Data"] : this.getKeys(this[d + "Data"])
		} else {
			return false
		}
	};
	this.getFilteredNetworkData = function(h, k) {
		var b = {
			type: {}
		};
		if (this.graphType == "Network") {
			var d = this.skipConfigurableProperties ? this.getObjectArray(this[h.replace("s", "") + "ConfigurableProperties"]) : {};
			for (var f = 0; f < this.data[h].length; f++) {
				var e = this.data[h][f];
				if (k || (!k && !e.hide)) {
					for (var j in e) {
						if (!d[j]) {
							if (typeof(e[j]) != "object") {
								if (b[h].hasOwnProperty(j)) {
									b[h][j]["o"][e[j]]++;
									if (isNaN(e[j])) {
										b[h][j]["t"] = "string"
									}
								} else {
									b[h][j] = {
										o: {},
										t: isNaN(e[j]) ? "string" : "numeric"
									};
									b[h][j]["o"][e[j]] = 1
								}
							}
						}
					}
				}
				if (this[h + "Properties"].length > 0) {
					this.getAdditionalData(e, b, this[h + "Properties"])
				}
			}
			for (var j in b[h]) {
				if (b[h][j]["t"] == "numeric") {
					var g = [];
					for (var c in b[h][j]["o"]) {
						for (var f = 0; f < b[h][j]["o"][c]; f++) {
							g.push(c)
						}
					}
					var a = this.range(g);
					b[h][j]["o"] = {
						min: a[0],
						max: a[1]
					}
				}
			}
		}
		return b
	};
	this.getFeatureData = function(a) {
		if (!this.featuresData) {
			var h = {};
			var d = this.skipConfigurableProperties ? this.getObjectArray(this.featureConfigurableProperties) : {};
			for (var g = 0; g < this.data.tracks.length; g++) {
				var c = this.data.tracks[g];
				var b = c.data;
				for (var e = 0; e < b.length; e++) {
					var l = b[e];
					for (var k in l) {
						if (!d[k]) {
							if (typeof(l[k]) != "object") {
								if (h.hasOwnProperty(k)) {
									if (h[k]["o"].hasOwnProperty(l[k])) {
										h[k]["o"][l[k]]++
									}
									if (isNaN(l[k])) {
										h[k]["t"] = "string"
									}
								} else {
									h[k] = {
										o: {},
										t: isNaN(l[k]) ? "string" : "numeric"
									};
									h[k]["o"][l[k]] = 1
								}
							}
						}
					}
				}
				if (this.featuresProperties.length > 0) {
					this.getAdditionalData(b, h, this.featuresProperties)
				}
			}
			this.featuresData = h
		}
		return a ? this.featuresData : this.getKeys(this.featuresData)
	};
	this.getAdditionalData = function(d, e, h) {
		for (var f = 0; f < h.length; f++) {
			var b = d;
			var k = false;
			if (h[f].length > 0) {
				for (var c = 0; c < h[f].length; c++) {
					var a = h[f][c];
					if (b[a]) {
						b = b[a]
					} else {
						k = true;
						break
					}
				}
				if (!k) {
					for (var g in b) {
						if (typeof(b[g]) != "object") {
							if (e.hasOwnProperty(g)) {
								if (e[g]["o"].hasOwnProperty(b[g])) {
									e[g]["o"][b[g]]++
								}
								if (isNaN(b[g])) {
									e[g]["t"] = "string"
								}
							} else {
								e[g] = {
									o: {},
									t: isNaN(b[g]) ? "string" : "numeric",
									r: f
								};
								e[g]["o"][b[g]] = 1
							}
						}
					}
				}
			}
		}
	};
	this.getOperators = function() {
		return ["", "like", "not like", ">", ">=", "<", "<=", "==", "null", "not null"]
	};
	this.zoonIn = function(a) {
		this.handleWheelEvent(a, 1)
	};
	this.zoonOut = function(a) {
		this.handleWheelEvent(a, -1)
	};
	this.clusterSamples = function(b, a) {
		this.functionCaller = "clusterSamples";
		if (this.isTransition()) {
			return
		}
		this.clusterAxis = "samples";
		if (b || !this.smpDendrogramNewick) {
			this.smpDendrogramNewick = this.cluster()
		}
		if (!a) {
			this.draw()
		}
	};
	this.clusterVariables = function(b, a) {
		this.functionCaller = "clusterVariables";
		if (this.isTransition()) {
			return
		}
		this.clusterAxis = "variables";
		if (b || !this.varDendrogramNewick) {
			this.varDendrogramNewick = this.cluster()
		}
		if (!a) {
			this.draw()
		}
	};
	this.kmeansSamples = function(e, d) {
		this.functionCaller = "kmeansSamples";
		if (this.isTransition()) {
			return
		}
		this.clusterAxis = "samples";
		if (!this.data.x) {
			this.data.x = {}
		}
		if (e || !this.data.x["k-Means-S"]) {
			var a = this.kmeans();
			this.data.x["k-Means-S"] = [];
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				this.data.x["k-Means-S"][c] = a[b]
			}
			if (!this.isInArray("k-Means-S", this.smpOverlays)) {
				this.smpOverlays.push("k-Means-S")
			}
			this.updateMetaData("x", "k-Means-S", false, true);
			this.sortSamplesByCategory("k-Means-S", true)
		}
		if (!d) {
			this.draw()
		}
	};
	this.kmeansVariables = function(e, d) {
		this.functionCaller = "kmeansVariables";
		if (this.isTransition()) {
			return
		}
		this.clusterAxis = "variables";
		if (!this.data.z) {
			this.data.z = {}
		}
		if (e || !this.data.z["k-Means-V"]) {
			var a = this.kmeans();
			this.data.z["k-Means-V"] = [];
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				this.data.z["k-Means-V"][c] = a[b]
			}
			if (!this.isInArray("k-Means-V", this.varOverlays)) {
				this.varOverlays.push("k-Means-V")
			}
			this.updateMetaData("z", "k-Means-V", false, true);
			this.sortVariablesByCategory("k-Means-V", true)
		}
		if (!d) {
			this.draw()
		}
	};
	this.setFunctions = function() {
		var a = this.functions;
		a.push("clusterSamples");
		a.push("clusterVariables");
		a.push("transpose");
		a.push("transform");
		a.push("sortSamplesByCategory");
		a.push("sortSamplesByVariable");
		a.push("sortVariablesByCategory");
		a.push("sortVariablesBySample");
		a.push("hideUnhideSmps");
		a.push("hideUnhideVars");
		a.push("desegregateSamples");
		a.push("segregateSamples");
		a.push("groupSamples");
		a.push("ungroupSamples");
		a.push("desegregateVariables");
		a.push("segregateVariables");
		a.push("kmeansSamples");
		a.push("kmeansVariables");
		a.push("createContour");
		a.push("removeContour");
		a.push("showCodeDiv");
		a.push("hideCodeDiv");
		a.push("showInfoDiv");
		a.push("hideInfoDiv");
		a.push("updateCodeDiv");
		a.push("createHistogram");
		a.push("removeHistogram");
		a.push("addRegressionLine");
		a.push("addNormalDistributionLine");
		a.push("recalculateLayout");
		a.push("createRandomData");
		a.push("drawArea");
		a.push("draw");
		a.push("reset");
		a.push("print")
	};
	this.initializeApi = function() {
		this.setFunctions()
	};
	this.initializeApi()
};
CanvasXpress.prototype.initDimensionUtils = function() {
	this.resizeCanvas = function(e, b, c) {
		this.functionCaller = "resizeCanvas";
		var a = this.margin;
		if (e || b || c) {
			if (b || c) {
				if (b) {
					this.width = b;
					this.originalWidth = b
				}
				if (c) {
					this.height = c;
					this.originalHeight = c
				}
			} else {
				if (e) {
					this.width = this.originalWidth;
					this.height = this.originalHeight
				}
			}
			this.top = a + this.getTitleSubtitleHeight();
			this.left = a;
			this.right = a;
			this.bottom = a;
			this.resetRender()
		}
		if (!this.isSVG) {
			this.meta.canvas.ctx.canvas.width = this.width;
			this.meta.canvas.ctx.canvas.height = this.height;
			this.meta.canvas.ctx.canvas.style.width = this.width + "px";
			this.meta.canvas.ctx.canvas.style.height = this.height + "px";
			this.meta.canvas.ctx2.canvas.width = this.width;
			this.meta.canvas.ctx2.canvas.height = this.height
		}
		this.addToRender(["disableGradientTransparencyShadow"]);
		if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
			this.drawImage(CanvasXpress.cacheImages[this.getFileName(this.backgroundImage)], 0, 0, this.width, this.height)
		} else {
			if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient" || this.backgroundType == "video") {
				this.addToRender(["drawShape", "rectangle", 0 + (this.width / 2), 0 + (this.height / 2), this.width, this.height, this.background, this.background])
			} else {
				var d = this.getLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
				this.addToRender(["drawShape", "rectangle", 0 + (this.width / 2), 0 + (this.height / 2), this.width, this.height, d, d])
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"])
	};
	this.setWidth = function(a, b) {
		this.setDimensions(a, false, b)
	};
	this.setHeight = function(b, a) {
		this.setDimensions(false, b, a)
	};
	this.getWidth = function() {
		return this.marginLeft + this.left + this.x + this.right + this.marginRight
	};
	this.getHeight = function() {
		return this.marginTop + this.top + this.y + this.bottom + this.marginBottom
	};
	this.setDimensions = function(a, e, d, b) {
		this.functionCaller = "setDimensions";
		if (this.isTransition()) {
			return
		}
		if (!this.resizable) {
			return
		}
		var g = this.meta.canvas.ctx.canvas;
		if (!a || !this.resizableX) {
			a = this.width + 18
		}
		if (!e || !this.resizableY) {
			e = this.height + 18
		}
		g.originalWidth = parseInt(a);
		g.originalHeight = parseInt(e);
		a = parseInt(a) - g.widthDecrease;
		e = parseInt(e) - g.heightDecrease;
		this.clickLayoutNoAnimation(d);
		this.resetAxesResizer();
		this.removeMotionDiv();
		this.draw(a, e);
		this.resizeAcknowledgmentDiv();
		this.updateRemoteNavigationWindow();
		if (b) {
			var f = this;
			setTimeout(function() {
				f.resizeViewport()
			}, b)
		} else {
			this.resizeViewport()
		}
	};
	this.initializeDimensions = function() {
		var b = this.meta.canvas.ctx.canvas;
		var a = this.margin;
		if (b.width) {
			this.originalWidth = b.width;
			this.width = b.width
		} else {
			if (this.width) {
				this.originalWidth = this.width;
				b.width = this.width
			} else {
				this.width = 600;
				this.originalWidth = this.width;
				b.width = this.width
			}
		}
		if (b.height) {
			this.originalHeight = b.height;
			this.height = b.height
		} else {
			if (this.height) {
				this.originalHeight = this.height;
				b.height = this.height
			} else {
				this.height = 600;
				this.originalHeight = this.height;
				b.height = this.height
			}
		}
		this.top = a + this.getTitleSubtitleHeight();
		this.left = a;
		this.right = a;
		this.bottom = a;
		this.x = this.width - (this.leftMargin + this.left + this.rightMargin + this.right);
		this.y = this.height - (this.topMargin + this.top + this.bottomMargin + this.bottom)
	};
	this.initializeDimensions()
};
CanvasXpress.prototype.initUtils = function() {
	this.initGeneralUtils();
	this.initPlotUtils();
	this.initConfigUtils();
	this.init3dUtils();
	this.initApiUtils();
	this.initDimensionUtils()
};
CanvasXpress.prototype.initLegendUtils = function() {
	this.validateLegendPositions = function() {
		if (!this.legendInside) {
			if (this.decorationsPosition != "right" && this.decorationsPosition != "bottom") {
				this.decorationsPosition = "bottom"
			}
			if (this.legendPosition != "right" && this.legendPosition != "bottom") {
				if (this.graphType == "Circular") {
					if (this.legendPosition != "top") {
						this.legendPosition = "right"
					}
				} else {
					this.legendPosition = "right"
				}
			}
		}
		if (!this.overlaysLegendPosition) {
			this.overlaysLegendPosition = "topRight"
		}
		if (this.layoutValid) {
			var a = this.meta.config.orig;
			a.insideLegend = this.insideLegend;
			this.insideLegend = false;
			if (this.legendPosition != "bottom" && this.legendPosition != "right") {
				a.legendPosition = this.legendPosition;
				this.legendPosition = "right"
			}
		}
	};
	this.setLegendFont = function() {
		if (this.autoScaleFont) {
			var b = (1 - this.percentAspectRatioPlotArea);
			var a = this.min(this.width * b, this.height * b);
			this.setPropertyFontSize(a, "legendFont")
		} else {
			this.legendFont = this.legendFontStyle + " " + parseInt(this.legendFontSize) + "px " + this.fontName
		}
	};
	this.drawLegendBackgroundBox = function(e, r, p, g, m, o, j, f) {
		this.functionCaller = "drawLegendBackgroundBox";
		var n = j ? this.decorationsBackgroundColor : this.legendBackgroundColor;
		var c = j ? this.decorationsBoxColor : this.legendBoxColor;
		var q = j ? this.decorationsBox : this.legendBox;
		var k = this.graphType;
		var s = [0, 0, this.width, this.height];
		if (m) {
			if (q && n && !f && k != "Network") {
				this.addToRender(["disableGradientTransparencyShadow"]);
				this.addToRender(["drawShape", "rectangle", e + (p / 2), r + (g / 2), p, g, n, c, "solid", false, false, true, s], [-1], o);
				this.addToRender(["enableGradientTransparencyShadow"])
			} else {
				this.addToRender(["drawShape", "rectangle", e + (p / 2), r + (g / 2), p, g, false, "rgba(255,255,255,0)", "open", false, false, true, s], [-1], o)
			}
		} else {
			if (q) {
				this.addToRender(["disableGradientTransparencyShadow"]);
				this.addToRender(["drawShape", "rectangle", e + (p / 2), r + (g / 2), p, g, false, c, "open", false, false, true, s]);
				this.addToRender(["enableGradientTransparencyShadow"])
			}
		}
	};
// Baohong : resize legend data points with legend font
    this.getDiameterLegend = function() {
        var a = Math.min(this.width, this.height);
        return Number(Math.max(0.5, 500 * this.getFontPt(this.legendFont) / 833).toFixed(1))
	};
	this.setPropertyLegendDimensions = function(c, n, b) {
		var a = c.toLowerCase() + "By";
		if (this[a] && this[a + "ShowLegend"]) {
			var r, g, o;
			if (n) {
				r = this[a];
				g = n;
				o = b && b.sizes ? b.sizes : this.sizes
			} else {
				if (this.data.x && this.data.x.hasOwnProperty(this[a])) {
					r = this[a];
					g = this.meta.data.x[this[a]].maxLevStr;
					o = this.meta.data.x[this[a]].sizes || this.sizes
				} else {
					if (this.data.z && this.data.z.hasOwnProperty(this[a])) {
						r = this[a];
						g = this.meta.data.z[this[a]].maxLevStr;
						o = this.meta.data.z[this[a]].sizes || this.sizes
					} else {
						r = 0;
						g = 0;
						o = this.sizes
					}
				}
			}
			var k = this.getDiameterLegend();
			if (c == "Size") {
				for (var h = 0; h < this["legend" + c + "sN"]; h++) {
					if (o[h]) {
						k = Math.max(k, o[h])
					}
				}
			}
			var j = this.getFontPt(this.legendFont);
			var t = this.legendColumns > this["legend" + (c == "Outline" ? "Color" : c) + "sN"] ? this["legend" + (c == "Outline" ? "Color" : c) + "sN"] : this.legendColumns;
			var e = Math.ceil(this["legend" + (c == "Outline" ? "Color" : c) + "sN"] / t);
			var q = this.measureText(r, this.legendFont);
			var s = (this.measureText(g, this.legendFont) + k + (this.margin * 2)) * t;
			this["legend" + (c == "Outline" ? "Color" : c) + "Width"] = Math.max(q, s) + (this.margin * (t + 2));
			this["legend" + (c == "Outline" ? "Color" : c) + "Height"] = (e * (Math.max(k, j) + this.margin)) + j + (this.margin * 3)
		}
	};
	this.setPropertyLegendIndicatorDimensions = function(d, a) {
		var i = d.toLowerCase() + "By";
		var c = 0;
		var e = 0;
		var g = this.getFontPt(this.legendFont);
		if (this[i]) {
			switch (d) {
				case "Color":
				case "Outline":
					var b = a.maxLevLen;
					if (this.legendPosition.match(/top|bottom/)) {
						e = this.heatmapIndicatorHeight + (this.margin * 4) + g;
						e += g + this.margin;
						c = this.heatmapIndicatorWidth + b
					} else {
						e = this.heatmapIndicatorWidth + (this.margin * 3) + g;
						c = this.heatmapIndicatorHeight + (this.margin * 4) + b
					}
					break;
				case "Shape":
				case "Size":
					this.setPropertyLegendDimensions(d, a.maxLevStr, a);
					return;
				case "Pattern":
					c = 0;
					e = 0;
					break
			}
		}
		this["legend" + (d == "Outline" ? "Color" : d) + "Width"] = c;
		this["legend" + (d == "Outline" ? "Color" : d) + "Height"] = e
	};
	this.setDecorationsLegendDimensions = function() {
		this.legendDecorationWidth = 0;
		this.legendDecorationHeight = 0;
		this.legendDecorationMaxLabel = 0;
		if (this.showDecorations && this.showDecorationsLegend && this.decorations) {
			if (!this.legendInside) {
				if (this.decorationsPosition != "right" && this.decorationsPosition != "bottom") {
					this.decorationsPosition = "bottom"
				}
			}
			var f = this.getFontPt(this.decorationFont);
			var h = this.decorations;
			var b = 0;
			if (h.nlfit) {
				var g = this.measureText(sprintf("%96s", "X"), this.decorationFont) + (this.margin * 5);
				var a = 0;
				for (var e = 0; e < h.nlfit.length; e++) {
					var c = this.measureText(h.nlfit[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight = (h.nlfit.length * f * 2) + f + this.margin
			}
			if (h.line) {
				var a = 0;
				for (var e = 0; e < h.line.length; e++) {
					if (h.line[e].label) {
						var c = this.measureText(h.line[e].label, this.decorationFont);
						a = Math.max(c, a);
						this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
					}
				}
				if (a > 0) {
					b = Math.max(b, this.margin + a + this.margin);
					this.legendDecorationHeight += (h.line.length * f * 2) + this.margin
				}
			}
			if (h.reg) {
				var g = this.measureText(sprintf("%45s", "X"), this.decorationFont) + (this.margin * 2);
				var a = 0;
				for (var e = 0; e < h.reg.length; e++) {
					var c = this.measureText(h.reg[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight += (h.reg.length * f * 2) + f + this.margin
			}
			if (h.nor) {
				var g = this.measureText(sprintf("%30s", "X"), this.decorationFont) + (this.margin * 1);
				var a = 0;
				for (var e = 0; e < h.nor.length; e++) {
					var c = this.measureText(h.nor[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight += (h.nor.length * f * 2) + f + this.margin
			}
			if (h.area) {
				var a = 0;
				for (var e = 0; e < h.area.length; e++) {
					var c = this.measureText(h.area[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin);
				this.legendDecorationHeight += (h.area.length * f * 2) + this.margin
			}
			if (h.kaplanMeier) {
				var a = 0;
				for (var e = 0; e < h.kaplanMeier.length; e++) {
					var c = this.measureText(h.kaplanMeier[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin);
				this.legendDecorationHeight += (h.kaplanMeier.length * f * 2) - this.margin
			}
			this.legendDecorationWidth = b
		}
	};
	this.setOncoprintLegendDimension = function() {
		this.legendOncoprintWidth = 0;
		this.legendOncoprintHeight = 0;
		if (this.isOncoprint) {
			var c = this.measureText("Amplification", this.legendFont);
			var e = this.measureText("Deletion", this.legendFont);
			var b = this.measureText("Mutation", this.legendFont);
			this.legendOncoprintWidth = 100 + c + e + b + (this.margin * 2);
			this.legendOncoprintHeight = 30 + (this.margin * 2)
		}
	};
	this.setSampleLegendDimension = function() {
		this.legendSampleWidth = 0;
		this.legendSampleHeight = 0;
		var d = this.getFontPt(this.legendFont);
		var b = 0;
		if (this.graphType.match(/Scatter/)) {
			if (this.xAxisIndices.length != this.yAxisIndices.length || this.xAxisIndices.length > 1) {
				if (this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length > 1) {
					for (var c = 0; c < this.xAxisIndices.length; c++) {
						var a;
						if (this.isHistogram) {
							a = this.measureText(this.shortenText(this.xAxis[c], this.maxSmpStringLen), this.legendFont)
						} else {
							a = this.measureText(this.shortenText(this.xAxis[c], this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[c], this.maxSmpStringLen), this.legendFont)
						}
						b = Math.max(a, b)
					}
				} else {
					if (this.xAxisIndices.length > this.yAxisIndices.length) {
						b = this.measureText(this.shortenText(this.getMaxText(this.xAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[0], this.maxSmpStringLen), this.legendFont)
					} else {
						if (this.yAxisIndices.length > this.xAxisIndices.length) {
							if (this.isHistogram) {
								b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen), this.legendFont)
							} else {
								b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.xAxis[0], this.maxSmpStringLen), this.legendFont)
							}
						}
					}
				}
				this.legendSampleWidth = (d - 1) + b + (this.margin * 3);
				this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (d + this.margin)) + this.margin
			} else {
				if (this.isHistogram) {
					b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen), this.legendFont);
					this.legendSampleWidth = (d - 1) + b + (this.margin * 3);
					this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (d + this.margin)) + this.margin
				}
			}
		}
	};
	this.setVariableLegendDimension = function() {
		this.legendVariableWidth = 0;
		this.legendVariableHeight = 0;
		var a = this.isDOE && this.layoutCurrentDOE ? this.meta.data.x[this.layoutCurrentDOE] : this.meta.data.y;
		var e = this.getFontPt(this.legendFont);
		if (this.graphType == "Pie") {
			var f = this.varIndices.length > this.maxPieSectors ? this.maxPieSectors : this.varIndices.length;
			var d = this.isDOE && this.layoutCurrentDOE ? this.shortenText(a.maxLevStr, this.maxVarStringLen) : this.shortenText(a.maxVarStr, this.maxVarStringLen);
			var b = this.measureText(d, this.legendFont);
			if (b > this.width / 2) {
				this.legendFont = this.scaleTextToFont(b, e, this.width / 2)
			}
			this.legendVariableWidth = this.measureText(d, this.legendFont) + e + (this.margin * 3);
			this.legendVariableHeight = ((e + this.margin) * f) + this.margin
		} else {
			if (this.layoutValid && this.segregateVariablesBy.length > 0) {
				if (this.segregateVariablesBy[0] == "variable" || (this.segregateVariablesBy.length > 1 && this.segregateVariablesBy[1] == "variable")) {
					return
				} else {
					var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
					this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
					this.legendVariableHeight = (Math.ceil(this.data.y.vars.length / this.legendColumns) * e * 1.5) + this.margin
				}
			} else {
				if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable") || (this.patternBy && this.patternBy == "variable")) {
					var c = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], this.getFontPt(this.legendFont)) : this.getFontPt(this.legendFont);
					var d = this.shortenText(a.maxVarStr, this.maxVarStringLen);
					this.legendVariableWidth = ((c - 1) + this.measureText(d, this.legendFont) + (this.margin * 3)) * this.legendColumns;
					this.legendVariableHeight = ((this.varIndices.length / this.legendColumns) * (c + this.margin)) + this.margin
				} else {
					if (this.graphType == "BarLine" || this.graphType == "DotLine" || this.graphType == "AreaLine" || this.graphType == "StackedLine" || this.graphType == "StackedPercentLine") {
						var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
						this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
						this.legendVariableHeight = (Math.ceil((this.xAxisVarIndices.length + this.xAxis2VarIndices.length) / this.legendColumns) * e * 1.5) + this.margin
					} else {
						if (!this.colorBy && (this.graphType == "Bar" || this.graphType == "Line" || this.graphType == "Area" || this.graphType == "Dotplot" || this.graphType == "Stacked" || this.graphType == "StackedPercent" || this.graphType == "Boxplot")) {
							var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
							this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
							this.legendVariableHeight = (Math.ceil(this.varIndices.length / this.legendColumns) * e * 1.5) + this.margin
						}
					}
				}
			}
		}
	};
	this.setVennLegendDimension = function() {
		var a = this.data.venn.legend ? this.getMaxText(this.data.venn.legend) : "N/A";
		this.legendWidth = this.measureText(a, this.legendFont) + (this.margin * 6);
		this.legendHeight = this.margin + this.margin + ((this.getFontPt(this.legendFont) + this.margin) * this.vennGroups)
	};
	this.setOverlaysLegendDimensions = function() {
		var b = this.getFontPt(this.legendFont);
		var s = this.getDiameterLegend();
		var k = Math.max(b, s);
		var d = ["varOverlays", "smpOverlays"];
		var e = ["varOverlayProperties", "smpOverlayProperties"];
		var y = ["showVarOverlaysLegend", "showSmpOverlaysLegend"];
		this.legendOverlaysLayout = [];
		this.legendOverlaysWidth = 0;
		this.legendOverlaysHeight = 0;
		var q = this.margin;
		var n = this.margin;
		var a = 0;
		var g = 0;
		var l = 0;
		var B = false;
		if (this.showOverlays && (this.showVarOverlaysLegend || this.showSmpOverlaysLegend)) {
			for (var v = 0; v < d.length; v++) {
				if (this[d[v]].length > 0 && this[y[v]]) {
					for (var t = 0; t < this[d[v]].length; t++) {
						var f = 0;
						var x = 0;
						var p = this[d[v]][t];
						if (p != "-") {
							var A = d[v] == "varOverlays" ? "z" : "x";
							var r = this.meta.data[A][p];
							var u = this.measureText(r.maxLevStr, this.legendFont);
							var z = this.measureText(p, this.legendFont);
							if (this[e[v]][p].type == "Default") {
								B = true;
								if (r.type == "String") {
									f = Math.max(z, u + k + (this.margin * 3));
									x = ((Math.max(b, s) + this.margin) * r.levels.length) + b + (this.margin * 3)
								} else {
									if (this.overlaysLegendPosition.match(/right/i)) {
										f = Math.max(this.heatmapIndicatorHeight + (this.margin * 2) + u, z);
										x = this.heatmapIndicatorWidth + (this.margin * 3) + b
									} else {
										f = this.heatmapIndicatorWidth + (this.margin * 3) + b;
										x = Math.max(this.heatmapIndicatorHeight + (this.margin * 2) + u, z)
									}
								}
								this["legend" + p + "Width"] = f;
								this["legend" + p + "Height"] = x;
								if (this.overlaysLegendPosition.match(/right/i)) {
									if (g + this.margin + x > (this.height - (this.top + this.bottom))) {
										q += this.margin + f;
										a = f;
										g = x;
										l++;
										this.legendOverlaysLayout[l] = [
											[A, p, f, x]
										]
									} else {
										if (f > a) {
											q += (f - a);
											a = f
										}
										g += x;
										if (!this.legendOverlaysLayout[l]) {
											this.legendOverlaysLayout[l] = []
										}
										this.legendOverlaysLayout[l].push([A, p, f, x])
									}
								} else {
									if (a + this.margin + f > (this.width - (this.left + this.right))) {
										n += this.margin + x;
										a = f;
										g = x;
										this.legendOverlaysLayout[v] = [
											[A, p, f, x]
										];
										l++
									} else {
										if (x > g) {
											n += (x - g);
											g = x
										}
										a += f;
										if (!this.legendOverlaysLayout[l]) {
											this.legendOverlaysLayout[l] = []
										}
										this.legendOverlaysLayout[l].push([A, p, f, x])
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.overlaysLegendPosition.match(/right/i)) {
			this.legendOverlaysWidth = B ? q + this.margin : 0;
			this.legendOverlaysHeight = B ? g + this.margin : 0
		} else {
			this.legendOverlaysWidth = B ? a + this.margin : 0;
			this.legendOverlaysHeight = B ? n + this.margin : 0
		}
	};
	this.setLegendDimensions = function() {
		if (this.showDecorations && this.showDecorationsLegend && this.decorations) {
			this.decorationLayout = [0]
		}
		if (this.showLegend) {
			this.legendLayout = [];
			this.legendWidth = 0;
			this.legendHeight = 0;
			var a = this.margin;
			var k = this.margin;
			var b = 0;
			var j = 0;
			var g = 0;
			var e = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			for (var c = 0; c < e.length; c++) {
				var f = this["legend" + e[c] + "Width"];
				var d = this["legend" + e[c] + "Height"];
				if (f > 0) {
					if (this.legendPosition.match(/right|left/i)) {
						if (j + this.margin + d > this.height) {
							a += this.margin + f;
							b = f;
							j = d;
							this.legendLayout[g] = [e[c]];
							g++
						} else {
							if (f > b) {
								a += (f - b);
								b = f
							}
							j += d;
							if (!this.legendLayout[g]) {
								this.legendLayout[g] = []
							}
							this.legendLayout[g].push(e[c])
						}
					} else {
						if (b + this.margin + f > this.width) {
							k += this.margin + d;
							b = f;
							j = d;
							this.legendLayout[c] = [e[c]];
							g++
						} else {
							if (d > j) {
								k += (d - j);
								j = d
							}
							b += f;
							if (!this.legendLayout[g]) {
								this.legendLayout[g] = []
							}
							this.legendLayout[g].push(e[c])
						}
					}
				}
			}
			this.legendWidth = this.legendPosition.match(/right|left/i) ? a + this.margin : b + this.margin;
			this.legendHeight = this.legendPosition.match(/right|left/i) ? j + this.margin : k + this.margin
		}
	};
	this.setLegends = function() {
		var h = this;
		var g = ["Color", "Shape", "Size", "Pattern", "Outline"];
		var q = ["shapeByData", "sizeByData", "patternByData", "outlineByData"];
		var n = function(a, o, t) {
			var u = o == "Outline" ? "Color" : o;
			var s = u.toLowerCase() + "s";
			delete(h["legend" + u + "sS"]);
			h["legend" + u + "Meta"] = a;
			if (t) {
				h["legend" + u + "Meta"].vals = h.rPretty(t[0], t[1], 5);
				h["legend" + u + "Meta"].decs = h.getAxisDecimals(t[1] - t[0]);
				h["legend" + u + "Meta"].maxLevStr = h.getMaxText(h["legend" + (o == "Outline" ? "Color" : o) + "Meta"].vals);
				h["legend" + u + "Meta"].maxLevLen = h.measureText(h["legend" + u + "Meta"].maxLevStr, h.font);
				h["legend" + u + "Meta"].maxLevChr = h["legend" + u + "Meta"].maxLevStr.toString().length
			}
			h["legend" + u + "sMax"] = h["legend" + u + "Meta"].maxLevStr;
			h["legend" + u + "sN"] = h["legend" + u + "Meta"].vals.length;
			for (var p = 0; p < h["legend" + u + "Meta"].vals.length; p++) {
				h["legend" + u + "s"][h["legend" + u + "Meta"].vals[p].toString()] = h[s][p]
			}
			h.setPropertyLegendIndicatorDimensions(o, h["legend" + u + "Meta"])
		};
		var j = function(A, H, w, C, x) {
			var E = 0;
			var u = 0;
			var z = false;
			var B = {};
			var r = {};
			var a = A[C.toLowerCase() + "s"] || h[C.toLowerCase() + "s"];
			var y = h.isGroupedData && h.graphType != "Dotplot" && h.graphType != "Boxplot" && !h.showBoxplotOriginalData && h.groupingFactors.length == 1;
			if (H == "x") {
				var s = h.isGroupedData ? h.grpIndices : h.smpIndices;
				for (var F = 0; F < s.length; F++) {
					var t = s[F];
					if (h.isGroupedData && (h.graphType == "Dotplot" || (h.graphType == "Boxplot" && h.showBoxplotOriginalData))) {
						for (var D = 0; D < h.data.w.grps[t].length; D++) {
							var v = h.data[H][h[w]][h.data.w.grps[t][D]];
							r[v] = true
						}
					} else {
						var v = h.isGroupedData ? h.getSmpAnnotations(h[w], h.data.w.grps[F], true) : h.data[H][h[w]][t];
						r[v] = true
					}
				}
			} else {
				if (H == "z") {
					for (var F = 0; F < h.varIndices.length; F++) {
						var t = h.varIndices[F];
						var v = h.data[H][h[w]][t];
						r[v] = true
					}
				} else {
					if (H == "m") {
						for (var F = 0; F < h.varIndices.length; F++) {
							for (var D = 0; D < h.smpIndices.length; D++) {
								var v = x[h.varIndices[F]][h.smpIndices[D]];
								r[v] = true
							}
						}
					} else {
						if (H == "modified") {
							A.order = {};
							for (var F = 0; F < A.levels.length; F++) {
								r[A.levels[F]] = true;
								A.order[A.levels[F]] = F
							}
						}
					}
				}
			}
			r = h.getKeys(r);
			if (A.type == "Numeric") {
				if (A.orderS) {
					r.sort(function(l, i) {
						return A.orderS[l] - A.orderS[i]
					})
				} else {
					r.sort(function(l, i) {
						return l - i
					});
					A.orderS = {};
					for (var F = 0; F < r.length; F++) {
						A.orderS[r[F]] = F
					}
				}
			} else {
				r.sort(function(l, i) {
					return A.order[l] - A.order[i]
				})
			}
			for (var F = 0; F < r.length; F++) {
				var v = r[F] != null ? r[F] : "NA";
				var G = h.measureText(v, h.legendFont);
				if (G > E) {
					E = G;
					h["legend" + C + "sMax"] = v
				}
				B[v] = (A.type == "Numeric" ? A.orderS[v] : A.order[v]) % a.length;
				h["legend" + C + "s"][v] = a[B[v]];
				u++
			}
			h["legend" + C + "sS"] = r;
			z = H == "m" || H == "modified" ? h["legend" + C + "sMax"] : false;
			h["legend" + C + "sN"] = u;
			h["legend" + C + "Meta"] = A;
			h.setPropertyLegendDimensions(C, z, A)
		};
		this.validateLegendPositions();
		this.setLegendFont();
		if (this.graphType == "Venn") {
			this.setVennLegendDimension();
			return
		} else {
			if (this.isMultidimensionalData) {
				for (var f = 0; f < q.length; f++) {
					if (this.data.y[this[q[f]]]) {
						var c = this.data.y[this[q[f]]];
						var d = this.meta.data[this[q[f]]];
						var e = q[f].replace("ByData", "");
						e = e.charAt(0).toUpperCase() + e.slice(1);
						var k = e.toLowerCase();
						var b = k + "By";
						this["legend" + (e == "Outline" ? "Color" : e) + "s"] = [];
						this["legend" + (e == "Outline" ? "Color" : e) + "sN"] = 0;
						if (d.type == "Numeric") {
							n(d, e, [d.min, d.max])
						} else {
							j(d, "m", b, e, c)
						}
					}
				}
			} else {
				for (var f = 0; f < g.length; f++) {
					var e = g[f];
					var k = g[f].toLowerCase();
					var b = k + "By";
					this["legend" + e + "s"] = {};
					this["legend" + e + "sN"] = 0;
					this["legend" + e + "Width"] = 0;
					this["legend" + e + "Height"] = 0;
					if (this[b]) {
						if (this.data.x && this.data.x.hasOwnProperty(this[b])) {
							var d = this.meta.data.x[this[b]];
							this[k + "ByType"] = "x";
							if (d.type == "Numeric" && !d[b]) {
								n(d, e)
							} else {
								j(d, "x", b, e)
							}
						} else {
							if (this.data.z && this.data.z.hasOwnProperty(this[b])) {
								var d = this.meta.data.z[this[b]];
								this[k + "ByType"] = "z";
								if (d.type == "Numeric" && !d[b]) {
									n(d, e)
								} else {
									j(d, "z", b, e)
								}
							} else {
								if (this.getSampleIndices(this[b]) > -1 && this.meta.data.y.range[this[b]]) {
									var d = this.meta.data;
									if (d.modified && d.modified.z && d.modified.z[this[b]]) {
										d = d.modified.z;
										if (!d.meta) {
											d.meta = {}
										}
										d.meta[this[b]] = {
											levels: d[this[b]]
										};
										j(d.meta[this[b]], "modified", b, e)
									} else {
										d = d.y.range[this[b]];
										n(d, e, [d.min, d.max])
									}
								} else {
									if (this[b] == "variable") {
										h["legend" + e + "sN"] = this.varIndices.length;
										this.setVariableLegendDimension()
									}
								}
							}
						}
					}
				}
			}
		}
		this.setDecorationsLegendDimensions();
		this.setSampleLegendDimension();
		this.setVariableLegendDimension();
		this.setOncoprintLegendDimension();
		this.setOverlaysLegendDimensions();
		this.setLegendDimensions()
	};
	this.drawDecorationData = function() {
		this.functionCaller = "drawDecorationData";
		var Y = this.marginLeft + this.offsetX + this.left;
		var U = this.marginTop + this.offsetY + this.top;
		var af = this.decorations;
		if (this.showDecorations && af) {
			if (this.graphType.match(/Scatter/)) {
				if (af.nlfit) {
					var h, M, f;
					var E = this.varIndices;
					var H, g;
					for (var ab = 0; ab < af.nlfit.length; ab++) {
						var av = [];
						var at = [];
						var L = ab % this.colors.length;
						var a = Number(this.transformValue(this.yAxisTransform, af.nlfit[ab].param[0]));
						var aH = Number(this.transformValue(this.yAxisTransform, af.nlfit[ab].param[1]));
						var aG = Number(af.nlfit[ab].param[2]);
						var aE = Number(af.nlfit[ab].param[3]);
						var V = this.xAxisIndices.length == 1 ? this.xAxisIndices[0] : this.xAxisIndices[ab];
						var aw = this.getDataForSmpGrpAtIndex(V);
						if (this.xAxisTransform == "percentile") {
							h = this.range(aw);
							f = h[0];
							M = h[1]
						}
						E.sort(function(i, d) {
							return aw[i] - aw[d]
						});
						L = af.nlfit[ab].color ? af.nlfit[ab].color : this.colors[L];
						for (var aa = 0; aa < E.length; aa++) {
							var A = E[aa];
							var O = this.getDataAtPos(A, V);
							var N;
							var K = [];
							if (O > 0) {
								if (aa > 0) {
									var au = E[aa - 1];
									var ax = this.getDataAtPos(au, V);
									if (ax > 0) {
										var P = (O - ax) / this.functionIntervals;
										for (var Z = 0; Z < this.functionIntervals; Z++) {
											K.push(ax);
											ax += P
										}
									}
								} else {
									K = [O]
								}
								for (var Z = 0; Z < K.length; Z++) {
									if (af.nlfit[ab].type == "reg") {
										N = a + ((aH - a) / (1 + aG / (Math.pow(K[Z], aE))))
									} else {
										N = a + ((aH - a) / (1 + (Math.pow((K[Z] / aG), aE))))
									}
									if (this.xAxisTransform) {
										K[Z] = this.xAxisTransform == "percentile" ? this.percentile(f, M, K[Z]) : this.transformValue(this.xAxisTransform, K[Z])
									}
									H = Y + ((K[Z] - this.xAxisMin) * this.xAxisUnit);
									g = (U + this.y) - ((N - this.yAxisMin) * this.yAxisUnit);
									av.push(H);
									at.push(g)
								}
							}
						}
						if (av.length > 0) {
							this.addToRender(["drawShape", "path", av, at, false, false, L, L, "open", false, false, true]);
							if (af.nlfit[ab].type == "reg") {
								N = a + ((aH - a) / (1 + aG / (Math.pow(aG, aE))))
							} else {
								N = a + ((aH - a) / (1 + (Math.pow((aG / aG), aE))))
							}
							if (this.xAxisTransform) {
								aG = this.xAxisTransform == "percentile" ? this.percentile(f, M, aG) : this.transformValue(this.xAxisTransform, aG)
							}
							H = Y + ((aG - this.xAxisMin) * this.xAxisUnit);
							g = (U + this.y) - ((N - this.yAxisMin) * this.yAxisUnit);
							this.addToRender(["drawLine", "dottedLine", Y, g, H, g, L]);
							this.addToRender(["drawLine", "dottedLine", H, g, H, (U + this.y), L])
						}
					}
				}
				if (af.line) {
					for (var ab = 0; ab < af.line.length; ab++) {
						if (af.line[ab].x != null || af.line[ab].y != null) {
							var L = af.line[ab].color ? af.line[ab].color : this.colors[ab % this.colors.length];
							var ah = af.line[ab].type ? af.line[ab].type : "line";
							var O = af.line[ab].x != null ? af.line[ab].x : null;
							var N = af.line[ab].y != null ? af.line[ab].y : null;
							var D = af.line[ab].x2 != null ? af.line[ab].x2 : null;
							var b = af.line[ab].y2 != null ? af.line[ab].y2 : null;
							var Q = af.line[ab].width ? af.line[ab].width : 1;
							var H, g, F, e;
							if (O != null && N != null && D != null && b != null) {
								H = Y + ((O - this.xAxisMin) * this.xAxisUnit);
								F = Y + ((D - this.xAxisMin) * this.xAxisUnit);
								g = U + this.y - ((N - this.yAxisMin) * this.yAxisUnit);
								e = U + this.y - ((b - this.yAxisMin) * this.yAxisUnit);
								this.addToRender(["drawLine", ah, H, g, F, e, L, Q])
							} else {
								if (O != null) {
									H = Y + ((O - this.xAxisMin) * this.xAxisUnit);
									g = U;
									F = H;
									e = g + this.y;
									this.addToRender(["drawLine", ah, H, g, F, e, L, Q])
								} else {
									if (N != null) {
										H = Y;
										g = U + this.y - ((N - this.yAxisMin) * this.yAxisUnit);
										F = H + this.x;
										e = g;
										this.addToRender(["drawLine", ah, H, g, F, e, L, Q])
									}
								}
							}
						}
					}
				}
				if (af.reg) {
					for (var ab = 0; ab < af.reg.length; ab++) {
						if (af.reg[ab].slope && af.reg[ab].intercept) {
							var L = af.reg[ab].color ? af.reg[ab].color : this.colors[ab % this.colors.length];
							var G = this.addColorTransparency(this.colors[ab % this.colors.length], 0.5);
							var m = this.getPropertyValue(ab, false, "patternBy");
							var ah = af.reg[ab].type ? af.reg[ab].type : "line";
							var aA = Number(af.reg[ab].slope);
							var ad = Number(af.reg[ab].intercept);
							var I = af.reg[ab].cor;
							var u = "y ~ " + this.formatNumber(aA) + "x + " + this.formatNumber(ad) + " (r = " + this.formatNumber(I) + ")";
							var R = af.reg[ab].ci;
							var H = af.reg[ab].start ? af.reg[ab].start : this.xAxisMin;
							var g = (aA * H) + ad;
							var F = af.reg[ab].end ? af.reg[ab].end : this.xAxisMax;
							var e = (aA * F) + ad;
							H = Y + (H * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							g = (U + this.y) - (g * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							F = Y + (F * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							e = (U + this.y) - (e * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							this.addToRender(["drawLine", ah, H, g, F, e, L, false, false, false, false, true]);
							var v = [];
							var r = [];
							var J = R.length - 1;
							var al = [];
							for (var aa = 0; aa < R.length; aa++) {
								H = Y + (R[aa][0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
								g = (U + this.y) - (R[aa][1] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
								e = (U + this.y) - (R[aa][2] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
								v.push([H, H]);
								r.push([g, e]);
								al.push([H, (g + e) / 2])
							}
							if (this.showDecorationsRegressionConfidence) {
								this.addToRender(["drawShape", "confidence", v, r, false, false, G, false, m, false, false, true], [u + ":Confidence"], false, null, false, al)
							}
						}
					}
				}
				if (af.nor) {
					for (var ab = 0; ab < af.nor.length; ab++) {
						if (af.nor[ab].mu && af.nor[ab].sigma) {
							var C = [];
							var B = [];
							var ar = [];
							var H, g;
							var L = ab % this.colors.length;
							var am = af.nor[ab].mu;
							var aj = af.nor[ab].sigma;
							var p = af.nor[ab].start ? af.nor[ab].start : af.nor[ab].yAxis ? this.yAxisMin : this.xAxisMin;
							var ac = af.nor[ab].end ? af.nor[ab].end : af.nor[ab].yAxis ? this.yAxisMax : this.xAxisMax;
							var an = 120;
							if (p < am && am < ac) {
								var ax, ao, q, c;
								var P = (am - p) / an;
								var s = aj * aj;
								var T = s * 2;
								var ae = 1 / Math.sqrt(2 * Math.PI * s);
								if (af.nor[ab].yAxis) {
									q = af.nor[ab].max ? af.nor[ab].max * this.xAxisUnit : this.x - (this.x * this.axisExtension);
									c = q / ae;
									ax = p;
									for (var aa = 0; aa < an - 1; aa++) {
										ao = (ae * Math.pow(Math.E, -Math.pow(ax - am, 2) / s));
										ar.push([ax, ao]);
										H = Y + (ao * c);
										g = (U + this.y) - (ax * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
										C.push(H);
										B.push(g);
										ax += P
									}
									P = (ac - am) / an;
									ax = am;
									for (var aa = 0; aa < an; aa++) {
										ao = (ae * Math.pow(Math.E, -Math.pow(ax - am, 2) / s));
										ar.push([ax, ao]);
										H = Y + (ao * c);
										g = (U + this.y) - (ax * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
										C.push(H);
										B.push(g);
										ax += P
									}
									L = af.nor[ab].color ? af.nor[ab].color : this.colors[L];
									this.addToRender(["drawShape", "path", C, B, false, false, L, L, "open", false, false, true])
								} else {
									q = af.nor[ab].max ? af.nor[ab].max * this.yAxisUnit : this.y - (this.y * this.axisExtension);
									c = q / ae;
									ax = p;
									for (var aa = 0; aa < an - 1; aa++) {
										ao = (ae * Math.pow(Math.E, -Math.pow(ax - am, 2) / s));
										ar.push([ax, ao]);
										H = Y + (ax * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
										g = (U + this.y) - (ao * c);
										C.push(H);
										B.push(g);
										ax += P
									}
									P = (ac - am) / an;
									ax = am;
									for (var aa = 0; aa < an; aa++) {
										ao = (ae * Math.pow(Math.E, -Math.pow(ax - am, 2) / s));
										ar.push([ax, ao]);
										H = Y + (ax * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
										g = (U + this.y) - (ao * c);
										C.push(H);
										B.push(g);
										ax += P
									}
									L = af.nor[ab].color ? af.nor[ab].color : this.colors[L];
									this.addToRender(["drawShape", "path", C, B, false, false, L, L, "open", false, false, true])
								}
							}
						}
					}
				}
				if (af.area) {
					for (var ab = 0; ab < af.area.length; ab++) {
						if (af.area[ab].type && af.area[ab].x && af.area[ab].y && af.area[ab].width && af.area[ab].height) {
							if (this.isValidShape(af.area[ab].type)) {
								var H = Y + (af.area[ab].x * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
								var g = (U + this.y) - (af.area[ab].y * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
								var L = af.area[ab].color ? af.area[ab].color : this.colors[ab % this.colors.length];
								var o = af.area[ab].width * this.xAxisUnit;
								var ag = af.area[ab].height * this.yAxisUnit;
								this.addToRender(["drawShape", af.area[ab].type, H, g, o, ag, L, af.area[ab].outline, af.area[ab].pattern, af.area[ab].rotate])
							}
						}
					}
				}
				if (af.kaplanMeier) {
					var H, g, F, e, aB, az, X, W, L, G, ai, aC, aF, aD, aq;
					for (var ab = 0; ab < af.kaplanMeier.length; ab++) {
						ai = [
							[],
							[]
						];
						aC = [
							[],
							[]
						];
						aF = [
							[],
							[]
						];
						L = af.kaplanMeier[ab].color;
						G = this.addColorTransparency(L, 0.5);
						H = Y;
						g = (U + this.y) - (this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						F = Y + (af.kaplanMeier[ab].data.times[0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
						e = (U + this.y) - (af.kaplanMeier[ab].data.data[0][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						az = (U + this.y) - (af.kaplanMeier[ab].data.data[0][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						W = (U + this.y) - (af.kaplanMeier[ab].data.data[0][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						aD = H;
						aq = g;
						this.addToRender(["drawLine", "line", H, g, F, g, L, false, false, false, false, true], false, false, null, false, [aD, aq, aD, aq]);
						this.addToRender(["drawLine", "line", F, g, F, e, L, false, false, false, false, true], false, false, null, false, [aD, aq, aD, aq]);
						if (this.showDecorationsKaplanMeierConfidence) {
							ai[0].push(H, F, F);
							ai[1].push(g, g, az);
							aC[0].push(H, F, F);
							aC[1].push(g, g, W)
						}
						for (var aa = 1; aa < af.kaplanMeier[ab].data.times.length; aa++) {
							H = Y + (af.kaplanMeier[ab].data.times[aa - 1] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							g = (U + this.y) - (af.kaplanMeier[ab].data.data[aa - 1][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							aB = (U + this.y) - (af.kaplanMeier[ab].data.data[aa - 1][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							X = (U + this.y) - (af.kaplanMeier[ab].data.data[aa - 1][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							F = Y + (af.kaplanMeier[ab].data.times[aa] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							e = (U + this.y) - (af.kaplanMeier[ab].data.data[aa][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							az = (U + this.y) - (af.kaplanMeier[ab].data.data[aa][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							W = (U + this.y) - (af.kaplanMeier[ab].data.data[aa][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							this.addToRender(["drawLine", "line", H, g, F, g, L, false, false, false, false, true], false, false, null, false, [aD, aq, aD, aq]);
							this.addToRender(["drawLine", "line", F, g, F, e, L, false, false, false, false, true], false, false, null, false, [aD, aq, aD, aq]);
							if (this.showDecorationsKaplanMeierConfidence) {
								ai[0].push(H, F, F);
								ai[1].push(aB, aB, az);
								aC[0].push(H, F, F);
								aC[1].push(X, X, W)
							}
						}
						if (this.showDecorationsKaplanMeierConfidence) {
							aF[0] = ai[0].concat(aC[0].reverse());
							aF[1] = ai[1].concat(aC[1].reverse());
							this.addToRender(["drawShape", "polygon", aF[0], aF[1], false, false, G, G, "closed"])
						}
					}
				}
			} else {
				if (af.line) {
					for (var ab = 0; ab < af.line.length; ab++) {
						var H, g, F, e;
						var ak = true;
						var ah = af.line[ab].type || "line";
						var z = af.line[ab].color;
						var S = this.transformValue(this.isTransformedData, af.line[ab].value || 0);
						var n = af.line[ab].label || false;
						var ap = af.line[ab].width || 1;
						var ay = af.line[ab].align || "left";
						if (this.graphOrientation == "vertical") {
							H = this.marginLeft + this.offsetX + this.left;
							F = H + this.x;
							g = this.marginTop + this.offsetY + this.top + this.y - ((S - this.xAxisMin) * this.xAxisUnit);
							e = g;
							ak = g <= this.marginTop + this.offsetY + this.top + this.y && g >= this.marginTop + this.offsetY + this.top ? true : false
						} else {
							H = this.marginLeft + this.offsetX + this.left + ((S - this.xAxisMin) * this.xAxisUnit);
							F = H;
							g = this.marginTop + this.offsetY + this.top;
							e = g + this.y;
							ak = H <= this.marginLeft + this.offsetX + this.left + this.x && this.marginLeft + this.offsetX + this.left ? true : false
						}
						if (ak) {
							if (n) {
								if (this.graphOrientation == "vertical") {
									if (ay == "right") {
										this.addToRender(["drawText", n, F - this.margin, e - this.margin, this.decorationFont, this.decorationColor, "right", "bottom"])
									} else {
										if (ay == "center") {
											this.addToRender(["drawText", n, H + (this.x / 2), e - this.margin, this.decorationFont, this.decorationColor, "center", "bottom"])
										} else {
											this.addToRender(["drawText", n, H + this.margin, e - this.margin, this.decorationFont, this.decorationColor, "left", "bottom"])
										}
									}
								} else {
									if (ay == "right") {
										this.addToRender(["drawText", n, F + (this.margin * 2), e - this.margin, this.decorationFont, this.decorationColor, "left", "middle"])
									} else {
										if (ay == "center") {
											this.addToRender(["drawText", n, F + (this.margin * 2), g + (this.y / 2), this.decorationFont, this.decorationColor, "left", "middle"])
										} else {
											this.addToRender(["drawText", n, F + (this.margin * 2), g + this.margin, this.decorationFont, this.decorationColor, "left", "middle"])
										}
									}
								}
							}
							this.addToRender(["drawLine", ah, H, g, F, e, z, ap])
						}
					}
				}
				if (af.marker) {
					this.drawMarkers()
				}
			}
		}
	};
	this.drawOncoprintLegend = function() {
		this.functionCaller = "drawOncoprintLegend";
		if (this.isOncoprint) {
			var a = this.marginLeft + this.offsetX + this.left + 15;
			var g = this.marginTop + this.offsetY + this.top + this.y + this.bottom + this.margin - 30;
			var d = this.measureText("Amplification", this.legendFont);
			var i = this.measureText("Deletion", this.legendFont);
			var f = this.measureText("Mutation", this.legendFont);
			if (this.legendOncoprintX && this.legendOncoprintY) {
				a = this.legendOncoprintX;
				g = this.legendOncoprintY
			} else {
				if (this.showLegend) {
					if (!this.legendInside && this.legendPosition == "bottom") {
						g -= this.legendHeight
					}
				}
			}
			this.legendOncoprintCurX = a;
			this.legendOncoprintCurY = g;
			var h = this.legendOncoprintCurX - 10;
			var e = g - 20;
			var c = 100 + d + i + f + (this.margin * 2);
			var b = 30 + (this.margin * 2);
			this.addToRender(["drawShape", "rect", h + (c / 2), e + (b / 2), c, b, this.background, this.background], [-1], ["-legend-oncoprint"]);
			this.addToRender(["drawShape", "rect", a, g, 10, 30, "rgb(255,0,0)"], ["Onc-Amplification"]);
			a = a + 10 + this.margin;
			this.addToRender(["drawText", "Amplification", a, g, this.legendFont, this.legendColor, "left", "middle"]);
			a = a + d + 25;
			this.addToRender(["drawShape", "rect", a, g, 10, 30, "rgb(0,0,255)"], ["Onc-Deletion"]);
			a = a + 10 + this.margin;
			this.addToRender(["drawText", "Deletion", a, g, this.legendFont, this.legendColor, "left", "middle"]);
			a = a + i + 25;
			this.addToRender(["drawShape", "rect", a, g, 10, 30, "rgb(220,220,220)"], ["Onc-Mutation"]);
			this.addToRender(["drawShape", "rect", a, g, 10, 10, "rgb(0,153,0)"]);
			a = a + 10 + this.margin;
			this.addToRender(["drawText", "Mutation", a, g, this.legendFont, this.legendColor, "left", "middle"])
		}
	};
	this.drawStockIndicatorsLegend = function() {
		this.functionCaller = "drawStockIndicatorsLegend";
		var d = this.marginLeft + this.offsetX + this.left;
		var n = this.marginTop + this.offsetY + this.top;
		if (this.summaryType == "candle" && this.stockIndicators.length > 0) {
			var a = this.getFontPt(this.legendFont);
			var f = a / 2;
			var b = this.measureText(this.getMaxText(this.stockIndicators), this.legendFont) + a + (this.margin * 2);
			var k = this.graphOrientation == "vertical" ? d + (this.margin * 2) : d + this.x - b;
			var j = n + this.margin + a;
			for (var e = 0; e < this.stockIndicators.length; e++) {
				var g = this.getTechnicalIndicatorColor(this.stockIndicators[e]);
				this.addToRender(["drawLine", "line", k + f, j + f, k + f + a, j + f, g, false, "butt", false, false, true]);
				this.addToRender(["drawText", this.stockIndicators[e], k + a + this.margin, j + f, this.legendFont, g, "left", "middle"]);
				j += this.margin + a
			}
		}
	};
	this.drawSampleLegend = function(b, l) {
		this.functionCaller = "drawSampleLegend";
		var k = b;
		var d = l;
		var q = this.getFontPt(this.legendFont);
		var p = (q - 1) / 2;
		l += this.margin + p;
		this.drawLegendBackgroundBox(k, d, this.legendSampleWidth, this.legendSampleHeight, true, "-legend-sample");
		var n = Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
		for (var f = 0; f < n; f++) {
			var c = f % this.colors.length;
			var o = 0;
			var h = this.getPropertyValue(f, false, "patternBy");
			var g = this.xAxisIndices.length == this.yAxisIndices.length ? this.yAxis[f] : this.xAxisIndices.length > this.yAxisIndices.length ? this.yAxis[this.yAxisCurrent] : this.yAxis[f];
			var j = this.xAxisIndices.length == this.yAxisIndices.length ? this.xAxis[f] : this.xAxisIndices.length > this.yAxisIndices.length ? this.xAxis[f] : this.xAxis[this.xAxisCurrent];
			var m = this.isHistogram ? this.shortenText(g, this.maxSmpStringLen) : this.shortenText(g, this.maxSmpStringLen) + " vs " + this.shortenText(j, this.maxSmpStringLen);
			var e = b + p + this.margin;
			var a = l + p + this.margin;
			if (this.colorBy) {
				this.addToRender(["drawShape", this.shapes[o], e, l, q - 1, q - 1, this.background, this.colors[c], "open"])
			} else {
				this.addToRender(["drawShape", this.shapes[o], e, l, q - 1, q - 1, this.colors[c], this.foreground, h])
			}
			this.addToRender(["drawText", m, e + p + this.margin, l, this.legendFont, this.legendColor, "left", "middle"]);
			l += q + this.margin
		}
		this.drawLegendBackgroundBox(k, d, this.legendSampleWidth, this.legendSampleHeight)
	};
	this.drawVariableLegend = function(z, c) {
		this.functionCaller = "drawVariableLegend";
		var n = z;
		var B = c;
		var m = this.getFontPt(this.legendFont);
		var r = m / 2;
		var a = m * 2;
		var d = m * 1.5;
		var s = 0;
		if (this.legendVariableWidth == 0 || this.legendVariableHeight == 0) {
			return
		} else {
			if (this.graphType == "Pie") {
				this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true, "-legend-variable");
				var y = !this.layoutComb ? this.width - (z + (this.margin * 1.5)) : this.isDOE ? this.layoutWidth - ((z - this.offsetX) + (this.margin * 1.5)) : 999999;
				z += r + this.margin;
				c += m;
				for (var v = 0; v < this.varPie.ids.length; v++) {
					var e = false;
					var l = this.varPie.ids[v];
					var f = this.varPie.cols[v];
					var p = l > -1 ? this.shortenText(this.data.y.vars[l], this.maxVarStringLen) : "Other";
					this.addToRender(["drawShape", "square", z, c, m, m, f, this.foreground, "closed"]);
					if (y > 0) {
						while (this.measureText(p, this.legendFont) > y && p.length > 1) {
							p = p.substring(0, p.length - 1);
							e = true
						}
						if (e) {
							p = p + "..."
						}
						this.addToRender(["drawText", p, z + m, c, this.legendFont, this.legendColor, "left", "middle"])
					}
					c += m + this.margin;
					if (this.layoutComb) {
						if ((c - this.offsetY) > this.layoutHeight) {
							this.addToRender(["drawText", "...", z + m, c, this.legendFont, this.legendColor, "left", "bottom"]);
							break
						}
					} else {
						if (c > this.height) {
							this.addToRender(["drawText", "...", z + m, c, this.legendFont, this.legendColor, "left", "bottom"]);
							break
						}
					}
				}
				this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight)
			} else {
				if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable") || (this.patternBy && this.patternBy == "variable")) {
					this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true, "-legend-variable");
					var u = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], m) : m;
					var A = u / 2;
					var x = this.legendVariableWidth / this.legendColumns;
					var b = Math.ceil(this.varIndices.length / this.legendColumns);
					c += this.margin + this.margin;
					for (var v = 0; v < b; v++) {
						for (var q = 0; q < this.legendColumns; q++) {
							z = n + (this.margin + (x * q));
							if (s < this.varIndices.length) {
								var l = this.varIndices[s];
								var f = this.graphType == "Circular" || (this.colorBy && this.colorBy == "variable") ? s % this.colors.length : 0;
								var o = this.shapeBy && this.shapeBy == "variable" ? s % this.shapes.length : 0;
								var t = this.sizeBy && this.sizeBy == "variable" ? this.sizes[s % this.sizes.length] : u;
								var k = this.patternBy && this.patternBy == "variable" ? this.patterns[s % this.patterns.length] : this.getPropertyValue(l, false, "patternBy");
								var h = z + A;
								var w = c + A;
								var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
								if (this.colorBy && this.colorBy != "variable") {
									this.addToRender(["drawShape", this.shapes[o], h, c, t, t, this.background, this.foreground, k])
								} else {
									this.addToRender(["drawShape", this.shapes[o], h, c, t, t, this.colors[f], this.foreground, k])
								}
								this.addToRender(["drawText", p, h + A + this.margin, c, this.legendFont, this.legendColor, "left", "middle"])
							} else {
								break
							}
							s++
						}
						c += u + this.margin
					}
					this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight)
				} else {
					if (this.graphType == "BarLine" || this.graphType == "DotLine" || this.graphType == "AreaLine" || this.graphType == "StackedLine" || this.graphType == "StackedPercentLine") {
						this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true, "-legend-variable");
						var g = this.xAxisVarIndices.concat(this.xAxis2VarIndices);
						var x = this.legendVariableWidth / this.legendColumns;
						var b = Math.ceil(g.length / this.legendColumns);
						c += this.margin;
						for (var v = 0; v < b; v++) {
							for (var q = 0; q < this.legendColumns; q++) {
								z = n + this.margin + (x * q);
								if (s < g.length) {
									var l = s < this.xAxisVarIndices.length ? this.xAxisVarIndices[s] : this.xAxis2VarIndices[s - this.xAxisVarIndices.length];
									var f = s < this.xAxisVarIndices.length ? this.getVariableColor(this.data.y.vars[l]) : this.coordinateLineColor ? this.colors[(s - this.xAxisVarIndices.length) % this.colors.length] : this.getVariableColor(this.data.y.vars[l]);
									var k = this.getPropertyValue(l, false, "patternBy");
									var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
									if (s < this.xAxisVarIndices.length) {
										this.addToRender(["drawShape", "rectangle", z + (m / 2), c + (m / 2), m, m, f, this.foreground, k], ["Var-" + l]);
										this.addToRender(["drawText", p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"], ["Var-" + l])
									} else {
										this.addToRender(["drawLine", "line", z, c + r, z + m, c + r, f], ["Var-" + l]);
										if (this.lineDecoration) {
											this.addToRender(["drawShape", this.lineDecoration == "symbol" ? this.shapes[(s - this.xAxisVarIndices.length) % this.shapes.length] : "circle", z + r, c + r, r, r, f, this.foreground, k])
										}
										this.addToRender(["drawText", p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"], ["Var-" + l])
									}
								} else {
									break
								}
								s++
							}
							c += d
						}
						this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight)
					} else {
						if (this.graphType == "Bar" || this.graphType == "Line" || this.graphType == "ParallelCoordinates" || this.graphType == "Area" || this.graphType == "Dotplot" || this.graphType == "Stacked" || this.graphType == "StackedPercent" || this.graphType == "Boxplot") {
							this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true, "-legend-variable");
							var x = this.legendVariableWidth / this.legendColumns;
							var b = Math.ceil(this.varIndices.length / this.legendColumns);
							c += this.margin;
							for (var v = 0; v < b; v++) {
								for (var q = 0; q < this.legendColumns; q++) {
									z = n + this.margin + (x * q);
									if (s < this.varIndices.length) {
										var l = this.varIndices[s];
										var f = this.getVariableColor(this.data.y.vars[l]);
										var k = this.getPropertyValue(l, false, "patternBy");
										var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
										if (this.graphType == "Line" || this.graphType == "ParallelCoordinates") {
											this.addToRender(["drawLine", "line", z, c + r, z + m, c + r, f], ["Var-" + l]);
											if (this.lineDecoration) {
												this.addToRender(["drawShape", this.lineDecoration == "symbol" ? this.shapes[s % this.shapes.length] : "circle", z + r, c + r, r, r, f, f, k])
											}
										} else {
											if (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
												this.addToRender(["drawShape", "circle", z + r, c + r, m, m, f, this.foreground, k], ["Var-" + l])
											} else {
												this.addToRender(["drawShape", "rectangle", z + (m / 2), c + (m / 2), m, m, f, this.foreground, k], ["Var-" + l])
											}
										}
										this.addToRender(["drawText", p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"], ["Var-" + l])
									} else {
										break
									}
									s++
								}
								c += d
							}
							this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight)
						}
					}
				}
			}
		}
	};
	this.drawVennLegend = function() {
		this.functionCaller = "drawVennLegend";
		if (this.showLegend) {
			var j = this.getFontPt(this.legendFont);
			var d = this.vennMarginLeft + this.marginLeft + this.left;
			var c = d + (j * 2);
			var g = this.vennMarginTop + this.marginTop + this.top + this.y + this.margin + (j / 2);
			var h = [];
			var a = [];
			for (var f in this.data.venn.legend) {
				a.push(f)
			}
			a = a.sort();
			if (this.vennGroups == 4) {
				h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
				h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)");
				h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)");
				h.push(this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
			} else {
				if (this.vennGroups == 3) {
					h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
					h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
					h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
				} else {
					if (this.vennGroups == 2) {
						h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
						h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)")
					} else {
						h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)")
					}
				}
			}
			for (var f = 0; f < this.vennGroups; f++) {
				if (!this.vennLegendColors) {
					this.addToRender(["drawText", a[f] + ": ", d, g, this.legendFont, this.legendColor, "left", "middle"])
				}
				var b = this.data.venn.legend && this.data.venn.legend[a[f]] ? this.data.venn.legend[a[f]] : "N/A";
				var e = (this.measureText(b, this.legendFont) > this.x) ? this.scaleTextToFont(b, j, this.x - this.margin) : this.legendFont;
				if (!this.vennLegendColors) {
					this.addToRender(["drawText", b, c, g, e, this.legendColor, "left", "middle"])
				} else {
					this.addToRender(["drawText", b, d, g, e, h[f], "left", "middle"])
				}
				g += this.margin + j
			}
		}
	};
	this.drawCircularLegend = function() {
		this.functionCaller = "drawCircularLegend";
		var e = this.legendPosition == "top" ? this.marginLeft + this.left : this.width - (this.legendVariableWidth + this.right + this.marginRight);
		var c = this.legendPosition == "top" ? this.marginTop + this.top : this.height - (this.legendVariableHeight + this.bottom + this.marginBottom);
		var t = this.legendVariableCurX || e;
		var a = this.legendVariableCurY || c;
		this.legendVariableCurX = this.legendVariableCurX ? t : false;
		this.legendVariableCurY = this.legendVariableCurY ? a : false;
		if (this.showLegend) {
			var h = t;
			var u = a;
			var g = this.getFontPt(this.legendFont);
			var o = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], g) : g;
			a += this.margin + (o / 2);
			this.drawLegendBackgroundBox(h, u, this.legendVariableWidth, this.legendVariableHeight, true, "-legend-variable");
			var f = 0;
			for (var p = 0; p < this.ringsNumber; p++) {
				if (this.rAxisIndex >= 0 && p == this.rAxisIndex) {
					continue
				}
				if (this.rAxisIndex < 0 && this.ringsType[p] == "heatmap") {
					f += this.ringsVarIndices[p].length;
					continue
				}
				for (var n = 0; n < this.ringsVarIndices[p].length; n++) {
					var s = this.ringsVarIndices[p][n];
					var b = f % this.colors.length;
					var k = this.shapeBy && this.shapeBy == "variable" ? f % this.shapes.length : 0;
					var q = this.sizeBy && this.sizeBy == "variable" ? this.sizes[f % 5] : o;
					var m = o / 2;
					var d = t + m + this.margin;
					var r = a + m + this.margin;
					var l = this.shortenText(this.data.y.vars[s], this.maxVarStringLen);
					if (this.colorBy && this.colorBy != "variable") {
						this.addToRender(["drawShape", this.shapes[k], d, a, q, q, this.background, this.foreground, "open"])
					} else {
						this.addToRender(["drawShape", this.shapes[k], d, a, q, q, this.colors[b], this.foreground, "closed"])
					}
					this.addToRender(["drawText", l, d + m + this.margin, a, this.legendFont, this.legendColor, "left", "middle"]);
					a += o + this.margin;
					f++
				}
			}
			this.drawLegendBackgroundBox(h, u, this.legendVariableWidth, this.legendVariableHeight)
		}
	};
	this.drawColorIndicator = function(z, e, n, F, C, f) {
		this.functionCaller = "drawColorIndicator";
		if (f || C || this.colorBy || this.outlineBy || this.colorNodeBy) {
			var l = f ? "-legend-" + f + "-color" : C ? "-legend-indicator-color" : "-legend-color";
			var g = f ? "overlaysLegendPosition" : C ? "heatmapIndicatorPosition" : "legendPosition";
			var E = f ? f : C ? 0 : this.legendColorWidth ? this.legendColorWidth / 2 : 10;
			var q = z;
			var D = e;
			var y = this.heatmapIndicatorHeight;
			var d = this.heatmapIndicatorHeight;
			var s = n.min;
			var w = n.max;
			var a = n.decs;
			var p = n.vals;
			var o = this.heatmapIndicatorWidth / (w - s);
			var B = this.graphType == "Network" || this.graphType == "Circular" ? n : n.colorBrew ? n.colorBrew : this.meta.def.colorBrew;
			var k = this.heatmapIndicatorWidth / this.colorSpectrumNumber;
			var r = g == "overlaysLegendPosition" && this[g] == "topRight" ? true : false;
			var b = this.heatmapIndicatorHeight + (this.getFontPt(this.legendFont) * ((F || this.colorBy || this.outlineBy || this.colorNodeBy) ? 2 : 1)) + (this.margin * 2);
			if (this[g] && this[g].toString().match(/top|bottom/) && !r) {
				this.drawLegendBackgroundBox(q - (this.margin * 2), D - this.margin, this.heatmapIndicatorWidth + (this.margin * 4), b, true, "-legend-indicator-color", false, true);
				if (F || this.colorBy || this.outlineBy || this.colorNodeBy) {
					this.addToRender(["drawText", F || this.colorBy || this.outlineBy || this.colorNodeBy, z + (this.heatmapIndicatorWidth / 2), e, this.legendFont, this.legendColor, "center", "top"]);
					e += this.margin + this.getFontPt(this.legendFont)
				}
				for (var u = 0; u < this.colorSpectrumNumber; u++) {
					var m = B.stops && B.stops.length > 0 ? this.getColorForValue(B, B.breaks[u]) : B.legend[u];
					var A = this.transparency != null ? this.addColorTransparency(m, this.transparency) : m;
					this.addToRender(["drawLine", "line", z, e, z, e + d, A, k + 1.5]);
					z += k
				}
				z = q;
				e += d;
				if (B.stops && B.stops.length > 0) {
					var x = z + (this.measureText(B.breaks[0].toString(), this.legendFont) / 2);
					this.addToRender(["drawText", B.breaks[0], z, e, this.legendFont, this.legendColor, "center", "top"]);
					for (var u = 0; u < B.stops.length - 1; u++) {
						for (var t = 0; t < this.colorSpectrumNumber; t++) {
							if (B.breaks[t] >= B.stops[u]) {
								z = q + (t * k);
								var h = (this.measureText(B.breaks[u].toString(), this.legendFont) / 2);
								if (z - h > x) {
									this.addToRender(["drawText", B.stops[u], z, e, this.legendFont, this.legendColor, "center", "top"]);
									x = z + h
								}
								break
							}
						}
					}
					z = q + (this.colorSpectrumNumber * k);
					this.addToRender(["drawText", B.stops[B.stops.length - 1], z, e, this.legendFont, this.legendColor, "center", "top"])
				} else {
					this.addToRender(["drawText", s, z, e, this.legendFont, this.legendColor, "center", "top"]);
					z = q + (this.heatmapIndicatorWidth / 2);
					this.addToRender(["drawText", (s + w) / 2, z, e, this.legendFont, this.legendColor, "center", "top"]);
					z = q + ((this.colorSpectrumNumber - 1) * k);
					this.addToRender(["drawText", w, z, e, this.legendFont, this.legendColor, "center", "top"])
				}
				if (this.graphType == "Heatmap" && this.heatmapIndicatorHistogram) {
					this.drawHeatmapIndicatorHistogram(q, D)
				}
			} else {
				this.drawLegendBackgroundBox(q, D, this.legendColorWidth, this.legendColorHeight, true, l, false, true);
				if (F || this.colorBy || this.outlineBy || this.colorNodeBy) {
					this.addToRender(["drawText", F || this.colorBy || this.outlineBy || this.colorNodeBy, z + E, e, this.legendFont, this.legendColor, "center", "top"]);
					e += (this.margin * 1.5) + this.getFontPt(this.legendFont)
				}
				for (var u = 0; u < this.colorSpectrumNumber; u++) {
					var A = this.transparency != null ? this.addColorTransparency(B.legend[u], this.transparency) : B.legend[u];
					this.addToRender(["drawLine", "line", z, e, z + y, e, A, k + 1.5]);
					e += k
				}
				z += y;
				if (F || this.colorBy || this.outlineBy || this.colorNodeBy) {
					e = D + (this.margin * 1.5) + this.getFontPt(this.legendFont)
				} else {
					e = D
				}
				for (var u = 0; u < p.length; u++) {
					if (p[u] >= s && p[u] <= w) {
						var d = e + ((p[u] - s) * o);
						this.addToRender(["drawText", p[u], z + this.margin, d, this.legendFont, this.legendColor, "left", "middle"])
					}
				}
			}
		}
	};
	this.drawHeatmapIndicatorHistogram = function(x, b) {
		this.functionCaller = "drawHeatmapIndicatorHistogram";
		var w, a;
		var o = x;
		var z = b + this.heatmapIndicatorHeight;
		var y = [];
		for (var u = 0; u < this.data.y.vars.length; u++) {
			for (var s = 0; s < this.data.y.smps.length; s++) {
				var g = this.getDataAtPos(u, s, false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
				if (g != null && g != "" && !isNaN(g)) {
					y.push(g)
				}
			}
		}
		var k = this.range(y);
		var m = this.freedmanDiaconis(y);
		var r = k[0];
		var t = k[1];
		var q = Math.ceil((t - r) / m);
		var e = [];
		for (var u = 0; u < q; u++) {
			e[u] = 0
		}
		for (var u = 0; u < this.data.y.vars.length; u++) {
			for (var s = 0; s < this.data.y.smps.length; s++) {
				var g = this.getDataAtPos(u, s, false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
				if (g != null && g != "" && !isNaN(g)) {
					var n = parseInt((g - r) / m);
					e[n]++
				}
			}
		}
		r = 0;
		t = 0;
		for (var u = 0; u < q; u++) {
			r = Math.min(r, e[u]);
			t = Math.max(t, e[u])
		}
		var l = this.legendFont;
		var h = this[this.axisAlgorithm](r, t, 3, this.axisWilkinsonLoose);
		var p = this.getMaxText(h);
		var f = (this.heatmapIndicatorWidth - 1) / q;
		var c = this.heatmapIndicatorHeight / h[h.length - 1];
		if (this.heatmapIndicatorPosition == "topLeft") {
			l = this.scaleTextToFont(p, this.getFontPt(this.legendFont), this.left - (this.heatmapIndicatorWidth + (this.margin * 3)))
		}
		for (var u = 0; u < h.length; u++) {
			b = (h[u] * c);
			this.addToRender(["drawLine", "line", o - this.margin, z - b, o, z - b, this.foreground]);
			this.addToRender(["drawText", h[u], o - (this.margin * 1.5), z - b, l, this.legendColor, "right", "middle"])
		}
		b = (e[0] * c);
		this.addToRender(["drawLine", "line", o, z, o, z - b, this.heatmapIndicatorHistogramColor]);
		for (var u = 0; u < q; u++) {
			b = (e[u] * c);
			this.addToRender(["drawLine", "line", o, z - b, o + f, z - b, this.heatmapIndicatorHistogramColor]);
			if (u < q - 1) {
				a = (e[u + 1] * c);
				this.addToRender(["drawLine", "line", o + f, z - b, o + f, z - a, this.heatmapIndicatorHistogramColor])
			}
			o += f
		}
		this.addToRender(["drawLine", "line", o, z - a, o, z, this.heatmapIndicatorHistogramColor])
	};
	this.drawColorLegend = function(a, b, c) {
		if (this.isMap) {
			a += parseInt(this.meta.canvas.ctx2.canvas.style.left);
			b += parseInt(this.meta.canvas.ctx2.canvas.style.top)
		}
		if ((this.outlineBy && this.isMultidimensionalData) || (this.colorBy && ((this.data.x && this.data.x.hasOwnProperty(this.colorBy)) || (this.data.z && this.data.z.hasOwnProperty(this.colorBy)) || this.getSampleIndices(this.colorBy) > -1))) {
			if (c.type == "Numeric" && !c.colorBy) {
				this.drawColorIndicator(a, b, c)
			} else {
				this.drawPropertyLegend("Color", a, b, c)
			}
		}
	};
	this.drawShapeLegend = function(a, b, c) {
		this.drawPropertyLegend("Shape", a, b, c)
	};
	this.drawSizeLegend = function(a, b, c) {
		this.drawPropertyLegend("Size", a, b, c)
	};
	this.drawPatternLegend = function(a, b, c) {
		this.drawPropertyLegend("Pattern", a, b, c)
	};
	this.drawPropertyLegend = function(f, A, h, o) {
		this.functionCaller = "drawPropertyLegend";
		var s = f.toLowerCase();
		if ((this[s + "By"] && this.isMultidimensionalData) || (this[s + "By"] && ((this.data.x && this.data.x.hasOwnProperty(this[s + "By"])) || (this.data.z && this.data.z.hasOwnProperty(this[s + "By"])) || this.getSampleIndices(this[s + "By"]) > -1))) {
			var B = f == "Size" ? 0 : this.getDiameterLegend();
			if (f == "Size") {
				for (var z = 0; z < this.legendSizesN; z++) {
					B = Math.max(B, o.sizes ? o.sizes[z] : this.sizes[z])
				}
			}
			var u = this.getFontPt(this.legendFont);
			var j = u / 2;
			var a = this.legendColumns > this["legend" + f + "sN"] ? this["legend" + f + "sN"] : this.legendColumns;
			var e = Math.ceil(this["legend" + f + "sN"] / a);
			var l = this["legend" + f + "Width"] / a;
			var g = h + this.margin + j;
			var y = Math.max(B, u);
			var w = 0;
			this.drawLegendBackgroundBox(A, h, this["legend" + f + "Width"], this["legend" + f + "Height"], true, "-legend-" + s);
			var D = f == "Color" && this.outlineBy ? this.outlineBy : this[s + "By"];
			this.addToRender(["drawText", D, A + (this["legend" + f + "Width"] / 2), g, this.legendFont, this.legendColor, "center", "middle"]);
			g += j + this.margin;
			this.disableGradientTransparencyShadow();
			if (this.legendBox) {
				this.addToRender(["drawLine", "line", A, g, A + this["legend" + f + "Width"], g, this.legendBoxColor])
			}
			this.enableGradientTransparencyShadow();
			g += this.margin + (y / 2);
			var b = this["legend" + f + "sS"] || this.sortObject(this["legend" + f + "s"]);
			for (var q = 0; q < e; q++) {
				for (var C = 0; C < a; C++) {
					var m = A + this.margin + B / 2 + (l * C);
					if (w < this["legend" + f + "sN"]) {
						var v = b[w];
						if (f == "Color") {
							var k = o.colorBy && o.colorBy.hasOwnProperty(v) ? o.colorBy[v] : this.legendColors[v];
							if (this.outlineBy) {
								this.addToRender(["drawShape", "circle", m, g, B, B, false, k, "open", false, 2])
							} else {
								this.addToRender(["drawShape", "circle", m, g, B, B, k, this.foreground, "closed"])
							}
						} else {
							if (f == "Shape") {
								var t = o.shapeBy && o.shapeBy.hasOwnProperty(v) ? o.shapeBy[v] : this.legendShapes[v];
								this.addToRender(["drawShape", t, m, g, B, B, this.background, this.foreground, "closed"])
							} else {
								if (f == "Size") {
									var x = o.sizeBy && o.sizeBy.hasOwnProperty(v) ? o.sizeBy[v] : this.legendSizes[v];
									this.addToRender(["drawShape", "circle", m, g, x, x, this.background, this.foreground, "closed"])
								} else {
									if (f == "Pattern") {
										var n = o.patternBy && o.patternBy.hasOwnProperty(v) ? o.patternBy[v] : this.legendPatterns[v];
										this.addToRender(["drawShape", "square", m, g, B, B, this.background, this.foreground, n])
									}
								}
							}
						}
						this.addToRender(["drawText", v, m + (y / 2) + this.margin, g, this.legendFont, this.legendColor, "left", "middle"])
					}
					w++
				}
				g += this.margin + y
			}
			this.drawLegendBackgroundBox(A, h, this["legend" + f + "Width"], this["legend" + f + "Height"])
		}
	};
	this.drawGenericLegend = function(a, p, k, e, o, j) {
		this.functionCaller = "drawGenericLegend";
		var f = this.getDiameterLegend();
		var d = this.getFontPt(this.legendFont);
		var n = Math.max(f, d);
		var b = n / 2;
		var g = 0;
		this.drawLegendBackgroundBox(a, p, k, e, true, "-legend");
		this.addToRender(["drawText", j, a + (k / 2), p + this.margin + (d / 2), this.legendFont, this.legendColor, "center", "middle"]);
		g = p + d + (this.margin * 2);
		if (this.legendBox) {
			this.addToRender(["drawLine", "line", a, g, a + k, g, this.legendBoxColor])
		}
		g += this.margin;
		for (var c = 0; c < o.levels.length; c++) {
			var m = o.type == "String" ? o.colors[c] : this.getColorForValue(o.colorBrew, o.levels[c]);
			this.addToRender(["drawShape", "square", a + this.margin + (f / 2), g + (n / 2), f, f, m, this.foreground]);
			this.addToRender(["drawText", o.levels[c], a + f + (this.margin * 2), g + (n / 2), this.legendFont, this.legendColor, "left", "middle"]);
			g += n + this.margin
		}
		this.drawLegendBackgroundBox(a, p, k, e)
	};
	this.drawDecorationLegend = function(e, s) {
		this.functionCaller = "drawDecorationLegend";
		if (this.graphType.match(/Scatter/)) {
			var p, o;
			var m = this.decorations;
			var u = this.getFontPt(this.decorationFont);
			var c = this.measureText(sprintf("%15s", "X"), this.decorationFont);
			var r = m.nlfit || m.nor || m.reg ? c : 0;
			var n = e + (r ? this.legendDecorationMaxLabel + c : this.margin);
			var a = n;
			var g = s;
			var q = g;
			this.legendDecorationCurX = e;
			this.legendDecorationCurY = s;
			this.drawLegendBackgroundBox(e, (s - ((u / 2) + this.margin)), this.legendDecorationWidth, this.legendDecorationHeight + this.margin, true, "-legend-decorations", true);
			if (m.nlfit) {
				this.addToRender(["drawText", "Min", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "Max", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "EC50", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "Slope", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "p-Val", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "F-Chg", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				q += u + u;
				for (var k = 0; k < m.nlfit.length; k++) {
					var f = k % this.colors.length;
					f = m.nlfit[k].color ? m.nlfit[k].color : this.colors[f];
					a = (n + this.margin) - c;
					if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
						a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
					}
					this.addToRender(["drawText", m.nlfit[k].label, a, q, this.decorationFont, f, "right", "middle"]);
					a = n;
					for (var h = 0; h < 6; h++) {
						var b = m.nlfit[k].param[h];
						if (h < 2) {
							b = this.transformValue(this.yAxisTransform, b)
						} else {
							if (h == 2) {}
						}
						this.addToRender(["drawText", this.formatNumber(b), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
						a += c + this.margin
					}
					q += u + u
				}
			}
			if (m.line) {
				for (var k = 0; k < m.line.length; k++) {
					if (m.line[k].label) {
						max = Math.max(max, this.measureText(m.line[k].label, this.decorationFont));
						for (var k = 0; k < m.line.length; k++) {
							var f = m.line[k].color ? m.line[k].color : this.colors[k % this.colors.length];
							if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
								a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
							}
							this.addToRender(["drawText", m.line[k].label, a, q, this.decorationFont, f, "left", "middle"]);
							q += u + u
						}
					}
				}
			}
			if (m.reg) {
				this.addToRender(["drawText", "Slope", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "Int", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "Cor", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				q += u + u;
				for (var k = 0; k < m.reg.length; k++) {
					var f = m.reg[k].color ? m.reg[k].color : this.colors[k % this.colors.length];
					a = (n + this.margin) - c;
					if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
						a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
					}
					this.addToRender(["drawText", m.reg[k].label, a, q, this.decorationFont, f, "right", "middle"]);
					a = n;
					this.addToRender(["drawText", this.formatNumber(m.reg[k].slope), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
					a += c + this.margin;
					this.addToRender(["drawText", this.formatNumber(m.reg[k].intercept), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
					a += c + this.margin;
					this.addToRender(["drawText", this.formatNumber(m.reg[k].cor), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
					a += c + this.margin;
					q += u + u
				}
			}
			if (m.nor) {
				this.addToRender(["drawText", "Mu", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				a += c + this.margin;
				this.addToRender(["drawText", "Sigma", a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
				q += u + u;
				for (var k = 0; k < m.nor.length; k++) {
					var f = k % this.colors.length;
					f = m.nor[k].color ? m.nor[k].color : this.colors[f];
					a = (n + this.margin) - c;
					if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
						a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
					}
					this.addToRender(["drawText", m.nor[k].label, a, q, this.decorationFont, f, "right", "middle"]);
					a = n;
					this.addToRender(["drawText", this.formatNumber(m.nor[k].mu), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
					a += c + this.margin;
					this.addToRender(["drawText", this.formatNumber(m.nor[k].sigma), a, q, this.decorationFont, this.decorationsColor, "right", "middle"]);
					a += c + this.margin;
					q += u + u
				}
			}
			if (m.area) {
				for (var k = 0; k < m.area.length; k++) {
					if (m.area[k].label) {
						var f = m.area[k].color ? m.area[k].color : this.colors[k % this.colors.length];
						if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
							a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
						}
						this.addToRender(["drawText", m.area[k].label, a, q, this.decorationFont, f, "left", "middle"]);
						q += u + u
					}
				}
			}
			if (m.kaplanMeier) {
				for (var k = 0; k < m.kaplanMeier.length; k++) {
					if (m.kaplanMeier[k].label) {
						var f = m.kaplanMeier[k].color ? m.kaplanMeier[k].color : this.colors[k % this.colors.length];
						if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
							a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
						}
						this.addToRender(["drawText", m.kaplanMeier[k].label, a, q, this.decorationFont, f, "left", "middle"]);
						q += u + u
					}
				}
			}
			this.drawLegendBackgroundBox(e, (s - ((u / 2) + this.margin)), this.legendDecorationWidth, this.legendDecorationHeight + this.margin, false, false, true)
		}
	};
	this.resetLegends = function(c) {
		if (c) {
			delete(this.legendDecorationCurX);
			delete(this.legendDecorationCurY);
			delete(this.legendDecorationX);
			delete(this.legendDecorationY)
		}
		var a = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
		for (var b = 0; b < a.length; b++) {
			this["legend" + a[b] + "Width"] = 0;
			this["legend" + a[b] + "Height"] = 0;
			if (c) {
				delete(this["legend" + a[b] + "CurX"]);
				delete(this["legend" + a[b] + "CurY"]);
				delete(this["legend" + a[b] + "X"]);
				delete(this["legend" + a[b] + "Y"])
			}
		}
		delete(this.legendColorIndicatorCurX);
		delete(this.legendColorIndicatorCurY)
	};
	this.getXYLegendCoords = function(u, b, z) {
		var r, p, a;
		var v = -1;
		var g = -1;
		var k = this;
		var n = function() {
			for (var l = 0; l < k.legendLayout.length; l++) {
				if (k.legendLayout[l]) {
					for (var h = 0; h < k.legendLayout[l].length; h++) {
						if (k.legendLayout[l][h] == u) {
							return [l, h]
						}
					}
				}
			}
			return [-1, -1]
		};
		if (this.legendLayout) {
			var m = n();
			v = m[0];
			g = m[1];
			if (v > -1 && g > -1) {
				var o = 0;
				var d = 0;
				if (this.legendPosition.match(/right|left/i)) {
					for (var e = 0; e < v; e++) {
						var s = 0;
						for (var c = 0; c < this.legendLayout[e].length; c++) {
							s = Math.max(s, this["legend" + this.legendLayout[e][c] + "Width"] + this.margin)
						}
						o += s
					}
					for (var c = 0; c < this.legendLayout[v].length; c++) {
						d += this["legend" + this.legendLayout[v][c] + "Height"] + this.margin
					}
				} else {
					for (var e = 0; e < v; e++) {
						var f = 0;
						for (var c = 0; c < this.legendLayout[e].length; c++) {
							f = Math.max(f, this["legend" + this.legendLayout[e][c] + "Height"] + this.margin)
						}
						d += f
					}
					for (var c = 0; c < this.legendLayout[v].length; c++) {
						o += this["legend" + this.legendLayout[v][c] + "Width"] + this.margin
					}
				}
				if (this.graphType == "Circular") {
					r = b;
					p = z
				} else {
					if (this.legendPosition.match(/right|left/i)) {
						z = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? this.marginTop + this.layoutTop : g == 0 ? this.marginTop + this.offsetY + this.top : z;
						r = b + o;
						a = this.legendPosition.match(/top/) ? this.margin : this.legendPosition.match(/bottom/) ? this.y - (d + this.margin) : ((this.y - d) / 2);
						p = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? (this.height - d) / 2 : g == 0 ? this.marginTop + this.offsetY + this.top + a : z;
						b = g == this.legendLayout[v].length - 1 ? b + o : b;
						z = p + this["legend" + this.legendLayout[v][g] + "Height"] + this.margin
					} else {
						b = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? this.marginLeft + this.layoutLeft : g == 0 ? this.marginLeft + this.offsetX + this.left : b;
						r = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? (this.width - o) / 2 : g == 0 ? this.marginLeft + this.offsetX + this.left + ((this.x - o) / 2) + this.margin : b + this.margin;
						p = z + d;
						b = r + this["legend" + this.legendLayout[v][g] + "Width"] + this.margin;
						z = g == this.legendLayout[v].length - 1 ? z + d : z
					}
				}
			}
		}
		return [r, p, b, z]
	};
	this.getVariableLegendPosition = function() {
		var c, h;
		if (this.graphType == "Pie") {
			if (this.legendPosition == "right") {
				if (this.isDOE) {
					c = this.marginLeft + this.offsetX + this.left + this.x - (this.margin * 3);
					h = this.marginTop + this.offsetY + this.top + (this.y / 2) - (this.legendVariableHeight / 2)
				} else {
					c = this.width - (this.marginRight + this.legendVariableWidth + this.margin);
					h = (this.height / 2) - (this.legendVariableHeight / 2)
				}
			} else {
				c = (this.width / 2) - (this.legendVariableWidth / 2);
				h = this.height - (this.marginBottom + this.legendVariableHeight + this.margin)
			}
		} else {
			if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
				return [0, 0]
			} else {
				if (this.layoutValid) {
					var d = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
					var b = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
					var j = this.legendVariableHeight + this.legendOverlaysHeight + this.margin;
					var e = this.legendVariableWidth + this.legendOverlaysWidth + this.margin;
					c = this.legendPosition == "right" ? this.width - (this.marginRight + e) : this.marginLeft + this.layoutLeft + (d / 2) - (e / 2);
					h = this.legendPosition == "right" ? this.marginTop + this.layoutTop + (b / 2) - (j / 2) : this.height - (this.marginBottom + j)
				} else {
					var f = this.marginLeft + this.offsetX + this.left;
					var k = this.marginTop + this.offsetY + this.top;
					var a = this.legendVariableHeight;
					var i = this.legendVariableWidth;
					if (this.legendInside) {
						switch (this.legendPosition) {
							case "bottomRight":
								c = f + this.x - (i + this.margin);
								h = k + this.y - (a + this.margin);
								break;
							case "bottom":
								c = f + (this.x / 2) - (i / 2);
								h = k + this.y - (a + this.margin);
								break;
							case "bottomLeft":
								c = f + this.margin;
								h = k + this.y - (a + this.margin);
								break;
							case "left":
								c = f + this.margin;
								h = k + (this.y / 2) - (a / 2);
								break;
							case "topLeft":
								c = f + this.margin;
								h = k + this.margin;
								break;
							case "top":
								c = f + (this.x / 2) - (i / 2);
								h = k + this.margin;
								break;
							case "topRight":
								c = f + this.x - (i + this.margin);
								h = k + this.margin;
								break;
							default:
								c = f + this.x - (i + this.margin);
								h = k + (this.y / 2) - (a / 2)
						}
					} else {
						var m = this.overlaysLegendPosition.match(/bottom/i) ? this.legendOverlaysHeight : 0;
						var g = this.overlaysLegendPosition.match(/right/i) ? this.legendOverlaysWidth : 0;
						switch (this.legendPosition) {
							case "bottom":
								c = f + (this.x / 2) - (i / 2);
								h = k + this.y + this.bottom - (a + m + this.margin);
								break;
							default:
								c = f + this.x + this.right - (i + g + this.margin);
								h = k + (this.y / 2) - (a / 2)
						}
					}
				}
			}
		}
		return [c, h]
	};
	this.getScatterLegendPosition = function() {
		var h = 0;
		var f = 0;
		var e = 0;
		var b = 0;
		var a = 0;
		var g = 0;
		var c = this.marginLeft + this.offsetX + this.left + this.margin;
		var i = this.marginTop + this.offsetY + this.top + this.margin;
		if (this.scatterPlotMatrix || this.layoutValid) {
			e = this.width + this.margin - (this.marginRight + (this.legendWidth || 0));
			b = this.height + this.margin - (this.marginBottom + (this.legendHeight || 0));
			h = e - (this.legendDecorationWidth + this.margin);
			f = b - (this.legendDecorationHeight + this.margin)
		} else {
			if (this.graphType == "Circular") {
				e = this.legendPosition == "top" ? this.marginLeft + this.left : this.width - (this.legendVariableWidth + this.right + this.marginRight);
				b = this.legendPosition == "top" ? this.marginTop + this.top : this.height - (this.legendVariableHeight + this.bottom + this.marginBottom)
			} else {
				if (this.legendInside) {
					if (this.legendDecorationWidth > 0 && this.legendDecorationHeight > 0) {
						var d = this.legendDecorationWidth + (this.margin * 2);
						switch (this.decorationsPosition) {
							case "bottomRight":
								h = c + this.x - d;
								f = i + this.y - (this.legendDecorationHeight + this.margin);
								break;
							case "bottom":
								h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
								f = i + this.y - (this.legendDecorationHeight + this.margin);
								break;
							case "bottomLeft":
								h = c + this.margin;
								f = i + this.y - (this.legendDecorationHeight + this.margin);
								break;
							case "left":
								h = c + this.margin;
								f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
								break;
							case "topLeft":
								h = c + this.margin;
								f = i + (this.margin * 2);
								break;
							case "top":
								h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
								f = i + (this.margin * 2);
								break;
							case "topRight":
								h = c + this.x - d;
								f = i + (this.margin * 2);
								break;
							default:
								h = c + this.x - d;
								f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
								break
						}
					}
					if (this.legendWidth > 0 && this.legendHeight > 0) {
						switch (this.legendPosition) {
							case "bottomRight":
								e = c + this.x - this.legendWidth;
								b = i + this.y - this.legendHeight;
								break;
							case "bottom":
								e = c + (this.x / 2) - (this.legendWidth / 2);
								b = i + this.y - this.legendHeight;
								break;
							case "bottomLeft":
								e = c;
								b = i + this.y - this.legendHeight;
								break;
							case "left":
								e = c;
								b = i + (this.y / 2) - (this.legendHeight / 2);
								break;
							case "topLeft":
								e = c;
								b = i;
								break;
							case "top":
								e = c + (this.x / 2) - (this.legendWidth / 2);
								b = i;
								break;
							case "topRight":
								e = c + this.x - this.legendWidth;
								b = i;
								break;
							default:
								e = c + this.x - this.legendWidth;
								b = i + (this.y / 2) - (this.legendHeight / 2);
								break
						}
					}
				} else {
					switch (this.decorationsPosition) {
						case "bottom":
							h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
							f = i + this.y + this.bottom - this.legendDecorationHeight;
							break;
						default:
							h = c + this.x + this.right - (this.legendDecorationWidth + (this.margin * 2));
							f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
							break
					}
					a = this.legendPosition == this.decorationsPosition ? this.legendDecorationWidth : 0;
					g = this.legendPosition == this.decorationsPosition ? this.legendDecorationHeight : 0;
					switch (this.legendPosition) {
						case "bottom":
							e = c + (this.x / 2) - (this.legendWidth / 2);
							b = i + this.y + this.bottom - (this.legendHeight + (g ? g + this.margin : 0));
							if (this.graphType == "Scatter3D" || this.is3DPlot) {
								b += this.legendHeight
							}
							break;
						default:
							e = c + this.x + this.right - (this.legendWidth + a);
							b = i + (this.y / 2) - (this.legendHeight / 2);
							if (this.graphType == "Scatter3D" || this.is3DPlot) {
								e += this.legendWidth
							}
							break
					}
				}
			}
		}
		return [h, f, e, b]
	};
	this.drawIndicator = function(a, b, c) {
		delete(this.legendColorIndicatorCurX);
		delete(this.legendColorIndicatorCurY);
		this.drawColorIndicator(a, b, false, c)
	};
	this.drawLegend = function() {
		if (this.graphType == "Venn") {
			this.drawVennLegend()
		} else {
			if (this.graphType == "Circular") {
				if (this.circularType == "sunburst") {
					this.drawScatterLegend()
				} else {
					this.drawCircularLegend()
				}
			} else {
				if (this.graphType.match(/Scatter/) || this.is3DPlot || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|TagCloud|ParallelCoordinates|Sankey|Tree|Line|Heatmap|Stacked|Map/))) {
					this.drawScatterLegend();
					if (this.isOncoprint) {
						this.drawOncoprintLegend()
					}
					this.drawOverlaysLegend()
				} else {
					this.draw1DLegend();
					this.drawOverlaysLegend()
				}
			}
		}
	};
	this.draw1DLegend = function() {
		this.drawStockIndicatorsLegend();
		if (this.showLegend && ((this.graphType != "Heatmap") || (this.graphType == "Heatmap" && (this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)))) {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|TagCloud|ParallelCoordinates|Sankey|Tree|Line|Heatmap|Stacked/))) {
				if (this.isOncoprint) {
					this.drawOncoprintLegend()
				}
				this.drawScatterLegend()
			} else {
				if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
					return
				}
				var c = this.getVariableLegendPosition();
				var a = c[0];
				var b = c[1];
				if (this.legendVariableX && this.legendVariableY) {
					a = this.legendVariableX;
					b = this.legendVariableY
				}
				this.legendVariableCurX = a;
				this.legendVariableCurY = b;
				this.drawVariableLegend(a, b)
			}
		} else {
			if (this.isOncoprint) {
				this.drawOncoprintLegend()
			}
		}
	};
	this.drawOverlaysLegend = function() {
		var q, d;
		if (this.overlaysLegendPosition.match(/right/i)) {
			q = this.layoutValid ? this.marginTop + this.layoutTop : this.marginTop + this.offsetY + this.top;
			if (this.overlaysLegendPosition == "right") {
				q += (this.y / 2) - (this.legendOverlaysHeight / 2)
			}
			d = this.layoutValid ? this.width - (this.marginRight + this.layoutRight + this.legendOverlaysWidth) : this.width - (this.marginRight + this.legendOverlaysWidth)
		} else {
			q = this.layoutValid ? this.height - (this.marginBottom + this.layoutBottom + this.legendOverlaysHeight) : this.height - (this.marginBottom + this.legendOverlaysHeight);
			d = this.layoutValid ? this.marginLeft + this.layoutLeft : this.marginLeft + this.offsetX + this.left;
			if (this.overlaysLegendPosition == "bottom") {
				d += (this.x / 2) - (this.legendOverlaysWidth / 2)
			}
		}
		var s = q;
		var e = d;
		for (var g = 0; g < this.legendOverlaysLayout.length; g++) {
			var k = this.legendOverlaysLayout[g];
			var p, a, b;
			var r = mw = 0;
			var n = mh = 0;
			for (var f = 0; f < k.length; f++) {
				p = k[f][0];
				a = k[f][1];
				mw = Math.max(r, k[f][2]);
				mh = Math.max(n, k[f][3])
			}
			for (var f = 0; f < k.length; f++) {
				p = k[f][0];
				a = k[f][1];
				b = this.meta.data[p][a];
				r = this["legend" + a + "Width"];
				n = this["legend" + a + "Height"];
				if (b.type == "String") {
					this.drawGenericLegend(e, s, r, n, b, a)
				} else {
					this.drawColorIndicator(e, s, b, a, false, r / 2)
				}
				if (this.overlaysLegendPosition.match(/right/i)) {
					s += n + this.margin
				} else {
					e += r + this.margin
				}
			}
			if (this.overlaysLegendPosition.match(/right/i)) {
				e += mw + this.margin;
				s = q
			} else {
				e = d;
				s += mh + this.margin
			}
		}
	};
	this.drawScatterLegend = function() {
		var j = this.getScatterLegendPosition();
		if (this.showDecorations && this.showDecorationsLegend && this.decorations && !this.scatterPlotMatrix) {
			if (this.legendDecorationX != null && this.legendDecorationY != null) {
				this.drawDecorationLegend(this.legendDecorationX, this.legendDecorationY)
			} else {
				this.drawDecorationLegend(j[0], j[1])
			}
		}
		if (this.showLegend) {
			var f = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			var c = j[2];
			var k = j[3];
			for (var d = 0; d < f.length; d++) {
				var o = this["legend" + f[d] + "Width"];
				var e = this["legend" + f[d] + "Height"];
				var n = this["legend" + f[d] + "X"];
				var g = this["legend" + f[d] + "Y"];
				if (o > 0) {
					var b = "draw" + f[d] + "Legend";
					var a = this["legend" + f[d] + "Meta"];
					var l = this.getXYLegendCoords(f[d], c, k);
					if (n && g) {
						this[b](n, g, a);
						this["legend" + f[d] + "CurX"] = n;
						this["legend" + f[d] + "CurY"] = g
					} else {
						this[b](l[0], l[1], a);
						this["legend" + f[d] + "CurX"] = l[0];
						this["legend" + f[d] + "CurY"] = l[1]
					}
					if (this.legendPosition.match(/right|left/i)) {
						k = l[3] + this.margin
					} else {
						c = l[2] + this.margin
					}
				}
			}
		}
	};
	this.setMarker = function(f) {
		var j = this;
		var k = function(q) {
			var p = j.meta.render.objects;
			for (var m = 0; m < p.length; m++) {
				var n = p[m];
				if (n.type == "Data" && n.idx) {
					var l = n.idx.join(":");
					if (l == q || l == q + ":false" || l == q + ":true" || l == q + ":box") {
						return n
					}
				}
			}
			return false
		};
		var c = function() {
			if (f.fontSize) {
				return (f.fontStyle || "") + " " + parseInt(f.fontSize) + "px " + j.fontName
			} else {
				return j.decorationFont
			}
		};
		var e = this.graphType.match(/Treemap|Stacked/) ? true : false;
		var g = this.isArray(f.variable) ? this.getVariableIndices(f.variable) : this.getVariableIndices([f.variable]);
		var h = this.isArray(f.sample) ? this.getSampleIndices(f.sample, e) : this.getSampleIndices([f.sample], e);
		var b = g.concat(h).join(":");
		var a = k(b);
		var i = a ? this.centroidArea(a.area) : false;
		var d = a ? a.params[4] : false;
		if (!f.id) {
			f.id = this.newId(this.target + "-marker-")
		}
		f.vi = g;
		f.si = h;
		if (!this.isArray(f.variable)) {
			f.variable = [f.variable]
		}
		if (!this.isArray(f.sample)) {
			f.sample = [f.sample]
		}
		if (!f.type) {
			f.type = "line"
		}
		f.b = f.b || [this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.x, this.y];
		f.len = this.measureText(f.text, c());
		f.width = this.measureTextWidth(f.text, c());
		f.tx = i ? i[0] : false;
		f.ty = i && f.type != "line" ? i[1] - ((d / 2) + f.width) : i ? i[1] : false;
		return f
	};
	this.getMarker = function(c) {
		if (c && this.decorations && this.decorations.marker) {
			for (var b = 0; b < this.decorations.marker.length; b++) {
				var a = this.decorations.marker[b];
				if (c == a.id) {
					return a
				}
			}
		}
	};
	this.drawMarkers = function() {
		this.functionCaller = "drawMarkers";
		var k = this;
		var j = function(d, c, h) {
			return d.ty > 0 && d.ty < k.height && d.tx > 0 && d.tx < k.width
		};
		var b = function() {
			if (e.fontSize) {
				return (e.fontStyle || "") + " " + parseInt(e.fontSize) + "px " + k.fontName
			} else {
				return k.decorationFont
			}
		};
		if (this.decorations && this.decorations.marker) {
			var l = this.decorations.marker;
			for (var f = 0; f < l.length; f++) {
				var e = this.setMarker(l[f]);
				if (e.tx && e.ty && e.b) {
					var p, o;
					if (e.type == "line") {
						p = e.x ? e.b[0] + (e.x * e.b[2]) : this.graphOrientation == "vertical" ? e.tx : e.tx + this.margin;
						o = e.y ? e.b[1] + (e.y * e.b[3]) : this.graphOrientation == "vertical" ? e.ty - this.margin : e.ty
					} else {
						p = e.tx;
						o = e.ty
					}
					if (j(e, p, o)) {
						var q = this.addToRender(["drawText", e.text, p, o, b(e), e.color || this.decorationsColor, e.align, e.baseline], "Marker:" + e.id);
						var a = this.meta.render.objects[q].area;
						if (e.type == "line") {
							var n = e.color || this.decorationsColor;
							var g;
							e.curX = p;
							e.curY = o;
							if (e.tx < a[1] - e.len) {
								g = (a[2] + a[4]) / 2;
								this.addToRender(["drawLine", "line", a[1] - this.margin, a[2], a[1] - this.margin, a[4], n], false, q);
								this.addToRender(["drawLine", e.type, e.tx, e.ty, a[1] - this.margin, g, n], false, q)
							} else {
								if (e.tx > a[3] + e.len) {
									g = (a[2] + a[4]) / 2;
									this.addToRender(["drawLine", "line", a[3] + this.margin, a[2], a[3] + this.margin, a[4], n], false, q);
									this.addToRender(["drawLine", e.type, e.tx, e.ty, a[3] + this.margin, g, n], false, q)
								} else {
									if (e.ty > a[4] + (e.width * 0.2)) {
										g = (a[1] + a[3]) / 2;
										this.addToRender(["drawLine", "line", a[1], a[4] + this.margin, a[3], a[4] + this.margin, n], false, q);
										this.addToRender(["drawLine", e.type, e.tx, e.ty, g, a[4] + this.margin, n], false, q)
									} else {
										if (e.ty < a[2] - (e.width * 0.2)) {
											g = (a[1] + a[3]) / 2;
											this.addToRender(["drawLine", "line", a[1], a[2] - this.margin, a[3], a[2] - this.margin, n], false, q);
											this.addToRender(["drawLine", e.type, e.tx, e.ty, g, a[2] - this.margin, n])
										} else {
											if (e.tx < a[1]) {
												g = (a[2] + a[4]) / 2;
												this.addToRender(["drawLine", "line", a[1] - this.margin, a[2], a[1] - this.margin, a[4], n], false, q);
												this.addToRender(["drawLine", e.type, e.tx, e.ty, a[1] - this.margin, g, n], false, q)
											} else {
												g = (a[2] + a[4]) / 2;
												this.addToRender(["drawLine", "line", a[3] + this.margin, a[2], a[3] + this.margin, a[4], n], false, q);
												this.addToRender(["drawLine", e.type, e.tx, e.ty, a[3] + this.margin, g, n], false, q)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
CanvasXpress.prototype.initFilterUtils = function() {
	this.filterVariables = function(e, d, a, b) {
		this.filterUserData(["filterVarBy"], ["vars"], [d], [a], null, b)
	};
	this.filterVariablesByCategory = function(e, d, a, b) {
		this.filterUserData(["filterVarBy"], [e], [d], [a], null, b)
	};
	this.filterSamples = function(e, d, a, b) {
		this.filterUserData(["filterSmpBy"], ["smps"], [d], [a], null, b)
	};
	this.filterSamplesByCategory = function(a, e, b, d) {
		this.filterUserData(["filterSmpBy"], [z], [e], [b], null, d)
	};
	this.filterUserData = function(g, f, j, k, a, d) {
		this.functionCaller = "filterUserData";
		if (this.isTransition()) {
			return
		}
		if (d) {
			this.resetFilters()
		}
		var e = {
			min: ">=",
			max: "<=",
			like: "like",
			exact: "exact"
		};
		for (var b = 0; b < g.length; b++) {
			this[g[b]].push(a != null && a[b] != null ? f[b] + ":::" + a[b] : f[b]);
			this[g[b] + "Op"].push(e[j[b]]);
			this[g[b] + "Case"].push(false);
			this[g[b] + "Value"].push(k[b])
		}
		this.reset(true);
		this.filterData(true);
		if (this.isGroupedData && this.smpIndices.length > 0) {
			this.groupSamples(this.groupingFactors, false, false, true)
		} else {
			this.draw()
		}
	};
	this.filterData = function(E) {
		if (this.isDOE) {
			return
		}
		var q = {};
		var Q = {};
		var P = {};
		var D = false;
		var o = this;
		var f = function(v, R, h) {
			if (R.hasOwnProperty(v)) {
				return R[v]
			} else {
				if (v.match(":::")) {
					var d = v.split(":::");
					if (h[d[1]]) {
						d[1] = parseInt(d[1]);
						for (var s = 0; s < h[d[1]].length; s++) {
							var k = h[d[1]][s];
							if (R.hasOwnProperty(k)) {
								R = R[k]
							} else {
								return false
							}
						}
						if (R.hasOwnProperty(d[0])) {
							return R[d[0]]
						}
					}
				}
				return false
			}
		};
		var F = function(k, v, j, h) {
			if (!v) {
				return true
			}
			if (o.filterSkipNullValues && (k == null || k == "")) {
				return true
			}
			if (v == ">") {
				return parseFloat(k) - parseFloat(j) > 0
			} else {
				if (v == ">=") {
					return parseFloat(k) - parseFloat(j) > 0 || parseFloat(k) - parseFloat(j) == 0
				} else {
					if (v == "<") {
						return parseFloat(k) - parseFloat(j) < 0
					} else {
						if (v == "<=") {
							return parseFloat(k) - parseFloat(j) < 0 || parseFloat(k) - parseFloat(j) == 0
						} else {
							if (v == "=" || v == "==") {
								return parseFloat(k) - parseFloat(j) == 0
							} else {
								if (v == "null") {
									return k == null
								} else {
									if (v == "not null") {
										return k != null
									} else {
										if (v == "exact") {
											for (var d = 0; d < j.length; d++) {
												if (k == j[d]) {
													return true
												}
											}
											return false
										} else {
											if (v == "like" || v == "not like") {
												var p = false;
												if (h) {
													for (var d = 0; d < j.length; d++) {
														if ((k + "").search(j[d] + "") != -1 || j[d] == k) {
															p = true;
															if (v == "like") {
																break
															}
														}
													}
												} else {
													var a = (k + "").toLowerCase();
													for (var d = 0; d < j.length; d++) {
														var s = (j[d] + "").toLowerCase();
														if (a.search(s) != -1 || a == s) {
															p = true;
															if (v == "like") {
																break
															}
														}
													}
												}
												return v == "like" ? p : !p
											}
										}
									}
								}
							}
						}
					}
				}
			}
		};
		var g = function(a) {
			if (!P[a]) {
				P[a] = 0
			}
			P[a]++
		};
		if (this.graphType == "Genome" && this.filterFeatureBy.length > 0) {
			for (var I = 0; I < this.filterFeatureBy.length; I++) {
				if (this.filterFeatureBy[I]) {
					for (var H = 0; H < this.data.tracks.length; H++) {
						var C = this.data.tracks[H];
						var m = C.data;
						for (var G = 0; G < m.length; G++) {
							var l = m[G];
							if (this.filterSkipNullKeys && !l.hasOwnProperty(this.filterFeatureBy[I])) {
								continue
							}
							var u = f(this.filterFeatureBy[I], l, this.featuresProperties);
							if (!F(u, this.filterFeatureByOp[I], this.filterFeatureByValue[I], this.filterFeatureByCase[I])) {
								l.hide = this.filterType == "and" ? true : q[H + ":" + G] ? false : true;
								Q[H + ":" + G] = true
							} else {
								q[H + ":" + G] = true;
								if (this.filterType == "or" && Q[H + ":" + G]) {
									l.hide = false
								}
							}
						}
					}
				}
			}
		} else {
			if (this.graphType == "Network" && (this.filterNodeBy.length > 0 || this.filterEdgeBy.length)) {
				for (var I = 0; I < this.filterNodeBy.length; I++) {
					if (this.filterNodeBy[I]) {
						for (var H = 0; H < this.data.nodes.length; H++) {
							if (this.filterSkipNullKeys && !this.data.nodes[H].hasOwnProperty(this.filterNodeBy[I])) {
								continue
							}
							if (this.data.nodes[H].hide) {
								continue
							}
							var u = f(this.filterNodeBy[I], this.data.nodes[H], this.nodesProperties);
							if (!F(u, this.filterNodeByOp[I], this.filterNodeByValue[I], this.filterNodeByCase[I])) {
								this.data.nodes[H].hide = this.filterType == "and" ? true : q[this.data.nodes[H].id] ? false : true;
								Q[this.data.nodes[H].id] = true
							} else {
								q[this.data.nodes[H].id] = true;
								if (this.filterType == "or" && Q[this.data.nodes[H].id]) {
									this.data.nodes[H].hide = false
								}
							}
						}
					}
				}
				for (var I = 0; I < this.filterEdgeBy.length; I++) {
					if (this.filterEdgeBy[I]) {
						for (var H = 0; H < this.data.edges.length; H++) {
							var t = this.data.nodes[this.data.nodeIndices[this.data.edges[H].id1]];
							var r = this.data.nodes[this.data.nodeIndices[this.data.edges[H].id2]];
							var B = t.id + ":" + r.id;
							if (this.filterSkipNullKeys && !this.data.edges[H].hasOwnProperty(this.filterEdgeBy[I])) {
								continue
							}
							var u = f(this.filterEdgeBy[I], this.data.edges[H], this.edgesProperties);
							if (!F(u, this.filterEdgeByOp[I], this.filterEdgeByValue[I], this.filterEdgeByCase[I])) {
								this.data.edges[H].hide = this.filterType == "and" ? true : q[B] ? false : true;
								Q[B] = true
							} else {
								q[B] = true;
								if (this.filterType == "or" && Q[B]) {
									this.data.edges[H].hide = false
								}
							}
							if (!this.data.edges[H].hide) {
								g(t.id);
								g(r.id)
							}
						}
					}
				}
				if (this.filterEdgeBy.length > 0) {
					for (var I = 0; I < this.data.nodes.length; I++) {
						var n = this.data.nodes[I];
						if (!P[n.id]) {
							n.hide = true
						}
					}
				}
			} else {
				if (this.isCreateHistogram) {
					if (this.filterVarBy.length > 0) {
						var N = this.dataStndBy;
						var K = this.data.y.histogram;
						var O = this.data.y.all
					}
				} else {
					if (this.filterSmpBy.length > 0) {
						for (var I = 0; I < this.filterSmpBy.length; I++) {
							if (this.filterSmpBy[I]) {
								D = true;
								if (this.isGroupedData && !E) {
									for (var H = 0; H < this.grpIndices.length; H++) {
										var M = this.grpIndices[H];
										var e;
										if (this.filterSmpBy[I] == "smps") {
											var x = false;
											for (var G = 0; G < this.data.w.grps[M].length; G++) {
												e = this.data.y.smps[this.data.w.grps[M][G]];
												if (F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
													x = true;
													break
												}
											}
											if (!x) {
												this.hiddenGrps[M] = this.filterType == "and" ? true : q[M] ? false : true;
												Q[M] = true
											} else {
												q[M] = true;
												if (this.filterType == "or" && Q[M]) {
													this.hiddenGrps[M] = false
												}
											}
										} else {
											e = this.data.w.factors[this.filterSmpBy[I]][M];
											if (!F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
												this.hiddenGrps[M] = this.filterType == "and" ? true : q[M] ? false : true;
												Q[M] = true
											} else {
												q[M] = true;
												if (this.filterType == "or" && Q[M]) {
													this.hiddenGrps[M] = false
												}
											}
										}
									}
								} else {
									for (var H = 0; H < this.smpIndices.length; H++) {
										var M = this.smpIndices[H];
										var e = this.filterSmpBy[I] == "smps" ? this.data.y.smps[M] : this.data.x[this.filterSmpBy[I]][M];
										if (!F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
											this.hiddenSmps[M] = this.filterType == "and" ? true : q[M] ? false : true;
											Q[M] = true
										} else {
											q[M] = true;
											if (this.filterType == "or" && Q[M]) {
												this.hiddenSmps[M] = false
											}
										}
									}
								}
							}
						}
						if (D) {
							var b = [];
							if (this.isGroupedData && !E) {
								for (var I = 0; I < this.grpIndices.length; I++) {
									var w = this.grpIndices[I];
									if (!this.hiddenGrps[w]) {
										b.push(w)
									}
								}
								this.grpIndices = b
							} else {
								for (var I = 0; I < this.smpIndices.length; I++) {
									var w = this.smpIndices[I];
									if (!this.hiddenSmps[w]) {
										b.push(w)
									}
								}
								this.smpIndices = b
							}
						}
					}
					if (this.filterVarBy.length > 0) {
						for (var I = 0; I < this.filterVarBy.length; I++) {
							if (this.filterVarBy[I]) {
								D = true;
								for (var H = 0; H < this.varIndices.length; H++) {
									var M = this.varIndices[H];
									var e = this.filterVarBy[I] == "vars" ? this.data.y.vars[M] : this.data.z[this.filterVarBy[I]][M];
									if (!F(e, this.filterVarByOp[I], this.filterVarByValue[I], this.filterVarByCase[I])) {
										this.hiddenVars[M] = this.filterType == "and" ? true : q[M] ? false : true;
										Q[M] = true
									} else {
										q[M] = true;
										if (this.filterType == "or" && Q[M]) {
											this.hiddenVars[M] = false
										}
									}
								}
							}
						}
						if (D) {
							var b = [];
							for (var I = 0; I < this.varIndices.length; I++) {
								var w = this.varIndices[I];
								if (!this.hiddenVars[w]) {
									b.push(w)
								}
							}
							this.varIndices = b
						}
					}
				}
			}
		}
		if (this.layoutComb && this.graphType != "Candlestick" && !this.graphType.match(/Scatter/)) {
			this.restoreEmptyCompartments();
			var L = this.getObjectArray(this.varIndices);
			var J = this.getObjectArray(this.smpIndices);
			for (var I = 0; I < this.data.l.comp.length; I++) {
				var A = this.layoutParams[I];
				var u = A.startingVarIndices;
				var y = A.startingSmpIndices;
				var O = [];
				if (u) {
					for (var H = 0; H < u.length; H++) {
						if (L.hasOwnProperty(u[H])) {
							O.push(u[H])
						}
					}
					A.varIndices = O
				}
				O = [];
				if (y) {
					for (var H = 0; H < y.length; H++) {
						if (J.hasOwnProperty(y[H])) {
							O.push(y[H])
						}
					}
					A.smpIndices = O
				}
			}
		}
	};
	this.resetSmpFilters = function(a) {
		if (a != null && this.filterSmpBy.length > 0) {
			this.filterSmpBy.splice(a, 1);
			this.filterSmpByOp.splice(a, 1);
			this.filterSmpByValue.splice(a, 1);
			this.filterSmpByCase.splice(a, 1);
			this.filteredSmpIndices.splice(a, 1)
		} else {
			this.filterSmpBy = [];
			this.filterSmpByOp = [];
			this.filterSmpByValue = [];
			this.filterSmpByCase = [];
			this.filteredSmpIndices = []
		}
	};
	this.resetVarFilters = function(a) {
		if (a != null && this.filterVarBy.length > 0) {
			this.filterVarBy.splice(a, 1);
			this.filterVarByOp.splice(a, 1);
			this.filterVarByValue.splice(a, 1);
			this.filterVarByCase.splice(a, 1);
			this.filteredVarIndices.splice(a, 1)
		} else {
			this.filterVarBy = [];
			this.filterVarByOp = [];
			this.filterVarByValue = [];
			this.filterVarByCase = [];
			this.filteredVarIndices = []
		}
	};
	this.resetNodeFilters = function(a) {
		if (a != null && this.filterNodeBy.length > 0) {
			this.filterNodeBy.splice(a, 1);
			this.filterNodeByOp.splice(a, 1);
			this.filterNodeByValue.splice(a, 1);
			this.filterNodeByCase.splice(a, 1)
		} else {
			this.filterNodeBy = [];
			this.filterNodeByOp = [];
			this.filterNodeByValue = [];
			this.filterNodeByCase = []
		}
	};
	this.resetEdgeFilters = function(a) {
		if (a != null && this.filterEdgeBy.length > 0) {
			this.filterEdgeBy.splice(a, 1);
			this.filterEdgeByOp.splice(a, 1);
			this.filterEdgeByValue.splice(a, 1);
			this.filterEdgeByCase.splice(a, 1)
		} else {
			this.filterEdgeBy = [];
			this.filterEdgeByOp = [];
			this.filterEdgeByValue = [];
			this.filterEdgeByCase = []
		}
	};
	this.resetFeatureFilters = function(a) {
		if (a != null && this.filterFeatureBy.length > 0) {
			this.filterFeatureBy.splice(a, 1);
			this.filterFeatureByOp.splice(a, 1);
			this.filterFeatureByValue.splice(a, 1);
			this.filterFeatureByCase.splice(a, 1)
		} else {
			this.filterFeatureBy = [];
			this.filterFeatureByOp = [];
			this.filterFeatureByValue = [];
			this.filterFeatureByCase = []
		}
	};
	this.resetFilters = function(e, d) {
		var a = [];
		if (!e) {
			a = ["filterSmpBy", "filterVarBy", "filterNodeBy", "filterEdgeBy", "filterFeatureBy"]
		} else {
			a = [e]
		}
		for (var b = 0; b < a.length; b++) {
			c = a[b];
			if (c == "filterSmpBy") {
				this.resetSmpFilters(d)
			} else {
				if (c == "filterVarBy") {
					this.resetVarFilters(d)
				} else {
					if (c == "filterNodeBy") {
						this.resetNodeFilters(d)
					} else {
						if (c == "filterEdgeBy") {
							this.resetEdgeFilters(d)
						} else {
							if (c == "filterFeatureBy") {
								this.resetFeatureFilters(d)
							}
						}
					}
				}
			}
		}
	}
};
CanvasXpress.prototype.initClusterUtils = function() {
	this.setDendrograms = function() {
		if (this.smpDendrogramNewick) {
			this.smpDendrogram = {};
			this.parseNewick(this.smpDendrogramNewick, "smpDendrogram")
		}
		if (this.varDendrogramNewick) {
			this.varDendrogram = {};
			this.parseNewick(this.varDendrogramNewick, "varDendrogram")
		}
	};
	this.parseNewick = function(a, d) {
		var j = this;
		var v = 0;
		var b = [];
		var s = {};
		var c = 0;
		var f = 0;
		var t = 0;
		var o = 0;
		var h = [];
		var y = 0;
		var z = 0;
		this[d + "NodeId"] = 0;
		var p = a.split(/\s*(;|\(|\)|,|:)\s*/);
		var k = function(C) {
			var x = [];
			for (var B = 0; B < C.length; B++) {
				x.push(C[B].mid)
			}
			return j.mean(x)
		};
		var m = function(B) {
			if (B.children) {
				B.depth = f++;
				y = Math.max(y, B.depth);
				for (var x = 0; x < B.children.length; x++) {
					m(B.children[x]);
					if (B.children[x].children) {
						B.children[x].mid = k(B.children[x].children)
					}
				}
				f--;
				o++
			} else {
				B.depth = f;
				t++
			}
		};
		var e = function(B) {
			if (B.children) {
				for (var x = 0; x < B.children.length; x++) {
					e(B.children[x]);
					if (B.children[x].children) {
						B.children[x].len = 1 + y - B.children[x].depth
					}
				}
			} else {
				B.len = 1 + y - B.depth
			}
		};
		for (var w = 0; w < p.length; w++) {
			if (!v) {
				var g = p[w];
				switch (g) {
					case "(":
						var A = {};
						s.children = [A];
						b.push(s);
						s = A;
						break;
					case ",":
						if (b.length > 0) {
							var A = {};
							b[b.length - 1].children.push(A);
							s = A
						} else {
							v++
						}
						break;
					case ")":
						s = b.pop();
						s.nodeId = this[d + "NodeId"]++;
						break;
					case ":":
						break;
					default:
						var l = p[w - 1];
						if (l == ")" || l == "(" || l == ",") {
							s.name = g;
							if (g && !s.children) {
								var r = d == "smpDendrogram" ? this.getSampleIndices(g) : this.getVariableIndices(g);
								if (r == -1) {
									r = parseInt(g);
									s.name = d == "smpDendrogram" ? this.data.y.smps[r] : this.data.y.vars[r];
									s.idx = r
								} else {
									s.idx = r
								}
								h.push(s.idx);
								s.ord = c++;
								s.mid = s.ord
							}
						} else {
							if (l == ":") {
								s.height = parseFloat(g);
								z++
							}
						}
				}
			} else {
				if (v < 3) {
					this.parseNewick("(" + a + ")", d);
					return
				} else {
					alert(d + "is not in a valid Newick format");
					this[d] = false;
					if (d == "varDendrogram") {
						this.varDendrogramNewick = false
					} else {
						this.smpDendrogramNewick = false
					}
					return
				}
			}
		}
		m(s);
		e(s);
		s.max = y + 1;
		s.leafs = t;
		s.useHeight = z == o;
		s.mid = k(s.children);
		s.axis = d;
		this[d] = s;
		var q = {
			labl: d == "varDendrogram" ? "variable" : "sample",
			show: d == "varDendrogram" ? "showVarDendrogram" : "showSmpDendrogram",
			data: d == "varDendrogram" ? "vars" : "smps",
			indx: d == "varDendrogram" ? "varIndices" : "smpIndices",
			strt: d == "varDendrogram" ? "varIndicesStart" : "smpIndicesStart"
		};
		if (this[q.show]) {
			if (this[q.strt] < 0) {
				if (t != this.data.y[q.data].length) {
					alert("Dude! The length of the " + q.labl + " nodes in the dendrogram (" + t + ") is different to that one in the data (" + this.data.y[q.data].length + "). This ain't gonna work!");
					this[q.show] = false
				} else {
					if (t != this[q.indx].length) {
						alert("Ooops! Cannot show dendrogram with " + t + " nodes when only " + this[q.indx].length + " " + q.labl + " are visible.");
						this[q.show] = false
					} else {
						this[q.indx] = h
					}
				}
			} else {
				var u = this[q.strt] + this[q.indx].length;
				this[q.indx] = [];
				for (var w = this[q.strt]; w < u; w++) {
					this[q.indx].push(h[w])
				}
			}
		}
	};
	this.writeNewick = function(b) {
		var d = "";
		if (b.children) {
			var a = [];
			for (var c = 0; c < b.children.length; c++) {
				a.push(this.writeNewick(b.children[c]))
			}
			if (a.length > 0) {
				d = "(" + a.join(",") + ")"
			}
		} else {
			d = b.idx
		}
		if (b.height) {
			d += ":" + sprintf("%.1f", b.height)
		}
		return d
	};
	this.euclidianDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f += Math.pow(b[c] - a[c], 2)
			}
			f = Math.sqrt(f)
		}
		return f
	};
	this.manhattanDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f += Math.abs(b[c] - a[c])
			}
		}
		return f
	};
	this.maxDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f = Math.max(f, Math.abs(b[c] - a[c]))
			}
		}
		return f
	};
	this.classifyKmeansVector = function(f, c) {
		var e = Number.POSITIVE_INFINITY;
		var a = 0;
		for (var d = 0; d < c.length; d++) {
			var b = this[this.distance + "Distance"](f, c[d]);
			if (b < e) {
				e = b;
				a = d
			}
		}
		return a
	};
	this.addVectors = function(c, b, g, f) {
		var e = this.cleanArrays(c, b, g, f);
		c = e[0];
		b = e[1];
		var a = [];
		if (c.length == b.length) {
			for (var d = 0; d < c.length; d++) {
				a.push(c[d] + b[d])
			}
		}
		return a
	};
	this.compareVectors = function(b, a) {
		if (this.isArray(b) && this.isArray(a)) {
			if (b.length != a.length) {
				return false
			}
			for (var c = 0; c < b.length; c++) {
				if (this.isArray(b[c]) && this.isArray(a[c])) {
					if (!this.compareArrays(b[c], a[c])) {
						return false
					}
				}
				if (b[c] !== a[c]) {
					return false
				}
			}
			return true
		}
	};
	this.vectorDotProduct = function(b, a, g, f) {
		var d = this.cleanArrays(b, a, g, f);
		b = d[0];
		a = d[1];
		var e = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				e += b[c] * a[c]
			}
		}
		return e
	};
	this.multiplyVectorByValue = function(a, d, e, c) {
		a = this.cleanArray(a, e, c);
		for (var b = 0; b < a.length; b++) {
			a[b] *= d
		}
		return a
	};
	this.getCentroid = function(d, g, f, a) {
		var h = [];
		if (g.length == a.length) {
			var e = d + f;
			for (var b = 0; b < g.length; b++) {
				h.push((d * g[b] + f * a[b]) / e)
			}
		}
		return h
	};
	this.createClusterNode = function(i, b, e, f, h, a) {
		var g = {
			id: i,
			left: b,
			right: e,
			dist: f,
			centroid: h
		};
		if (a != null) {
			g.mid = a
		}
		if (b == null && e == null) {
			g.size = 1;
			g.depth = 0
		} else {
			g.size = b.size + e.size;
			g.depth = 1 + Math.max(b.depth, e.depth)
		}
		return g
	};
	this.createRandomCentroids = function(c) {
		var b = this;
		var a = c.slice(0);
		a.sort(function() {
			return (Math.round(b.random()) - 0.5)
		});
		return a.slice(0, this.clusterAxis == "samples" ? this.kmeansSmpClusters : this.kmeansVarClusters)
	};
	this.createRandomVectors = function(d, g) {
		var c = g.length;
		if (d > c) {
			return null
		}
		var l = [];
		var f = [];
		var a = {};
		var m = 0;
		var o = 0;
		var j, b;
		while (o < d) {
			if (m == c) {
				return null
			}
			var h = Math.floor(this.random() * c);
			if (h in a) {
				continue
			}
			a[h] = 1;
			m++;
			j = g[h];
			b = true;
			for (var e = 0; e < o; e++) {
				if (this.compareVectors(j, l[e])) {
					b = false;
					break
				}
			}
			if (b) {
				l[o] = j;
				f[o] = h;
				o++
			}
		}
		return {
			vectors: l,
			indices: f
		}
	};
	this.imputeDatum = function(a) {
		var d = [];
		if (this.clusterAxis == "samples") {
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				d.push(this.data.y.data[c][a])
			}
		} else {
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				d.push(this.data.y.data[a][c])
			}
		}
		return this[this.imputeMethod](d)
	};
	this.getIdsForClustering = function() {
		var e = [];
		if (this.clusterAxis == "samples") {
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				var a = this.getSampleIndices(c);
				e[b] = a == -1 ? c : this.data.y.smps[c]
			}
		} else {
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				var a = this.getVariableIndices(c);
				e[b] = a == -1 ? c : this.data.y.smps[c]
			}
		}
		return e
	};
	this.getDataForClustering = function() {
		var h = [];
		var a = [];
		if (this.clusterAxis == "samples") {
			for (var c = 0; c < this.smpIndices.length; c++) {
				h[c] = []
			}
			for (var c = 0; c < this.varIndices.length; c++) {
				var e = this.varIndices[c];
				for (var b = 0; b < this.smpIndices.length; b++) {
					var f = this.smpIndices[b];
					var g = this.data.y.data[e][f];
					if (isNaN(g)) {
						if (!a[b]) {
							a[b] = this.imputeDatum(f)
						}
						g = a[b]
					}
					h[b][c] = g
				}
			}
		} else {
			for (var c = 0; c < this.varIndices.length; c++) {
				h[c] = []
			}
			for (var c = 0; c < this.varIndices.length; c++) {
				var e = this.varIndices[c];
				for (var b = 0; b < this.smpIndices.length; b++) {
					var f = this.smpIndices[b];
					var g = this.data.y.data[e][f];
					if (isNaN(g)) {
						if (!a[c]) {
							a[c] = this.imputeDatum(e)
						}
						g = a[c]
					}
					h[c][b] = g
				}
			}
		}
		return h
	};
	this.cluster = function() {
		var n = function() {
			var i = a[s][0].id;
			var d = a[r][0].id;
			if (i < 0 && d >= 0) {
				return true
			} else {
				if (i < 0 && d < 0) {
					return d > i
				} else {
					if (i >= 0 && d >= 0) {
						return i > d
					} else {
						return false
					}
				}
			}
		};
		var h;
		var z = this.getDataForClustering();
		var v = this.getIdsForClustering();
		var o = [];
		var e = [];
		var B = [];
		var a = [];
		if (!this.meta.tree) {
			this.meta.tree = {}
		}
		var u = this.meta.tree;
		u[this.clusterAxis] = [];
		for (var y = 0; y < z.length; y++) {
			o[y] = []
		}
		o[0][0] = Number.POSITIVE_INFINITY;
		for (var y = 0; y < z.length - 1; y++) {
			for (var x = y + 1; x < z.length; x++) {
				o[x][x] = Number.POSITIVE_INFINITY;
				o[y][x] = this[this.distance + "Distance"](z[y], z[x]);
				o[x][y] = o[y][x]
			}
		}
		for (var y = 0; y < z.length; y++) {
			e[y] = 0;
			for (var x = 0; x < z.length; x++) {
				if (o[y][e[y]] > o[y][x]) {
					e[y] = x
				}
			}
		}
		for (var y = 0; y < z.length; y++) {
			a[y] = [];
			a[y][0] = this.createClusterNode(v[y], null, null, 0, z[y]);
			B[y] = 1
		}
		var b = -1;
		for (var q = 0; q < z.length - 1; q++) {
			var s = 0;
			for (var y = 0; y < z.length; y++) {
				if (o[y][e[y]] < o[s][e[s]]) {
					s = y
				}
			}
			var r = e[s];
			if (n()) {
				var c = r;
				r = s;
				s = c
			}
			var f = a[s][0];
			var t = a[r][0];
			var g = this.getCentroid(f.size, f.centroid, t.size, t.centroid);
			var A = this.createClusterNode(b, f, t, o[s][r], g);
			a[s].splice(0, 0, A);
			for (var x = 0; x < z.length; x++) {
				if (this.linkage == "single") {
					if (o[s][x] > o[r][x]) {
						o[x][s] = o[s][x] = o[r][x]
					}
				} else {
					if (this.linkage == "complete") {
						if (o[s][x] < o[r][x]) {
							o[x][s] = o[s][x] = o[r][x]
						}
					} else {
						if (this.linkage == "average") {
							o[x][s] = o[s][x] = ((B[s] * o[s][x]) + (B[r] * o[r][x])) / (B[s] + B[r])
						}
					}
				}
			}
			B[s] += B[r];
			o[s][s] = Number.POSITIVE_INFINITY;
			for (var y = 0; y < z.length; y++) {
				o[y][r] = o[r][y] = Number.POSITIVE_INFINITY
			}
			for (var x = 0; x < z.length; x++) {
				if (e[x] == r) {
					e[x] = s
				}
			}
			for (var x = 0; x < z.length; x++) {
				for (var w = 0; w < z.length; w++) {
					if (o[w][x] < o[w][e[w]]) {
						e[w] = x
					}
				}
			}
			h = A;
			u[this.clusterAxis].push([f.id, t.id, h.dist]);
			b--
		}
		return this.writeNewickCluster(h, true)
	};
	this.isLeafNode = function(a) {
		if (a.left == null && a.right == null) {
			return true
		} else {
			return false
		}
	};
	this.writeNewickCluster = function(k, g, j) {
		var h = "";
		var e = "";
		var f = false;
		if (this.isLeafNode(k)) {
			f = true;
			if (isNaN(k.id)) {
				h = this.clusterAxis == "variables" ? this.getVariableIndices(k.id) : this.getSampleIndices(k.id)
			} else {
				h = k.id
			}
		} else {
			var b;
			var c = this.writeNewickCluster(k.left, g, true);
			var a = this.writeNewickCluster(k.right, g, false);
			if (k.mid) {
				for (var d = 0; d < k.mid.length; d++) {
					if (g && k.mid[d].dist) {
						e += "," + k.mid[d].id + ":" + k.mid[d].dist
					} else {
						e += "," + k.mid[d].id
					}
					e += k.mid[d].id
				}
			}
			h = "(" + c + e + "," + a + ")"
		}
		if (g && !f) {
			h += ":" + sprintf("%.1f", k.dist)
		}
		return h
	};
	this.kmeans = function() {
		var p = this.getDataForClustering();
		var q = this.createRandomCentroids(p);
		var m = new Array(p.length);
		var b = this.clusterAxis == "samples" ? this.kmeansSmpClusters : this.kmeansVarClusters;
		var n = new Array(b);
		var s = 0;
		var v = true;
		while (v) {
			for (var e = 0; e < p.length; e++) {
				m[e] = this.classifyKmeansVector(p[e], q)
			}
			v = false;
			for (var c = 0; c < b; c++) {
				var l = [];
				for (var e = 0; e < m.length; e++) {
					if (m[e] == c) {
						l.push(p[e])
					}
				}
				if (!l.length) {
					continue
				}
				var o = q[c];
				var u = new Array(o.length);
				for (var f = 0; f < o.length; f++) {
					var h = 0;
					for (var e = 0; e < l.length; e++) {
						if (!isNaN(l[e][f])) {
							h += l[e][f]
						}
					}
					u[f] = h / l.length;
					if (u[f] != o[f]) {
						v = true
					}
				}
				q[c] = u;
				n[c] = l
			}
			s++;
			if (s > this.maxIterations) {
				v = false
			}
		}
		var r = [];
		for (var e = 0; e < b; e++) {
			r[e] = {
				distance: this[this.distance + "Distance"](q[0], q[e]),
				assign: e
			}
		}
		r = r.sort(function(g, d) {
			return g.distance - d.distance
		});
		var a = {};
		for (var e = 0; e < r.length; e++) {
			a[r[e].assign] = e
		}
		for (var e = 0; e < m.length; e++) {
			var t = a[m[e]] + 1;
			if (t > 9) {
				m[e] = "K" + t
			} else {
				m[e] = "K-0" + t
			}
		}
		return m
	}
};
CanvasXpress.prototype.initSortUtils = function() {
	this.sortNetworkIndices = function(h) {
		this.functionCaller = "sortNetworkIndices";
		if (this.isTransition()) {
			return
		}
		var g = this.data[this.networkShowDataTable];
		var c = [h] ? h : this.networkShowDataTable == "nodes" ? "id" : "id1";
		var b = [];
		var f = [];
		for (var e = 0; e < g.length; e++) {
			b.push(e);
			f.push(g[e][c] ? g[e][c] : null)
		}
		if (this.isNumeric(f)) {
			var a = Number.MAX_VALUE * -1;
			b.sort(function(j, i) {
				return (f[j] || a) - (f[i] || a)
			})
		} else {
			b.sort(function(j, i) {
				return f[j] > f[i] ? 1 : f[j] < f[i] ? -1 : 0
			})
		}
		var d = [];
		for (var e = 0; e < g.length; e++) {
			d.push(g[b[e]])
		}
		if (this.sortDir == "ascending") {
			d.reverse()
		}
		this.data[this.networkShowDataTable] = d;
		if (this.networkShowDataTable == "nodes") {
			this.setNodeIndices()
		}
		this.draw()
	};
	this.sortIndices = function(h, c, k, a, m, j, o) {
		var g = this;
		var n = this.meta.def;
		this.tmpAsciiArray = [];
		this.tmpAsciiArray1 = [];
		this.tmpAsciiArray2 = [];
		this.tmpAsciiArrayAscii = false;
		this.tmpAsciiArrayAscii1 = false;
		this.tmpAsciiArrayAscii2 = false;
		if (k) {
			k = this.toArray(k)
		}
		if (a) {
			a = this.toArray(a)
		}
		if (m) {
			m = this.toArray(m)
		}
		if (!c) {
			c = this.sortDir
		}
		if (h == "onc") {
			var b = [];
			for (var f = 0; f < this.data.y.vars.length; f++) {
				b.push(f)
			}
			this.varIndices = b;
			this.tmpAsciiArray = this.data.z.Alterations;
			this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(this.smpIndices[0]);
			this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
			this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
		} else {
			if (k && h == "vars") {
				if (k.length == 1 && this.data.z && this.data.z[k[0]]) {
					this.tmpAsciiArray = this.data.z[k[0]];
					this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
				} else {
					if (k.length == 2 && this.data.z && this.data.z[k[0]] && this.data.z[k[1]]) {
						this.tmpAsciiArray = this.data.z[k[0]];
						this.tmpAsciiArray1 = this.data.z[k[1]];
						this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
						this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
					} else {
						if (k.length == 3 && this.data.z && this.data.z[k[0]] && this.data.z[k[1]] && this.data.z[k[2]]) {
							this.tmpAsciiArray = this.data.z[k[0]];
							this.tmpAsciiArray1 = this.data.z[k[1]];
							this.tmpAsciiArray2 = this.data.z[k[2]];
							this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
							this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
							this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
						}
					}
				}
				this.smpSort = -1;
				this.varSort = k
			} else {
				if (k && h == "smps") {
					if (this.isGroupedData) {
						this.isGroupedData = false;
						this.sortIndices(h, c, k, a, m, j, o);
						this.isGroupedData = true
					}
					if (k.length == 1 && this.data.x && this.data.x[k[0]]) {
						this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
						this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
					} else {
						if (k.length == 2 && this.data.x && this.data.x[k[0]] && this.data.x[k[1]]) {
							this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
							this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[k[1]] : this.data.x[k[1]];
							this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
							this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
						} else {
							if (k.length == 3 && this.data.x && this.data.x[k[0]] && this.data.x[k[1]] && this.data.x[k[2]]) {
								this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
								this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[k[1]] : this.data.x[k[1]];
								this.tmpAsciiArray2 = this.isGroupedData ? this.data.w.factors[k[2]] : this.data.x[k[2]];
								this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
								this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
								this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
							}
						}
					}
					this.varSort = -1;
					this.smpSort = k
				} else {
					if (j && o) {
						var f = a ? parseInt(this.getVariableIndices(a[0])) : parseInt(this.getSampleIndices(m[0]));
						this.tmpAsciiArray = this.data.y[j][f];
						this.tmpAsciiArrayAscii = false;
						this.smpSort = [f]
					} else {
						if (a) {
							var d = [];
							for (var f = 0; f < this.varIndices.length; f++) {
								d.push(f)
							}
							if (a.length == 1) {
								this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
								this.tmpAsciiArrayAscii = false;
								this.smpSort = [a[0] - 1]
							} else {
								if (a.length == 2) {
									this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
									this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(a[1] - 1, d, j);
									this.tmpAsciiArrayAscii = false;
									this.tmpAsciiArrayAscii1 = false;
									this.smpSort = [a[0] - 1, a[1] - 1]
								} else {
									if (a.length == 3) {
										this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
										this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(a[1] - 1, d, j);
										this.tmpAsciiArray2 = this.getDataForSmpGrpAtIndex(a[2] - 1, d, j);
										this.tmpAsciiArrayAscii = false;
										this.tmpAsciiArrayAscii1 = false;
										this.tmpAsciiArrayAscii2 = false;
										this.smpSort = [a[0] - 1, a[1] - 1, a[2] - 1]
									}
								}
							}
						} else {
							if (m) {
								if (this.isGroupedData) {
									this.isGroupedData = false;
									this.sortIndices(h, c, k, a, m, j, o);
									this.isGroupedData = true
								}
								var e = this.isGroupedData && this.summaryType == "iqr" ? this.data.w.median : this.isGroupedData ? this.data.w[this.summaryType] : j ? this.data.y[j] : this.data.y.data;
								if (m.length == 1) {
									this.tmpAsciiArray = e[m[0] - 1];
									this.tmpAsciiArrayAscii = false;
									this.smpSort = [m[0] - 1]
								} else {
									if (m.length == 2) {
										this.tmpAsciiArray = e[m[0] - 1];
										this.tmpAsciiArray1 = e[m[1] - 1];
										this.tmpAsciiArrayAscii = false;
										this.tmpAsciiArrayAscii1 = false;
										this.smpSort = [m[0] - 1, m[1] - 1]
									} else {
										if (a.length == 3) {
											this.tmpAsciiArray = e[m[0] - 1];
											this.tmpAsciiArray1 = e[m[1] - 1];
											this.tmpAsciiArray2 = e[m[2] - 1];
											this.tmpAsciiArrayAscii = false;
											this.tmpAsciiArrayAscii1 = false;
											this.tmpAsciiArrayAscii2 = false;
											this.smpSort = [m[0] - 1, m[1] - 1, m[2] - 1]
										}
									}
								}
							} else {
								if (this.isGroupedData) {
									this.isGroupedData = false;
									this.sortIndices(h, c, k, a, m, j, o);
									this.isGroupedData = true
								}
								this.tmpAsciiArray = this.isGroupedData ? this.data.w.smps : h == "vars" ? this.data.y.vars : this.data.y.smps;
								this.tmpAsciiArrayAscii = true;
								if (h == "vars") {
									this.varSort = false
								} else {
									this.smpSort = false
								}
							}
						}
					}
				}
			}
		}
		var l = h == "vars" || h == "onc" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
		if (this.tmpAsciiArrayAscii) {
			l.sort(function(p, i) {
				return g.sortAsciibetically(p, i)
			})
		} else {
			l.sort(function(p, i) {
				return g.sortNumerically(p, i)
			})
		}
		if (c != "ascending") {
			l.reverse()
		}
		this.tmpAsciiArray = [];
		this.tmpAsciiArray1 = [];
		this.tmpAsciiArray2 = [];
		this.tmpAsciiArrayAscii = false;
		this.tmpAsciiArrayAscii1 = false;
		this.tmpAsciiArrayAscii2 = false;
		if (h == "smps") {
			this.sortingSampleCategories = k
		} else {
			this.sortingVariableCategories = k
		}
		this.sortingSamples = a;
		this.sortingVariables = m;
		if (!n.sort) {
			n.sort = {}
		}
		if (this.isGroupedData && h == "smps") {
			n.sort.grps = l
		} else {
			n.sort[h] = l
		}
	};
	this.isAsciiArray = function(a) {
		return !this.isNumeric(a)
	};
	this.sortAsciibetically = function(d, c) {
		var e = this;
		if (this.tmpAsciiArray[d] == this.tmpAsciiArray[c] && this.tmpAsciiArray1.length > 0) {
			if (this.tmpAsciiArrayAscii1) {
				return e.sortAsciibetically1(d, c)
			} else {
				return e.sortNumerically1(d, c)
			}
		} else {
			return ((this.tmpAsciiArray[d] > this.tmpAsciiArray[c]) ? 1 : (this.tmpAsciiArray[d] < this.tmpAsciiArray[c]) ? -1 : 0)
		}
	};
	this.sortAsciibetically1 = function(d, c) {
		var e = this;
		if (this.tmpAsciiArray1[d] == this.tmpAsciiArray1[c] && this.tmpAsciiArray2.length > 0) {
			if (this.tmpAsciiArrayAscii2) {
				return e.sortAsciibetically2(d, c)
			} else {
				return e.sortNumerically2(d, c)
			}
		} else {
			return ((this.tmpAsciiArray1[d] > this.tmpAsciiArray1[c]) ? 1 : (this.tmpAsciiArray1[d] < this.tmpAsciiArray1[c]) ? -1 : 0)
		}
	};
	this.sortAsciibetically2 = function(d, c) {
		return ((this.tmpAsciiArray2[d] > this.tmpAsciiArray2[c]) ? 1 : (this.tmpAsciiArray2[d] < this.tmpAsciiArray2[c]) ? -1 : 0)
	};
	this.sortNumerically = function(e, d) {
		var f = this;
		var c = Number.MAX_VALUE * -1;
		if ((this.tmpAsciiArray[e] || c) - (this.tmpAsciiArray[d] || c) == 0 && this.tmpAsciiArray1.length > 0) {
			if (this.tmpAsciiArrayAscii1) {
				return f.sortAsciibetically1(e, d)
			} else {
				return f.sortNumerically1(e, d)
			}
		} else {
			return (this.tmpAsciiArray[e] || c) - (this.tmpAsciiArray[d] || c)
		}
	};
	this.sortNumerically1 = function(e, d) {
		var f = this;
		var c = Number.MAX_VALUE * -1;
		if ((this.tmpAsciiArray1[e] || c) - (this.tmpAsciiArray1[d] || c) == 0 && this.tmpAsciiArray2.length > 0) {
			if (this.tmpAsciiArrayAscii2) {
				return f.sortAsciibetically2(e, d)
			} else {
				return f.sortNumerically2(e, d)
			}
		} else {
			return (this.tmpAsciiArray1[e] || c) - (this.tmpAsciiArray1[d] || c)
		}
	};
	this.sortNumerically2 = function(e, d) {
		var c = Number.MAX_VALUE * -1;
		return (this.tmpAsciiArray2[e] || c) - (this.tmpAsciiArray2[d] || c)
	};
	this.sortArray = function(a, b) {
		var d = [];
		if (a.length != b.length) {
			return a
		}
		for (var c = 0; c < a.length; c++) {
			if (a[b[c]]) {
				d[c] = a[b[c]]
			} else {
				return a
			}
		}
		return d
	};
	this.sortObject = function(b) {
		var a = Object.keys(b);
		if (this.isAsciiArray(a)) {
			if (this.sortCaseSensitive) {
				return a.sort()
			} else {
				return a.sort(function(d, c) {
					return d.toLowerCase().localeCompare(c.toLowerCase())
				})
			}
		} else {
			return a.sort(function(d, c) {
				return d - c
			})
		}
	};
	this.stringRangeSort = function(d) {
		var c = {};
		var a;
		for (var b = 0; b < d.length; b++) {
			if (d[b].match(/^\d+\-\d+/)) {
				a = d[b].split(/\-/);
				c[b] = Number(a[0])
			} else {
				if (d[b].match(/^\>\d+/)) {
					a = d[b].split(/\>/);
					c[b] = Number(a[1]) + 1e-8
				} else {
					if (d[b].match(/^\<\d+/)) {
						a = d[b].split(/\</);
						c[b] = Number(a[1]) - 1e-8
					} else {
						if (d[b].match(/^\d+/)) {
							a = d[b];
							c[b] = a
						} else {
							return d.sort()
						}
					}
				}
			}
		}
		d.sort(function(f, e) {
			c[f] - c[e]
		});
		return d
	};
	this.radixSort = function(n) {
		var h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		var e = new Int32Array(n.length);
		var f = [].concat(h);
		var g = [].concat(h);
		var j = [].concat(h);
		var l = [].concat(h);
		var a = 0;
		var i;
		var b = 0;
		var k;
		var c = 0;
		var m;
		var d = 0;
		var o;
		var p;
		for (p = 0; p < n.length; p++) {
			i = n[p] & 255;
			k = (n[p] >> 8) & 255;
			m = (n[p] >> 16) & 255;
			o = (n[p] >> 24) & 255 ^ 128;
			f[i]++;
			g[k]++;
			j[m]++;
			l[o]++
		}
		for (p = 0; p < 256; p++) {
			i = a + f[p];
			k = b + g[p];
			m = c + j[p];
			o = d + l[p];
			f[p] = a;
			g[p] = b;
			j[p] = c;
			l[p] = d;
			a = i;
			b = k;
			c = m;
			d = o
		}
		for (p = 0; p < n.length; p++) {
			i = n[p] & 255;
			e[f[i]] = n[p];
			f[i]++
		}
		for (p = 0; p < n.length; p++) {
			k = (e[p] >> 8) & 255;
			n[g[k]] = e[p];
			g[k]++
		}
		for (p = 0; p < n.length; p++) {
			m = (n[p] >> 16) & 255;
			e[j[m]] = n[p];
			j[m]++
		}
		for (p = 0; p < n.length; p++) {
			o = (e[p] >> 24) & 255 ^ 128;
			n[l[o]] = e[p];
			l[o]++
		}
		return n
	}
};
CanvasXpress.prototype.initMathUtils = function() {
	this.isNaN = function(a) {
		return isNaN(a) ? true : a == Number.POSITIVE_INFINITY ? true : a == Number.NEGATIVE_INFINITY ? true : false
	};
	this.isFinite = function(a) {
		if (this.isArray(a)) {
			for (var b = 0; b < a.length; b++) {
				if (!isFinite(a[b])) {
					return false
				}
			}
			return true
		} else {
			return isFinite(a)
		}
	};
	this.triCube = function(a) {
		return (a = 1 - a * a * a) * a * a
	};
	this.degreesToArcLength = function(b, a) {
		return b * a
	};
	this.radiansToArcLength = function(a, b) {
		return (a * Math.PI * b) / 180
	};
	this.arcLengthToDegrees = function(b, a) {
		return (a * 180) / (b * Math.PI)
	};
	this.arcLengthToRadians = function(b, a) {
		return a / b
	};
	this.radians = function(a) {
		return a * Math.PI / 180
	};
	this.getAngle = function(e, g, c, f, d) {
		var b = (Math.atan2(f - g, c - e) * 180 / Math.PI) % 360;
		if (!d) {
			d = 0
		}
		while (b < d) {
			b += 360
		}
		while (b >= (d + 360)) {
			b -= 360
		}
		return b
	};
	this.getRadians = function(e, g, c, f, d) {
		var b = Math.atan2(f - g, c - e);
		if (b < 0) {
			b += (2 * Math.PI)
		}
		return b
	};
	this.rotatePoint = function(c, h, b, g, d) {
		var f = Math.cos(d) * (c - b) - Math.sin(d) * (h - g) + b;
		var e = Math.sin(d) * (c - b) + Math.cos(d) * (h - g) + g;
		return [f, e]
	};
	this.lineLength = function(b, d, a, c) {
		return Math.sqrt(Math.pow(a - b, 2) + Math.pow(c - d, 2))
	};
	this.parallelLinePoints = function(r, d, p, b, n) {
		var i = p - r;
		var h = b - d;
		var o = this.lineLength(r, d, p, b);
		var u = i / o;
		var t = h / o;
		var s = -t;
		var q = u;
		var c = r + n * s;
		var f = d + n * q;
		var a = r - n * s;
		var e = d - n * q;
		var j = p + n * s;
		var m = b + n * q;
		var g = p - n * s;
		var k = b - n * q;
		return [c, f, a, e, j, m, g, k]
	};
	this.shortenLine = function(b, j, a, i, k, f, l) {
		if (this.isNumeric([b, j, a, i, k, f])) {
			if (l.match(/bezier/i)) {
				if (l.match(/beziery/i)) {
					return i > j ? [b, j + k, a, i - f] : [b, j - k, a, i + f]
				} else {
					return a > b ? [b + k, j, a - f, i] : [b - k, j, a + f, i]
				}
			} else {
				if (l.match(/curved/i)) {
					return [b, j, a, i]
				} else {
					var c = Math.atan2(i - j, a - b);
					var d = Math.cos(c);
					var h = Math.sin(c);
					var g = this.lineLength(b, j, a, i);
					if (g) {
						while (g < (k + f)) {
							k /= 1.1;
							f /= 1.1
						}
						b += d * k;
						j += h * k;
						a -= d * f;
						i -= h * f
					}
				}
			}
			return [b, j, a, i]
		}
	};
	this.traceArc = function(c, b, a, m, h, d) {
		if (m > h) {
			var k = m;
			m = h;
			h = k
		}
		var l = [];
		var g = Math.PI;
		var i = h - m;
		var f = i < g / 16 ? 0 : i < g / 8 ? 4 : i < g / 4 ? 8 : i < g ? 16 : 32;
		var j = i / f;
		l.push([a * Math.cos(m) + c, a * Math.sin(m) + b]);
		m += j;
		while (m < h) {
			l.push([a * Math.cos(m) + c, a * Math.sin(m) + b]);
			m += j
		}
		l.push([a * Math.cos(h) + c, a * Math.sin(h) + b]);
		return d ? l : l.reverse()
	};
	this.traceQuadraticCurve = function(l, k, e, c, j, h, b, f) {
		var m = [];
		var a = function(i, q, p, o) {
			var n = 1 - i;
			return n * n * q + 2 * n * i * p + i * i * o
		};
		var d = function(i) {
			return [a(i, l, e, j), a(i, k, c, h)]
		};
		for (var g = 0; g <= 1; g += b) {
			m.push(d(g))
		}
		return f ? m : m.reverse()
	};
	this.traceBezierCurve = function(j, h, c, b, l, k, g, f, a, d) {
		var m = [];
		for (var e = 0; e <= 1; e += a) {
			m.push(this.deCasteljau([
				[j, h],
				[c, b],
				[l, k],
				[g, f]
			], e))
		}
		return d ? m : m.reverse()
	};
	this.splineControlPoint = function(e, m, d, l, c, k) {
		var n = Math.sqrt(Math.pow(d - e, 2) + Math.pow(l - m, 2));
		var h = Math.sqrt(Math.pow(c - d, 2) + Math.pow(k - l, 2));
		var g = this.tension * n / (n + h);
		var f = this.tension - g;
		var b = d + g * (e - c);
		var a = l + g * (m - k);
		var j = d - f * (e - c);
		var i = l - f * (m - k);
		return [b, a, j, i]
	};
	this.hullControlPoints = function(f) {
		var c = this;
		var f;
		var e = [];
		var g = 0;
		var b, a;
		var d = function(p, n, m) {
			var l = function(r, q) {
				var t = q[0] - r[0];
				var s = q[1] - r[1];
				return Math.sqrt(t * t + s * s)
			};
			var o = l(p, n);
			var k = l(n, m);
			var h = c.tension * o / (o + k);
			var j = [((p[0] - m[0]) * h) + n[0], ((p[1] - m[1]) * h) + n[1]];
			var i = [n[0] - ((p[0] - m[0]) * h), (n[1] - (p[1] - m[1]) * h)];
			return [j, i]
		};
		for (b = 0; b < f.length - 2; b++) {
			e.push.apply(e, d(f[b], f[b + 1], f[b + 2]))
		}
		e.push.apply(e, d(f[b], f[b + 1], f[0]));
		e.push.apply(e, d(f[b + 1], f[0], f[1]));
		return e
	};
	this.expandPolygon = function(o, w) {
		var b = function(i) {
			var d = Math.sqrt(i.x * i.x + i.y * i.y);
			return {
				x: i.x / d,
				y: i.y / d
			}
		};
		var s = function(d, i) {
			return {
				x: d.x * i,
				y: d.y * i
			}
		};
		var l = function(i, d) {
			return i.x * d.x + i.y * d.y
		};
		var c = function(d) {
			return {
				x: d.y,
				y: -d.x
			}
		};
		var x = function(d) {
			return {
				x: -d.y,
				y: d.x
			}
		};
		var v = function(F, E) {
			var i = F[1].x - F[0].x;
			var D = E[0].x - E[1].x;
			var B = E[0].x - F[0].x;
			var d = F[1].y - F[0].y;
			var C = E[0].y - E[1].y;
			var p = E[0].y - F[0].y;
			var G = (D * p - C * B) / (d * D - i * C);
			return {
				x: F[0].x + G * (F[1].x - F[0].x),
				y: F[0].y + G * (F[1].y - F[0].y)
			}
		};
		var z = function(d) {
			return l(c({
				x: d[1].x - d[0].x,
				y: d[1].y - d[0].y
			}), {
				x: d[2].x - d[1].x,
				y: d[2].y - d[1].y
			}) >= 0
		};
		var t = [];
		var g = z(o) ? x : c;
		for (var u = 0; u < o.length; ++u) {
			var k = o[(u > 0) ? u - 1 : o.length - 1];
			var h = o[u];
			var f = o[(u < o.length - 1) ? u + 1 : 0];
			var m = {
				x: h[0] - k[0],
				y: h[1] - k[1]
			};
			var y = {
				x: f[0] - h[0],
				y: f[1] - h[1]
			};
			var n = s(b(g(m)), w);
			var A = s(b(g(y)), w);
			var r = {
				x: k[0] + n.x,
				y: k[1] + n.y
			};
			var j = {
				x: h[0] + n.x,
				y: h[1] + n.y
			};
			var e = {
				x: h[0] + A.x,
				y: h[1] + A.y
			};
			var q = {
				x: f[0] + A.x,
				y: f[1] + A.y
			};
			var a = v([r, j], [e, q]);
			t.push([a.x, a.y])
		}
		return t
	};
	this.seq = function(e, b, d, a) {
		var c = [];
		if (a || d) {
			if (a) {
				d = (b - e) / (Math.abs(a) - 1)
			} else {
				if (b < e) {
					d = -d
				}
			}
			if (d) {
				while (d > 0 ? b >= e : b <= e) {
					c.push(e);
					e += d
				}
			}
		}
		return c
	};
	this.rnorm = function(h, b, d) {
		var g = this;
		var c = [];
		if (b == null) {
			b = 0
		}
		if (d == null) {
			d = 1
		}
		var f = function() {
			var l, k, j, i;
			var a = 2;
			while (a > 1) {
				j = g.random();
				i = g.random();
				l = 2 * j - 1;
				k = 2 * i - 1;
				a = l * l + k * k
			}
			return (b + Math.sqrt(d) * (Math.sqrt(-2 * Math.log(a) / a) * l))
		};
		for (var e = 0; e < h; e++) {
			c.push(f())
		}
		return c
	};
	this.percentile2 = function(a, f) {
		if (a.length === 0) {
			return 0
		}
		if (typeof f !== "number") {
			throw new TypeError("p must be a number")
		}
		if (f <= 0) {
			return a[0]
		}
		if (f >= 1) {
			return a[a.length - 1]
		}
		var c = a.length * f,
			b = Math.floor(c),
			d = b + 1,
			e = c % 1;
		if (d >= a.length) {
			return a[b]
		}
		return a[b] * (1 - e) + a[d] * e
	};
	this.percentRank = function(a, c) {
		if (typeof c !== "number") {
			throw new TypeError("v must be a number")
		}
		for (var d = 0, b = a.length; d < b; d++) {
			if (c <= a[d]) {
				while (d < b && c === a[d]) {
					d++
				}
				if (d === 0) {
					return 0
				}
				if (c !== a[d - 1]) {
					d += (c - a[d - 1]) / (a[d] - a[d - 1])
				}
				return d / b
			}
		}
		return 1
	};
	this.percentile = function(d, a, e) {
		var b = a - d;
		if (b == 0) {
			return 50
		}
		var c = e - d;
		return c * 100 / b
	};
	this.rank = function(a) {
		var c = [];
		for (var b = 0; b < a.length; b++) {
			c.push(b)
		}
		c.sort(function(e, d) {
			return a[e] - a[d]
		});
		return c
	};
	this.rank2 = function(b) {
		var d = b.slice().sort(function(g, f) {
			return g - f
		});
		var e = b.slice().map(function(f) {
			return d.indexOf(f) + 1
		});
		var c = {};
		e.map(function(f) {
			c[f] = c[f] ? c[f]++ : 1
		});
		var a = e.map(function(f) {
			return f / c[f]
		});
		return a
	};
	this.min = function(b, a, e) {
		if (this.isArray(b)) {
			b = this.cleanArray(b, a, e);
			var d = Number.POSITIVE_INFINITY;
			for (var c = 0; c < b.length; c++) {
				d = Math.min(d, b[c])
			}
			return d
		} else {
			return this.Min(b, a)
		}
	};
	this.max = function(c, b, e) {
		if (this.isArray(c)) {
			c = this.cleanArray(c, b, e);
			var a = Number.NEGATIVE_INFINITY;
			for (var d = 0; d < c.length; d++) {
				a = Math.max(a, c[d])
			}
			return a
		} else {
			return this.Max(c, b)
		}
	};
	this.sum = function(b, a, g, e, f) {
		b = this.cleanArray(b, a, g);
		var d = 0;
		for (var c = 0; c < b.length; c++) {
			if (e) {
				if (b[c] > 0) {
					d += b[c]
				}
			} else {
				if (f) {
					if (b[c] < 0) {
						d += b[c]
					}
				} else {
					d += b[c]
				}
			}
		}
		return d
	};
	this.sumSquared = function(b, a, f, e) {
		b = this.cleanArray(b, a, f);
		var d = 0;
		for (var c = 0; c < b.length; c++) {
			if (e) {
				if (b[c] > 0) {
					d += b[c] * b[c]
				}
			} else {
				d += b[c] * b[c]
			}
		}
		return d
	};
	this.sumSquaredError = function(b, a, g) {
		b = this.cleanArray(b, a, g);
		var c = this.mean(b);
		var f = 0;
		for (var e = 0; e < b.length; e++) {
			var d = b[e] - c;
			f += d * d
		}
		return f
	};
	this.mean = function(b, a, e) {
		b = this.cleanArray(b, a, e);
		var c = 0;
		var f = 0;
		for (var d = 0; d < b.length; d++) {
			if (!this.isNaN(b[d])) {
				c += Number(b[d]);
				f++
			}
		}
		if (f > 0) {
			c /= f
		}
		return c
	};
	this.range = function(c, b, f) {
		c = this.cleanArray(c, b, f);
		var e = Number.MAX_VALUE;
		var a = Number.MAX_VALUE * -1;
		for (var d = 0; d < c.length; d++) {
			e = Math.min(c[d], e);
			a = Math.max(c[d], a)
		}
		return e == a && e == 0 ? [0, 0.1] : e == a ? [Number(e), Number(a)] : [Number(e), Number(a)]
	};
	this.median = function(b, a, f) {
		b = this.cleanArray(b, a, f);
		var e = [];
		var d = [];
		var g = 0;
		e[0] = Number.NaN;
		e[1] = Number.NaN;
		for (var c = 0; c < b.length; c++) {
			d.push(b[c]);
			g++
		}
		if (g > 0) {
			e[1] = g;
			d.sort(function(i, h) {
				return i - h
			});
			if (g % 2) {
				e[0] = d[parseInt(g / 2)]
			} else {
				e[0] = (d[parseInt((g - 1) / 2)] + d[g / 2]) / 2
			}
		}
		return e
	};
	this.subtractArray = function(c, e) {
		var b = [];
		for (var d = 0; d < c.length; d++) {
			b.push(c[d] - e)
		}
		return b
	};
	this.addArray = function(c, e) {
		var b = [];
		for (var d = 0; d < c.length; d++) {
			b.push(c[d] + e)
		}
		return b
	};
	this.replaceArray = function(c, e) {
		var b = [];
		for (var d = 0; d < c.length; d++) {
			b.push(e)
		}
		return b
	};
	this.random = function() {
		if (this.pseudoRandom) {
			this.randomSeed = (this.randomSeed * 9301 + 49297) % 233280;
			return this.randomSeed / 233280
		} else {
			return Math.random()
		}
	};
	this.sumarizeErrorData = function(b, a, c) {
		if (this.errorBarsType == "standardErrorMean") {
			return this.meanStandardErrorN(b, a, c)
		} else {
			if (this.errorBarsType == "confidenceInterval95") {
				return this.mean95ConfidenceIntervalN(b, a, c)
			} else {
				return this.meanStandardDeviationN(b, a, c)
			}
		}
	};
	this.meanStandardErrorN = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], Math.sqrt(c[1]) / Math.sqrt(c[2]), c[2]]
	};
	this.mean95ConfidenceIntervalN = function(b, a, d) {
		var c = this.meanStandardErrorN(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], c[1] * 1.96, c[2]]
	};
	this.meanStandardDeviationN = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], Math.sqrt(c[1]), c[2]]
	};
	this.quantile = function(b, a) {
		if (a < b[0]) {
			return 0
		} else {
			if (a >= b[0] && a < b[1]) {
				return 1
			} else {
				if (a >= b[1] && a < b[2]) {
					return 2
				} else {
					if (a >= b[2]) {
						return 3
					}
				}
			}
		}
	};
	this.quantiles = function(k, l, f) {
		var o = [];
		var g = [];
		var c = k.length;
		if (c > 3) {
			var p = Math.floor(c * 0.25);
			var j = Math.floor(c * 0.5);
			var b = Math.floor(c * 0.75);
			k.sort(function(n, i) {
				return n - i
			});
			var a;
			var s;
			var q;
			var r = this.mean(k);
			if (c % 2) {
				s = k[j]
			} else {
				s = this.mean([k[j - 1], k[j]])
			}
			if ((c / 2) % 2) {
				a = k[p];
				q = k[b]
			} else {
				a = this.mean([k[p - 1], k[p]]);
				q = this.mean([k[b - 1], k[b]])
			}
			var m = (q - a) * 1.5;
			var e, d;
			for (var h = 0; h <= p; h++) {
				if (k[h] < a - m) {
					g.push(k[h])
				} else {
					e = k[h];
					break
				}
			}
			for (var h = c - 1; h >= b; h--) {
				if (k[h] > q + m) {
					g.push(k[h])
				} else {
					d = k[h];
					break
				}
			}
			o.push(r);
			o.push(a);
			o.push(s);
			o.push(q);
			o.push(e);
			o.push(d);
			o.push(g);
			o.push(c)
		} else {
			if (c > 2) {
				k.sort(function(n, i) {
					return n - i
				});
				var r = this.mean(k);
				o.push(r);
				o.push((k[0] + k[1]) / 2);
				o.push(k[1]);
				o.push((k[1] + k[2]) / 2);
				o.push(k[0]);
				o.push(k[2]);
				o.push(g);
				o.push(c)
			} else {
				if (c > 1) {
					k.sort(function(n, i) {
						return n - i
					});
					var r = this.mean(k);
					o.push(r);
					o.push((k[0] + r) / 2);
					o.push(r);
					o.push((r + k[1]) / 2);
					o.push(k[0]);
					o.push(k[1]);
					o.push(g);
					o.push(c)
				} else {
					if (c > 0) {
						o.push(k[0]);
						o.push(k[0]);
						o.push(k[0]);
						o.push(k[0]);
						o.push(k[0]);
						o.push(k[0]);
						o.push(g);
						o.push(c)
					} else {
						o.push(NaN);
						o.push(NaN);
						o.push(NaN);
						o.push(NaN);
						o.push(NaN);
						o.push(NaN);
						o.push(NaN)
					}
				}
			}
		}
		return o
	};
	this.quants = function(c, b, e, d) {
		c = this.cleanArray(c, b, e);
		c = c.slice().sort(function(h, g) {
			return h - g
		});
		var f = c.length - 1;
		var a = d || [0.25, 0.5, 0.75];
		return a.map(function(l) {
			if (l === 0) {
				return c[0]
			} else {
				if (l === 1) {
					return c[f]
				} else {
					var i = 1 + l * f;
					var k = Math.floor(i);
					var j = i - k;
					var g = c[k - 1];
					return j === 0 ? g : g + j * (c[k] - g)
				}
			}
		})
	};
	this.medianByQuantile = function(b, a, c) {
		return this.quants(b, a, c, [0.5])
	};
	this.iqr = function(b, a, d) {
		var c = this.quants(b, a, d);
		return c[2] - c[0]
	};
	this.variance = function(e, f, c, a) {
		e = this.cleanArray(e, f, c);
		var b = e.length;
		if (b < 1) {
			return a ? [NaN, NaN, NaN] : NaN
		} else {
			if (b == 1) {
				return a ? [e[0], 0, 1] : 0
			} else {
				var j = this.mean(e);
				var h = 0;
				var d = b;
				while (--d >= 0) {
					if (!this.isNaN(e[d])) {
						var g = e[d] - j;
						h += g * g
					}
				}
				if (a) {
					return this.standardDeviationType == "unbiased" ? [j, h / (b - 1), b] : [j, h / b, b]
				} else {
					return this.standardDeviationType == "unbiased" ? h / (b - 1) : h / b
				}
			}
		}
	};
	this.deviation = function(b, a, f) {
		b = this.cleanArray(b, a, f);
		var g = b.length;
		if (g < 1) {
			return [NaN]
		} else {
			if (g == 1) {
				return [0]
			} else {
				var c = this.mean(b);
				var d = [];
				for (var e = 0; e < g; e++) {
					if (!this.isNaN(b[e])) {
						d[e] = b[e] - c
					} else {
						d[e] = NaN
					}
				}
				return d
			}
		}
	};
	this.standardDeviation = function(b, a, d) {
		var c = this.variance(b, a, d);
		if (this.isNaN(c)) {
			return c
		}
		return Math.sqrt(c)
	};
	this.standardError = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return c[1]
		}
		return Math.sqrt(c[1]) / Math.sqrt(c[2])
	};
	this.meanSquaredError = function(b, a, c) {
		b = this.cleanArray(b, a, c);
		return this.sumSquaredError(this.sumSquaredError(b, a, c)) / b.length
	};
	this.confidenceInterval95 = function(c, b, d) {
		var a = this.standardError(c, b, d);
		if (this.isNaN(a)) {
			return a
		}
		return a * 1.96
	};
	this.covariance = function(h, g, e, c) {
		var f = this.cleanArrays(h, g, e, c);
		h = f[0];
		g = f[1];
		var l = 0;
		var a = [];
		var b = 0;
		var k = this.mean(h);
		var j = this.mean(g);
		for (var d = 0; d < h.length; d++) {
			a[d] = (h[d] - k) * (g[d] - j);
			l += a[d];
			b++
		}
		if (b > 0) {
			return l / (this.standardDeviationType == "unbiased" ? b - 1 : b)
		} else {
			return NaN
		}
	};
	this.correlation = function(c, b, a, e, d) {
		if (d && d == "spearman") {
			return this.correlationSpearman(c, b, a, e)
		} else {
			return this.correlationPearson(c, b, a, e)
		}
	};
	this.correlationSpearman = function(m, l, h, f) {
		var k = this.cleanArrays(m, l, h, f);
		m = k[0];
		l = k[1];
		var a = m.length;
		var b = 0;
		var e = this.rank2(m);
		var c = this.rank2(l);
		for (var g = 0; g < m.length; g++) {
			var j = e[g] - c[g];
			b += j * j
		}
		return 1 - (6 * b / (a * (a * a - 1)))
	};
	this.correlationPearson = function(c, b, a, d) {
		return this.covariance(c, b, a, d) / this.standardDeviation(c, a, d) / this.standardDeviation(b, a, d)
	};
	this.regression = function(f, e, g, c, t, z) {
		var k = this;
		var m = function() {
			if (!t) {
				t = k.min(f)
			}
			if (!z) {
				z = k.max(f)
			}
			var n = (z - t) / 10;
			var E = [];
			for (var D = 0; D < 11; D++) {
				E.push(t + (D * n))
			}
			return E
		};
		var u = this.cleanArrays(f, e, g, c);
		f = u[0];
		e = u[1];
		var s = 0;
		var r = 0;
		var q = 0;
		var B = 0;
		var l = 0;
		var w = 0;
		var b = 0;
		var o = 0;
		var j = 0;
		var v = 0;
		var y = 0;
		var d = 0;
		var h = 0;
		var a = m();
		var p = [];
		for (var x = 0; x < f.length; x++) {
			if (!this.isNaN(f[x]) && !this.isNaN(e[x])) {
				r += f[x];
				q += e[x];
				B += f[x] * e[x];
				l += f[x] * f[x];
				w += e[x] * e[x];
				s++
			}
		}
		if (s > 2) {
			o = (s * B - r * q) / (s * l - r * r);
			j = (q - o * r) / s;
			b = (B - (r * q / s)) / Math.sqrt((l - Math.pow(r, 2) / s) * (w - Math.pow(q, 2) / s));
			d = r / s;
			h = this.tinv(0.05, s - 2, true);
			for (var x = 0; x < f.length; x++) {
				if (!this.isNaN(f[x]) && !this.isNaN(e[x])) {
					v += Math.pow(e[x] - ((f[x] * o) + j), 2);
					y += Math.pow(f[x] - d, 2)
				}
			}
			v = Math.sqrt(v / (s - 2));
			for (var x = 0; x < a.length; x++) {
				var C = -h * v * Math.sqrt((1 / s) + Math.pow(a[x] - d, 2) / y);
				var A = o * a[x] + j;
				p.push([a[x], A + C, A - C, C])
			}
		}
		return [o, j, b, p]
	};
	this.confidenceIntervalRegression = function() {};
	this.slope = function(b, d, a, c) {
		return d != c ? (a - b) / (c - d) : 0
	};
	this.intercept = function(a, c, b) {
		return c - (a * b)
	};
	this.slopeIntercept = function(b, e, a, d) {
		var c = this.slope(b, e, a, d);
		return [c, this.intercept(b, e, c)]
	};
	this.normalize = function(f) {
		var e = this.standardDeviationType;
		this.standardDeviationType = "biased";
		for (var c = 0; c < f.length; c++) {
			var a = this.meanStandardDeviationN(f[c]);
			for (var b = 0; b < f[c].length; b++) {
				f[c][b] = (f[c][b] - a[0]) / a[1]
			}
		}
		this.standardDeviationType = e;
		return f
	};
	this.checkLoessCache = function(d) {
		var a = this.meta;
		if (!a.vals.loess) {
			a.vals.loess = []
		}
		for (var e = 0; e < a.vals.loess.length; e++) {
			var b = a.vals.loess[e];
			var f = b.x == d[0] ? 0 : 1;
			f += b.y == d[1] ? 0 : 1;
			f += b.b == this.loessBandwidth ? 0 : 1;
			f += b.i == this.loessIterations ? 0 : 1;
			f += b.a == this.loessAccuracy ? 0 : 1;
			if (f == 0) {
				return b.l
			}
		}
		return false
	};
	this.loess = function(M, G, J) {
		var l = this.checkLoessCache(J);
		if (l) {
			return l
		}
		var F = [];
		var D = [];
		var C = function(V, W, y, U) {
			var T = function(b, X) {
				var x = X + 1;
				while (x < b.length && b[x] === 0) {
					x++
				}
				return x
			};
			var j = U[0];
			var a = U[1];
			var d = T(W, a);
			if ((d < V.length) && (V[d] - V[y]) < (V[y] - V[j])) {
				var k = T(W, j);
				U[0] = k;
				U[1] = d
			}
		};
		M = this.cleanArrays(M[0], M[1]);
		if (M[0].length > 0) {
			var t = this.rank(M[0]);
			for (var L = 0; L < t.length; L++) {
				F.push(M[0][t[L]]);
				D.push(M[1][t[L]])
			}
			if (M[0].length < 2) {
				return [F, D]
			}
			if (!G) {
				G = [];
				for (var L = 0; L < F.length; L++) {
					G.push(1)
				}
			}
			var H = Math.floor(this.loessBandwidth * M[0].length);
			if (H < 2) {
				alert("Bandwidth for loess fitting too small!");
				return false
			} else {
				var m = [];
				var v = [];
				var N = [];
				for (var L = 0; L < F.length; L++) {
					m[L] = 0;
					v[L] = 0;
					N[L] = 1
				}
				var q = 0;
				while (q <= this.loessIterations) {
					var O = [0, H - 1];
					for (var L = 0; L < F.length; L++) {
						if (L > 0) {
							C(F, G, L, O)
						}
						var A = O[0];
						var r = O[1];
						var Q = (F[L] - F[A]) > (F[r] - F[L]) ? A : r;
						var g = 0;
						var u = 0;
						var n = 0;
						var s = 0;
						var c = 0;
						var S = Math.abs(1 / (F[Q] - F[L]));
						for (var K = A; K <= r; ++K) {
							var f = K < L ? F[L] - F[K] : F[K] - F[L];
							var R = this.triCube(f * S) * N[K] * G[K];
							var z = F[K] * R;
							g += R;
							u += z;
							n += F[K] * z;
							s += D[K] * R;
							c += D[K] * z
						}
						var p = u / g;
						var o = s / g;
						var E = c / g;
						var e = n / g;
						var B = (Math.sqrt(Math.abs(e - p * p)) < this.loessAccuracy) ? 0 : ((E - p * o) / (e - p * p));
						var I = o - B * p;
						m[L] = B * F[L] + I;
						v[L] = Math.abs(D[L] - m[L])
					}
					if (q === this.loessIterations) {
						break
					}
					var h = this.medianByQuantile(v);
					if (Math.abs(h) < this.loessAccuracy) {
						break
					}
					for (var L = 0; L < F.length; L++) {
						var P = v[L] / (6 * h);
						N[L] = P >= 1 ? 0 : Math.pow(1 - P * P, 2)
					}
					q++
				}
				this.meta.vals.loess.push({
					x: J[0],
					y: J[1],
					b: this.loessBandwidth,
					i: this.loessIterations,
					a: this.loessAccuracy,
					l: [F, m]
				});
				return [F, m]
			}
		} else {
			alert("Not valid array for loess fitting!");
			return false
		}
	};
	this.errorEllipse = function(a, c, b) {
		if (b) {
			return this.errorEllipse3D(a, c, b)
		} else {
			return this.errorEllipse2D(a, c)
		}
	};
	this.errorEllipse2D = function(k, g) {
		var i = this.variance(k, false, false, true);
		var h = this.variance(g, false, false, true);
		var j = this.covariance(k, g);
		var m = [
			[i[1], j],
			[j, h[1]]
		];
		var n = numeric.eig(m);
		var l = Math.sqrt(2 * this.gammaPinv(this.errorEllipseConfidence, 1));
		var f = n.lambda.x[0] > n.lambda.x[1] ? 0 : 1;
		var e = n.lambda.x[0] < n.lambda.x[1] ? 0 : 1;
		var b = i[1] > h[1] ? Math.sqrt(n.lambda.x[f]) * l : Math.sqrt(n.lambda.x[e]) * l;
		var a = h[1] > i[1] ? Math.sqrt(n.lambda.x[f]) * l : Math.sqrt(n.lambda.x[e]) * l;
		var c = Math.atan2(n.E.x[f][1], n.E.x[f][0]);
		if (c < 0) {
			c += Math.PI / 2
		}
		var d = {
			rx: b,
			ry: a,
			cx: i[0],
			cy: h[0],
			rot: c
		};
		return d
	};
	this.errorEllipse3D = function(m, l, j) {
		var p = this.variance(m, false, false, true);
		var o = this.variance(l, false, false, true);
		var n = this.variance(j, false, false, true);
		var c = this.covariance(m, l);
		var b = this.covariance(m, j);
		var i = this.covariance(l, j);
		var t = [
			[p[1], c, b],
			[c, o[1], i],
			[b, i, n[1]]
		];
		var k = numeric.eig(t);
		var a = Math.sqrt(2 * this.gammaPinv(this.errorEllipseConfidence, 1));
		var f = this.rank(k.lambda.x);
		var s = f[2];
		var q = f[1];
		var r = f[0];
		var h = Math.sqrt(k.lambda.x[s]) * a;
		var e = Math.sqrt(k.lambda.x[q]) * a;
		var d = Math.sqrt(k.lambda.x[r]) * a;
		var w = Math.atan2(k.E.x[2][s] * -1, k.E.x[1][s] * -1);
		var v = Math.atan2(k.E.x[2][s] * -1, k.E.x[0][s] * -1);
		var u = Math.atan2(k.E.x[1][s] * -1, k.E.x[0][s] * -1);
		if (w < 0) {}
		if (v < 0) {
			v += Math.PI / 2
		}
		if (u < 0) {}
		var g = {
			rx: [h],
			ry: [e],
			rz: [d],
			cx: p[0],
			cy: o[0],
			cz: n[0],
			rot: [w, v, u]
		};
		return g
	};
	this.epanechnikovKernel = function(a) {
		return function(b) {
			return Math.abs(b /= a) <= 1 ? 0.75 * (1 - b * b) / a : 0
		}
	};
	this.uniformKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				return 0.5
			}
			return 0
		}
	};
	this.triangularKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				return 1 - Math.abs(b / a)
			}
			return 0
		}
	};
	this.quarticKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				var c = (1 - b * b) / a;
				return (15 / 16) * c * c
			}
			return 0
		}
	};
	this.triweightKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				var c = (1 - b * b) / a;
				return (35 / 32) * c * c * c
			}
			return 0
		}
	};
	this.gaussianKernel = function(a) {
		return function(b) {
			return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * b * b / a)
		}
	};
	this.cosineKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b >= -1 / a) {
				return Math.PI / 4 * Math.cos((Math.PI / 2 * b) / a)
			}
			return 0
		}
	};
	this.getBandwidthEstimate = function(e, a) {
		var b = Math.sqrt(this.variance(e));
		var f = this.iqr(e) / 1.34;
		var d = Math.pow(e.length, -0.2);
		var c = Math.min(b, f);
		return !a ? 1.06 * c * d : 0.9 * c * d
	};
	this.kernelDensityEstimator = function(d, b) {
		var c = function(e) {
			return null != e && !this.isNaN(e)
		};
		var a = function(j, l) {
			var k, g = j.length,
				h = 0,
				m = -1,
				f = 0;
			for (; ++m < g;) {
				c(k = l.call(j, j[m], m)) && (h += (k - h) / ++f)
			}
			return f ? h : void 0
		};
		return function(e) {
			return b.map(function(f) {
				return [f, a(e, function(g) {
					return d(f - g)
				})]
			})
		}
	};
	this.kde = function(d, b, f, h, e) {
		var g = f[0];
		var c = f[1];
		var i = [];
		for (var j = g; j <= c; j += h) {
			i.push(j)
		}
		if (!b) {
			b = this.getBandwidthEstimate(e)
		}
		var a = this.kernelDensityEstimator(this[d](b), i);
		return a(e)
	};
	this.freedmanDiaconis = function(b, a, c) {
		if (b && b.length > 1) {
			b = this.cleanArray(b, a, c);
			var d = this.iqr(b);
			return d == 0 ? 1 : this.pretty(2 * d * Math.pow(b.length, -1 / 3))
		} else {
			if (b && b.length == 1) {
				return Number(b[0])
			} else {
				return 1
			}
		}
	};
	this.pretty = function(a) {
		var c = Math.pow(10, Math.floor(Math.log(a / 10) / Math.LN10));
		var b = 10 / a * c;
		if (b <= 0.15) {
			c *= 10
		} else {
			if (b <= 0.35) {
				c *= 5
			} else {
				if (b <= 0.75) {
					c *= 2
				}
			}
		}
		return c * 10
	};
	this.getHistogramBin = function(c, a) {
		var d = a * Math.floor(c / a);
		return parseFloat(d.toFixed(this.getAxisDecimals(a)))
	};
	this.toFixed = function(h, b) {
		var e = b || 0;
		var d = g < 0;
		var a = Math.pow(10, e);
		var g = Math.round(h * a);
		var c = String((d ? Math.ceil : Math.floor)(g / a));
		var i = String((d ? -g : g) % a);
		var f = new Array(Math.max(e - i.length, 0) + 1).join("0");
		return e ? c + "." + f + i : c
	};
	this.bezierCalculatePoints = function(g, e) {
		var b = g[0][0];
		var a = g[0][1];
		var d = g[1][0];
		var c = g[1][1];
		var h = b + (d - b) * e;
		var f = a + (c - a) * e;
		return [h, f]
	};
	this.deCasteljau = function(e, d) {
		if (d === 1) {
			return e[e.length - 1]
		}
		if (d === 0) {
			return e[0]
		}
		if (e.length == 1) {
			return e[0]
		}
		var b = [];
		for (var c = 1, a = e.length; c < a; c++) {
			b.push(this.bezierCalculatePoints([e[c - 1], e[c]], d))
		}
		return this.deCasteljau(b, d)
	};
	this.divideBezierCurve = function(f, e, c, g) {
		c = c || [];
		g = g || [];
		c.push(f[0]);
		g.push(f[f.length - 1]);
		if (f.length === 1) {
			return [c, g]
		}
		var b = [];
		for (var d = 1, a = f.length; d < a; d++) {
			b.push(this.bezierCalculatePoints([f[d - 1], f[d]], e))
		}
		return this.divideBezierCurve(b, e, c, g)
	};
	this.centroid = function(a) {
		var c = [];
		if (!a || a.length < 2) {
			return [0, 0]
		} else {
			if (a.length < 3 || a.length % 2) {
				return [a[0], a[1]]
			} else {
				while (a.length > 1) {
					c.push([a.shift(), a.shift()])
				}
			}
		}
		var b = c.reduce(function(d, e) {
			return [d[0] + e[0] / c.length, d[1] + e[1] / c.length]
		}, [0, 0]);
		return b
	};
	this.centroidArea = function(a) {
		var b = this.cloneObject(a);
		b.shift();
		return this.centroid(b)
	};
	this.getD3Sankey = function() {
		var h = function(D, C) {
			return D < C ? -1 : D > C ? 1 : D >= C ? 0 : NaN
		};
		var f = function(H, F) {
			var E = 0,
				G = H.length,
				C, D = -1;
			if (F == null) {
				while (++D < G) {
					if (C = +H[D]) {
						E += C
					}
				}
			} else {
				while (++D < G) {
					if (C = +F(H[D], D, H)) {
						E += C
					}
				}
			}
			return E
		};
		var t = function(H, F) {
			var E = -1,
				G = H.length,
				D, C;
			if (F == null) {
				while (++E < G) {
					if ((C = H[E]) != null && C >= C) {
						D = C;
						break
					}
				}
				while (++E < G) {
					if ((C = H[E]) != null && D > C) {
						D = C
					}
				}
			} else {
				while (++E < G) {
					if ((C = F(H[E], E, H)) != null && C >= C) {
						D = C;
						break
					}
				}
				while (++E < G) {
					if ((C = F(H[E], E, H)) != null && D > C) {
						D = C
					}
				}
			}
			return D
		};
		var x = function(D, C) {
			return D = +D, C -= D,
				function(E) {
					return D + C * E
				}
		};
		var v = "$";

		function j() {}
		j.prototype = A.prototype = {
			constructor: j,
			has: function(C) {
				return (v + C) in this
			},
			get: function(C) {
				return this[v + C]
			},
			set: function(C, D) {
				this[v + C] = D;
				return this
			},
			remove: function(C) {
				var D = v + C;
				return D in this && delete this[D]
			},
			clear: function() {
				for (var C in this) {
					if (C[0] === v) {
						delete this[C]
					}
				}
			},
			keys: function() {
				var C = [];
				for (var D in this) {
					if (D[0] === v) {
						C.push(D.slice(1))
					}
				}
				return C
			},
			values: function() {
				var C = [];
				for (var D in this) {
					if (D[0] === v) {
						C.push(this[D])
					}
				}
				return C
			},
			entries: function() {
				var C = [];
				for (var D in this) {
					if (D[0] === v) {
						C.push({
							key: D.slice(1),
							value: this[D]
						})
					}
				}
				return C
			},
			size: function() {
				var C = 0;
				for (var D in this) {
					if (D[0] === v) {
						++C
					}
				}
				return C
			},
			empty: function() {
				for (var C in this) {
					if (C[0] === v) {
						return false
					}
				}
				return true
			},
			each: function(D) {
				for (var C in this) {
					if (C[0] === v) {
						D(this[C], C.slice(1), this)
					}
				}
			}
		};

		function A(C, F) {
			var G = new j;
			if (C instanceof j) {
				C.each(function(K, J) {
					G.set(J, K)
				})
			} else {
				if (Array.isArray(C)) {
					var E = -1,
						I = C.length,
						H;
					if (F == null) {
						while (++E < I) {
							G.set(E, C[E])
						}
					} else {
						while (++E < I) {
							G.set(F(H = C[E], E, C), H)
						}
					}
				} else {
					if (C) {
						for (var D in C) {
							G.set(D, C[D])
						}
					}
				}
			}
			return G
		}
		var z = function() {
			var G = [],
				I = [],
				F, H, E;

			function D(P, N, L, Q) {
				if (N >= G.length) {
					return H != null ? H(P) : (F != null ? P.sort(F) : P)
				}
				var O = -1,
					J = P.length,
					T = G[N++],
					M, R, K = A(),
					S, U = L();
				while (++O < J) {
					if (S = K.get(M = T(R = P[O]) + "")) {
						S.push(R)
					} else {
						K.set(M, [R])
					}
				}
				K.each(function(V, W) {
					Q(U, W, D(V, N, L, Q))
				});
				return U
			}

			function C(K, L) {
				if (++L > G.length) {
					return K
				}
				var M, J = I[L - 1];
				if (H != null && L >= G.length) {
					M = K.entries()
				} else {
					M = [], K.each(function(O, N) {
						M.push({
							key: N,
							values: C(O, L)
						})
					})
				}
				return J != null ? M.sort(function(O, N) {
					return J(O.key, N.key)
				}) : M
			}
			return E = {
				object: function(J) {
					return D(J, 0, r, o)
				},
				map: function(J) {
					return D(J, 0, s, B)
				},
				entries: function(J) {
					return C(D(J, 0, s, B), 0)
				},
				key: function(J) {
					G.push(J);
					return E
				},
				sortKeys: function(J) {
					I[G.length - 1] = J;
					return E
				},
				sortValues: function(J) {
					F = J;
					return E
				},
				rollup: function(J) {
					H = J;
					return E
				}
			}
		};

		function r() {
			return {}
		}

		function o(C, D, E) {
			C[D] = E
		}

		function s() {
			return A()
		}

		function B(E, C, D) {
			E.set(C, D)
		}
		var l = {};
		var e = 12;
		var i = 5;
		var m = [1, 1];
		var p = [];
		var d = [];
		l.nodeWidth = function(C) {
			if (!arguments.length) {
				return e
			}
			e = +C;
			return l
		};
		l.nodePadding = function(C) {
			if (!arguments.length) {
				return i
			}
			i = +C;
			return l
		};
		l.nodes = function(C) {
			if (!arguments.length) {
				return p
			}
			p = C;
			return l
		};
		l.links = function(C) {
			if (!arguments.length) {
				return d
			}
			d = C;
			return l
		};
		l.size = function(C) {
			if (!arguments.length) {
				return m
			}
			m = C;
			return l
		};
		l.layout = function(C) {
			c();
			k();
			a();
			g(C);
			b();
			u();
			return l
		};
		l.relayout = function() {
			b();
			u();
			return l
		};
		l.link = function() {
			var D = 0.5;

			function C(L) {
				var I = L.source.x + L.source.dx,
					H = L.target.x,
					G = x(I, H),
					F = G(D),
					E = G(1 - D),
					K = L.source.y + L.sy + L.dy / 2,
					J = L.target.y + L.ty + L.dy / 2;
				return "M" + I + "," + K + "C" + F + "," + K + " " + E + "," + J + " " + H + "," + J
			}
			C.curvature = function(E) {
				if (!arguments.length) {
					return D
				}
				D = +E;
				return C
			};
			return C
		};

		function u() {
			var C = 0.5;
			d.forEach(function(K) {
				var H = K.source.x + K.source.dx,
					G = K.target.x,
					F = x(H, G),
					E = F(C),
					D = F(1 - C),
					J = K.source.y + K.sy + K.dy / 2,
					I = K.target.y + K.ty + K.dy / 2;
				K.bezier = [
					[H, E, D, G],
					[J, J, I, I]
				]
			})
		}

		function c() {
			p.forEach(function(C) {
				C.sourceLinks = [];
				C.targetLinks = []
			});
			d.forEach(function(C) {
				var D = C.source,
					E = C.target;
				if (typeof D === "number") {
					D = C.source = p[C.source]
				}
				if (typeof E === "number") {
					E = C.target = p[C.target]
				}
				D.sourceLinks.push(C);
				E.targetLinks.push(C)
			})
		}

		function k() {
			p.forEach(function(C) {
				C.value = Math.max(f(C.sourceLinks, q), f(C.targetLinks, q))
			})
		}

		function a() {
			var D = p,
				E, C = 0;
			while (D.length) {
				E = [];
				D.forEach(function(F) {
					F.x = C;
					F.breadth = C;
					F.dx = e;
					F.sourceLinks.forEach(function(G) {
						E.push(G.target)
					})
				});
				D = E;
				++C
			}
			w(C);
			n((m[0] - e) / (C - 1))
		}

		function w(C) {
			p.forEach(function(D) {
				if (!D.sourceLinks.length) {
					D.x = C - 1
				}
			})
		}

		function n(C) {
			p.forEach(function(D) {
				D.x *= C
			})
		}

		function g(H) {
			var C = z().key(function(K) {
				return K.x
			}).sortKeys(h).entries(p).map(function(K) {
				return K.values
			});
			F();
			J();
			for (var I = 1; H > 0; --H) {
				D(I *= 0.99);
				J();
				E(I);
				J()
			}

			function F() {
				var K = t(C, function(L) {
					return (m[1] - (L.length - 1) * i) / f(L, q)
				});
				C.forEach(function(L) {
					L.forEach(function(N, M) {
						N.y = M;
						N.dy = N.value * K
					})
				});
				d.forEach(function(L) {
					L.dy = L.value * K
				})
			}

			function E(L) {
				C.forEach(function(M, N) {
					M.forEach(function(O) {
						if (O.targetLinks.length) {
							var P = f(O.targetLinks, K) / f(O.targetLinks, q);
							O.y += (P - y(O)) * L
						}
					})
				});

				function K(M) {
					return y(M.source) * M.value
				}
			}

			function D(L) {
				C.slice().reverse().forEach(function(M) {
					M.forEach(function(N) {
						if (N.sourceLinks.length) {
							var O = f(N.sourceLinks, K) / f(N.sourceLinks, q);
							N.y += (O - y(N)) * L
						}
					})
				});

				function K(M) {
					return y(M.target) * M.value
				}
			}

			function J() {
				C.forEach(function(L) {
					var O, K, N = 0,
						P = L.length,
						M;
					L.sort(G);
					for (M = 0; M < P; ++M) {
						O = L[M];
						K = N - O.y;
						if (K > 0) {
							O.y += K
						}
						N = O.y + O.dy + i
					}
					K = N - i - m[1];
					if (K > 0) {
						N = O.y -= K;
						for (M = P - 2; M >= 0; --M) {
							O = L[M];
							K = O.y + O.dy + i - N;
							if (K > 0) {
								O.y -= K
							}
							N = O.y
						}
					}
				})
			}

			function G(L, K) {
				return L.y - K.y
			}
		}

		function b() {
			p.forEach(function(E) {
				E.sourceLinks.sort(C);
				E.targetLinks.sort(D)
			});
			p.forEach(function(F) {
				var G = 0,
					E = 0;
				F.sourceLinks.forEach(function(H) {
					H.sy = G;
					G += H.dy
				});
				F.targetLinks.forEach(function(H) {
					H.ty = E;
					E += H.dy
				})
			});

			function D(F, E) {
				return F.source.y - E.source.y
			}

			function C(F, E) {
				return F.target.y - E.target.y
			}
		}

		function y(C) {
			return C.y + C.dy / 2
		}

		function q(C) {
			return C.value
		}
		return l
	};
	this.setSankey = function() {
		var a = this.getD3Sankey();
		a.nodeWidth(this.sankeyNodeWidth);
		a.nodePadding(this.margin);
		a.size([this.x, this.y]);
		a.nodes(this.data.sankey.nodes);
		a.links(this.data.sankey.links);
		a.layout(this.sankeyIterations);
		this.data.sankey.object = a
	};
	this.getD3Tree = function() {
		var b = this;
		var l = function(y, x, w) {
			var z = w / (x.i - y.i);
			x.c -= z;
			x.s += w;
			y.c += z;
			x.z += w;
			x.m += w
		};
		var f = function(z) {
			var y = 0;
			var C = 0;
			var B = z.children;
			var A = B.length;
			var x;
			while (--A >= 0) {
				x = B[A];
				x.z += y;
				x.m += y;
				y += x.s + (C += x.c)
			}
		};
		var a = function(x, w, y) {
			return x.a.parent === w.parent ? x.a : y
		};
		var r = function(w) {
			var x = w.children;
			return x ? x[0] : w.t
		};
		var v = function(w) {
			var x = w.children;
			return x ? x[x.length - 1] : w.t
		};
		var e = function(x, w) {
			return x.parent === w.parent ? 1 : 2
		};
		var i = 1;
		var g = 1;
		var n = null;
		var h = function(z, x) {
			if (z === x) {
				return z
			}
			var y = z.ancestors();
			var w = x.ancestors();
			var A = null;
			z = y.pop();
			x = w.pop();
			while (z === x) {
				A = z;
				z = y.pop();
				x = w.pop()
			}
			return A
		};
		var d = function(w) {
			w.data = w.data.data
		};
		var j = function(x) {
			var w = 0;
			do {
				x.height = w
			} while ((x = x.parent) && (x.height < ++w))
		};
		var c = function(C, y) {
			var F = new u(C);
			var D = +C.value && (F.value = C.value);
			var A;
			var w = [F];
			var x;
			var E;
			var B;
			var z;
			if (y == null) {
				y = function(G) {
					return G.children
				}
			}
			while (A = w.pop()) {
				if (D) {
					A.value = +A.data.value
				}
				if ((E = y(A.data)) && (z = E.length)) {
					A.children = new Array(z);
					for (B = z - 1; B >= 0; --B) {
						w.push(x = A.children[B] = new u(E[B]));
						x.parent = A;
						x.depth = A.depth + 1
					}
				}
			}
			return F.eachBefore(j)
		};
		var u = function(w) {
			this.data = w;
			this.depth = 0;
			this.height = 0;
			this.parent = null;
			if (this.nid == null) {
				this.id = b.treeNodeId++
			}
		};
		u.prototype = c.prototype = {
			constructor: u,
			count: function() {
				return this.eachAfter(count)
			},
			each: function(C) {
				var z = this;
				var A;
				var y = [z];
				var x, w, B;
				do {
					A = y.reverse();
					y = [];
					while (z = A.pop()) {
						C(z);
						x = z.children;
						if (x) {
							for (w = 0, B = x.length; w < B; ++w) {
								y.push(x[w])
							}
						}
					}
				} while (y.length);
				return this
			},
			eachAfter: function(C) {
				var A = this;
				var w = [A];
				var z = [];
				var y, x, B;
				while (A = w.pop()) {
					z.push(A);
					y = A.children;
					if (y) {
						for (x = 0, B = y.length; x < B; ++x) {
							w.push(y[x])
						}
					}
				}
				while (A = z.pop()) {
					C(A)
				}
				return this
			},
			eachBefore: function(A) {
				var z = this;
				var w = [z];
				var y, x;
				while (z = w.pop()) {
					A(z);
					y = z.children;
					if (y) {
						for (x = y.length - 1; x >= 0; --x) {
							w.push(y[x])
						}
					}
				}
				return this
			},
			sum: function(w) {
				return this.eachAfter(function(A) {
					var z = +w(A.data) || 0;
					var y = A.children;
					var x = y && y.length;
					while (--x >= 0) {
						z += y[x].value
					}
					A.value = z
				})
			},
			sort: function(w) {
				return this.eachBefore(function(x) {
					if (x.children) {
						x.children.sort(w)
					}
				})
			},
			path: function(w) {
				var A = this;
				var z = h(A, w);
				var y = [A];
				while (A !== z) {
					A = A.parent;
					y.push(A)
				}
				var x = y.length;
				while (w !== z) {
					y.splice(x, 0, w);
					w = w.parent
				}
				return y
			},
			ancestors: function() {
				var x = this;
				var w = [x];
				while (x = x.parent) {
					w.push(x)
				}
				return w
			},
			descendants: function() {
				var w = [];
				this.each(function(x) {
					w.push(x)
				});
				return w
			},
			leaves: function() {
				var w = [];
				this.eachBefore(function(x) {
					if (!x.children) {
						w.push(x)
					}
				});
				return w
			},
			links: function() {
				var w = this;
				var x = [];
				w.each(function(y) {
					if (y !== w) {
						x.push({
							source: y.parent,
							target: y
						})
					}
				});
				return x
			},
			copy: function() {
				return c(this).eachBefore(d)
			}
		};
		var p = function(x, w) {
			this._ = x;
			this.parent = null;
			this.children = null;
			this.A = null;
			this.a = this;
			this.z = 0;
			this.m = 0;
			this.c = 0;
			this.s = 0;
			this.t = null;
			this.i = w
		};
		p.prototype = Object.create(u.prototype);
		var q = function(x) {
			var w = new p(x, 0);
			var B;
			var y = [w];
			var D;
			var A;
			var z;
			var C;
			while (B = y.pop()) {
				if (A = B._.children) {
					B.children = new Array(C = A.length);
					for (z = C - 1; z >= 0; --z) {
						y.push(D = B.children[z] = new p(A[z], z));
						D.parent = B
					}
				}
			}(w.parent = new p(null, 0)).children = [w];
			return w
		};

		function k(B) {
			var D = q(B);
			D.eachAfter(t), D.parent.m = -D.z;
			D.eachBefore(o);
			if (n) {
				B.eachBefore(s)
			} else {
				var x = B;
				var C = B;
				var w = B;
				B.eachBefore(function(F) {
					if (F.x < x.x) {
						x = F
					}
					if (F.x > C.x) {
						C = F
					}
					if (F.depth > w.depth) {
						w = F
					}
				});
				var E = x === C ? 1 : e(x, C) / 2;
				var y = E - x.x;
				var A = i / (C.x + E + y);
				var z = g / (w.depth || 1);
				B.eachBefore(function(F) {
					F.x = (F.x + y) * A;
					F.y = F.depth * z
				})
			}
			return B
		}

		function t(y) {
			var A = y.children;
			var B = y.parent.children;
			var x = y.i ? B[y.i - 1] : null;
			if (A) {
				f(y);
				var z = (A[0].z + A[A.length - 1].z) / 2;
				if (x) {
					y.z = x.z + e(y._, x._);
					y.m = y.z - z
				} else {
					y.z = z
				}
			} else {
				if (x) {
					y.z = x.z + e(y._, x._)
				}
			}
			y.parent.A = m(y, x, y.parent.A || B[0])
		}

		function o(w) {
			w._.x = w.z + w.parent.m;
			w.m += w.parent.m
		}

		function m(I, H, C) {
			if (H) {
				var z = I;
				var y = I;
				var B = H;
				var A = z.parent.children[0];
				var E = z.m;
				var D = y.m;
				var G = B.m;
				var F = A.m;
				var x;
				while (B = v(B), z = r(z), B && z) {
					A = r(A);
					y = v(y);
					y.a = I;
					x = B.z + G - z.z - E + e(B._, z._);
					if (x > 0) {
						l(a(B, I, C), I, x);
						E += x;
						D += x
					}
					G += B.m;
					E += z.m;
					F += A.m;
					D += y.m
				}
				if (B && !v(y)) {
					y.t = B;
					y.m += G - D
				}
				if (z && !r(A)) {
					A.t = z;
					A.m += E - F;
					C = I
				}
			}
			return C
		}

		function s(w) {
			w.x *= i;
			w.y = w.depth * g
		}
		k.separation = function(w) {
			return arguments.length ? (e = w, k) : e
		};
		k.size = function(w) {
			return arguments.length ? (n = false, i = +w[0], g = +w[1], k) : (n ? null : [i, g])
		};
		k.nodeSize = function(w) {
			return arguments.length ? (n = true, i = +w[0], g = +w[1], k) : (n ? [i, g] : null)
		};
		k.setTree = function(x, w) {
			return c(x, w)
		};
		k.collapse = function(w) {
			k.collapseTree(w);
			k.update(w)
		};
		k.expand = function(w) {
			k.expandTree(w);
			k.update(w)
		};
		k.collapseTree = function(w) {
			if (w.children) {
				w._children = w.children;
				w._children.forEach(k.collapseTree);
				w.children = null
			}
		};
		k.expandTree = function(w) {
			if (w._children) {
				w.children = w._children;
				w.children.forEach(k.expandTree);
				delete w._children
			}
		};
		return k
	};
	this.setTree = function() {
		var b = [];
		if (this.treeCircular) {
			b = this.x > this.y ? [360, this.y / 2] : [360, this.x / 2]
		} else {
			b = [this.graphOrientation == "vertical" ? this.x : this.y, this.graphOrientation == "vertical" ? this.y : this.x]
		}
		var a = function(d, c) {
			return (d.parent == c.parent ? 1 : 2) / d.depth
		};
		this.data.tree.object = this.treeCircular ? this.getD3Tree().size(b).separation(a) : this.getD3Tree().size(b);
		if (!this.data.tree.root) {
			this.data.tree.root = this.getD3Tree().setTree(this.data.tree.data, function(c) {
				return c.children
			})
		}
		this.data.tree.plot = this.data.tree.object(this.data.tree.root);
		this.data.tree.plot.size = b
	};
	this.getD3CirclePack = function() {
		var l = this;
		var r = function(K, I) {
			if (K === I) {
				return K
			}
			var J = K.ancestors();
			var H = I.ancestors();
			var L = null;
			K = J.pop();
			I = H.pop();
			while (K === I) {
				L = K;
				K = J.pop();
				I = H.pop()
			}
			return L
		};
		var o = function(H) {
			H.data = H.data.data
		};
		var w = function(I) {
			var H = 0;
			do {
				I.height = H
			} while ((I = I.parent) && (I.height < ++H))
		};
		var m = function(N, J) {
			var Q = new F(N);
			var O = +N.value && (Q.value = N.value);
			var L;
			var H = [Q];
			var I;
			var P;
			var M;
			var K;
			if (J == null) {
				J = function(R) {
					return R.children
				}
			}
			while (L = H.pop()) {
				if (O) {
					L.value = +L.data.value
				}
				if ((P = J(L.data)) && (K = P.length)) {
					L.children = new Array(K);
					for (M = K - 1; M >= 0; --M) {
						H.push(I = L.children[M] = new F(P[M]));
						I.parent = L;
						I.depth = L.depth + 1
					}
				}
			}
			return Q.eachBefore(w)
		};
		var F = function(H) {
			this.data = H;
			this.depth = 0;
			this.height = 0;
			this.parent = null;
			if (this.nid == null) {
				this.id = l.treeNodeId++
			}
		};
		F.prototype = m.prototype = {
			constructor: F,
			count: function() {
				return this.eachAfter(count)
			},
			each: function(N) {
				var K = this;
				var L;
				var J = [K];
				var I, H, M;
				do {
					L = J.reverse();
					J = [];
					while (K = L.pop()) {
						N(K);
						I = K.children;
						if (I) {
							for (H = 0, M = I.length; H < M; ++H) {
								J.push(I[H])
							}
						}
					}
				} while (J.length);
				return this
			},
			eachAfter: function(N) {
				var L = this;
				var H = [L];
				var K = [];
				var J, I, M;
				while (L = H.pop()) {
					K.push(L);
					J = L.children;
					if (J) {
						for (I = 0, M = J.length; I < M; ++I) {
							H.push(J[I])
						}
					}
				}
				while (L = K.pop()) {
					N(L)
				}
				return this
			},
			eachBefore: function(L) {
				var K = this;
				var H = [K];
				var J, I;
				while (K = H.pop()) {
					L(K);
					J = K.children;
					if (J) {
						for (I = J.length - 1; I >= 0; --I) {
							H.push(J[I])
						}
					}
				}
				return this
			},
			sum: function(H) {
				return this.eachAfter(function(L) {
					var K = +H(L.data) || 0;
					var J = L.children;
					var I = J && J.length;
					while (--I >= 0) {
						K += J[I].value
					}
					L.value = K
				})
			},
			sort: function(H) {
				return this.eachBefore(function(I) {
					if (I.children) {
						I.children.sort(H)
					}
				})
			},
			path: function(H) {
				var L = this;
				var K = r(L, H);
				var J = [L];
				while (L !== K) {
					L = L.parent;
					J.push(L)
				}
				var I = J.length;
				while (H !== K) {
					J.splice(I, 0, H);
					H = H.parent
				}
				return J
			},
			ancestors: function() {
				var I = this;
				var H = [I];
				while (I = I.parent) {
					H.push(I)
				}
				return H
			},
			descendants: function() {
				var H = [];
				this.each(function(I) {
					H.push(I)
				});
				return H
			},
			leaves: function() {
				var H = [];
				this.eachBefore(function(I) {
					if (!I.children) {
						H.push(I)
					}
				});
				return H
			},
			links: function() {
				var H = this;
				var I = [];
				H.each(function(J) {
					if (J !== H) {
						I.push({
							source: J.parent,
							target: J
						})
					}
				});
				return I
			},
			copy: function() {
				return m(this).eachBefore(o)
			}
		};
		var e = null;
		var s = 1;
		var q = 1;
		var h = function(H) {
			this._ = H;
			this.next = null
		};
		var g = function(M) {
			var I;
			var L = (M = M.slice()).length;
			var H = null;
			var K = H;
			while (L) {
				var J = new h(M[L - 1]);
				if (K) {
					K = K.next = J
				} else {
					K = H = J
				}
				M[I] = M[--L]
			}
			return {
				head: H,
				tail: K
			}
		};
		var t = function(H) {
			return G(g(H), [])
		};
		var d = function(J, H) {
			var K = H.x - J.x;
			var I = H.y - J.y;
			var L = J.r - H.r;
			return L * L + 0.000001 > K * K + I * I
		};
		var G = function(I, O) {
			var M;
			var K = null;
			var J = I.head;
			var H;
			var N;
			switch (O.length) {
				case 1:
					M = y(O[0]);
					break;
				case 2:
					M = x(O[0], O[1]);
					break;
				case 3:
					M = u(O[0], O[1], O[2]);
					break
			}
			while (J) {
				N = J._;
				H = J.next;
				if (!M || !d(M, N)) {
					if (K) {
						I.tail = K;
						K.next = null
					} else {
						I.head = I.tail = null
					}
					O.push(N);
					M = G(I, O);
					O.pop();
					if (I.head) {
						J.next = I.head;
						I.head = J
					} else {
						J.next = null;
						I.head = I.tail = J
					}
					K = I.tail;
					K.next = H
				} else {
					K = J
				}
				J = H
			}
			I.tail = K;
			return M
		};
		var y = function(H) {
			return {
				x: H.x,
				y: H.y,
				r: H.r
			}
		};
		var x = function(S, P) {
			var I = S.x;
			var R = S.y;
			var K = S.r;
			var H = P.x;
			var O = P.y;
			var J = P.r;
			var N = H - I;
			var Q = O - R;
			var L = J - K;
			var M = Math.sqrt(N * N + Q * Q);
			return {
				x: (I + H + N / M * L) / 2,
				y: (R + O + Q / M * L) / 2,
				r: (M + K + J) / 2
			}
		};
		var u = function(ag, ae, ad) {
			var ac = ag.x;
			var L = ag.y;
			var X = ag.r;
			var aa = ae.x;
			var K = ae.y;
			var V = ae.r;
			var Y = ad.x;
			var I = ad.y;
			var U = ad.r;
			var aj = 2 * (ac - aa);
			var N = 2 * (L - K);
			var T = 2 * (V - X);
			var ak = ac * ac + L * L - X * X - aa * aa - K * K + V * V;
			var ah = 2 * (ac - Y);
			var M = 2 * (L - I);
			var S = 2 * (U - X);
			var ai = ac * ac + L * L - X * X - Y * Y - I * I + U * U;
			var af = ah * N - aj * M;
			var Z = (N * ai - M * ak) / af - ac;
			var W = (M * T - N * S) / af;
			var J = (ah * ak - aj * ai) / af - L;
			var H = (aj * S - ah * T) / af;
			var R = W * W + H * H - 1;
			var Q = 2 * (Z * W + J * H + X);
			var P = Z * Z + J * J - X * X;
			var O = (-Q - Math.sqrt(Q * Q - 4 * R * P)) / (2 * R);
			return {
				x: Z + W * O + ac,
				y: J + H * O + L,
				r: O
			}
		};
		var n = function(M, K, I) {
			var H = M.x;
			var Q = M.y;
			var R = K.r + I.r;
			var P = M.r + I.r;
			var S = K.x - H;
			var O = K.y - Q;
			var N = S * S + O * O;
			if (N) {
				var L = 0.5 + ((P *= P) - (R *= R)) / (2 * N);
				var J = Math.sqrt(Math.max(0, 2 * R * (P + N) - (P -= N) * P - R * R)) / (2 * N);
				I.x = H + L * S + J * O;
				I.y = Q + L * O - J * S
			} else {
				I.x = H + P;
				I.y = Q
			}
		};
		var a = function(J, H) {
			var K = H.x - J.x;
			var I = H.y - J.y;
			var L = J.r + H.r;
			return L * L - 0.000001 > K * K + I * I
		};
		var A = function(M, I, O) {
			var K = M._;
			var H = M.next._;
			var N = K.r + H.r;
			var L = (K.x * H.r + H.x * K.r) / N - I;
			var J = (K.y * H.r + H.y * K.r) / N - O;
			return L * L + J * J
		};
		var i = function(H) {
			this._ = H;
			this.next = null;
			this.previous = null
		};
		var k = function(P) {
			if (!(N = P.length)) {
				return 0
			}
			var U, N, R, V, V, T;
			var X = P[0];
			X.x = 0;
			X.y = 0;
			if (!(N > 1)) {
				return X.r
			}
			var W = P[1];
			X.x = -W.r;
			W.x = X.r;
			W.y = 0;
			if (!(N > 2)) {
				return X.r + W.r
			}
			n(W, X, U = P[2]);
			var Y = X.r * X.r;
			var L = W.r * W.r;
			var M = U.r * U.r;
			var Q = Y + L + M;
			var K = Y * X.x + L * W.x + M * U.x;
			var J = Y * X.y + L * W.y + M * U.y;
			var I, H, S, R, O, V, T;
			X = new i(X);
			W = new i(W);
			U = new i(U);
			X.next = U.previous = W;
			W.next = X.previous = U;
			U.next = W.previous = X;
			B: for (var S = 3; S < N; ++S) {
				n(X._, W._, U = P[S]);
				U = new i(U);
				R = W.next;
				O = X.previous;
				V = W._.r;
				T = X._.r;
				do {
					if (V <= T) {
						if (a(R._, U._)) {
							W = R;
							X.next = W;
							W.previous = X;
							--S;
							continue B
						}
						V += R._.r;
						R = R.next
					} else {
						if (a(O._, U._)) {
							X = O;
							X.next = W;
							W.previous = X;
							--S;
							continue B
						}
						T += O._.r;
						O = O.previous
					}
				} while (R !== O.next);
				U.previous = X;
				U.next = W;
				X.next = W.previous = W = U;
				Q += M = U._.r * U._.r;
				K += M * U._.x;
				J += M * U._.y;
				Y = A(X, I = K / Q, H = J / Q);
				while ((U = U.next) !== W) {
					if ((M = A(U, I, H)) < Y) {
						X = U;
						Y = M
					}
				}
				W = X.next
			}
			X = [W._];
			U = W;
			while ((U = U.next) !== W) {
				X.push(U._)
			}
			U = t(X);
			for (var S = 0; S < N; ++S) {
				X = P[S];
				X.x -= U.x;
				X.y -= U.y
			}
			return U.r
		};
		var j = function(H) {
			k(H);
			return H
		};
		var E = function(H) {
			return H == null ? null : p(H)
		};
		var p = function(H) {
			if (typeof H !== "function") {
				throw new Error
			}
			return H
		};
		var z = function() {
			return 0
		};
		var f = function(H) {
			return function() {
				return H
			}
		};
		var D = function(H) {
			return Math.sqrt(H.value)
		};
		var E = function(H) {
			return H == null ? null : p(H)
		};
		var C = function(H) {
			return function(I) {
				if (!I.children) {
					I.r = Math.max(0, +H(I) || 0)
				}
			}
		};
		var c = function(I, H) {
			return function(M) {
				if (K = M.children) {
					var K, J, O = K.length,
						L = I(M) * H || 0,
						N;
					if (L) {
						for (J = 0; J < O; ++J) {
							K[J].r += L
						}
					}
					N = k(K);
					if (L) {
						for (J = 0; J < O; ++J) {
							K[J].r -= L
						}
					}
					M.r = N + L
				}
			}
		};
		var b = function(H) {
			return function(J) {
				var I = J.parent;
				J.r *= H;
				if (I) {
					J.x = I.x + H * J.x;
					J.y = I.y + H * J.y
				}
			}
		};
		var v = z;

		function B(H) {
			H.x = s / 2, H.y = q / 2;
			if (e) {
				H.eachBefore(C(e)).eachAfter(c(v, 0.5)).eachBefore(b(1))
			} else {
				H.eachBefore(C(D)).eachAfter(c(z, 1)).eachAfter(c(v, H.r / Math.min(s, q))).eachBefore(b(Math.min(s, q) / (2 * H.r)))
			}
			return H
		}
		B.radius = function(H) {
			return arguments.length ? (e = E(H), B) : e
		};
		B.size = function(H) {
			return arguments.length ? (s = +H[0], q = +H[1], B) : [s, q]
		};
		B.padding = function(H) {
			return arguments.length ? (v = typeof H === "function" ? H : f(+H), B) : v
		};
		B.setPack = function(H) {
			return m(H).sum(function(I) {
				return I.size
			}).sort(function(J, I) {
				return I.value - J.value
			})
		};
		return B
	};
	this.setCirclePack = function() {
		var b = Math.max(this.top, this.right);
		var a = this.width - (this.right + this.left + this.marginLeft + this.marginRight);
		var e = this.height - (this.top + this.bottom + this.marginTop + this.marginBottom);
		var c = a > e ? e : a;
		this.data.bubble.object = this.getD3CirclePack().size([c, c]).padding(2);
		if (!this.data.bubble.root) {
			this.data.bubble.root = this.getD3CirclePack().setPack(this.data.bubble.data)
		}
		this.data.bubble.plot = this.data.bubble.object(this.data.bubble.root);
		this.data.bubble.plot.diameter = c
	}
};
CanvasXpress.prototype.initLayout = function() {
	this.isValidLayout = function() {
		var a = this.layoutTopology ? this.layoutTopology.split(/X/i) : this.layout.split(/X/i);
		if (a.length == 2) {
			this.layoutRows = a[0];
			this.layoutCols = a[1]
		} else {
			this.layoutRows = 1;
			this.layoutCols = 1;
			this.layoutValid = false
		}
		if (!this.graphType.match(/Scatter/) && this.layoutComb && this.data.l && (this.data.l.vars || this.data.l.smps) && this.data.l.weight && this.data.l.type) {
			this.data.l.comp = [];
			if (this.data.l.vars && this.data.l.smps) {
				var f = 0;
				for (var d = 0; d < this.data.l.smps.length; d++) {
					for (var b = 0; b < this.data.l.vars.length; b++) {
						this.data.l.comp[f] = [this.getVariableIndices(this.data.l.vars[b]), this.getSampleIndices(this.data.l.smps[d])];
						f++
					}
				}
			} else {
				if (this.data.l.vars) {
					for (var d = 0; d < this.data.l.vars.length; d++) {
						this.data.l.comp[d] = this.getVariableIndices(this.data.l.vars[d])
					}
				} else {
					for (var d = 0; d < this.data.l.smps.length; d++) {
						this.data.l.comp[d] = this.getSampleIndices(this.data.l.smps[d])
					}
				}
			}
			this.layoutValid = true
		} else {
			if (this.layoutComb && this.data.l && this.data.l.smps && this.data.l.weight && this.data.l.type) {
				this.data.l.comp = [];
				var e = this.getVariableIndices(this.data.y.vars);
				for (var d = 0; d < this.data.l.type.length; d++) {
					this.data.l.comp[d] = e
				}
				this.layoutValid = true
			} else {
				if (this.data.l && this.data.l.comp) {
					if (this.data.l.comp.length <= (this.layoutRows * this.layoutCols)) {
						this.layoutValid = true
					} else {
						this.layoutValid = false
					}
				} else {
					this.layoutValid = false
				}
			}
		}
		if (this.layoutValid) {
			this.meta.config.orig.adjustAspectRatio = this.adjustAspectRatio;
			this.adjustAspectRatio = true
		}
	};
	this.addLayoutResizer = function(b) {
		var a = 0;
		if (this.resizerType && this.resizerPosition == b) {
			a += this.resizerWidth + (this.margin * 2);
			if (this.resizerType == "samples") {
				a += 14 + this.margin
			}
		}
		return a
	};
	this.getLayoutResizerDimensions = function() {
		if (this.resizerType) {
			var u, j, e, d;
			var f = this.data.l.comp.length - 1;
			var k = this.resizerWidth;
			var z = this.resizerWidth;
			var B = this.marginTop + this.layoutTop;
			var c = this.marginRight + this.layoutRight;
			var q = this.marginBottom + this.layoutBottom;
			var g = this.marginLeft + this.layoutLeft;
			var A = this.getAxesVals(0);
			var s = 0;
			var m = 0;
			switch (this.resizerPosition) {
				case "right":
					u = "xAxis";
					j = "y";
					e = "v";
					d = "r";
					B += this.layoutParams[0].top;
					g = this.resizerType == "samples" ? this.width - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
					k = this.height - (B + q + this.layoutParams[f].bottom);
					break;
				case "left":
					u = "xAxis";
					j = "y";
					e = "v";
					d = "l";
					B += this.layoutParams[0].top;
					g = this.resizerType == "samples" && this.graphOrientation == "horizontal" ? (this.margin * 2) : this.margin;
					k = this.height - (B + q + this.layoutParams[f].bottom);
					break;
				case "top":
					u = "xAxis";
					j = "x";
					e = "h";
					d = "t";
					B = this.resizerType == "samples" ? (this.margin * 2) + 14 : this.margin;
					g += this.layoutParams[0].left;
					z = this.width - (g + c + this.layoutParams[f].right);
					m += this.resizerWidth;
					break;
				case "bottom":
					u = "xAxis";
					j = "x";
					e = "h";
					d = "b";
					B = this.resizerType == "samples" && this.graphOrientation == "vertical" ? this.height - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
					g += this.layoutParams[0].left;
					z = this.width - (g + c + this.layoutParams[f].right);
					m += this.resizerWidth;
					break
			}
			if (e == "v") {
				return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g + 14, B, z, k])
			} else {
				return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g, B, z, k])
			}
		}
	};
	this.drawLayoutResizer = function() {
		if (this.resizerType) {
			var a = this.getLayoutResizerDimensions();
			this.showAxesResizer(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], "", 0, 0, 0);
			this.drawAxesResizerBackgroundData(a[9], a[10], a[11], a[12]);
			this.drawAxesResizerMasks()
		}
	};
	this.setLayoutFonts = function() {
		this.setLegends();
		if (this.graphType == "Scatter2D") {
			this.set2DFont()
		} else {
			if (this.graphType == "Pie") {
				this.setPieFont()
			} else {
				this.set1DFont()
			}
		}
	};
	this.getLayoutAxisTitleHeight = function(a) {
		var b = 0;
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Pie" || this.graphType == "Heatmap") {
			return 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (a) {
					return this.yAxisTitle ? this.axisTitleFontSize + (this.margin * 2) : 0
				} else {
					return this.xAxisTitle ? this.axisTitleFontSize + (this.margin * 2) : 0
				}
			} else {
				if (this.graphOrientation == "vertical") {
					b = a ? this.getAxisDescription(true) : this.getAxisDescription();
					b = b != "" ? this.axisTitleFontSize + (this.margin * 2) : 0
				} else {
					b = a ? this.getAxisDescription(true) : this.getAxisDescription();
					b = b != "" ? this.axisTitleFontSize + (this.margin * 2) : 0
				}
			}
		}
		return b
	};
	this.setLayoutLeft = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a = this.get2DYAxisWidth()
				}
				a += this.getLayoutAxisTitleHeight()
			} else {
				if (this.graphType == "Pie") {
					a = (this.margin * 2) + this.measureText("XX", this.smpLabelFont)
				} else {
					if (this.graphType == "Candlestick") {
						if (this.graphOrientation != "vertical") {
							this.setTimeAxis();
							a = this.getSampleLabelLength()
						} else {
							a = 0
						}
					} else {
						if (this.graphType == "Heatmap") {
							a = 0
						} else {
							if (!this.layoutAdjust) {
								if (this.segregateVariablesBy.length > 0) {
									if (this.graphOrientation != "vertical") {
										a = this.getSampleLabelLength()
									} else {
										a = this.getAxisTitleTickLength()
									}
								} else {
									if (this.segregateSamplesBy.length > 0) {
										if (this.graphOrientation == "vertical") {
											a = this.getAxisTitleTickLength()
										}
									}
								}
							} else {
								if (this.graphOrientation != "vertical" && this.segregateVariablesBy.length > 0) {
									a = this.getSampleLabelLength()
								}
							}
							if (this.graphOrientation == "vertical") {
								a += this.getLayoutAxisTitleHeight()
							} else {
								a += this.smpTitle ? this.smpTitleFontSize + (this.margin * 2) : 0
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("left")
	};
	this.setLayoutRight = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.showLegend) {
					a = this.legendWidth;
					if (!this.layoutAdjust) {
						a += this.get2DYAxisWidth(true)
					}
				}
			} else {
				if (this.graphType == "Pie") {
					if (this.showLegend && this.legendPosition == "right") {
						a = this.legendVariableWidth
					}
				} else {
					if (this.graphType == "Heatmap") {
						return 0
					} else {
						if (!this.layoutAdjust) {
							if (this.graphOrientation == "vertical") {
								a = this.getAxisTitleTickLength(true)
							}
						} else {
							a = 0
						}
						if (this.graphOrientation == "vertical") {
							a += this.getLayoutAxisTitleHeight(true)
						}
						if (this.showLegend && this.legendPosition == "right") {
							a += this.getLegendWidth();
							if (this.graphOrientation != "vertical") {
								a += this.margin
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("right")
	};
	this.setLayoutTop = function() {
		if (this.isDOE) {
			return 0
		}
		var a = this.getTitleSubtitleHeight();
		if (this.graphType == "Pie") {
			a += this.getFontHeight() + (this.margin * 2)
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a += this.get2DXAxisHeight(true)
				}
			} else {
				if (this.graphType != "Heatmap") {
					if (!this.layoutAdjust) {
						if (this.graphOrientation != "vertical") {
							a += this.getAxisTitleTickLength()
						}
					}
					if (this.graphOrientation != "vertical") {
						a += this.getLayoutAxisTitleHeight()
					}
				}
			}
		}
		return a + this.addLayoutResizer("top")
	};
	this.setLayoutBottom = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a = this.get2DXAxisHeight()
				}
				if (this.showLegend && this.legendPosition == "bottom") {
					a += this.legendHeight
				}
				a += this.getLayoutAxisTitleHeight()
			} else {
				if (this.graphType == "Pie") {
					if (this.showLegend && this.legendPosition == "bottom") {
						var c = this.getPieLegendDimensions();
						a = c[1]
					}
				} else {
					if (this.graphType == "Candlestick" && this.graphOrientation == "vertical") {
						this.setTimeAxis();
						a = this.getSampleLabelLength()
					} else {
						if (this.graphType == "Heatmap") {
							a = this.getHeatmapIndicatorHeight()
						} else {
							if (!this.layoutAdjust) {
								if (this.graphOrientation != "vertical") {
									a = this.getAxisTitleTickLength(true)
								}
							}
							if (this.graphOrientation == "vertical") {
								if (this.segregateVariablesBy.length > 0) {
									a = this.getSampleLabelLength()
								}
								a += this.smpTitle ? this.smpTitleFontSize + (this.margin * 2) : 0
							} else {
								a += this.getLayoutAxisTitleHeight(true)
							}
							if (this.showLegend && this.legendPosition == "bottom") {
								a += this.getLegendHeight()
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("bottom")
	};
	this.drawLayoutSampleOverlays = function(b) {
		var a = this.smpIndices;
		this.smpIndices = b;
		this.smpIndices = a;
		this.showSampleNames = true;
		this.showOverlays = true;
		this.draw1DYLayout()
	};
	this.setLayoutDimensions = function() {
		var c = this.isGroupedData;
		this.offsetX = 0;
		this.offsetY = 0;
		this.isGroupedData = false;
		this.setLayoutFonts();
		this.setLayoutLegendDimensions();
		this.isGroupedData = c;
		this.layoutLeft = this.setLayoutLeft();
		this.layoutRight = this.setLayoutRight();
		this.layoutTop = this.setLayoutTop();
		this.layoutBottom = this.setLayoutBottom();
		if (this.layoutCanvasCompartments) {
			var a = this.width - (this.marginLeft + this.layoutLeft + this.marginRight + this.layoutRight);
			var b = this.height - (this.marginTop + this.layoutTop + this.marginBottom + this.layoutBottom);
			this.addToRender(["drawShape", "rectangle", this.marginLeft + this.layoutLeft + (a / 2), this.marginTop + this.layoutTop + (b / 2), a, b, false, this.canvasBoxColor, "open"])
		}
	};
	this.setLayoutLegendDimensions = function() {
		if (this.graphType == "Pie" || this.isDOE) {
			this.setVariableLegendDimension()
		} else {
			if (this.graphType == "Scatter2D" || this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap/))) {
				this.validatePropertyValues(true)
			} else {
				this.setVariableLegendDimension()
			}
		}
	};
	this.drawLabelsTitlesLayout = function() {
		this.functionCaller = "drawLabelsTitlesLayout";
		var g = 0;
		var f = 0;
		var p = 0;
		var A = 0;
		var B = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
		var b = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
		if (this.resizerType) {
			if (this.resizerPosition == "top") {
				f = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
				A = f
			} else {
				if (this.resizerPosition == "left") {
					g = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
					p = g
				}
			}
		}
		if (this.graphType == "Treemap") {
			return
		}
		if (this.graphType == "Pie" && (this.showPieGrid || this.showPieSampleLabel)) {
			var v, m;
			var z = 0;
			this.setFont();
			var q = this.getFontPt(this.font);
			var d = this.marginTop + this.layoutTop;
			var a = this.marginLeft + this.layoutLeft;
			var n = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
			for (var u = 0; u < this.layoutRows; u++) {
				v = b * this.layoutParams[z].weight[1];
				g = (this.marginLeft + this.layoutLeft) - this.margin;
				d += v;
				if (this.showPieGrid) {
					this.addToRender(["drawText", n[u], g, (d + (q / 2)) - (v / 2), this.font, this.foreground, "right", "middle"])
				}
				for (var t = 0; t < this.layoutCols; t++) {
					if (this.xAxis.length <= z) {
						break
					}
					m = B * this.layoutParams[z].weight[0];
					a += m;
					f = (this.marginTop + this.layoutTop) - this.margin;
					if (u == 0) {
						if (this.showPieGrid) {
							this.addToRender(["drawText", t + 1, (a + (q / 2)) - (m / 2), f, this.font, this.foreground, "center", "bottom"])
						}
					}
					if (this.showPieSampleLabel) {
						this.addToRender(["drawText", this.xAxis[z], a - (m / 1.1), d - (v / 5), this.legendFont, this.foreground, "center", "middle"])
					}
					z++
				}
				a = this.marginLeft + this.layoutLeft
			}
		} else {
			if (this.graphType == "Scatter2D") {
				if (this.xAxisTitle) {
					this.addToRender(["drawText", this.xAxisTitle, this.marginLeft + this.margin + (this.axisTitleFontSize / 2), this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", -Math.PI / 2])
				}
				if (this.yAxisTitle) {
					var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
					var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
					var v = this.marginBottom + this.margin + (this.axisTitleFontSize / 2) + s;
					this.addToRender(["drawText", this.yAxisTitle, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle"])
				}
			} else {
				if (this.graphType == "Heatmap") {
					this.draw1DXLayout()
				}
				if (this.smpTitle && this.graphType != "Heatmap") {
					if (this.graphOrientation == "vertical") {
						var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.marginBottom + this.margin + (this.smpTitleFontSize / 2) + s;
						this.addToRender(["drawText", this.smpTitle, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.smpTitleFont, this.smpTitleFontColor, "center", "middle"])
					} else {
						this.addToRender(["drawText", this.smpTitle, this.marginLeft + this.margin + (this.smpTitleFontSize / 2), this.height / 2, this.smpTitleFont, this.smpTitleFontColor, "center", "middle", -Math.PI / 2])
					}
				}
				var k = this.getAxisDescription();
				var e = this.getAxisDescription(true);
				if (k != "" && this.graphType != "Heatmap" && this.xAxisShow) {
					if (this.graphOrientation == "vertical") {
						this.addToRender(["drawText", k, this.marginLeft + this.margin + (this.axisTitleFontSize / 2), this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", -Math.PI / 2])
					} else {
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.margin + (this.axisTitleFontSize / 2) + this.getTitleSubtitleHeight();
						this.addToRender(["drawText", k, this.marginLeft + this.layoutLeft + (m / 2), this.marginTop + v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle"])
					}
				}
				if (e != "" && this.graphType != "Heatmap" && this.xAxis2Show) {
					if (this.graphOrientation == "vertical") {
						var s = this.legendPosition == "right" ? this.getLegendWidth() : 0;
						var o = this.marginRight + this.margin + (this.axisTitleFontSize / 2) + s;
						this.addToRender(["drawText", e, this.width - o, this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", Math.PI / 2])
					} else {
						var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.marginBottom + this.margin + (this.axisTitleFontSize / 2) + s;
						this.addToRender(["drawText", e, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle"])
					}
				}
			}
		}
	};
	this.drawDOELabelsLayout = function(m) {
		this.functionCaller = "drawDOELabelsLayout";
		var g = this.foreground;
		var j = this.font;
		var e = this.measureText(m, j);
		var b = this.getFontPt(j) / 2;
		var l = this.layoutWidth;
		var d = this.layoutHeight;
		var k = this.marginLeft + this.offsetX;
		var i = this.marginTop + this.offsetY;
		var a = k + l - 5;
		var c = i + d - 5;
		this.addToRender(["drawText", m, k + 20, i, j, g, "left", "top"]);
		this.addToRender(["drawLine", "line", k + b, i + b, k + 15, i + b, g]);
		this.addToRender(["drawLine", "line", k + e + 25, i + b, a, i + b, g]);
		this.addToRender(["drawLine", "line", a, i + b, a, c, g]);
		this.addToRender(["drawLine", "line", k + b, c, a, c, g]);
		this.addToRender(["drawLine", "line", k + b, i + b, k + b, c, g])
	};
	this.setLayoutWeights = function() {
		var a = this.data.l.weight;
		var d = this.layoutParams;
		var e = this.data.l.comp;
		if (a) {
			if (this.isDOE || this.scatterPlotMatrix || (this.data.l.vars && this.data.l.smps) || this.segregateSamplesBy.length > 1 || this.segregateVariablesBy.length > 1) {
				for (var b = 0; b < a.length; b++) {
					d[b].weight = a[b]
				}
			} else {
				if (this.graphType == "Pie") {
					for (var b = 0; b < e.length; b++) {
						d[b].weight = a[b]
					}
				} else {
					for (var b = 0; b < a.length; b++) {
						d[b].weight = a[b]
					}
				}
			}
		} else {
			if (e) {
				a = [];
				for (var b = 0; b < e.length; b++) {
					a[b] = e.length;
					d[b].weight = a[b]
				}
			} else {
				alert("Wuz going on dude? This aint't gonna work!")
			}
		}
	};
	this.setLayoutGraphTypes = function() {
		var b = this.data.l.type;
		if (b) {
			for (var a = 0; a < b.length; a++) {
				this.layoutParams[a].graphType = b && b[a] ? b[a] : this.graphType
			}
		}
	};
	this.setLayoutIndices = function(f) {
		if (!this.layoutIndices) {
			for (var d = 0; d < this.data.l.comp.length; d++) {
				var a;
				var b = this.getObjectArray(this.varIndices);
				var e = this.getObjectArray(this.smpIndices);
				if (this.data.l.vars && this.data.l.smps) {
					a = [];
					for (var c = 0; c < this.data.l.comp[d][0].length; c++) {
						if (b.hasOwnProperty(this.data.l.comp[d][0][c])) {
							a.push(this.data.l.comp[d][0][c])
						}
					}
					this.layoutParams[d].varIndices = a;
					a = [];
					for (var c = 0; c < this.data.l.comp[d][1].length; c++) {
						if (e.hasOwnProperty(this.data.l.comp[d][1][c])) {
							a.push(this.data.l.comp[d][1][c])
						}
					}
					this.layoutParams[d].smpIndices = a;
					this.setOriginalIndices(d, this.layoutParams[d].varIndices, this.layoutParams[d].smpIndices)
				} else {
					if (this.data.l.comp[d]) {
						a = [];
						if (this.data.l.vars) {
							for (var c = 0; c < this.data.l.comp[d].length; c++) {
								if (b.hasOwnProperty(this.data.l.comp[d][c])) {
									a.push(this.data.l.comp[d][c])
								}
							}
							this.layoutParams[d].varIndices = a;
							this.layoutParams[d].smpIndices = this.smpIndices;
							this.setOriginalIndices(d, this.layoutParams[d].varIndices, this.smpIndices)
						} else {
							for (var c = 0; c < this.data.l.comp[d].length; c++) {
								if (e.hasOwnProperty(this.data.l.comp[d][c])) {
									a.push(this.data.l.comp[d][c])
								}
							}
							this.layoutParams[d].varIndices = this.varIndices;
							this.layoutParams[d].smpIndices = a;
							this.setOriginalIndices(d, this.varIndices, this.layoutParams[d].smpIndices)
						}
					} else {
						if (this.data.l.vars) {
							this.layoutParams[d].varIndices = [];
							this.layoutParams[d].smpIndices = this.smpIndices
						} else {
							this.layoutParams[d].varIndices = this.varIndices;
							this.layoutParams[d].smpIndices = []
						}
					}
				}
				this.layoutParams[d].varIndicesStart = -1;
				this.layoutParams[d].smpIndicesStart = -1
			}
			for (var d = 0; d < this.data.l.type.length; d++) {
				for (var c = 0; c < f.length; c++) {
					if (!this.layoutParams[d].hasOwnProperty(f[c])) {
						this.layoutParams[d][f[c]] = this[f[c]]
					}
				}
			}
			this.layoutIndices = true
		}
	};
	this.resetLayout = function() {
		delete(this.data.l);
		delete(this.layoutParams);
		this.offsetX = 0;
		this.offsetY = 0;
		this.layoutValidN = false;
		this.layoutValidR = false;
		this.layoutValidC = false;
		this.layoutCurrent = false;
		this.layoutComb = false;
		this.layoutIndices = false;
		this.layoutRestore = false;
		this.layout = "1X1"
	};
	this.setDOE = function() {
		this.oneDPlot(true);
		this.Scatter2D(true);
		this.Scatter3D(true);
		this.Pie(true)
	};
	this.setLayoutRestore = function() {
		if (!this.layoutRestore) {
			this.layoutRestore = {};
			var c = ["title", "subtitle", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart", "smpTitle", "showVariableNames", "showSampleNames", "showOverlays", "showLegend", "legendInside", "showDecorationsLegend", "xAxisShow", "xAxis2Show", "xAxisS2Show", "yAxisShow", "yAxisS2Show", "xAxisTitle", "xAxis2Title", "yAxisTitle", "legendLayout"];
			c.push("legendDecorationWidth");
			c.push("legendDecorationHeight");
			var a = ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			for (var b = 0; b < a.length; b++) {
				c.push("legend" + a[b] + "s")
			}
			for (var b = 0; b < c.length; b++) {
				this.layoutRestore[c[b]] = this[c[b]]
			}
			if (this.isGroupedData && this.data.w) {
				this.layoutRestore.isGroupedData = this.isGroupedData
			}
		}
	};
	this.setLayoutParams = function() {
		if (!this.layoutParams && this.data.l.comp) {
			this.layoutParams = [];
			for (var a = 0; a < this.data.l.type.length; a++) {
				this.layoutParams[a] = {}
			}
		}
	};
	this.removeEmptyCompartments = function() {
		if (this.layoutRemoveEmpty && this.layoutParams && !this.isDOE) {
			var f = {};
			var d = [];
			var g = ["comp", "desc", "name", "type", "vars", "smps", "weight"];
			var h = 0;
			for (var c = 0; c < g.length; c++) {
				if (this.data.l[g[c]]) {
					f[g[c]] = []
				}
			}
			for (var c = 0; c < this.data.l.weight.length; c++) {
				var b = this.layoutParams[c].varIndices.length;
				var e = this.layoutParams[c].smpIndices.length;
				if (b && e) {
					d.push(this.layoutParams[c]);
					for (var a = 0; a < g.length; a++) {
						if (this.data.l[g[a]]) {
							f[g[a]].push(this.data.l[g[a]][c])
						}
					}
					if (this.data.l.group) {
						f.group = this.data.l.group
					}
					h++
				}
			}
			if (h != this.data.l.weight.length) {
				this.stndByLayoutData = {};
				this.stndByLayoutData.data = this.cloneObject(this.data.l);
				this.stndByLayoutData.pars = this.cloneObject(this.layoutParams);
				this.stndByLayoutData.layoutRows = this.layoutRows;
				this.stndByLayoutData.layoutCols = this.layoutCols;
				this.stndByLayoutData.layout = this.layout;
				this.data.l = f;
				this.layoutParams = d;
				this.layoutRows = Math.ceil(Math.sqrt(h));
				this.layoutCols = this.layoutRows * (this.layoutRows - 1) >= h ? this.layoutRows - 1 : this.layoutRows;
				this.layout = this.layoutRows + "X" + this.layoutCols;
				for (var c = 0; c < this.data.l.weight.length; c++) {
					this.data.l.weight[c] = [1 / this.layoutCols, 1 / this.layoutRows]
				}
			}
		}
	};
	this.restoreEmptyCompartments = function() {
		if (this.stndByLayoutData) {
			this.data.l = this.stndByLayoutData.data;
			this.layoutParams = this.stndByLayoutData.pars;
			this.layoutRows = this.stndByLayoutData.layoutRows;
			this.layoutCols = this.stndByLayoutData.layoutCols;
			this.layout = this.stndByLayoutData.layout;
			delete(this.stndByLayoutData)
		}
	};
	this.drawLayoutCompartments = function(l) {
		this.functionCaller = "drawLayoutCompartments";
		var n = ["left", "right", "top", "bottom", "x", "y", "offsetX", "offsetY", "graphType", "summaryType", "transformType", "smpInfo", "varInfo", "minData", "maxData", "xAxisMin", "xAxisMax", "xAxisRange", "xAxis2Min", "xAxis2Max", "xAxis2Range", "yAxisMin", "yAxisMax", "yAxisRange", "zAxisMin", "zAxisMax", "zAxisRange", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit"];
		var f = ["weight", "graphType", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
		if (this.layoutComb) {
			if (this.isDOE) {
				n.push("data");
				this.setDOE()
			}
			this.removeEmptyCompartments();
			if (this.graphType.match(/Scatter/)) {
				this.xAxis = this.data.y.smps;
				this.yAxis = this.data.y.smps;
				this.initAxes()
			} else {
				if (this.data.l && this.data.l.group) {
					this.groupSamples(this.data.l.group, false, false, true, true);
					this.meta.data.g = this.data.w;
					this.initAxes()
				} else {
					this.initAxes(true)
				}
			}
			this.setLayoutDimensions();
			var u = this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight;
			var r = this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom;
			this.setLayoutRestore();
			this.setLayoutParams();
			this.title = "";
			this.subtitle = "";
			this.offsetX = this.layoutLeft;
			this.offsetY = this.layoutTop;
			this.setLayoutWeights();
			this.setLayoutGraphTypes();
			this.setLayoutIndices(f);
			var s = 0;
			for (var q = 0; q < this.layoutRows; q++) {
				for (var o = 0; o < this.layoutCols; o++) {
					this.layoutCurrent = s;
					if (this.isDOE) {
						if (this.dataStndBy.l.smps.length <= s) {
							break
						}
					} else {
						if (this.graphType == "Pie") {
							if (this.data.l.smps.length <= s) {
								break
							}
						} else {
							if (this.layoutParams.length <= s) {
								break
							}
						}
					}
					if (this.layoutParams[s]) {
						for (var m = 0; m < f.length; m++) {
							this[f[m]] = this.layoutParams[s].hasOwnProperty(f[m]) ? this.layoutParams[s][f[m]] : this[f[m]]
						}
					}
					this.setLayoutGraphDimensions(u, r, s);
					if (this.isDOE) {
						this.drawLayoutCompartmentsDOE(u, r, s)
					} else {
						if (this.graphType.match(/Scatter/)) {
							this.drawLayoutCompartmentsScatter(u, r, q, o, s)
						} else {
							if (this.graphType == "Pie") {
								this.drawLayoutCompartmentsPie(u, r, s)
							} else {
								this.drawLayoutCompartmentsOneD(u, r, s)
							}
						}
					}
					if (!this.isDOE && this.varIndices.length > 0 && this.smpIndices.length > 0) {
						l.call(this)
					}
					for (var m = 0; m < n.length; m++) {
						this.layoutParams[s][n[m]] = this.cloneObject(this[n[m]])
					}
					if (this.data.w) {
						this.layoutParams[s].w = this.cloneObject(this.data.w)
					}
					if (this.layoutCanvasCompartments) {
						this.drawLayoutCanvasCompartments()
					}
					if (this.isDOE || this.graphType == "Pie") {} else {
						if (this.graphType.match(/Scatter/)) {
							var g, d;
							this.functionCaller = "drawLayoutCompartmentsBox";
							if (q == o && this.scatterPlotMatrixType.match(/complete/)) {
								var g = this.scaleTextToFont(this.meta.data.y.maxSmpStr, this.maxTextSize, (this.width - u) * 0.7 / this.layoutCols);
								this.addToRender(["drawShape", "rectangle", this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), this.x, this.y, false, this.foreground, "open"]);
								this.addToRender(["drawText", this.data.y.smps[q], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), g, this.foreground, "center", "middle"])
							} else {
								if (!this.scatterPlotMatrixType.match(/complete/) && this.data.y.smps[s + 1]) {
									g = this.scaleTextToFont(this.meta.data.y.maxSmpStr + " & " + this.meta.data.y.maxSmpStr, this.maxTextSize, (this.width - u) * 0.8 / this.layoutCols);
									d = this.axisTitleFontSize + this.margin + this.margin;
									if (this.layoutBoxLabelColors[0]) {
										this.addToRender(["drawShape", "rectangle", this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top - (d / 2), this.x, d, this.layoutBoxLabelColors[0], this.foreground])
									} else {
										this.addToRender(["drawShape", "rectangle", this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top - (d / 2), this.x, d, false, this.foreground, "open"])
									}
									this.addToRender(["drawText", this.data.y.smps[0] + " & " + this.data.y.smps[s + 1], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top - (d / 2), g, this.foreground, "center", "middle"])
								}
							}
							this.functionCaller = "drawLayoutCompartments"
						} else {
							if (!this.layoutAdjust) {
								var t = this.graphOrientation == "vertical" ? o : q;
								var b = this.graphOrientation == "vertical" ? this.layoutCols - 1 : this.layoutRows - 1;
								if (t == 0 && this.layoutRestore.xAxisShow && this.graphType != "Heatmap") {
									this.layoutAxis = 1;
									this.xAxisShow = true;
									this.draw1DXLayout()
								}
								if (t == b && this.layoutRestore.xAxis2Show && this.graphType != "Heatmap") {
									this.layoutAxis = 2;
									this.xAxis2Show = true;
									this.draw1DXLayout()
								}
							}
							if (this.segregateVariablesBy.length) {
								var a = false;
								if (this.graphOrientation == "vertical") {
									if (q == this.layoutRows - 1) {
										a = true
									} else {
										if (q == this.layoutRows - 2 && (s + 1 + parseInt(this.layoutCols)) > this.data.l.weight.length) {
											a = true
										}
									}
								} else {
									if (o == 0) {
										a = true
									}
								}
								if (a) {
									this.showSampleNames = this.layoutRestore.showSampleNames;
									this.draw1DYLayout()
								}
							}
							if (this.graphType != "Candlestick") {
								this.draw1DLabels(s)
							}
						}
					}
					this.offsetX += this.layoutWidth;
					s++
				}
				this.offsetX = this.layoutLeft;
				this.offsetY += this.layoutHeight
			}
			this.layoutCurrent = false;
			for (var e in this.layoutRestore) {
				this[e] = this.layoutRestore[e]
			}
			if (this.isDOE) {
				this.data = this.dataStndBy;
				this.graphType = this.data.l.type[0]
			} else {
				this.drawTitle();
				this.drawLabelsTitlesLayout();
				this.drawLayoutResizer();
				if (this.showLegend) {
					if (this.isDOE || this.graphType != "Pie") {
						this.drawLegend()
					}
				}
			}
			if (this.meta.data.g) {
				this.data.w = this.meta.data.g;
				delete(this.meta.data.g)
			} else {
				this.isGroupedData = false
			}
		}
	};
	this.setLayoutGraphDimensions = function(a, b, d) {
		this.layoutWidth = (this.width - a) * this.layoutParams[d].weight[0];
		this.layoutHeight = (this.height - b) * this.layoutParams[d].weight[1];
		this.layoutParams[d].width = this.layoutWidth;
		this.layoutParams[d].height = this.layoutHeight
	};
	this.drawLayoutCompartmentsDOE = function(a, b, d) {
		this.legendPosition = "right";
		this.graphOrientation = "vertical";
		if (d == 0 && this.showDOEData) {
			this.isShowDOEData = true;
			this.showLegend = this.layoutRestore.showLegend;
			if (this.graphType.match(/Scatter/i)) {
				this.isHistogram = false;
				this.xAxis = this.configStndBy.xAxis;
				this.yAxis = this.configStndBy.yAxis;
				this.xAxisTitle = this.configStndBy.xAxisTitle;
				this.yAxisTitle = this.configStndBy.yAxisTitle;
				this.initAxes();
				this.initializeData(this.dataStndBy);
				this.varIndices = this.dataStndBy.l.doe
			} else {
				this.initializeData(this.dataStndBy);
				this.smpIndices = this.dataStndBy.l.doe
			}
			this.showLegend = false;
			if (this.graphType == "Scatter3D") {
				this.draw3DPlot()
			} else {
				if (this.graphType.match(/Scatter/i)) {
					this.draw2DPlot()
				} else {
					this.plotByVariable = this.configStndBy.plotByVariable;
					if (this.configStndBy.groupingFactors.length > 0) {
						this.isGroupedData = true;
						if (this.dataStndBy.y.smps.length != this.smpIndices.length) {
							this.layoutComb = false;
							this.groupSamples(this.configStndBy.groupingFactors, false, false, true, true);
							this.layoutComb = true
						}
						this.draw1DPlot();
						this.isGroupedData = false
					} else {
						this.draw1DPlot()
					}
					this.plotByVariable = false
				}
			}
			this.showLegend = true;
			this.isShowDOEData = false
		} else {
			this.drawDOELabelsLayout(this.dataStndBy.l.smps[d][0]);
			this.top = 5;
			this.bottom = 5;
			this.right = 5;
			this.left = 5;
			if (this.dataStndBy.l.type[d] == "Pie") {
				this.showLegend = true;
				this.createPie(this.dataStndBy.l.smps[d][0]);
				this.layoutCurrentDOE = this.dataStndBy.l.smps[d][0];
				this.legendBox = false;
				this.drawPiePlot()
			} else {
				if (this.dataStndBy.l.type[d] == "Treemap") {
					this.createTreemap(this.dataStndBy.l.smps[d][0]);
					this.draw1DPlot()
				} else {
					if (this.dataStndBy.l.type[d] == "Scatter2D") {
						this.createHistogram(false, false, this.dataStndBy.l.smps[d][0]);
						this.initAxes();
						this.showLegend = false;
						this.xAxisTitle = "";
						this.yAxisTitle = "";
						this.draw2DPlot()
					}
				}
			}
		}
	};
	this.drawLayoutCompartmentsScatter = function(a, e, d, b, f) {
		if (this.data.l.smps[f].xAxis && this.data.l.smps[f].yAxis) {
			this.xAxis = this.data.l.smps[f].xAxis;
			this.yAxis = this.data.l.smps[f].yAxis;
			this.xAxisIndices = this.getSampleIndices(this.xAxis);
			this.yAxisIndices = this.getSampleIndices(this.yAxis)
		} else {
			this.xAxis = false;
			this.yAxis = false;
			this.xAxisIndices = false;
			this.yAxisIndices = false
		}
		if (this.layoutAdjust && this.xAxis && this.yAxis) {
			this.initAxes();
			this.layoutAxis = 3
		} else {
			this.layoutAxis = b == 0 ? 2 : 0;
			this.layoutAxis = d == this.layoutRows && this.layoutAxis ? 3 : d == this.layoutRows ? 1 : 0
		}
		if (this.data.l.reg) {
			if (this.data.l.reg[f]) {
				if (this.decorations) {
					delete(this.decorations)
				}
				this.addRegressionDecoration(this.data.l.reg[f].reg, this.data.l.reg[f].lab, this.data.l.reg[f].col)
			}
		}
		this.showLegend = false;
		this.legendInside = true;
		this.showDecorationsLegend = true;
		this.xAxisTitle = "";
		this.yAxisTitle = "";
		if (!this.layoutAdjust) {
			this.xAxisShow = false;
			this.yAxisShow = false;
			this.xAxisS2Show = false;
			this.yAxisS2Show = false;
			if (d == 0 && b % 2 > 0) {
				this.xAxisS2Show = true
			}
			if (d == this.layoutRows - 1 && b % 2 == 0) {
				this.xAxisShow = true
			}
			if (b == 0 && d % 2 > 0) {
				this.yAxisShow = true
			}
			if (b == this.layoutCols - 1 && d % 2 == 0) {
				this.yAxisS2Show = true
			}
		}
	};
	this.drawLayoutCompartmentsPie = function(a, b, d) {
		this.smpIndices = [this.getSampleIndices(this.data.l.smps[d])];
		this.showLegend = true
	};
	this.drawLayoutCompartmentsOneD = function(b, d, e) {
		if (this.graphType == "Candlestick") {
			this.xAxisShow = true;
			this.xAxis2Show = true;
			this.xAxisTitle = true;
			this.xAxis2Title = true;
			if (e == 1) {
				this.summaryType = "volume";
				if (this.showVolume) {
					this.showSampleNames = true
				}
			} else {
				this.summaryType = "candle";
				this.showSampleNames = false
			}
		} else {
			this.showLegend = false;
			this.showOverlays = true;
			this.isGroupedData = false;
			this.xAxisTitle = false;
			this.xAxis2Title = false;
			this.smpTitle = false;
			this.adjustAspectRatioXTries = 0;
			this.adjustAspectRatioYTries = 0;
			this.layoutLabels = [];
			if (this.segregateSamplesBy.length > 0 && this.segregateVariablesBy.length > 0) {
				this.layoutLabels.push(this.data.l.name[e][0]);
				this.layoutLabels.push(this.data.l.name[e][1])
			} else {
				if (this.segregateSamplesBy.length > 1 || this.segregateVariablesBy.length > 1) {
					this.layoutLabels.push(this.data.l.name[e][1]);
					this.layoutLabels.push(this.data.l.name[e][0])
				} else {
					this.layoutLabels.push(this.data.l.name[e])
				}
			}
			if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
				if (this.data.l.group) {
					var a = this.layoutParams[e].dragged ? this.layoutParams[e].grpIndices : false;
					this.groupSamples(this.data.l.group, false, a, true, true, true);
					this.layoutParams[e].grpIndices = this.grpIndices
				} else {
					if (this.smpIndices.length == 1 && this.graphType != "Heatmap") {
						this.showSampleNames = false
					}
				}
				if (this.segregateVariablesBy.length > 0 && this.graphType != "Heatmap") {
					this.showSampleNames = false
				}
				if (this.layoutAdjust) {
					this.layoutAxis = 3;
					if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
						this.initAxes()
					}
				} else {
					if (this.graphOrientation == "vertical") {
						this.xAxisShowLayout = !(e % this.layoutCols) ? true : false
					} else {
						this.xAxisShowLayout = e < this.layoutCols ? true : false;
						this.xAxis2ShowLayout = e >= this.layoutCols * (this.layoutRows - 1) ? true : false
					}
					this.xAxisShow = false;
					this.xAxis2Show = false
				}
			}
		}
	};
	this.draw1DLabels = function(j) {
		this.functionCaller = "draw1DLabels";
		if (this.layoutValid) {
			var e = this.layoutCollapse ? this.marginLeft + this.offsetX : this.marginLeft + this.offsetX + this.margin;
			var o = this.marginTop + this.offsetY;
			var k = this.layoutWidth;
			var d = k / 2;
			var g = this.getFontHeight() + (this.margin * 2);
			var b = g / 2;
			var a = this.layoutHeight - ((this.layoutLabels.length * g) + (this.margin * (this.layoutCollapse ? 0 : 1)));
			if (this.graphOrientation != "vertical" && this.graphType != "Heatmap" && !this.layoutAdjust) {
				if (j >= this.layoutCols) {
					a -= this.getAxisTitleTickLength()
				}
			}
			if (!this.layoutCollapse) {
				if (this.layoutAdjust) {
					k = this.x;
					e += this.left - this.margin;
					d = k / 2;
					a = this.y
				} else {
					k -= this.margin * 2
				}
			}
			for (var f = 0; f < this.layoutLabels.length; f++) {
				if (this.layoutBoxLabelColors[f]) {
					this.addToRender(["drawShape", "rectangle", e + (k / 2), o + (g / 2), k, g, this.layoutBoxLabelColors[f], this.layoutBoxShow ? this.foreground : this.layoutBoxLabelColors[f]], false, false, null, true)
				} else {
					if (this.layoutBoxShow) {
						this.addToRender(["drawShape", "rectangle", e + (k / 2), o + (g / 2), k, g, false, this.foreground, "open"], false, false, null, true)
					}
				}
				this.addToRender(["drawText", this.layoutLabels[f], e + d, o + b, this.font, this.foreground, "center", "middle"]);
				o += g
			}
			if (this.graphOrientation != "vertical" && this.xAxisShow) {
				o = this.marginTop + this.offsetY + this.top
			}
			if (this.layoutBoxShow) {
				this.addToRender(["drawShape", "rectangle", e + (k / 2), o + (a / 2), k, a, false, this.foreground, "open"], false, false, null, true)
			}
		}
	};
	this.initializeLayout = function() {
		this.isValidLayout()
	};
	this.initializeLayout()
};
CanvasXpress.prototype.initViewport = function(a) {
	this.setViewport = function() {
		var d = this.$("container-" + this.target);
		if (!d) {
			var H = this.$(this.target);
			H.className = "CanvasXpress";
			H.style.visibility = this.debug ? "visible" : "hidden";
			var B = H.parentNode;
			if (!B.id) {
				B.id = this.target + "ParentNode"
			}
			this.targetParentNode = B.id;
			this.targetParentNodeResponsive = false;
			this.targetParentNodeAspectRatio = [];
			var E = H.getAttribute("responsive");
			var z = H.getAttribute("aspectRatio");
			var f = H.getAttribute("resizable");
			if (f) {
				if (f == "both") {
					this.resizable = true;
					this.resizableX = true;
					this.resizableY = true
				} else {
					if (f == "x" || f == "X") {
						this.resizable = true;
						this.resizableX = true;
						this.resizableY = false
					} else {
						if (f == "y" || f == "Y") {
							this.resizable = true;
							this.resizableX = false;
							this.resizableY = true
						} else {
							if (f == "none") {
								this.resizable = false;
								this.resizableX = false;
								this.resizableY = false
							}
						}
					}
				}
			}
			if (E) {
				this.targetParentNodeResponsive = true;
				var m = z ? z.split(/:/) : [];
				var r = this.meta.system.isjQuery ? 16 : 0;
				if (B.clientWidth) {
					H.width = B.clientWidth - r
				} else {
					H.width = 250
				}
				if (m.length == 2) {
					m[0] = m[0] ? parseInt(m[0]) : 1;
					m[1] = m[1] ? parseInt(m[1]) : 1;
					H.height = parseInt(H.width * m[1] / m[0])
				} else {
					if (B.clientHeight) {
						H.height = B.clientHeight - r
					} else {
						H.height = 250
					}
				}
				this.targetParentNodeAspectRatio = [H.width, H.height]
			}
			H.widthDecrease = 18;
			H.heightDecrease = 18;
			H.originalWidth = parseInt(H.width);
			H.originalHeight = parseInt(H.height);
			H.width = H.originalWidth - H.widthDecrease;
			H.height = H.originalHeight - H.heightDecrease;
			H.style.width = H.width + "px";
			H.style.height = H.height + "px";
			var y = this.$cX("canvas", {
				id: this.target + "-events",
				className: "CanvasXpress",
				width: H.width,
				height: H.height
			}, {
				position: "absolute",
				left: 0,
				top: 0,
				visibility: this.debug ? "visible" : "hidden"
			});
			this.target2 = this.target + "-events";
			var h = this.$cX("canvas", {
				id: this.target + "-transitions0",
				className: "CanvasXpress",
				width: H.width,
				height: H.height
			}, {
				position: "absolute",
				left: 0,
				top: 0,
				visibility: "hidden"
			});
			this.target3 = this.target + "-transitions0";
			var g = this.$cX("canvas", {
				id: this.target + "-transitions1",
				className: "CanvasXpress",
				width: H.width,
				height: H.height
			}, {
				position: "absolute",
				left: 0,
				top: 0,
				visibility: "hidden"
			});
			this.target4 = this.target + "-transitions1";
			var d = this.$cX("div", {
				id: "container-" + this.target,
				className: "CanvasXpressContainer"
			});
			var D = this.$cX("div", {
				id: this.leafletId || this.target + "-leafletId",
				className: "CanvasXpressMap"
			}, {
				width: H.width + "px",
				height: H.height + "px"
			});
			if (this.isMap) {
				H.style.position = "absolute";
				H.style.left = "0px";
				H.style.top = "0px"
			}
			if (a) {
				d.style.display = "none"
			}
			var J = this.$cX("div", {
				id: "northest-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: H.width + "px",
				clear: "left",
				zIndex: 1000
			});
			var w = this.$cX("div", {
				id: "northest-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: H.width + "px"
			});
			var k = this.$cX("div", {
				id: "north-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: H.width + "px",
				height: "0px",
				clear: "left",
				zIndex: 1000
			});
			var I = this.$cX("div", {
				id: "north-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: H.width + "px",
				height: "0px"
			});
			var L = this.$cX("div", {
				id: "middle-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: (H.width + 4) + "px",
				height: (H.height + 4) + "px",
				clear: "left",
				margin: "-1px"
			});
			var n = this.$cX("div", {
				id: "west-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: "0px",
				height: H.height + "px",
				cssFloat: "left"
			});
			var K = this.$cX("div", {
				id: "west-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: "0px",
				height: H.height + "px"
			});
			var e = this.$cX("div", {
				id: "center-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			});
			var j = this.$cX("div", {
				id: "east-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: "0px",
				height: H.height + "px"
			});
			var G = this.$cX("div", {
				id: "east-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: "0px",
				height: H.height + "px"
			});
			var b = this.$cX("div", {
				id: "south-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: H.width + "px",
				height: "0px",
				clear: "left"
			});
			var A = this.$cX("div", {
				id: "south-wrapper-" + this.target,
				className: "CanvasXpressWrapper",
				state: "open"
			}, {
				width: H.width + "px",
				height: "0px"
			});
			J.appendChild(w);
			k.appendChild(I);
			n.appendChild(K);
			j.appendChild(G);
			b.appendChild(A);
			L.appendChild(n);
			L.appendChild(e);
			L.appendChild(j);
			d.appendChild(J);
			d.appendChild(k);
			d.appendChild(L);
			d.appendChild(b);
			if (this.isVideo) {
				var q = this.$(this.target + "-cX-Video");
				if (!q) {
					q = this.$cX("video", {
						id: this.target + "-cX-Video",
						autoplay: false,
						controls: this.videoControls,
						loop: this.videoLoop,
						preload: this.videoPreload,
						poster: this.videoPoster,
						dataSet: this.videoData,
						width: this.meta.canvas.ctx.canvas.width,
						height: this.meta.canvas.ctx.canvas.height,
						className: this.videoClassName
					});
					var u = [];
					var C = this.backgroundVideo;
					if (C && !(C.propertyIsEnumerable("length")) && typeof C === "object" && typeof C.length === "number") {
						u = C
					} else {
						u.push(this.backgroundVideo)
					}
					for (var F = 0; F < u.length; F++) {
						var x = this.$cX("source", {
							src: u[F],
							type: u[F].match(/mp4$/) ? "video/mp4" : u[F].match(/webm$/) ? "video/webm" : "video/ogv"
						});
						q.appendChild(x)
					}
				}
				H.parentNode.insertBefore(d, H);
				e.appendChild(H.parentNode.appendChild(H));
				H.parentNode.insertBefore(q, H);
				H.parentNode.appendChild(y)
			} else {
				H.parentNode.insertBefore(d, H);
				e.appendChild(H.parentNode.appendChild(H));
				if (this.isMap) {
					H.parentNode.appendChild(D)
				}
				H.parentNode.appendChild(y);
				H.parentNode.appendChild(h);
				H.parentNode.appendChild(g)
			}
			this.meta.canvas.ctx2 = y.getContext("2d");
			this.meta.canvas.ctx2.setTransform(this.meta.canvas.canvasPixelRatio, 0, 0, this.meta.canvas.canvasPixelRatio, 0, 0);
			this.meta.canvas.ctx3 = h.getContext("2d");
			this.meta.canvas.ctx3.setTransform(this.meta.canvas.canvasPixelRatio, 0, 0, this.meta.canvas.canvasPixelRatio, 0, 0);
			this.meta.canvas.ctx4 = g.getContext("2d");
			this.meta.canvas.ctx4.setTransform(this.meta.canvas.canvasPixelRatio, 0, 0, this.meta.canvas.canvasPixelRatio, 0, 0)
		}
	};
	this.resizeViewportNorth = function() {
		var f = this.$("west-container-" + this.target);
		var e = this.$("east-container-" + this.target);
		var c = this.$("northest-container-" + this.target);
		var d = this.$("northest-wrapper-" + this.target);
		var g = this.$("north-container-" + this.target);
		var b = this.$("north-wrapper-" + this.target);
		if (f && e && c && d && g && b) {
			c.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
			d.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
			g.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
			b.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
			g.style.height = "0px";
			b.style.height = "0px"
		}
	};
	this.resizeViewportWest = function() {
		var e = this.$(this.target + "-cX-Configurator");
		var b = this.$("west-container-" + this.target);
		var d = this.$("west-wrapper-" + this.target);
		if (b && d) {
			b.style.width = "0px";
			d.style.width = "0px";
			b.style.height = this.meta.canvas.ctx.canvas.height + "px";
			d.style.height = this.meta.canvas.ctx.canvas.height + "px"
		}
	};
	this.resizeViewportEast = function() {
		var d = this.$(this.target + "-cX-DataFilter");
		var b = this.$("east-container-" + this.target);
		var c = this.$("east-wrapper-" + this.target);
		if (b && c) {
			b.style.width = "0px";
			c.style.width = "0px";
			b.style.height = this.meta.canvas.ctx.canvas.height + "px";
			c.style.height = this.meta.canvas.ctx.canvas.height + "px"
		}
	};
	this.resizeViewportSouth = function(c) {
		var h = this.$(this.target + "-cX-DataTable");
		var f = this.$("west-container-" + this.target);
		var e = this.$("east-container-" + this.target);
		var g = this.$("south-container-" + this.target);
		var b = this.$("south-wrapper-" + this.target);
		if (h && f && e && g && b) {
			if (c) {
				g.style.height = parseInt(h.style.height) + "px";
				b.style.height = parseInt(h.style.height) + "px";
				g.style.width = parseInt(h.style.width) + "px";
				b.style.width = parseInt(h.style.width) + "px"
			} else {
				g.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
				b.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
				g.style.height = "0px";
				b.style.height = "0px"
			}
		}
	};
	this.resizeViewport = function(h) {
		if (h) {
			var b = this.getTargetEvent(h);
			if (this.Ext) {
				for (var d = 0; d < CanvasXpress.instances.length; d++) {
					CanvasXpress.instances[d].resizeViewport()
				}
			}
			if (b.className && b.className.match(/x-tab-strip-text/)) {
				return
			}
		}
		var g = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var f = this.$("west-container-" + this.target);
		if (g && c && f) {
			this.resizeViewportWest();
			this.resizeViewportEast();
			this.resizeViewportNorth();
			this.resizeViewportSouth();
			g.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(c.style.width) + 0) + "px";
			g.style.height = (this.meta.canvas.ctx.canvas.height + 0) + "px"
		}
	};
	this.resizeViewportMiddle = function(b, d) {
		var f = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var e = this.$("west-container-" + this.target);
		if (f && c && e) {
			this.resizeViewportWest();
			this.resizeViewportEast();
			this.resizeViewportNorth();
			this.resizeViewportSouth();
			f.style.width = (parseInt(e.style.width) + b + parseInt(c.style.width) + 0) + "px";
			f.style.height = (d + 0) + "px"
		}
	};
	this.resetViewportOverflow = function(c) {
		if (c) {
			var b = this.$(c + "-wrapper-" + this.target);
			if (b) {
				b.style.overflow = "visible"
			}
		}
	};
	this.initializeViewport = function() {
		this.setViewport()
	};
	this.initializeViewport()
};
CanvasXpress.prototype.initMenus = function() {
	this.addMenu = function(A, a, n, b, g, d, t, z) {
		if (this.disableMenu) {
			return
		}
		var p;
		var o;
		var j = this.$("north-wrapper-" + this.target);
		var c = this.$("west-container-" + this.target);
		this.resetLinkDiv();
		if (j && c) {
			if (a) {
				o = this.newId("-cX-Menu-");
				p = this.$cX("div", {
					id: o,
					className: "CanvasXpressMenu draggable",
					par: n
				}, {
					left: "0px",
					top: "0px",
					zIndex: this.menuIndex++,
					display: "none"
				})
			} else {
				this.removeMenus();
				if (b) {
					a = b;
					g += c.offsetWidth
				} else {
					a = this.setMenu();
					var v = this.getTargetEvent(A);
					var B = this.adjustedCoordinates(A, this.isMap ? false : v);
					if (z) {
						g = 8;
						d = 8
					} else {
						g = B.x + c.offsetWidth;
						d = B.y
					}
				}
				o = this.newId("-cX-Menu-");
				p = this.$cX("div", {
					id: o,
					className: "CanvasXpressMenu draggable"
				}, {
					left: g + "px",
					top: d + "px",
					zIndex: this.menuIndex++
				})
			}
			var k = this.$cX("ul", {
				id: this.newId("-cX-List-"),
				className: "CanvasXpressList",
				header: t
			});
			p.appendChild(k);
			j.appendChild(p);
			var s = this.maxSubMenus;
			var q = a.length > s ? s : a.length;
			if (a.length > s) {
				k.rawMenu = a;
				k.rawMenuIndex = 0;
				this.addMenuItemScroller(k, "Top")
			}
			for (var r = 0; r < q; r++) {
				if (a[r][0] == "-") {
					this.addMenuItemSep(k)
				} else {
					if (a[r][0] == "-text-") {
						this.addMenuItemText(a[r], k)
					} else {
						if (a[r][0] == "-color-") {
							this.addMenuItemColor(a[r], k)
						} else {
							if (a[r][0] == "-slider-") {
								this.addMenuItemSlider(a[r], k)
							} else {
								this.addMenuItem(a[r], k)
							}
						}
					}
				}
			}
			if (a.length > s) {
				this.addMenuItemScroller(k, "Bottom")
			}
		}
		return o
	};
	this.pageMenuItem = function(e, f) {
		var g, j, a, i;
		var h = e.rawMenuMatch || e.rawMenu;
		if (h) {
			var d = e.childNodes.length - 2;
			if (f == "Top" && e.rawMenuIndex > 0) {
				g = e.childNodes[e.childNodes.length - 2];
				j = h[e.rawMenuIndex - 1];
				a = e.childNodes[2];
				i = true;
				e.rawMenuIndex--
			} else {
				if (f == "Bottom" && h.length > (e.rawMenuIndex + d)) {
					g = e.childNodes[2];
					j = h[e.rawMenuIndex + d];
					a = e.childNodes[e.childNodes.length - 1];
					i = true;
					e.rawMenuIndex++
				}
			}
			if (i) {
				this.addRemoveItemListeners("removeEvtListener", g);
				g.parentNode.removeChild(g);
				if (j[0] == "-") {
					this.addMenuItemSep(e, a)
				} else {
					if (j[0] == "-text-") {
						this.addMenuItemText(j, e, a)
					} else {
						if (j[0] == "-color-") {
							this.addMenuItemColor(j, e, a)
						} else {
							if (j[0] == "-slider-") {
								this.addMenuItemSlider(j, e, a)
							} else {
								this.addMenuItem(j, e, a)
							}
						}
					}
				}
			}
		}
	};
	this.filterScrollSearch = function(b) {
		var k = this.$(b);
		if (k) {
			var c = k.value;
			var n = new RegExp(k.value, "i");
			var h = k.parentNode.parentNode;
			var j = h.rawMenu;
			var f = [];
			for (var e = 0; e < j.length; e++) {
				if (j[e][0].match(n)) {
					f.push(j[e])
				}
			}
			if (f.length != j.length) {
				h.rawMenuMatch = f
			} else {
				delete(h.rawMenuMatch)
			}
			while (h.childNodes.length > 0) {
				var d = h.childNodes[0];
				this.addRemoveItemListeners("removeEvtListener", d);
				h.removeChild(d)
			}
			var m = this.maxSubMenus;
			var g = f.length > m ? m : f.length;
			h.rawMenuIndex = 0;
			var a = this.addMenuItemScroller(h, "Top", c);
			for (var e = 0; e < g; e++) {
				this.addMenuItem(f[e], h)
			}
			this.addMenuItemScroller(h, "Bottom");
			a.focus();
			a.value = c
		}
	};
	this.addMenuItemSep = function(d, a) {
		var c = this.$cX("li", {
			id: this.newId("-cX-List-Item-Sep-"),
			className: "CanvasXpressListItemSep"
		});
		var e = this.$cX("span", {
			id: this.newId("-cX-List-Item-Text-Sep-"),
			className: "CanvasXpressListItemTextSep",
			innerHTML: "&nbsp;"
		});
		c.appendChild(e);
		if (a) {
			a.parentNode.insertBefore(c, a)
		} else {
			d.appendChild(c)
		}
	};
	this.addMenuItemScroller = function(c, d) {
		var b = this.$cX("li", {
			id: this.newId("-cX-List-Item-Scroll-" + d),
			className: "CanvasXpressListItemScroll" + d
		});
		var f = this.$cX("span", {
			id: this.newId("-cX-List-Item-Text-Scroll-" + d),
			className: "CanvasXpressListItemTextScroll" + d,
			innerHTML: "&nbsp;"
		});
		b.appendChild(f);
		c.appendChild(b);
		this.addRemoveItemListeners("addEvtListener", b);
		if (d == "Top") {
			var a = this.$cX("li", {
				id: this.newId("-cX-List-Item-Scroll-Search"),
				className: "CanvasXpressListItemScrollSearch" + d
			});
			var e = this.$cX("input", {
				id: this.newId("-cX-List-Item-Scroll-Search-Input"),
				className: "CanvasXpressListItemScrollSearch",
				type: "text",
				placeholder: " Search menu"
			});
			a.appendChild(e);
			c.appendChild(a);
			return e
		}
	};
	this.getMenuItemValue = function(d) {
		if (d[2][2]) {
			var c = this.cloneObject(d[2][2]);
			var b = this;
			while (c.length > 0) {
				var a = c.shift();
				if (b[a]) {
					b = b[a]
				} else {
					return ""
				}
			}
			return b != null ? b : ""
		} else {
			return this[d[2][0]] || ""
		}
	};
	this.addMenuItem = function(d, n, k) {
		var j = this.newId("-cX-List-Item-");
		var e = this.$cX("li", {
			id: j,
			className: "CanvasXpressListItem",
			click: d[2],
			params: d[3] || [],
			upload: d[0] && d[0] == "Load" ? true : false,
			uploadParams: d[0] && d[0] == "Load Parameters" ? true : false
		});
		var m;
		if (d[5]) {
			m = this.$cX("a", {
				id: this.newId("-cX-List-Item-A-"),
				className: "CanvasXpressListItemAArrow",
				hidefocus: "true",
				unselectable: "on",
				href: "#",
				menu: j,
				menuId: "false",
				menuFunc: d[5],
				menuParm: d[6],
				title: "Drag to position menu",
				draggable: false
			})
		} else {
			m = this.$cX("a", {
				id: this.newId("-cX-List-Item-A-"),
				className: "CanvasXpressListItemA",
				hidefocus: "true",
				unselectable: "on",
				href: "#",
				menuFunc: d[2],
				menuParm: d[3],
				draggable: false
			})
		}
		var g = this.$cX("img", {
			id: this.newId("-cX-List-Icon-"),
			className: "CanvasXpressListIcon",
			src: d[1] && CanvasXpress.images[d[1]] ? CanvasXpress.images[d[1]] : CanvasXpress.images.canvasXpress,
			key: d[1]
		});
		var p;
		if (d[0] && (d[0] == "Load" || d[0] == "Load Parameters")) {
			p = this.$cX("span", {
				id: this.newId("-cX-List-Item-Text-"),
				className: "CanvasXpressListItemText",
				draggable: false
			}, {
				marginRight: 0
			});
			var h = this.$cX("input", {
				id: this.newId("-cX-List-Item-Text-File-Upload"),
				className: "CanvasXpressListItemText",
				type: "file",
				draggable: false
			}, {
				color: "transparent",
				width: "100px"
			});
			p.appendChild(h)
		} else {
			p = this.$cX("span", {
				id: this.newId("-cX-List-Item-Text-"),
				className: "CanvasXpressListItemText",
				innerHTML: d[0] || "",
				draggable: false
			})
		}
		var c = this.$cX("span", {
			className: "CanvasXpressListItemTextShort",
			innerHTML: d[4] || "",
			draggable: false
		});
		m.appendChild(g);
		m.appendChild(p);
		m.appendChild(c);
		e.appendChild(m);
		if (k) {
			k.parentNode.insertBefore(e, k)
		} else {
			n.appendChild(e)
		}
		this.addRemoveItemListeners("addEvtListener", e)
	};
	this.addMenuItemText = function(c, m, j) {
		var h = this.newId("-cX-List-Item-Text-");
		var f = this.newId("-cX-List-Item-Text-Input-");
		var d = this.getMenuItemValue(c);
		var e = this.$cX("li", {
			id: h,
			className: "CanvasXpressListItem",
			click: c[1],
			params: [c[2], f]
		});
		var n = this.$cX("input", {
			id: f,
			className: "CanvasXpressList",
			type: "text",
			value: d
		});
		var k = this.$cX("a", {
			id: this.newId("-cX-List-Text-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		});
		var g = this.$cX("img", {
			id: this.newId("-cX-List-Text-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "4px"
		});
		k.appendChild(g);
		k.appendChild(n);
		e.appendChild(k);
		if (j) {
			j.parentNode.insertBefore(e, j)
		} else {
			m.appendChild(e)
		}
		this.addRemoveItemListeners("addEvtListener", e)
	};
	this.addMenuItemColor = function(E, v, L) {
		var m = this.newId("-cX-List-Item-Color-");
		var n = this.newId("-cX-List-Item-Color-Container-");
		var g = this.newId("-cX-List-Item-Color-Current-");
		var B = this.newId("-cX-List-Item-Color-Palete-");
		var f = this.newId("-cX-List-Item-Color-Palete-Current-");
		var k = this.newId("-cX-List-Item-Color-Saturation-");
		var w = this.newId("-cX-List-Item-Color-Saturation-Current-");
		var N = this[E[2][0]] || "";
		var G = this.$cX("li", {
			id: m,
			className: "CanvasXpressListItem",
			click: E[1],
			params: [E[2], g],
			palete: B,
			paleteCurrent: f,
			colorCurrent: g,
			saturation: k,
			saturationCurrent: w
		});
		var M = this.$cX("a", {
			id: this.newId("-cX-List-Color-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		}, {
			height: "126px"
		});
		var I = this.$cX("img", {
			id: this.newId("-cX-List-Color-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "2px"
		});
		var J = N ? this.rgbToHex(this.validateColor(N.replace(/[\'\"]/g, ""))) : this.foreground;
		this.colorRGBfromString(J);
		var t = Math.round(this.colorHSV[0] / 6 * 180);
		var r = Math.round((1 - this.colorHSV[1]) * 100);
		var q = Math.round((1 - this.colorHSV[2]) * 100);
		var K = this.$cX("div", {
			id: n
		}, {
			width: "188px",
			height: "130px",
			cssFloat: "left"
		});
		var C = this.$cX("div", {
			id: g,
			parentItem: m,
			className: "CanvasXpressConfiguratorColor",
			value: N
		}, {
			width: "203px",
			height: "16px",
			cssFloat: "left",
			marginBottom: "5px",
			cursor: "default"
		});
		var D = this.$cX("div", {
			id: B,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorMain"
		}, {
			position: "relative",
			left: "0px",
			top: "0px",
			width: "181px",
			height: "101px"
		});
		var d = this.$cX("div", {
			id: f,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorExtra"
		}, {
			position: "relative",
			left: (t - 7) + "px",
			top: (r - 7) + "px",
			width: "195px",
			height: "115px"
		});
		D.appendChild(d);
		var A = this.$cX("div", {
			id: k,
			parentItem: m,
			className: "CanvasXpressConfiguratorColor"
		}, {
			position: "relative",
			left: "188px",
			top: "-102px",
			width: "15px",
			height: "100px",
			border: "1px solid rgb(51,122,183)",
			clear: "left",
			cursor: "crosshair"
		});
		for (var H = 0; H < 100; H += 4) {
			var F = this.$cX("div", false, {
				height: "4px",
				position: "relative",
				left: "0px",
				cursor: "crosshair"
			});
			A.appendChild(F)
		}
		var e = this.$cX("div", {
			id: w,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorExtra"
		}, {
			position: "relative",
			left: "0px",
			top: (q - 108) + "px",
			width: "29px",
			height: "115px"
		});
		A.appendChild(e);
		K.appendChild(C);
		K.appendChild(D);
		K.appendChild(A);
		M.appendChild(I);
		M.appendChild(K);
		G.appendChild(M);
		if (L) {
			L.parentNode.insertBefore(G, L)
		} else {
			v.appendChild(G)
		}
		this.colorizeCurrentItemColor(G);
		this.colorizeSaturationItemColor(G);
		this.addRemoveItemListeners("addEvtListener", G)
	};
	this.colorizeCurrentItemColor = function(a) {
		var e = this.$(a.colorCurrent);
		if (e) {
			var d = this.colorRGBToString();
			var b = this.hexToRgb("#" + d);
			e.style.backgroundColor = "#" + d;
			e.innerHTML = "&nbsp;&nbsp;" + b;
			e.style.color = this.complementaryColor(b, true);
			e.value = b
		}
	};
	this.colorizeSaturationItemColor = function(a) {
		var d = function(m, k, c, j, h) {
			return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
		};
		var f = this.$(a.saturation);
		if (f && this.colorHSV) {
			var g = f.childNodes;
			var b = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
			if (b) {
				for (var e = 0; e < g.length - 1; e++) {
					g[e].style.backgroundColor = d(b[0], b[1], b[2], e, g.length - 1)
				}
			}
		}
	};
	this.updateColorItemValue = function(b, c) {
		if (!b) {
			var g = this.getMenuItemComp(c);
			if (g) {
				b = g[0]
			} else {
				return false
			}
		}
		if (this.changingColorItemOn) {
			if (this.changingColorItemOn == "palette") {
				var a = this.$(b.palete);
				var h = this.$(b.paleteCurrent);
				if (a && h) {
					var j = this.adjustedCoordinates(c, a);
					if (j) {
						var i = Math.min(Math.max(0, j.x), 181);
						var f = Math.min(Math.max(0, j.y - 25), 101);
						h.style.left = (i - 7) + "px";
						h.style.top = (f - 7) + "px";
						this.colorFromHsv(i * 6 / 180, 1 - f / 100, null);
						this.colorizeCurrentItemColor(b);
						this.colorizeSaturationItemColor(b)
					}
				}
			} else {
				var k = this.$(b.saturation);
				var d = this.$(b.saturationCurrent);
				if (k && d) {
					var j = this.adjustedCoordinates(c, k);
					if (j) {
						var f = Math.min(Math.max(0, j.y - 25), 101);
						d.style.top = (f - 108) + "px";
						this.colorFromHsv(null, null, 1 - f / 100);
						this.colorizeCurrentItemColor(b)
					}
				}
			}
		}
		return false
	};
	this.endColorItemChange = function(a) {
		this.changingColorItemOn = false
	};
	this.addMenuItemSlider = function(q, m, I) {
		var f = this.newId("-cX-List-Item-Slider-");
		var e = this.newId("-cX-List-Item-Slider-Container-");
		var E = this.newId("-cX-List-Item-Slider-Table-");
		var K = q[2][0] || "";
		var D = this.formatNumber(this.binConfigurations[K]["max"], this.binConfigurations[K]["dec"]);
		var v = this.$cX("li", {
			id: f,
			className: "CanvasXpressListItem",
			click: q[1],
			params: [q[2][0], e],
			slider: K
		});
		var J = this.$cX("a", {
			id: this.newId("-cX-List-Slider-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		});
		var H = this.$cX("div", {
			id: e,
			className: "CanvasXpressList"
		});
		var n = this.$cX("table", {
			id: E,
			className: "CanvasXpressListItemTable"
		}, {
			width: "100%"
		});
		var g = this.$cX("tbody");
		var h = D.length * 8;
		for (var B = 0; B < this.binConfigurations[K]["n"]; B++) {
			var s = Number(B > 0 ? this.binConfigurations[K]["bins"][B - 1]["value"] : this.binConfigurations[K]["min"]);
			var A = Number(B < this.binConfigurations[K]["n"] - 1 ? this.binConfigurations[K]["bins"][B + 1]["value"] : this.binConfigurations[K]["max"]);
			var k = this.$cX("input", {
				id: E + "-Range-" + B,
				className: "CanvasXpressListItem",
				type: "range",
				value: this.binConfigurations[K]["bins"][B]["value"],
				min: s,
				max: A,
				step: Number(this.formatNumber((A - s) / 20, this.binConfigurations[K]["dec"])),
				slider: K,
				sliderRange: B,
				sliderNumber: false
			}, {
				width: "120px"
			});
			var j = this.$cX("input", {
				id: E + "-Number-" + B,
				className: "CanvasXpressListItem",
				type: "number",
				value: this.binConfigurations[K]["bins"][B]["value"],
				min: s,
				max: A,
				step: Number(this.formatNumber((A - s) / 20, this.binConfigurations[K]["dec"])),
				slider: K,
				sliderRange: B,
				sliderNumber: true
			}, {
				width: (h + 18) + "px",
				textAlign: "right"
			});
			var c = this.$cX("tr");
			var G = this.$cX("th", {
				innerHTML: this.binConfigurations[K]["bins"][B]["name"]
			}, {
				paddingRight: "5px"
			});
			var F = this.$cX("td", {
				id: E + "-Min-" + B,
				innerHTML: this.formatNumber(s, this.binConfigurations[K]["dec"])
			}, {
				width: h + "px",
				textAlign: "right"
			});
			var C = this.$cX("td");
			C.appendChild(k);
			var z = this.$cX("td", {
				id: E + "-Max-" + B,
				innerHTML: this.formatNumber(A, this.binConfigurations[K]["dec"])
			}, {
				width: h + "px"
			});
			var w = this.$cX("td", false, {
				paddingLeft: "5px"
			});
			w.appendChild(j);
			c.appendChild(G);
			c.appendChild(F);
			c.appendChild(C);
			c.appendChild(z);
			c.appendChild(w);
			g.appendChild(c)
		}
		n.appendChild(g);
		H.appendChild(n);
		H.appendChild(this.$cX("br"));
		var p = this.$cX("img", {
			id: this.newId("-cX-List-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "4px"
		});
		J.appendChild(p);
		J.appendChild(H);
		v.appendChild(J);
		if (I) {
			I.parentNode.insertBefore(v, I)
		} else {
			m.appendChild(v)
		}
		this.addRemoveItemListeners("addEvtListener", v)
	};
	this.updateSliderItemValue = function(h) {
		var a = this.changingSliderItemOn.slider;
		var g = this.changingSliderItemOn.sliderRange;
		var c = Number(this.formatNumber(this.changingSliderItemOn.value, this.binConfigurations[a]["dec"]));
		var d = this.$(this.changingSliderItemOn.id.replace("-Range-", "-Number-"));
		var f = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Range-" + (g - 1)));
		var j = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Max-" + (g - 1)));
		var b = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Range-" + (g + 1)));
		var i = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Min-" + (g + 1)));
		this.binConfigurations[a]["bins"][g]["value"] = c;
		if (d) {
			d.value = c
		}
		if (f && j) {
			f.max = c;
			f.step = (f.max - f.min) / 20;
			j.innerHTML = c
		}
		if (b && i) {
			b.min = c;
			b.step = (b.max - b.min) / 20;
			i.innerHTML = c
		}
		this.applySliderItemValue(a);
		return false
	};
	this.endSliderItemChange = function(g) {
		if (this.changingSliderItemOn.sliderNumber) {
			var a = this.changingSliderItemOn.slider;
			var f = this.changingSliderItemOn.sliderRange;
			var c = Number(this.formatNumber(this.changingSliderItemOn.value, this.binConfigurations[a]["dec"]));
			var i = this.$(this.changingSliderItemOn.id.replace("-Number-", "-Range-"));
			var d = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Range-" + (f - 1)));
			var j = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Max-" + (f - 1)));
			var b = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Range-" + (f + 1)));
			var h = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Min-" + (f + 1)));
			this.binConfigurations[a]["bins"][f]["value"] = c;
			if (i) {
				i.value = c
			}
			if (d && j) {
				d.max = c;
				d.step = (d.max - d.min) / 20;
				j.innerHTML = c
			}
			if (b && h) {
				b.min = c;
				b.step = (b.max - b.min) / 20;
				h.innerHTML = c
			}
			this.applySliderItemValue(a)
		}
		this.changingSliderItemOn = false
	};
	this.applySliderItemValue = function(f) {
		var a = this.binConfigurations[f]["name"];
		var e = this.binConfigurations[f]["vi"];
		this.data.x[a] = [];
		for (var d = 0; d < this.data.y.data[e].length; d++) {
			var b = this.data.y.data[e][d];
			if (!isNaN(b) && b != "" && b != null) {
				for (var c = 0; c < this.binConfigurations[f]["n"]; c++) {
					if (b <= this.binConfigurations[f]["bins"][c].value) {
						this.data.x[a][d] = this.binConfigurations[f]["bins"][c].name;
						break
					}
				}
			} else {
				this.data.x[a][d] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a])
	};
	this.addRemoveItemListeners = function(b, a) {
		if (!a) {
			return this.removeMenus()
		} else {
			if (a.className == "CanvasXpressListItemSep") {
				return
			}
		}
		var e = a.parentNode.parentNode;
		var f = a.id.match("-cX-List-Item-Color-");
		if (this.hasClass(e, "draggable") && !f) {
			this[b](e, "mousedown", this.registerMousemove, false)
		}
		if (a.upload) {
			var d = a.childNodes[0].childNodes[1].childNodes[0];
			this[b](d, "change", this.loadFile, false)
		} else {
			if (a.uploadParams) {
				var d = a.childNodes[0].childNodes[1].childNodes[0];
				this[b](d, "change", this.loadParamsFile, false)
			} else {
				this[b](a, "click", this.clickMenuItem, false)
			}
		}
		this[b](a, "mouseover", this.mouseoverMenuItem, false);
		this[b](a, "mouseout", this.mouseoutMenuItem, false);
		this[b](a, "mousewheel", this.mousewheelMenuItem, false);
		this[b](a, "contextmenu", this.contextMenuItem, false);
		if (a.className.match(/Scroll/)) {
			this[b](a, "mousedown", this.mousedownMenuItem, false);
			this[b](a, "mouseup", this.mouseupMenuItem, false)
		}
		if (a.paleteCurrent && a.saturation) {
			this[b](a, "mousedown", this.mousedownMenuItemColor, false)
		}
		if (a.slider) {
			this[b](a, "mousedown", this.mousedownMenuItemSlider, false)
		}
	};
	this.contextMenuItem = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.cancelEvent(h);
			var b = a.getTargetEvent(h);
			var n = a.getMenuItemComp(h);
			var f = n[1].childNodes[0];
			var g = n[1].childNodes[1].innerText;
			var k = n[1].menuFunc;
			var j = n[1].menuParm;
			var p = n[1].menuId;
			var q = n[2].offsetLeft;
			var l = n[2].offsetTop + n[1].offsetTop;
			a.removeMenus();
			var o = [
				["Pin " + g + " to Toolbar", "pin", "pinToToolbar", [f, g, k, j, p]]
			];
			var d = a.addMenu(h, o);
			var c = a.$(d);
			c.style.left = q + "px";
			c.style.top = l + "px";
			c.style.display = "block";
			return false
		}
	}(this);
	this.pinToToolbar = function(d, a, c, f, e) {
		this.removeMenus();
		var b = this.$(this.target + "-cX-Toolbar-Custom");
		if (b) {
			var g = this.target + "-cX-Custom-Toolbar-Menu-" + c;
			if (!this.$(g)) {
				d.id = g;
				d.style.cssFloat = "left";
				d.style.marginLeft = "10px";
				d.style.position = "relative";
				d.title = a;
				d.fun = c;
				d.par = f;
				d.mid = e;
				b.appendChild(d);
				this.addRemoveEvtListener("addEvtListener", d, "click", this.addCustomToolbarMenu, false);
				this.addRemoveEvtListener("addEvtListener", d, "contextmenu", this.unpinFromToolbar, false);
				CanvasXpress.stack[this.target].afterRender.push(["addImageToToolbar", [d.key, a, c, f, e]])
			}
		}
	};
	this.unpinFromToolbar = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			a.cancelEvent(j);
			var c = a.getTargetEvent(j);
			var g = c.offsetLeft;
			var h = c.offsetTop;
			var f = [
				["Unpin " + c.title + "from Toolbar", "unpin", "removeImageFromToolbar", [c.id]]
			];
			var d = a.addMenu(j, f);
			var b = a.$(d);
			b.style.left = g + "px";
			b.style.top = h + "px";
			b.style.display = "block";
			return false
		}
	}(this);
	this.addCustomToolbarMenu = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			a.cancelEvent(f);
			var c = a.getTargetEvent(f);
			var g = a[c.fun].apply(a, c.par);
			if (c.mid) {
				var d = a.addMenu(false, g);
				var b = a.$(d);
				b.style.left = c.offsetLeft + "px";
				b.style.top = "10px";
				b.style.display = "block"
			}
		}
	}(this);
	this.addImageToToolbar = function(e, a, b, f, d) {
		var c = this.$cX("img", {
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images[e],
			key: e
		});
		this.pinToToolbar(c, a, b, f, d)
	};
	this.removeImageFromToolbar = function(b) {
		var a = this.$(b);
		if (a) {
			this.addRemoveEvtListener("removeEvtListener", a, "click", this.addCustomToolbarMenu, false);
			this.addRemoveEvtListener("removeEvtListener", a, "contextmenu", this.unpinFromToolbar, false);
			a.parentNode.removeChild(a);
			this.removeMenus();
			CanvasXpress.stack[this.target].afterRender.push(["removeImageFromToolbar", [b]])
		}
	};
	this.clickMenuItem = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.cancelEvent(h);
			var b = a.getTargetEvent(h);
			var m = a.getMenuItemComp(h);
			if (m && !/input|textarea|select/i.test(b.tagName)) {
				if (m[0].className.match(/Scroll/) || m[1].className.match(/Scroll/)) {
					var c = m[0].className.match(/Scroll/) ? m[0] : m[1];
					var n = c.parentNode;
					var j = c.className.match(/ScrollTop/) ? "Top" : "Bottom";
					a.pageMenuItem(n, j)
				} else {
					var f = [];
					if (m[0].params) {
						for (var g = 0; g < m[0].params.length; g++) {
							if (m[0].params[g] == "event") {
								f.push(h)
							} else {
								if (m[0].params[g] == "component") {
									f.push(m)
								} else {
									f.push(m[0].params[g])
								}
							}
						}
					}
					if (a[m[0].click]) {
						a[m[0].click].apply(a, f);
						var d = m[1].firstChild.key;
						var o = m[1].firstChild.src;
						if (d) {
							if (d.match("unchecked")) {
								m[1].firstChild.key = "checked";
								m[1].firstChild.src = CanvasXpress.images.checked
							} else {
								if (d.match("checked")) {
									m[1].firstChild.key = "unchecked";
									m[1].firstChild.src = CanvasXpress.images.unchecked
								} else {
									if (d.match("eyeMinusIcon")) {
										m[1].firstChild.key = "eyePlusIcon";
										m[1].firstChild.src = CanvasXpress.images.eyePlusIcon
									} else {
										if (d.match("eyePlusIcon")) {
											m[1].firstChild.key = "eyeMinusIcon";
											m[1].firstChild.src = CanvasXpress.images.eyeMinusIcon
										} else {
											if (d == "lightbulb") {
												m[1].firstChild.key = "lightbulbOff";
												m[1].firstChild.src = CanvasXpress.images.lightbulbOff
											} else {
												if (d == "lightbulbOff") {
													m[1].firstChild.key = "lightbulb";
													m[1].firstChild.src = CanvasXpress.images.lightbulb
												} else {
													if (d == "sortAsciiDesc") {
														m[1].firstChild.key = "sortAsciiAsc";
														m[1].firstChild.src = CanvasXpress.images.sortAsciiAsc
													} else {
														if (d == "sortAsciiAsc") {
															m[1].firstChild.key = "sortAsciiDesc";
															m[1].firstChild.src = CanvasXpress.images.sortAsciiDesc
														} else {
															if (d.match("radioOn")) {
																a.resetRadioMenuItem(m[2].firstChild.childNodes);
																if (f[1] && f[1].match(/xAxis|yAxis|zAxis/)) {
																	m[1].firstChild.key = "radioOn";
																	m[1].firstChild.src = CanvasXpress.images.radioOn
																} else {
																	m[1].firstChild.key = "radioOff";
																	m[1].firstChild.src = CanvasXpress.images.radioOff
																}
															} else {
																if (d.match("radioOff")) {
																	a.resetRadioMenuItem(m[2].firstChild.childNodes);
																	m[1].firstChild.key = "radioOn";
																	m[1].firstChild.src = CanvasXpress.images.radioOn
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return false
			} else {
				return false
			}
		}
	}(this);
	this.resetRadioMenuItem = function(b) {
		for (var c = 0; c < b.length; c++) {
			var a = b[c].firstChild.firstChild;
			if (a && a.nodeName.match(/img/i)) {
				a.src = CanvasXpress.images.radioOff;
				a.key = "radioOff"
			}
		}
	};
	this.adjustMenuItemPosition = function(f, p, o) {
		var g, x;
		var q = this.remoteParentId ? this.$(this.remoteParentId) : this.$("container-" + this.target);
		var i = window.innerWidth;
		var b = window.innerHeight;
		var u = q.offsetLeft;
		var k = q.offsetTop;
		var s = q.clientWidth;
		var j = q.clientHeight;
		var a = i - u;
		var v = f.clientWidth;
		var n = f.clientHeight;
		if (p) {
			g = p.offsetLeft + p.offsetWidth - 5;
			if (g + v + 5 > a) {
				g = p.offsetLeft - v + 5
			}
			x = p.offsetTop + o.offsetTop
		} else {
			g = f.offsetLeft;
			x = f.offsetTop
		}
		f.style.left = g + "px";
		f.style.top = x + "px"
	};
	this.mouseoverMenuItem = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var h = a.getMenuItemComp(j);
			if (!h) {
				return false
			}
			if (h[0].className.match(/Scroll/) || h[1].className.match(/Scroll/)) {
				var n = h[0].className.match(/Scroll/) ? h[0] : h[1];
				n.className += "Active";
				return false
			}
			var f = h[2].firstChild.childNodes;
			a.hideMenusRecursively(f);
			h[0].className = "CanvasXpressListItemActive";
			if (h[1].menu) {
				var l = a[h[1].menuFunc].apply(a, h[1].menuParm);
				var g = a.addMenu(false, l, h[1].menu);
				var b = a.$(g);
				var k = h[2];
				b.style.left = "0px";
				b.style.top = "0px";
				b.style.display = "block";
				a.adjustMenuItemPosition(b, k, h[1]);
				h[1].className = "CanvasXpressListItemAArrowActive";
				h[1].menuId = g
			} else {
				h[1].className = "CanvasXpressListItemAActive"
			}
			return false
		}
	}(this);
	this.mouseoutMenuItem = function(a) {
		return function(i) {
			if (!i) {
				i = window.event
			}
			if (a.fastScrollMenuOn) {
				a.fastScrollMenuOn = false;
				clearInterval(a.fastScrollMenu)
			}
			var d, c, b, q, o, n, k, j;
			var p = a.adjustedCoordinates(i);
			if (p) {
				var h = a.$("north-container-" + a.target);
				var g = a.$("west-container-" + a.target);
				p.x += g.offsetWidth;
				p.y += h.offsetHeight;
				var l = a.getMenuItemComp(i);
				if (!l) {
					return false
				} else {
					if (l[1] && l[1].menu) {
						var f = a.$(l[1].menuId);
						d = f.offsetLeft;
						o = f.offsetTop;
						c = d + f.offsetWidth;
						n = o + f.offsetHeight;
						if (p.x >= d && p.x <= c && p.y >= o && p.y <= n) {
							return false
						}
						a.hideMenu(l, f)
					} else {
						a.hideMenu(l)
					}
				}
			}
			return false
		}
	}(this);
	this.mousedownMenuItemColor = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			var c = a.getMenuItemComp(d);
			if (!c) {
				return false
			} else {
				if (b.id && b.id.match(/-cX-List-Item-Color-Palete-/)) {
					a.changingColorItemOn = "palette";
					if (a.colorHSV[2] == 0) {
						a.colorFromHsv(null, null, 1);
						a.colorizeCurrentItemColor(c[0]);
						var f = a.$(c[0].saturationCurrent);
						if (f) {
							f.style.top = "-108px"
						}
					}
					a.updateColorItemValue(c[0], d);
					a.colorizeSaturationItemColor(c[0])
				} else {
					if (b.parentNode.id && b.parentNode.id.match(/-cX-List-Item-Color-Saturation-/)) {
						a.changingColorItemOn = "saturation";
						a.updateColorItemValue(c[0], d)
					}
				}
			}
			a.cancelEvent(d);
			return false
		}
	}(this);
	this.mousedownMenuItemSlider = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingSliderItemOn = a.getTargetEvent(b);
			return false
		}
	}(this);
	this.mousedownMenuItem = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.fastScrollMenuOn = true;
			a.fastScrollMenu = this.setInterval(function() {
				a.clickMenuItem(b)
			}, 100);
			return false
		}
	}(this);
	this.mouseupMenuItem = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.fastScrollMenuOn) {
				a.fastScrollMenuOn = false;
				clearInterval(a.fastScrollMenu)
			}
		}
	}(this);
	this.mousewheelMenuItem = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.cancelEvent(g);
			var h = 0;
			if (g.wheelDelta) {
				h = g.wheelDelta;
				if (window.opera) {
					h = -h
				}
			} else {
				if (g.detail) {
					h = -g.detail
				}
			}
			if (h) {
				var b = a.getTargetEvent(g);
				var f = a.getMenuItemComp(g);
				if (!f) {
					return false
				}
				var c = f[0].parentNode;
				if (h > 0) {
					a.pageMenuItem(c, "Top")
				} else {
					a.pageMenuItem(c, "Bottom")
				}
			}
			return false
		}
	}(this);
	this.getMenuItemComp = function(b) {
		var a = this.getTargetEvent(b);
		while (a && a.tagName && !a.tagName.match(/li/i)) {
			a = a.parentNode
		}
		return a.parentNode && a.parentNode.parentNode ? [a, a.firstChild, a.parentNode.parentNode] : false
	};
	this.hideMenu = function(e, f) {
		if (e) {
			if (e[0].className.match(/Scroll/) || e[1].className.match(/Scroll/)) {
				var g = e[0].className.match(/Scroll/) ? e[0] : e[1];
				g.className = g.className.replace("Active", "")
			} else {
				if (e[1].menu) {
					e[1].className = "CanvasXpressListItemAArrow"
				} else {
					e[1].className = "CanvasXpressListItemA"
				}
				e[0].className = "CanvasXpressListItem"
			}
		}
		if (f) {
			var b = f.firstChild.childNodes;
			for (var d = 0; d < b.length; d++) {
				var a = b[d];
				if (!a.className.match(/Scroll|ItemSep/)) {
					this.addRemoveItemListeners("removeEvtListener", a)
				}
			}
			f.parentNode.removeChild(f)
		}
	};
	this.hideMenusRecursively = function(e) {
		for (var f = 0; f < e.length; f++) {
			var c = e[f];
			if (!c.className.match(/Scroll|ItemSep/)) {
				var d = c.firstChild;
				var b = d.menu ? this.$(d.menuId) : false;
				if (b) {
					this.hideMenusRecursively(b.firstChild.childNodes)
				}
				this.hideMenu([c, d], b)
			}
		}
	};
	this.removeMenus = function(k) {
		var f = [];
		if (this.skipHeaderMouseout) {
			this.skipHeaderMouseout.className = "CanvasXpressTableCellHead";
			this.skipHeaderMouseout.firstChild.firstChild.className = "CanvasXpressTableCellHead";
			this.skipHeaderMouseout = false
		}
		if (!k) {
			var c = this.$("north-wrapper-" + this.target);
			if (c) {
				var h = c.getElementsByTagName("div");
				for (var g = 0; g < h.length; g++) {
					if (this.hasClass(h[g], "CanvasXpressMenu")) {
						f.unshift(this.$(h[g].id))
					}
				}
			}
			this.menuIndex = 10000
		} else {
			f.push(this.$(this.target + "-cX-Menu-" + k))
		}
		if (f.length > 0) {
			for (g in this.meta.ids) {
				if (g.match(/cX-Menu-|cX-Menu/)) {
					delete(this.meta.ids[g])
				}
			}
			for (var g = 0; g < f.length; g++) {
				var a = f[g];
				var b = a.getElementsByTagName("li");
				for (var e = 0; e < b.length; e++) {
					if (b[e].className != "CanvasXpressListItemSep") {
						this.addRemoveItemListeners("removeEvtListener", b[e])
					}
				}
				a.parentNode.removeChild(a)
			}
		}
	};
	this.changeTextColorAttributeMenu = function(a, b) {
		return this.isArray(b) ? [
			[a, "changeTextColorAttribute", b]
		] : [
			[a, "changeTextColorAttribute", [b]]
		]
	};
	this.getAxisLayoutTypeMenu = function() {
		var a = [];
		a.push(["Complete - Both", this.scatterPlotMatrixType == "completeBoth" ? "radioOn" : "radioOff", "changeLayoutType", ["completeBoth"]]);
		a.push(["Complete - Upper", this.scatterPlotMatrixType == "completeUpper" ? "radioOn" : "radioOff", "changeLayoutType", ["completeUpper"]]);
		a.push(["Complete - Lower", this.scatterPlotMatrixType == "completeLower" ? "radioOn" : "radioOff", "changeLayoutType", ["completeLower"]]);
		a.push(["First", this.scatterPlotMatrixType == "first" ? "radioOn" : "radioOff", "changeLayoutType", ["first"]]);
		return a
	};
	this.getAxisLayoutMenu = function() {
		var a = [];
		a.push(["Auto-Adjust", this.layoutAdjust ? "lightbulb" : "lightbulbOff", "toggleAttribute", ["layoutAdjust"]]);
		a.push(["Type", false, false, false, false, "getAxisLayoutTypeMenu", []]);
		return a
	};
	this.getAxisSampleMenu = function(c) {
		var d = [];
		var a = this.getObjectArray(this[c + "Axis"]);
		for (var b = 0; b < this.data.y.smps.length; b++) {
			d.push([this.data.y.smps[b], a[this.data.y.smps[b]] ? "checked" : "unchecked", "changeSampleInAxis", [this.data.y.smps[b], c + "Axis"]])
		}
		return d
	};
	this.getAxisMenu = function(e, d) {
		var c = e.toUpperCase();
		var b = d ? "2" : "";
		var a = [];
		a.push([this[e + "Axis" + b + "Show"] ? "Hide Axis" : "Show Axis", this[e + "AxisShow"] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [e + "Axis" + b + "Show"]]);
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMin" + c + b]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMax" + c + b]]);
		a.push(["Transform", "transform", false, false, false, "getAxisTransformMenu", [e]]);
		if (this.graphType == "Scatter3D" || this.graphType == "ScatterBubble2D" || this.is3DPlot) {
			a.push(["Exact Range", "exactValue", "toggleAttribute", [e + "AxisExact"]])
		}
		a.push(["Format", "format", false, false, false, "changeTextColorAttributeMenu", ["-text-", e + "Axis" + b + "TickFormat"]]);
		if (this.graphType.match(/Scatter/)) {
			a.push(["Samples", "samples", false, false, false, "getAxisSampleMenu", [e]])
		}
		return a
	};
	this.getFirstAxisMenu = function() {
		return [
			[this.xAxisShow ? "Hide Axis" : "Show Axis", this.xAxisShow ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["xAxisShow"]]
		]
	};
	this.getSecondAxisMenu = function() {
		return [
			[this.xAxis2Show ? "Hide Axis" : "Show Axis", this.xAxis2Show ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["xAxis2Show"]]
		]
	};
	this.getRangeAxisMenu = function() {
		var a = [];
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMinX"]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMaxX"]]);
		return a
	};
	this.getAxesMenu = function() {
		var a = [];
		if (this.graphType == "Scatter2D") {
			a.push(["X-Axis", "xAxis", false, false, false, "getAxisMenu", ["x"]]);
			a.push(["Y-Axis", "yAxis", false, false, false, "getAxisMenu", ["y"]]);
			a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
			a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]]);
			if (this.scatterPlotMatrix) {
				a.push(["Axes Layout", false, false, false, false, "getAxisLayoutMenu", []])
			}
		} else {
			if (this.graphType == "Scatter3D" || this.graphType == "ScatterBubble2D" || this.is3DPlot) {
				a.push(["X-Axis", "xAxis", false, false, false, "getAxisMenu", ["x"]]);
				a.push(["Y-Axis", "yAxis", false, false, false, "getAxisMenu", ["y"]]);
				a.push(["Z-Axis", "zAxis", false, false, false, "getAxisMenu", ["z"]]);
				a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
				a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]])
			} else {
				if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
					a.push(["First Axis", "firstAxis", false, false, false, "getAxisMenu", ["x"]]);
					a.push(["Second Axis", "secondAxis", false, false, false, "getAxisMenu", ["x", true]]);
					a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
					a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]])
				} else {
					a.push(["First Axis", "firstAxis", false, false, false, "getFirstAxisMenu", []]);
					a.push(["Second Axis", "secondAxis", false, false, false, "getSecondAxisMenu", []]);
					a.push(["Range", "range", false, false, false, "getRangeAxisMenu", []]);
					a.push(["Format", "format", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTickFormat"]]);
					a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
					a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]]);
					if (this.layoutValid) {
						a.push(["Auto-Adjust", this.layoutAdjust ? "lightbulb" : "lightbulbOff", "toggleAttribute", ["layoutAdjust"]])
					}
				}
			}
		}
		return a
	};
	this.getHeatmapBoxMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "heatmapCellBoxColor"]]);
		a.push(["Width", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapCellBoxWidth"]]);
		a.push([this.heatmapCellBox ? "Hide Box" : "Show Box", this.heatmapCellBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["heatmapCellBox"]]);
		return a
	};
	this.getHeatmapHighlightMenu = function() {
		return [
			["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "heatmapCellBoxColorHighlight"]]
		]
	};
	this.getHeatmapVarSmpSeparatorsMenu = function(h, d, j) {
		var e = this.meta.data;
		var k = [];
		if (e[h] && d.length > 0) {
			var f = {};
			for (var g = 0; g < d.length; g++) {
				var a = d[g];
				if (e[h][a].type != "Numeric") {
					f[a] = true
				}
			}
			var b = this.sortObject(f);
			for (var g = 0; g < b.length; g++) {
				k.push([b[g], b[g] == this[j] ? "radioOn" : "radioOff", "changeAttribute", [j, b[g]]])
			}
		}
		return k
	};
	this.getHeatmapSeparatorsMenu = function() {
		var a = [];
		if (this.isStringOverlays("v")) {
			a.push(["Variables", "variables", false, false, false, "getHeatmapVarSmpSeparatorsMenu", ["z", this.varOverlays, "heatmapVarSeparateBy"]])
		}
		if (this.isStringOverlays("s")) {
			a.push(["Samples", "samples", false, false, false, "getHeatmapVarSmpSeparatorsMenu", ["x", this.smpOverlays, "heatmapSmpSeparateBy"]])
		}
		return a
	};
	this.getHeatmapMenu = function() {
		var a = [];
		a.push(["Cell Boxes", "border", false, false, false, "getHeatmapBoxMenu", []]);
		a.push(["Highlight", "heatmapHighlight", false, false, false, "getHeatmapHighlightMenu", []]);
		if (this.isStringOverlays()) {
			a.push(["Separators", "heatmapSeparate", false, false, false, "getHeatmapSeparatorsMenu", []])
		}
		return a
	};
	this.getPlotAreaMajorTicksMenu = function(a) {
		return [
			[this[a] ? "Hide Major Ticks" : "Show Major Ticks", this[a] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [a]]
		]
	};
	this.getPlotAreaMinorTicksMenu = function(a) {
		return [
			[this[a] ? "Hide Minor Ticks" : "Show Minor Ticks", this[a] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [a]]
		]
	};
	this.getPlotAreaTickTypeMenu = function(a) {
		var b = [];
		b.push(["Solid", "axesTickTypeSolid", "changeAttribute", [a, "solid"]]);
		b.push(["Dotted", "axesTickTypeDotted", "changeAttribute", [a, "dotted"]]);
		return b
	};
	this.getPlotAreaGridMenu = function(b) {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", b + "AxisTickColor"]]);
		if (this.graphType != "Scatter3D" && !this.is3DPlot) {
			a.push(["Major Ticks", "axesMinorTicks", false, false, false, "getPlotAreaMajorTicksMenu", [b + "AxisMajorTicks"]]);
			a.push(["Minor Ticks", "axesMinorTicks", false, false, false, "getPlotAreaMinorTicksMenu", [b + "AxisMinorTicks"]]);
			a.push(["Number", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", b + "AxisTicks"]])
		}
		a.push(["Style", "axesTickType", false, false, false, "getPlotAreaTickTypeMenu", [b + "AxisTickStyle"]]);
		return a
	};
	this.getPlotAreaScatterGridMenu = function() {
		var a = [];
		if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
			a.push(["X-Axis", "xGridS", false, false, false, "getPlotAreaGridMenu", ["x"]]);
			a.push(["Y-Axis", "yGridS", false, false, false, "getPlotAreaGridMenu", ["y"]])
		} else {
			if (this.graphType == "Scatter3D" || this.is3DPlot) {
				a.push(["X-Axis", "xGridS", false, false, false, "getPlotAreaGridMenu", ["x"]]);
				a.push(["Y-Axis", "yGridS", false, false, false, "getPlotAreaGridMenu", ["y"]]);
				a.push(["Z-Axis", "zGridS", false, false, false, "getPlotAreaGridMenu", ["z"]])
			}
		}
		return a
	};
	this.getPlotAreaAxisAlgorithmMenu = function() {
		var a = [];
		a.push(["Heckbert", this.axisAlgorithm == "heckbert" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "heckbert"]]);
		a.push(["R Pretty", this.axisAlgorithm == "rPretty" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "rPretty"]]);
		a.push(["Wilkinson", this.axisAlgorithm == "wilkinson" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "wilkinson"]]);
		a.push(["Wilkinson Extended", this.axisAlgorithm == "wilkinsonExtended" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "wilkinsonExtended"]]);
		return a
	};
	this.getPlotAreaBarsTypeMenu = function() {
		var a = [];
		a.push(["Standard Deviation", this.errorBarsType == "standardDeviation" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "standardDeviation"]]);
		a.push(["Standard Error of Mean", this.errorBarsType == "standardErrorMean" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "standardErrorMean"]]);
		a.push(["95% Confidence Interval", this.errorBarsType == "confidenceInterval95" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "confidenceInterval95"]]);
		return a
	};
	this.getPlotAreaErrorBarsMenu = function() {
		var a = [];
		a.push(["Error Bars Type", false, false, false, false, "getPlotAreaBarsTypeMenu", []]);
		a.push([this.showErrorBars ? "Hide Error Bars" : "Show Error Bars", this.showErrorBars ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showErrorBars"]]);
		return a
	};
	this.getPlotAreaOneVariableSpaceMenu = function() {
		var a = [];
		a.push(["Farther", "spaceFarther", "setFontAttributeSize", ["variableSeparationFactor", "increase"]]);
		a.push(["Closer", "spaceCloser", "setFontAttributeSize", ["variableSeparationFactor", "decrease"]]);
		return a
	};
	this.getPlotAreaOneSampleWidthMenu = function() {
		var a = [];
		a.push(["Wider", "widthSpaceWider", "setFontAttributeSize", ["widthFactor", "increase"]]);
		a.push(["Thinner", "widthSpaceThinner", "setFontAttributeSize", ["widthFactor", "decrease"]]);
		return a
	};
	this.getPlotAreaOneMenu = function() {
		var b = [];
		b.push(["Axis Algorithm", "gridS", false, false, false, "getPlotAreaAxisAlgorithmMenu", []]);
		b.push(["Error Bars", "errorBars", false, false, false, "getPlotAreaErrorBarsMenu", []]);
		b.push(["Border Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "plotBoxColor"]]);
		b.push([this.plotBox ? "Hide Border" : "Show Border", this.plotBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["plotBox"]]);
		if (this.graphType.match(/Dot|Boxplot/)) {
			b.push(["Jitter", "jitter", "toggleAttribute", ["jitter"]])
		}
		if (this.graphType == "Boxplot") {
			b.push(["Plot Data", "bpdata", "toggleAttribute", ["showBoxplotOriginalData"]]);
			b.push(["Violin", "violinOn", "toggleAttribute", ["showViolinBoxplot"]]);
			b.push(["Connect Boxplot", "connects", "toggleAttribute", ["boxplotConnect"]])
		}
		if (this.graphType.match(/Bar|Boxplot/) && this.data.y.vars.length > 1) {
			b.push(["Variable Space", "spaceWidth", false, false, false, "getPlotAreaOneVariableSpaceMenu", []])
		}
		b.push(["Sample Width", "widthSpace", false, false, false, "getPlotAreaOneSampleWidthMenu", []]);
		return b
	};
	this.getPlotAreaScatterMenu = function() {
		var b = [];
		b.push(["Axis Algorithm", "gridS", false, false, false, "getPlotAreaAxisAlgorithmMenu", []]);
		b.push(["Error Bars", "errorBars", false, false, false, "getPlotAreaErrorBarsMenu", []]);
		b.push(["Border Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "plotBoxColor"]]);
		b.push([this.plotBox ? "Hide Border" : "Show Border", this.plotBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["plotBox"]]);
		return b
	};
	this.getAxesTitleXMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTitle"]]
		]
	};
	this.getAxesTitleX2Menu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxis2Title"]]
		]
	};
	this.getAxesTitleYMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "yAxisTitle"]]
		]
	};
	this.getAxesTitleZMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "zAxisTitle"]]
		]
	};
	this.getAxesTitleMenu = function() {
		var a = [];
		if (this.graphType.match(/scatter/i) || this.is3DPlot) {
			a.push(["X-Axis", "xAxisTitleS", false, false, false, "getAxesTitleXMenu", []]);
			a.push(["Y-Axis", "yAxisTitleS", false, false, false, "getAxesTitleYMenu", []]);
			if (this.graphType == "Scatter3D" || this.is3DPlot) {
				a.push(["Z-Axis", "zAxisTitleS", false, false, false, "getAxesTitleZMenu", []])
			}
		} else {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
				a.push(["First Axis", "firstAxisTitle", false, false, false, "getAxesTitleXMenu", []]);
				a.push(["Second Axis", "secondAxisTitle", false, false, false, "getAxesTitleX2Menu", []])
			} else {
				a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTitle"]])
			}
		}
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTitleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTitle"]]);
		return a
	};
	this.getTitleMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "titleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["title"]]);
		a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "title"]]);
		return a
	};
	this.getSubtitleMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "subtitleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["subtitle"]]);
		a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "subtitle"]]);
		return a
	};
	this.getTitleSubtitleMenu = function() {
		var a = [];
		if (this.graphType.match(/scatter/i) || this.is3DPlot) {
			a.push(["Title", "titleS", false, false, false, "getTitleMenu", []]);
			a.push(["Subtitle", "subtitleS", false, false, false, "getSubtitleMenu", []])
		} else {
			a.push(["Title", this.graphType == "Heatmap" ? "titleH" : "title", false, false, false, "getTitleMenu", []]);
			a.push(["Subtitle", this.graphType == "Heatmap" ? "subtitleH" : "subtitle", false, false, false, "getSubtitleMenu", []])
		}
		return a
	};
	this.getLegendLocationMenu = function() {
		var a = [];
		a.push(["Inside Plot", "legendInside", "changeAttribute", ["legendInside", true]]);
		a.push(["Outside Plot", "legendOutside", "changeAttribute", ["legendInside", false]]);
		return a
	};
	this.getLegendPositionMenu = function() {
		var a = [];
		if (this.legendInside) {
			a.push(["Top", "legendInsideTop", "changeAttribute", ["legendPosition", "top"]]);
			a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["legendPosition", "topRight"]]);
			a.push(["Right", "legendInsideRight", "changeAttribute", ["legendPosition", "right"]]);
			a.push(["Bottom Right", "legendInsideBottomRight", "changeAttribute", ["legendPosition", "bottomRight"]]);
			a.push(["Bottom", "legendInsideBottom", "changeAttribute", ["legendPosition", "bottom"]]);
			a.push(["Bottom Left", "legendInsideBottomLeft", "changeAttribute", ["legendPosition", "bottomLeft"]]);
			a.push(["Left", "legendInsideLeft", "changeAttribute", ["legendPosition", "left"]]);
			a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["legendPosition", "topLeft"]])
		} else {
			a.push(["Bottom", "bottom", "changeAttribute", ["legendPosition", "bottom"]]);
			a.push(["Right", "right", "changeAttribute", ["legendPosition", "right"]])
		}
		return a
	};
	this.getLegendBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendBoxColor"]]);
		a.push([this.legendBox ? "Hide Border" : "Show Border", this.legendBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["legendBox"]]);
		return a
	};
	this.getLegendMenu = function() {
		var a = [];
		a.push(["Border", "border", false, false, false, "getLegendBorderMenu", []]);
		a.push(["Background", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendBackgroundColor"]]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["legend"]]);
		a.push(["Position", this.legendInside ? "legendInsidePosition" : "positionRightBottom", false, false, false, "getLegendPositionMenu", []]);
		a.push(["Location", "legendLocation", false, false, false, "getLegendLocationMenu", []]);
		a.push(["Columns", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "legendColumns"]]);
		a.push(["Reset Positions", "refreshForm", "resetLegendPosition"]);
		a.push([this.showLegend ? "Hide Legend" : "Show Legend", this.showLegend ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showLegend"]]);
		return a
	};
	this.getIndicatorPositionMenu = function() {
		var a = [];
		a.push(["Right", "legendInsideRight", "changeAttribute", ["heatmapIndicatorPosition", "right"]]);
		a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["heatmapIndicatorPosition", "topRight"]]);
		a.push(["Top", "legendInsideTop", "changeAttribute", ["heatmapIndicatorPosition", "top"]]);
		a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["heatmapIndicatorPosition", "topLeft"]]);
		return a
	};
	this.getIndicatorMenu = function() {
		var a = [];
		a.push(["Position", "legendInsidePosition", false, false, false, "getIndicatorPositionMenu", []]);
		a.push(["Height", "heightSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapIndicatorHeight"]]);
		a.push(["Width", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapIndicatorWidth"]]);
		a.push(["Histogram", "indicatorHistogram", "toggleAttribute", ["heatmapIndicatorHistogram"]]);
		a.push([this.showHeatmapIndicator ? "Hide Indicator" : "Show Indicator", this.showHeatmapIndicator ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showHeatmapIndicator"]]);
		return a
	};
	this.getDecorationsBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsBoxColor"]]);
		a.push([this.decorationsBox ? "Hide Border" : "Show Border", this.decorationsBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["decorationsBox"]]);
		return a
	};
	this.getDecorationsPositionMenu = function() {
		var a = [];
		if (this.legendInside) {
			a.push(["Top", "legendInsideTop", "changeAttribute", ["decorationsPosition", "top"]]);
			a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["decorationsPosition", "topRight"]]);
			a.push(["Right", "legendInsideRight", "changeAttribute", ["decorationsPosition", "right"]]);
			a.push(["Bottom Right", "legendInsideBottomRight", "changeAttribute", ["decorationsPosition", "bottomRight"]]);
			a.push(["Bottom", "legendInsideBottom", "changeAttribute", ["decorationsPosition", "bottom"]]);
			a.push(["Bottom Left", "legendInsideBottomLeft", "changeAttribute", ["decorationsPosition", "bottomLeft"]]);
			a.push(["Left", "legendInsideLeft", "changeAttribute", ["decorationsPosition", "left"]]);
			a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["decorationsPosition", "topLeft"]])
		} else {
			a.push(["Bottom", "bottom", "changeAttribute", ["decorationsPosition", "bottom"]]);
			a.push(["Right", "right", "changeAttribute", ["decorationsPosition", "right"]])
		}
		return a
	};
	this.getDecorationsDataMenu = function() {
		return [
			[this.showDecorations ? "Hide Decorations" : "Show Decorations", this.showDecorations ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showDecorations"]]
		]
	};
	this.getDecorationsLegendMenu = function() {
		return [
			[this.showDecorationsLegend ? "Hide Decorations Legend" : "Show Decorations Legend", this.showDecorationsLegend ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showDecorationsLegend"]]
		]
	};
	this.getDecorationsConfidenceIntervalsMenu = function() {
		var b = this.decorations;
		var a = b.reg ? "correlationConfidence" : "kaplanMeier";
		var c = b.reg ? "showDecorationsRegressionConfidence" : "showDecorationsKaplanMeierConfidence";
		return [
			[this[c] ? "Hide Confidence Intervals" : "Show Confidence Intervals", this[c] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [c]]
		]
	};
	this.getDecorationsMenu = function() {
		var b = this.decorations;
		var a = [];
		a.push(["Border", "border", false, false, false, "getDecorationsBorderMenu", []]);
		a.push(["Background", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsBackgroundColor"]]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["decoration"]]);
		a.push(["Position", this.legendInside ? "legendInsidePosition" : "positionRightBottom", false, false, false, "getDecorationsPositionMenu", []]);
		a.push(["Data and Legend", "data", false, false, false, "getDecorationsDataMenu", []]);
		a.push(["Legend", "legendS", false, false, false, "getDecorationsLegendMenu", []]);
		if (b.reg || b.kaplanMeier) {
			a.push(["Confidence Intervals", ic, false, false, false, "getDecorationsConfidenceIntervalsMenu", []])
		}
		return a
	};
	this.getOverlaysMemebersMenu = function(g, b) {
		var f = [];
		var e = {};
		for (var a = 0; a < this[b + "Overlays"].length; a++) {
			e[this[b + "Overlays"][a]] = true
		}
		var d = this.sortObject(this.data[g]);
		for (var a = 0; a < d.length; a++) {
			f.push([d[a], e[d[a]] ? "checked" : "unchecked", b == "var" ? "showVariableOverlays" : "showSampleOverlays", [d[a]]])
		}
		return f
	};
	this.getOverlaysPositionMemberMenu = function(a, b) {
		var c = [];
		if (a == "var") {
			c.push(["Bottom", "bottom", "modifyOverlaysProperties", ["bottom", a + "OverlayProperties", b, "position"]]);
			c.push(["Top", "top", "modifyOverlaysProperties", ["top", a + "OverlayProperties", b, "position"]])
		} else {
			if (this.graphType == "Heatmap" || this.graphOrientation == "horizontal") {
				c.push(["Left", "left", "modifyOverlaysProperties", ["left", a + "OverlayProperties", b, "position"]]);
				c.push(["Right", "right", "modifyOverlaysProperties", ["right", a + "OverlayProperties", b, "position"]])
			} else {
				c.push(["Bottom", "bottom", "modifyOverlaysProperties", ["bottom", a + "OverlayProperties", b, "position"]]);
				c.push(["Top", "top", "modifyOverlaysProperties", ["top", a + "OverlayProperties", b, "position"]])
			}
		}
		return c
	};
	this.getOverlaysPositionMenu = function(f, b) {
		var e = [];
		var d = this.sortObject(this.data[f]);
		for (var a = 0; a < d.length; a++) {
			e.push([d[a], false, false, false, false, "getOverlaysPositionMemberMenu", [b, d[a]]])
		}
		return e
	};
	this.getOverlaysThicknessMenu = function(f, b) {
		var e = [];
		var d = this.sortObject(this.data[f]);
		for (var a = 0; a < d.length; a++) {
			e.push([d[a], false, false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyOverlaysProperties", [b + "OverlayProperties", d[a], "thickness"]]]])
		}
		return e
	};
	this.getOverlaysColorSchemesMenu = function(g, f) {
		var e = [];
		var b = this.meta.data[g];
		var a = this.getColorSchemes();
		for (var d = 0; d < a.length; d++) {
			e.push([a[d], b[f].spectrum == a[d] ? "radioOn" : "radioOff", "modifyColorProperties", [a[d], f, g, "String"]])
		}
		return e
	};
	this.getOverlaysColorMenu = function(g, d) {
		var f = [];
		var a = this.meta.data[g];
		var e = this.sortObject(this.data[g]);
		for (var b = 0; b < e.length; b++) {
			if (this.isNumeric(this.data[g][e[b]])) {
				if (this[d + "OverlayProperties"][e[b]] && this[d + "OverlayProperties"][e[b]].type && this[d + "OverlayProperties"][e[b]].type == "Heatmap") {
					f.push([e[b], false, false, false, false, "getColorSpectrumMenu", [a[e[b]].colorBrew.spectrum, "modifyColorProperties", e[b], g, "Numeric"]])
				} else {
					f.push([e[b], false, false, false, false, "changeTextColorAttributeMenu", ["-color-", [false, "modifyOverlaysProperties", [d + "OverlayProperties", e[b], "color"]]]])
				}
			} else {
				f.push([e[b], false, false, false, false, "getOverlaysColorSchemesMenu", [g, e[b]]])
			}
		}
		return f
	};
	this.getOverlaysGraphTypeMenu = function(d, f) {
		var e = [];
		var b = ["Area", "AreaLine", "Bar", "BarLine", "Dotplot", "DotLine", "Heatmap", "Line", "Pie", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Treemap"];
		var a = ["area", "areaLine", "bar", "barLine", "dotplot", "dotplotLine", "heatmap", "line", "pie", "stacked", "stackedPercent", "stackedPercent", "stackedPercentLine", "treemap"];
		for (var c = 0; c < b.length; c++) {
			e.push([b[c], a[c], "modifyOverlaysProperties", [b[c], d + "OverlayProperties", f, "type"]])
		}
		return e
	};
	this.getOverlaysGraphDefaultMenu = function(a, c) {
		var b = [];
		b.push(["Default", "heatmap", "modifyOverlaysProperties", ["Heatmap", a + "OverlayProperties", c, "type"]]);
		b.push(["Text", "ut", "modifyOverlaysProperties", ["Text", a + "OverlayProperties", c, "type"]]);
		b.push(["Treemap", "treemap", "modifyOverlaysProperties", ["Treemap", a + "OverlayProperties", c, "type"]]);
		return b
	};
	this.getOverlaysGraphMenu = function(g, d) {
		var f = [];
		var a = this.meta.data[g];
		var e = this.sortObject(this.data[g]);
		for (var b = 0; b < e.length; b++) {
			if (this.isNumeric(this.data[g][e[b]])) {
				f.push([e[b], false, false, false, false, "getOverlaysGraphTypeMenu", [d, e[b]]])
			} else {
				f.push([e[b], false, false, false, false, "getOverlaysGraphDefaultMenu", [d, e[b]]])
			}
		}
		return f
	};
	this.getOverlaysPropertiesMenu = function(d, a) {
		var b = [];
		if (a == "var") {
			b.push(["Position", "positionTopBottom", false, false, false, "getOverlaysPositionMenu", [d, a]])
		} else {
			if (this.graphType == "Heatmap" || this.graphOrientation == "vertical") {
				b.push(["Position", "positionLeftRight", false, false, false, "getOverlaysPositionMenu", [d, a]])
			} else {
				b.push(["Position", "positionTopBottom", false, false, false, "getOverlaysPositionMenu", [d, a]])
			}
		}
		b.push(["Thickness", "widthSpace", false, false, false, "getOverlaysThicknessMenu", [d, a]]);
		b.push(["Color", "colors", false, false, false, "getOverlaysColorMenu", [d, a]]);
		b.push(["Type", "graphType", false, false, false, "getOverlaysGraphMenu", [d, a]]);
		return b
	};
	this.getLegendOverlaysPositionMenu = function() {
		var a = [];
		a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["overlaysLegendPosition", "topRight"]]);
		a.push(["Right", "right", "changeAttribute", ["overlaysLegendPosition", "right"]]);
		a.push(["Bottom Left", "legendInsideBottomLeft", "changeAttribute", ["overlaysLegendPosition", "bottomLeft"]]);
		a.push(["Bottom", "bottom", "changeAttribute", ["overlaysLegendPosition", "bottom"]]);
		return a
	};
	this.getLegendOverlaysMenu = function(a) {
		var b = "show" + a + "OverlaysLegend";
		return [
			[this[b] ? "Hide Legend" : "Show Legend", this[b] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [b]]
		]
	};
	this.getOverlaysMenu = function() {
		var a = [];
		if (this.graphType == "Heatmap" && this.data.z) {
			a.push(["Variable Overlays", "overlaysVariables", false, false, false, "getOverlaysMemebersMenu", ["z", "var"]]);
			a.push(["Variable Overlays Properties", "overlaysVariablesEdit", false, false, false, "getOverlaysPropertiesMenu", ["z", "var"]]);
			a.push(["Variable Overlays Legend", "legends", false, false, false, "getLegendOverlaysMenu", ["Var"]]);
			a.push(["-"])
		}
		if (this.data.x) {
			a.push(["Sample Overlays", this.graphType == "Heatmap" ? "overlaysSamplesH" : "overlaysSamples1", false, false, false, "getOverlaysMemebersMenu", ["x", "smp"]]);
			a.push(["Sample Overlays Properties", this.graphType == "Heatmap" ? "overlaysSamplesHEdit" : "overlaysSamples1Edit", false, false, false, "getOverlaysPropertiesMenu", ["x", "smp"]]);
			a.push(["Sample Overlays Legend", "legends", false, false, false, "getLegendOverlaysMenu", ["Smp"]]);
			a.push(["-"])
		}
		a.push(["Overlays Legend Position", "positionRightBottom", false, false, false, "getLegendOverlaysPositionMenu", []]);
		a.push(["-"]);
		a.push(["Label Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "overlayFontColor"]]);
		a.push(["Label Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["overlay"]]);
		a.push(["Default Thickness", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "overlaysThickness"]]);
		if (this.data.x || this.data.z) {
			a.push([this.showOverlays ? "Hide Overlays" : "Show Overlays", this.showOverlays ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showOverlays"]])
		}
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Overlays"]]);
		return a
	};
	this.getBinDataPercentileMenu = function(d) {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			if (d) {
				b.push([this.data.y.vars[a], "radioOff", "binDataByPercentile", [a, true]])
			} else {
				b.push([this.data.y.vars[a], "radioOff", "binDataByPercentile", [a]])
			}
		}
		return b
	};
	this.getBinDataQuantileMenu = function(d) {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			if (d) {
				b.push([this.data.y.vars[a], "radioOff", "binDataByQuantile", [a, true]])
			} else {
				b.push([this.data.y.vars[a], "radioOff", "binDataByQuantile", [a]])
			}
		}
		return b
	};
	this.getBinDataCustomBinMenu = function(b) {
		var c = [];
		for (var a = 2; a < 9; a++) {
			c.push([a + " bins", "radioOff", "binDataCustom", [b, a]])
		}
		return c
	};
	this.getBinDataCustomMenu = function() {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			b.push([this.data.y.vars[a], false, false, false, false, "getBinDataCustomBinMenu", [a]])
		}
		return b
	};
	this.getBinDataMenu = function() {
		var a = [];
		a.push(["By Percentile Discrete", "prcnt", false, false, false, "getBinDataPercentileMenu", []]);
		a.push(["By Percentile Continuous", "prcnt", false, false, false, "getBinDataPercentileMenu", [true]]);
		a.push(["By Quantile Discrete", "uq", false, false, false, "getBinDataQuantileMenu", []]);
		a.push(["By Quantile Continuous", "uq", false, false, false, "getBinDataQuantileMenu", [true]]);
		a.push(["Custom", "uc", false, false, false, "getBinDataCustomMenu", []]);
		return a
	};
	this.getGroupSamplesMenu = function() {
		if (this.data.x) {
			var d = [];
			var b = {};
			var a = this.sortObject(this.data.x);
			for (var c = 0; c < this.groupingFactors.length; c++) {
				b[this.groupingFactors[c]] = true
			}
			for (var c = 0; c < a.length; c++) {
				d.push([a[c], b[a[c]] ? "checked" : "unchecked", "showSampleGroups", [a[c]]])
			}
			return d
		} else {
			return false
		}
	};
	this.getSmpLabelHighlightLevelMenu = function() {
		var c = [];
		var b = {};
		var d = this.isGroupedData ? this.data.w : this.data.y;
		for (var a = 0; a < this.highlightSmp.length; a++) {
			b[this.highlightSmp[a]] = true
		}
		for (var a = 0; a < d.smps.length; a++) {
			c.push([d.smps[a], b[d.smps[a]] ? "checked" : "unchecked", "modifyObjectArray", [d.smps[a], false, "highlightSmp", true, true]])
		}
		return c
	};
	this.getSmpLabelHighlightMenu = function() {
		var a = [];
		a.push(["Samples", "samples", false, false, false, "getSmpLabelHighlightLevelMenu", []]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "smpHighlightColor"]]);
		return a
	};
	this.getSmpLabelMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "smpLabelFontColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["smpLabel"]]);
		a.push(["Highlight", this.graphType == "Heatmap" ? "highlightSampleLabelsH" : "highlightSampleLabels1", false, false, false, "getSmpLabelHighlightMenu", []]);
		a.push(["Interval", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "smpLabelInterval"]]);
		a.push(["Rotate", "rotateClockwise", false, false, false, "changeTextColorAttributeMenu", ["-text-", "smpLabelRotate"]]);
		a.push([this.showSampleNames ? "Hide Labels" : "Show Labels", this.showSampleNames ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showSampleNames"]]);
		return a
	};
	this.getVarLabelHighlightLevelMenu = function() {
		var d = [];
		var c = {};
		var a = this.data.y.vars;
		for (var b = 0; b < this.highlightVar.length; b++) {
			c[this.highlightVar[b]] = true
		}
		for (var b = 0; b < a.length; b++) {
			d.push([a[b], c[a[b]] ? "checked" : "unchecked", "modifyObjectArray", [a[b], false, "highlightVar", true, true]])
		}
		return d
	};
	this.getVarLabelHighlightMenu = function() {
		var a = [];
		a.push(["Variables", "variables", false, false, false, "getVarLabelHighlightLevelMenu", []]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "varHighlightColor"]]);
		return a
	};
	this.getVarLabelMenu = function(b) {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "varLabelFontColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["varLabel"]]);
		a.push(["Highlight", "highlightVariableLabelsH", false, false, false, "getVarLabelHighlightMenu", []]);
		a.push(["Interval", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "varLabelInterval"]]);
		a.push(["Rotate", "rotateClockwise", false, false, false, "changeTextColorAttributeMenu", ["-text-", "varLabelRotate"]]);
		a.push([this.showVariableNames ? "Hide Labels" : "Show Labels", this.showVariableNames ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showVariableNames"]]);
		return a
	};
	this.getGraphPartMenu = function(c, b) {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", c + (b ? "FontColor" : "Color")]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", [c]]);
		a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", c]]);
		return a
	};
	this.getFontStyleMenu = function(c) {
		var b = [];
		var a = "ScaleFontFactor";
		b.push(["Bigger", "biggerFont", "setFontAttributeSize", [c + a, "increase"]]);
		b.push(["Smaller", "smallerFont", "setFontAttributeSize", [c + a, "decrease"]]);
		b.push(["Normal", "normalFont", "setFontAttributeStyle", [c + "FontStyle", "normal"]]);
		b.push(["Bold", "boldFont", "setFontAttributeStyle", [c + "FontStyle", "bold"]]);
		b.push(["Italic", "italicFont", "setFontAttributeStyle", [c + "FontStyle", "italic"]]);
		return b
	};
	this.getDataPointAttributesPropertySampleMenu = function(b) {
		var d = [];
		var c = this.isGroupedData ? this.data.w : this.data.y;
		for (var a = 0; a < c.smps.length; a++) {
			d.push([c.smps[a], this[b] == c.smps[a] ? "radioOn" : "radioOff", "changeAttribute", [b, c.smps[a]]])
		}
		return d
	};
	this.getDataPointAttributesPropertyMenu = function(f) {
		var g = [];
		if (f == "treemapBy") {
			var a = {};
			var b = this.sortObject(this.data.x);
			for (var c = 0; c < this.treemapBy.length; c++) {
				a[this.treemapBy[c]] = true
			}
			for (var c = 0; c < b.length; c++) {
				g.push([b[c], a[b[c]] ? "checked" : "unchecked", "showTreemapGroups", [b[c]]])
			}
		} else {
			if (this.graphType != "Line" && this.graphType != "ParallelCoordinates") {
				var e = this.graphType.match(/scatter/i) || this.graphType == "Map" ? this.sortObject(this.data.z) : this.sortObject(this.data.x);
				for (var c = 0; c < e.length; c++) {
					g.push([e[c], e[c] == this[f] ? "radioOn" : "radioOff", "changeAttribute", [f, e[c]]])
				}
				g.push(["-"])
			}
			var c = "variable";
			if (f != "connectBy") {
				g.push(["Variable", c == this[f] ? "radioOn" : "radioOff", "changeAttribute", [f, c]])
			}
			if (((!this.graphType.match(/scatter/i) && !this.graphType == "Map") || this.graphType == "Dotplot") && this.data.z) {
				var d = this.sortObject(this.data.z);
				if (f != "connectBy" || this.graphType == "Dotplot") {
					g.push(["-"])
				}
				for (var c = 0; c < d.length; c++) {
					if (f != "connectBy" || this.graphType == "Dotplot") {
						g.push([d[c], d[c] == this[f] ? "radioOn" : "radioOff", "changeAttribute", [f, d[c]]])
					}
				}
			}
			if (this.graphType == "Line" || this.graphType == "ParallelCoordinates" || this.graphType == "Map") {
				g.push(["-"]);
				g.push(["Sample", "samples", false, false, false, "getDataPointAttributesPropertySampleMenu", [f]])
			}
		}
		return g
	};
	this.getDataPointAttributesMenu = function() {
		var a = [];
		if (this.graphType != "Heatmap") {
			a.push(["Color By", "colors", false, false, false, "getDataPointAttributesPropertyMenu", ["colorBy"]])
		}
		if (this.graphType.match(/scatter/i) || this.is3DPlot || this.graphType == "Dotplot" || this.graphType == "Tree" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
			a.push(["Shape By", "shapes", false, false, false, "getDataPointAttributesPropertyMenu", ["shapeBy"]]);
			a.push(["Size By", "sizes", false, false, false, "getDataPointAttributesPropertyMenu", ["sizeBy"]])
		}
		if (!this.graphType.match(/parallelcoordinates|line/i)) {
			a.push(["Pattern By", "patterns", false, false, false, "getDataPointAttributesPropertyMenu", ["patternBy"]])
		}
		if (this.graphType.match(/scatter/i) || this.is3DPlot || this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
			a.push(["Connect By", "connects", false, false, false, "getDataPointAttributesPropertyMenu", ["connectBy"]])
		}
		if (this.graphType.match(/stacked/i) && this.data.x && this.isGroupedData) {
			a.push(["Treemap By", "treemap", false, false, false, "getDataPointAttributesPropertyMenu", ["treemapBy"]])
		}
		if (this.graphType.match(/scatter/i)) {
			a.push(["Ellipse By", "ellipses", false, false, false, "getDataPointAttributesPropertyMenu", ["ellipseBy"]])
		}
		return a
	};
	this.getDendrogramColorMenu = function(d) {
		var e = [];
		if (d) {
			var c = this.sortObject(this.data.z);
			for (var b = 0; b < c.length; b++) {
				e.push([c[b], this.colorVarDendrogramBy == c[b] ? "radioOn" : "radioOff", "changeAttribute", ["colorVarDendrogramBy", c[b]]])
			}
		} else {
			var a = this.sortObject(this.data.x);
			for (var b = 0; b < a.length; b++) {
				e.push([a[b], this.colorSmpDendrogramBy == a[b] ? "radioOn" : "radioOff", "changeAttribute", ["colorSmpDendrogramBy", a[b]]])
			}
		}
		return e
	};
	this.getDendrogramsMenu = function() {
		var a = [];
		if (this.graphType == "Tree") {
			a.push(["Radial Layout", this.treeCircular ? "checked" : "unchecked", "toggleAttribute", ["treeCircular"]]);
			a.push(["Inverted Tree", this.treeInverted ? "checked" : "unchecked", "toggleAttribute", ["treeInverted"]])
		} else {
			if (this.graphType == "Heatmap") {
				a.push(["Cluster Variable", "clusterVariables", "clusterVariables", [true]]);
				a.push(["K-Means Variable", "kmeansVariables", "kmeansVariables", [true]]);
				if (this.varDendrogram) {
					a.push(["Color Variable Cluster By", "colors", false, false, false, "getDendrogramColorMenu", [true]]);
					if (this.showVarDendrogram) {
						a.push(["Hide Dendrogram", "eyeMinusIcon", "showHideDendrogram", ["showVarDendrogram"]])
					} else {
						a.push(["Show Dendrogram", "eyePlusIcon", "showHideDendrogram", ["showVarDendrogram"]])
					}
				}
				a.push(["-"])
			}
			a.push(["Cluster Samples", "clusterSamples", "clusterSamples", [true]]);
			a.push(["K-Means Samples", "kmeansSamples", "kmeansSamples", [true]]);
			if (this.smpDendrogram) {
				a.push(["Color Sample Cluster By", "colors", false, false, false, "getDendrogramColorMenu", []]);
				if (this.showSmpDendrogram) {
					a.push(["Hide Dendrogram", "eyeMinusIcon", "showHideDendrogram", ["showSmpDendrogram"]])
				} else {
					a.push(["Show Dendrogram", "eyePlusIcon", "showHideDendrogram", ["showSmpDendrogram"]])
				}
			}
			a.push(["-"]);
			a.push(["More", "more", "showConfiguratorCategory", ["event", "Clustering"]])
		}
		return a
	};
	this.getGraphTypeMenu = function() {
		var a = [];
		a.push(["Area", "area", "changeAttribute", ["graphType", "Area"], "Shit + Alt + A"]);
		a.push(["Area Line", "areaLine", "changeAttribute", ["graphType", "AreaLine"], "Shit + Alt + F"]);
		a.push(["Bar", "bar", "changeAttribute", ["graphType", "Bar"], "Shit + Alt + B"]);
		a.push(["Bar Line", "barLine", "changeAttribute", ["graphType", "BarLine"], "Shit + Alt + C"]);
		a.push(["Boxplot", "boxplot", "changeAttribute", ["graphType", "Boxplot"], "Shit + Alt + I"]);
		a.push(["Circular", "circular", "changeAttribute", ["graphType", "Circular"]]);
		a.push(["Correlation", "correlation", "changeAttribute", ["graphType", "Correlation"], "Shit + Alt + X"]);
		a.push(["Dot Line", "dotplotLine", "changeAttribute", ["graphType", "DotLine"], "Shit + Alt + E"]);
		a.push(["Dotplot", "dotplot", "changeAttribute", ["graphType", "Dotplot"], "Shit + Alt + D"]);
		a.push(["Heatmap", "heatmap", "changeAttribute", ["graphType", "Heatmap"], "Shit + Alt + H"]);
		a.push(["Line", "line", "changeAttribute", ["graphType", "Line"], "Shit + Alt + L"]);
		a.push(["Pie Chart", "pie", "changeAttribute", ["graphType", "Pie"], "Shit + Alt + P"]);
		if (this.data.y.smps.length > 1) {
			a.push(["Scatter 2D", "scatter2d", "changeAttribute", ["graphType", "Scatter2D"], "Shit + Alt + 2"])
		}
		if (this.data.y.smps.length > 2) {
			a.push(["Scatter Bubble 2D", "scatterBubble2d", "changeAttribute", ["graphType", "ScatterBubble2D"], "Shit + Alt + 4"]);
			a.push(["Scatter 3D", "scatter3d", "changeAttribute", ["graphType", "Scatter3D"], "Shit + Alt + 3"])
		}
		a.push(["Stacked", "stacked", "changeAttribute", ["graphType", "Stacked"], "Shit + Alt + S"]);
		a.push(["Stacked Line", "stackedLine", "changeAttribute", ["graphType", "StackedLine"], "Shit + Alt + U"]);
		a.push(["Stacked Percent", "stackedPercent", "changeAttribute", ["graphType", "StackedPercent"], "Shit + Alt + T"]);
		a.push(["Stacked Percent Line", "stackedPercentLine", "changeAttribute", ["graphType", "StackedPercentLine"], "Shit + Alt + W"]);
		a.push(["Tag Cloud", "tagCloud", "changeAttribute", ["graphType", "TagCloud"]]);
		a.push(["Parallel Coordinates", "line", "changeAttribute", ["graphType", "ParallelCoordinates"]]);
		a.push(["Sankey", "network", "changeAttribute", ["graphType", "Sankey"]]);
		a.push(["Tree", "cluster", "changeAttribute", ["graphType", "Tree"]]);
		a.push(["Treemap", "treemap", "changeAttribute", ["graphType", "Treemap"]]);
		return a
	};
	this.getGraphOrientationMenu = function() {
		var a = [];
		a.push(["Horizontal", "graphOrientationHorizontal", "changeAttribute", ["graphOrientation", "horizontal"]]);
		a.push(["Vertical", "graphOrientationVertical", "changeAttribute", ["graphOrientation", "vertical"]]);
		return a
	};
	this.getMarginsMenu = function() {
		var a = [];
		a.push(["General", "margin", false, false, false, "changeTextColorAttributeMenu", ["-text-", "margin"]]);
		a.push(["-"]);
		a.push(["Bottom", "marginBottom", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginBottom"]]);
		a.push(["Left", "marginLeft", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginLeft"]]);
		a.push(["Top", "marginTop", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginTop"]]);
		a.push(["Right", "marginRight", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginRight"]]);
		return a
	};
	this.getShadesMenu = function() {
		var a = [];
		a.push(["Objects", "shadow", "toggleAttribute", ["showShadow"]]);
		a.push(["Text", "textShadow", "toggleAttribute", ["showTextShadow"]]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "shadowColor"]]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Shadows"]]);
		return a
	};
	this.getCanvasBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "canvasBoxColor"]]);
		a.push([this.canvasBox ? "Hide Border" : "Show Border", this.canvasBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["canvasBox"]]);
		return a
	};
	this.getGradientsOrientationMenu = function() {
		var a = [];
		a.push(["Horizontal", "gradientHorizontal", "changeAttribute", ["gradientOrientation", "horizontal"]]);
		a.push(["Vertical", "gradientVertical", "changeAttribute", ["gradientOrientation", "vertical"]]);
		return a
	};
	this.getGradientsTypeMenu = function() {
		var a = [];
		a.push(["Linear", "gradientVertical", "changeAttribute", ["gradientType", "linear"]]);
		a.push(["Radial", "gradientRadial", "changeAttribute", ["gradientType", "radial"]]);
		return a
	};
	this.getGradientsMenu = function() {
		var a = [];
		a.push(["Gradient", "gradientToggle", "toggleAttribute", ["gradient"]]);
		a.push(["Orientation", "gradientOrientation", false, false, false, "getGradientsOrientationMenu", []]);
		a.push(["Type", "gradientType", false, false, false, "getGradientsTypeMenu", []]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Gradients"]]);
		return a
	};
	this.getBackgroundTypeMenu = function() {
		var a = [];
		a.push(["Solid", "background", "changeAttribute", ["backgroundType", "solid", "solid"]]);
		a.push(["Gradient", "backgroundGradient", "changeAttribute", ["backgroundType", "gradient", "gradient"]]);
		a.push(["Solid Window", "backgroundWindow", "changeAttribute", ["backgroundType", "window", "window"]]);
		a.push(["Solid Window on Gradient", "backgroundWindowGradient", "changeAttribute", ["backgroundType", "windowGradient", "windowGradient"]]);
		a.push(["Gradient Window on Solid", "backgroundGradientWindow", "changeAttribute", ["backgroundType", "windowSolidGradient", "windowSolidGradient"]]);
		return a
	};
	this.getBackgroundMenu = function() {
		var a = [];
		a.push(["Type", "backgroundType", false, false, false, "getBackgroundTypeMenu", []]);
		a.push(["-"]);
		a.push(["Area Solid", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "background"]]);
		a.push(["Area Gradient Start Color", "backgroundGradient", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundGradient1Color"]]);
		a.push(["Area Gradient End Color", "backgroundGradient", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundGradient2Color"]]);
		a.push(["-"]);
		a.push(["Window Solid", "backgroundWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindow"]]);
		a.push(["Window Gradient Start Color", "backgroundGradientWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindowGradient1Color"]]);
		a.push(["Window Gradient End Color", "backgroundGradientWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindowGradient2Color"]]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Background"]]);
		return a
	};
	this.getFontsSizeStyleMenu = function() {
		var a = [];
		a.push(["Bigger", "biggerFont", "setFontAttributeSize", ["fontScaleFontFactor", "increase"]]);
		a.push(["Smaller", "smallerFont", "setFontAttributeSize", ["fontScaleFontFactor", "decrease"]]);
		a.push(["Normal", "normalFont", "setFontAttributeStyle", ["fontStyle", "normal"]]);
		a.push(["Bold", "boldFont", "setFontAttributeStyle", ["fontStyle", "bold"]]);
		a.push(["Italic", "italicFont", "setFontAttributeStyle", ["fontStyle", "italic"]]);
		return a
	};
	this.getFontsMenu = function() {
		var a = [];
		a.push(["Size and Style", "fontSizeStyle", false, false, false, "getFontsSizeStyleMenu", []]);
		a.push(["-"]);
		a.push(["Architects Daughter", this.fontName == "Architects Daughter" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Architects Daughter", "Architects Daughter"]]);
		a.push(["Arial", this.fontName == "Arial" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Arial", "Arial"]]);
		a.push(["Courier", this.fontName == "Courier" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Courier", "Courier"]]);
		a.push(["Indie Flower", this.fontName == "Indie Flower" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Indie Flower", "Indie Flower"]]);
		a.push(["Roboto", this.fontName == "Roboto" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Roboto", "Roboto"]]);
		a.push(["Ubuntu", this.fontName == "Ubuntu" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Ubuntu", "Ubuntu"]]);
		a.push(["Verdana", this.fontName == "Verdana" ? "radioOn" : "radioOff", "changeAttribute", ["fontName", "Verdana", "Verdana"]]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Text"]]);
		return a
	};
	this.getLayoutVarMenu = function() {
		var d = [];
		var a = {};
		for (var b = 0; b < this.segregateVariablesBy.length; b++) {
			a[this.segregateVariablesBy[b]] = true
		}
		if (this.data.z) {
			var c = this.sortObject(this.data.z);
			for (var b = 0; b < c.length; b++) {
				d.push([c[b], a[c[b]] ? "checked" : "unchecked", "showVariableSegregation", [c[b]]])
			}
			d.push(["-"])
		}
		d.push(["variable", a.variable ? "checked" : "unchecked", "showVariableSegregation", ["variable"]]);
		return d
	};
	this.getLayoutSmpMenu = function() {
		var a = [];
		var d = {};
		for (var c = 0; c < this.segregateSamplesBy.length; c++) {
			d[this.segregateSamplesBy[c]] = true
		}
		if (this.data.x) {
			var b = this.sortObject(this.data.x);
			for (var c = 0; c < b.length; c++) {
				a.push([b[c], d[b[c]] ? "checked" : "unchecked", "showSampleSegregation", [b[c]]])
			}
			a.push(["-"])
		}
		a.push(["sample", d.sample ? "checked" : "unchecked", "showSampleSegregation", ["sample"]]);
		return a
	};
	this.getLayoutMenu = function() {
		var a = [];
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Segregate Samples By", "samples", false, false, false, "getLayoutSmpMenu", []]);
			a.push(["Segregate Variables By", "variables", false, false, false, "getLayoutVarMenu", []])
		}
		return a
	};
	this.getSegregationMenu = function() {
		var d = [];
		var c = {};
		var d = [];
		if (this.data.z) {
			var e = this.sortObject(this.data.z);
			for (var b = 0; b < this.segregateVariablesBy.length; b++) {
				c[this.segregateVariablesBy[b]] = true
			}
			for (var b = 0; b < e.length; b++) {
				d.push([e[b], c[e[b]] ? "checked" : "unchecked", "showVariableSegregation", [e[b]]])
			}
			d.push(["-"])
		}
		if (this.data.x) {
			var a = this.sortObject(this.data.x);
			for (var b = 0; b < this.segregateSamplesBy.length; b++) {
				c[this.segregateSamplesBy[b]] = true
			}
			for (var b = 0; b < a.length; b++) {
				d.push([a[b], c[a[b]] ? "checked" : "unchecked", "showSampleSegregation", [a[b]]])
			}
			d.push(["-"])
		}
		d.push(["variable", c.variable ? "checked" : "unchecked", "showVariableSegregation", ["variable"]]);
		d.push(["sample", c.sample ? "checked" : "unchecked", "showSampleSegregation", ["sample"]]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot && d.length > 0) {
			return d
		} else {
			return false
		}
	};
	this.getColorSpectrumMenu = function(b, g, m, l, k) {
		var c = [];
		var a = this.getObjectArray(b);
		var f = this.getColorNames();
		for (var e = 0; e < f.length; e++) {
			if (a[f[e]]) {
				var h = 0;
				for (var d = 0; d < b.length; d++) {
					if (f[e] == b[d]) {
						h = d;
						break
					}
				}
				if (m && l && k) {
					c.push([f[e] + " (" + (h + 1) + ")", "checked", g, [f[e], m, l, k]])
				} else {
					c.push([f[e] + " (" + (h + 1) + ")", "checked", g, [f[e]]])
				}
			} else {
				if (m && l && k) {
					c.push([f[e], "unchecked", g, [f[e], m, l, k]])
				} else {
					c.push([f[e], "unchecked", g, [f[e]]])
				}
			}
		}
		return c
	};
	this.getColorSchemeMenu = function(e, f) {
		var d = [];
		var a = this.getColorSchemes();
		for (var b = 0; b < a.length; b++) {
			d.push([a[b], this[e] == a[b] ? "radioOn" : "radioOff", "changeAttribute", [e, a[b], false, f]])
		}
		return d
	};
	this.getColorsSpectrumCompMenu = function() {
		var a = [];
		a.push(["Colors", "colors", false, false, false, "getColorSpectrumMenu", [this.colorSpectrum, "changeColorSpectrum"]]);
		a.push(["Zero-Center", "z", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "changeColorSpectrumZeroValue", []]]]);
		return a
	};
	this.getColorsMenu = function() {
		var a = [];
		a.push(["Scheme", "palette", false, false, false, "getColorSchemeMenu", ["colorScheme", "changeColorScheme"]]);
		a.push(["Spectrum", "indicatorCenterRainbow", false, false, false, "getColorsSpectrumCompMenu", []]);
		return a
	};
	this.getResizeMenu = function() {
		var a = [];
		a.push(["Height", "resizeVer", false, false, false, "changeTextColorAttributeMenu", ["-text-", ["height", "setHeight"]]]);
		a.push(["Width", "resizeHor", false, false, false, "changeTextColorAttributeMenu", ["-text-", ["width", "setWidth"]]]);
		return a
	};
	this.getThemeMenu = function() {
		var a = [];
		a.push(["CanvasXpress", this.theme == "cx" ? "radioOn" : "radioOff", "changeTheme", ["cx"]]);
		a.push(["Economist", this.theme == "economist" ? "radioOn" : "radioOff", "changeTheme", ["economist"]]);
		a.push(["GGPlot", this.theme == "ggplot" ? "radioOn" : "radioOff", "changeTheme", ["ggplot"]]);
		a.push(["Gray-Inverse", this.theme == "igray" ? "radioOn" : "radioOff", "changeTheme", ["igray"]]);
		a.push(["Excel", this.theme == "excel" ? "radioOn" : "radioOff", "changeTheme", ["excel"]]);
		a.push(["Paul Tol", this.theme == "paulTol" ? "radioOn" : "radioOff", "changeTheme", ["paulTol"]]);
		a.push(["Solarized", this.theme == "solarized" ? "radioOn" : "radioOff", "changeTheme", ["solarized"]]);
		a.push(["Stata", this.theme == "stata" ? "radioOn" : "radioOff", "changeTheme", ["stata"]]);
		a.push(["Tableau", this.theme == "tableau" ? "radioOn" : "radioOff", "changeTheme", ["tableau"]]);
		a.push(["Wall Street Journal", this.theme == "wallStreetJournal" ? "radioOn" : "radioOff", "changeTheme", ["wallStreetJournal"]]);
		a.push(["-"]);
		a.push(["None", this.theme == "none" ? "radioOn" : "radioOff", "changeTheme", ["none"]]);
		return a
	};
	this.getGeneralMenu = function() {
		var a = [];
		a.push(["Background", "background", false, false, false, "getBackgroundMenu", []]);
		a.push(["Border", "border", false, false, false, "getCanvasBorderMenu", []]);
		a.push(["Color", "colors", false, false, false, "getColorsMenu", []]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontsMenu", []]);
		a.push(["Gradients", "gradientDiagonal", false, false, false, "getGradientsMenu", []]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Graph Orientation", "graphOrientation", false, false, false, "getGraphOrientationMenu", []])
		}
		a.push(["Graph Type", "graphType", false, false, false, "getGraphTypeMenu", []]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Layout", "segregate", false, false, false, "getLayoutMenu", []])
		}
		a.push(["Margins", "margin", false, false, false, "getMarginsMenu", []]);
		a.push(["Shadows", "shadow", false, false, false, "getShadesMenu", []]);
		a.push(["Size", "resize", false, false, false, "getResizeMenu", []]);
		a.push(["Theme", "palette", false, false, false, "getThemeMenu", []]);
		a.push(["Transparency", "transparency", false, false, false, "changeTextColorAttributeMenu", ["-text-", "transparency"]]);
		return a
	};
	this.getSwitchSmpToAnnotationMenu = function() {
		var b = [];
		for (var a = 0; a < this.data.y.smps.length; a++) {
			b.push([this.data.y.smps[a], "radioOff", "switchSmpToAnnotation", [this.data.y.smps[a]]])
		}
		return b
	};
	this.getSwitchAnnotationToSmpMenu = function() {
		var c = [];
		var b = this.sortObject(this.data.z);
		for (var a = 0; a < b.length; a++) {
			if (this.meta.data.z[b[a]]) {
				c.push([b[a], "radioOff", "switchAnnotationToSmp", [b[a]]])
			}
		}
		return c
	};
	this.getSwitchSmpAnnotationToIdMenu = function() {
		var c = [];
		var a = this.sortObject(this.data.x);
		for (var b = 0; b < a.length; b++) {
			if (this.meta.data.x[a[b]].unique) {
				c.push([a[b], "radioOff", "switchSmpAnnotationToId", [a[b]]])
			}
		}
		return c
	};
	this.getSwitchVarToAnnotationMenu = function() {
		var a = [];
		for (var b = 0; b < this.data.y.vars.length; b++) {
			a.push([this.data.y.vars[b], "radioOff", "switchVarToAnnotation", [this.data.y.vars[b]]])
		}
		return a
	};
	this.getSwitchAnnotationToVarMenu = function() {
		var b = [];
		var a = this.sortObject(this.data.x);
		for (var c = 0; c < a.length; c++) {
			if (this.meta.data.x[a[c]]) {
				b.push([a[c], "radioOff", "switchAnnotationToVar", [a[c]]])
			}
		}
		return b
	};
	this.getSwitchVarAnnotationToIdMenu = function() {
		var c = [];
		var b = this.sortObject(this.data.z);
		for (var a = 0; a < b.length; a++) {
			if (this.meta.data.z[b[a]].unique) {
				c.push([b[a], "radioOff", "switchVarAnnotationToId", [b[a]]])
			}
		}
		return c
	};
	this.getSwitchSamplesMenu = function() {
		var a = [];
		a.push(["Sample to Annotation", "switchb", false, false, false, "getSwitchSmpToAnnotationMenu", []]);
		if (this.data.z) {
			a.push(["Annotation to Sample", "switchu", false, false, false, "getSwitchAnnotationToSmpMenu", []])
		}
		if (this.data.x && this.isUniqueFactor("s")) {
			a.push(["Annotation to Id", "switch", false, false, false, "getSwitchSmpAnnotationToIdMenu", []])
		}
		a.push(["Create New Sample Id", "more", "switchSmpIdToAnnotation", []]);
		return a
	};
	this.getSwitchVariablesMenu = function() {
		var a = [];
		a.push(["Variable to Annotation", "switchb", false, false, false, "getSwitchVarToAnnotationMenu", []]);
		if (this.data.x) {
			a.push(["Annotation to Variable", "switchu", false, false, false, "getSwitchAnnotationToVarMenu", []])
		}
		if (this.data.z && this.isUniqueFactor("v")) {
			a.push(["Annotation to Id", "switch", false, false, false, "getSwitchVarAnnotationToIdMenu", []])
		}
		a.push(["Create New Variable Id", "more", "switchVarIdToAnnotation", []]);
		return a
	};
	this.getSwitchMenu = function() {
		var a = [];
		a.push(["Samples", "samples", false, false, false, "getSwitchSamplesMenu", []]);
		a.push(["Variables", "variables", false, false, false, "getSwitchVariablesMenu", []]);
		return a
	};
	this.getConvertNumericToStringMenu = function(f, b) {
		var d = [];
		var e = this.sortObject(this.data[f]);
		for (var a = 0; a < e.length; a++) {
			if (this.meta.data[f][e[a]] && this.meta.data[f][e[a]].type == "Numeric") {
				d.push([e[a], "radioOff", "switchNumericToString", [e[a], b]])
			}
		}
		return d
	};
	this.getConvertStringToNumericMenu = function(f, b) {
		var d = [];
		var e = this.sortObject(this.data[f]);
		for (var a = 0; a < e.length; a++) {
			if (this.meta.data[f][e[a]] && this.meta.data[f][e[a]].type != "Numeric") {
				d.push([e[a], "radioOff", "switchStringToNumeric", [e[a], b]])
			}
		}
		return d
	};
	this.getConvertVarSmpMenu = function(d, a) {
		var b = [];
		if (this.isNumericFactor(a)) {
			b.push(["Numeric to String", "convertNumberString", false, false, false, "getConvertNumericToStringMenu", [d, a == "s"]])
		}
		if (this.isStringFactor(a)) {
			b.push(["String to Numeric", "convertStringNumber", false, false, false, "getConvertStringToNumericMenu", [d, a == "s"]])
		}
		return b
	};
	this.getConvertMenu = function() {
		var a = [];
		if (this.data.x) {
			a.push(["Samples", "samples", false, false, false, "getConvertVarSmpMenu", ["x", "s"]])
		}
		if (this.data.z) {
			a.push(["Variables", "variables", false, false, false, "getConvertVarSmpMenu", ["z", "v"]])
		}
		return a
	};
	this.getTransformLogMenu = function() {
		var a = [];
		a.push([2, this.transformBase == "2" ? "radioOn" : "radioOff", "changeAttribute", ["transformBase", "2", 2]]);
		a.push([10, this.transformBase == "10" ? "radioOn" : "radioOff", "changeAttribute", ["transformBase", "10", 2]]);
		return a
	};
	this.getTransformPercentMenu = function() {
		var a = [];
		a.push(["By Sample", "samples", "transform", ["percentile", "samples"]]);
		a.push(["By Variable", "variables", "transform", ["percentile", "variables"]]);
		return a
	};
	this.getTransformZScoreMenu = function() {
		var a = [];
		a.push(["By Sample", "samples", "transform", ["zscore", "samples"]]);
		a.push(["By Variable", "variables", "transform", ["zscore", "variables"]]);
		return a
	};
	this.getTransformRatioMenu = function() {
		var a = [];
		a.push(["To Sample", "samples", false, false, false, "getTransformRatioSmpMenu", []]);
		if (this.data.x && this.isGroupedData) {
			a.push(["To Group", "groups", false, false, false, "getTransformRatioGrpMenu", []]);
			if (this.ratioGroupReference && this.data.x.hasOwnProperty(this.ratioGroupReference)) {
				a.push(["To Level", "levels", false, false, false, "getTransformRatioLevMenu", []])
			}
		}
		a.push(["-"]);
		a.push(["Log Base", this.transformBase == "2" ? "log2" : "log10", false, false, false, "getTransformLogMenu", []]);
		return a
	};
	this.getTransformRatioLevMenu = function() {
		var c = [];
		var a = this.sortObject(this.getObjectArray(this.data.x[this.ratioGroupReference]));
		for (var b = 0; b < a.length; b++) {
			if (a[b] != null) {
				c.push([a[b], this.ratioLevelReference == a[b] ? "radioOn" : "radioOff", "changeTransformRatio", ["level", a[b]]])
			}
		}
		return c
	};
	this.getTransformRatioGrpMenu = function() {
		var b = [];
		var a = this.sortObject(this.data.x);
		for (var c = 0; c < a.length; c++) {
			b.push([a[c], this.ratioGroupReference == a[c] ? "radioOn" : "radioOff", "changeTransformRatio", ["group", a[c]]])
		}
		return b
	};
	this.getTransformRatioSmpMenu = function() {
		var c = [];
		for (var a = 0; a < this.data.y.smps.length; a++) {
			var b = this.data.y.smps[a];
			c.push([b, this.ratioSampleReference == b ? "radioOn" : "radioOff", "changeTransformRatio", ["sample", b]])
		}
		return c
	};
	this.getTransformMenu = function() {
		var a = [];
		a.push(["Log Base 2", "log2", "transform", ["log2"]]);
		a.push(["Log Base 10", "log10", "transform", ["log10"]]);
		a.push(["Exp Base 2", "exp2", "transform", ["exp2"]]);
		a.push(["Exp Base 10", "exp10", "transform", ["exp10"]]);
		a.push(["Ceil data", "ceil", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyTransform", ["tceil"]]]]);
		a.push(["Floor data", "floor", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyTransform", ["tfloor"]]]]);
		a.push(["Percentile", "percent2", false, false, false, "getTransformPercentMenu", []]);
		a.push(["Z-Score", "zScore", false, false, false, "getTransformZScoreMenu", []]);
		a.push(["Ratio", "ratio", false, false, false, "getTransformRatioMenu", []]);
		a.push(["-"]);
		a.push(["Reset", "refreshForm", "transform", ["reset"]]);
		a.push(["-"]);
		a.push(["Overwrite data", "disk", "transform", ["save"]]);
		return a
	};
	this.getAxisTransformMenu = function(b) {
		var c = [];
		b = b.toLowerCase();
		c.push(["Log Base 2", "log2", "changeAttribute", [b + "AxisTransform", "log2"]]);
		c.push(["Log Base 10", "log10", "changeAttribute", [b + "AxisTransform", "log10"]]);
		c.push(["Exp Base 2", "exp2", "changeAttribute", [b + "AxisTransform", "exp2"]]);
		c.push(["Exp Base 10", "exp10", "changeAttribute", [b + "AxisTransform", "exp10"]]);
		c.push(["Percentile", "percent2", "changeAttribute", [b + "AxisTransform", "exp10"]]);
		c.push(["-"]);
		c.push(["Reset", "refreshForm", "changeAttribute", [b + "AxisTransform", false]]);
		return c
	};
	this.getSortSmpIntensityMenu = function() {
		var c = [];
		var a = {};
		if (this.sortingSamples) {
			for (var b = 0; b < this.sortingSamples.length; b++) {
				a[this.sortingSamples[b]] = true
			}
		}
		for (var b = 0; b < this.data.y.smps.length; b++) {
			c.push([this.data.y.smps[b], a[b + 1] ? "radioOn" : "radioOff", "showSorting", ["smp", "var", this.data.y.smps[b]]])
		}
		return c
	};
	this.getSortVarIntensityMenu = function() {
		var c = [];
		var a = {};
		if (this.sortingVariables) {
			for (var b = 0; b < this.sortingVariables.length; b++) {
				a[this.sortingVariables[b]] = true
			}
		}
		for (var b = 0; b < this.data.y.vars.length; b++) {
			c.push([this.data.y.vars[b], a[b + 1] ? "radioOn" : "radioOff", "showSorting", ["var", "smp", this.data.y.vars[b]]])
		}
		return c
	};
	this.getSortSmpCatMenu = function() {
		var d = [];
		var b = {};
		var a = this.sortObject(this.data.x);
		if (this.sortingSampleCategories) {
			for (var c = 0; c < this.sortingSampleCategories.length; c++) {
				b[this.sortingSampleCategories[c]] = true
			}
		}
		for (var c = 0; c < a.length; c++) {
			d.push([a[c], b[a[c]] ? "checked" : "unchecked", "showSorting", ["cat", "smp", a[c]]])
		}
		return d
	};
	this.getSortVarCatMenu = function() {
		var d = [];
		var a = {};
		var c = this.sortObject(this.data.z);
		if (this.sortingVariableCategories) {
			for (var b = 0; b < this.sortingVariableCategories.length; b++) {
				a[this.sortingVariableCategories[b]] = true
			}
		}
		for (var b = 0; b < c.length; b++) {
			d.push([c[b], a[c[b]] ? "checked" : "unchecked", "showSorting", ["cat", "var", c[b]]])
		}
		return d
	};
	this.getSortSmpMenu = function() {
		var a = [];
		a.push(["By Variable Intensity", "variables", false, false, false, "getSortVarIntensityMenu", []]);
		if (this.data.x) {
			a.push(["By Sample Category", "X", false, false, false, "getSortSmpCatMenu", []])
		}
		a.push(["By Name", "samples", "showSorting", ["cat", "smp", "samples"]]);
		return a
	};
	this.getSortVarMenu = function() {
		var a = [];
		a.push(["By Sample Intensity", "samples", false, false, false, "getSortSmpIntensityMenu", []]);
		if (this.data.z) {
			a.push(["By Variable Category", "z", false, false, false, "getSortVarCatMenu", []])
		}
		a.push(["By Name", "variables", "showSorting", ["cat", "var", "variables"]]);
		return a
	};
	this.getSortMenu = function() {
		var a = [];
		if (this.sortDir == "ascending") {
			a.push(["Change Sorting", "sortAsciiDesc", "changeAttribute", ["sortDir", "descending", true]])
		} else {
			a.push(["Change Sorting", "sortAsciiAsc", "changeAttribute", ["sortDir", "ascending", true]])
		}
		a.push(["Case Sensitive", this.sortCaseSensitive ? "checked" : "unchecked", "toggleAttribute", ["sortCaseSensitive"]]);
		a.push(["-"]);
		a.push(["Sort Samples", "samples", false, false, false, "getSortSmpMenu", []]);
		a.push(["Sort Variables", "variables", false, false, false, "getSortVarMenu", []]);
		return a
	};
	this.getSliderMenu = function() {
		var a = [];
		for (var b in this.binConfigurations) {
			a.push([b, false, false, false, false, [
				["-slider-", "changeBin", [b]]
			]])
		}
		return a
	};
	this.getPivotMenu = function() {
		var b = [];
		if (this.isPivotable()) {
			if (this.data.y.vars.length == 3) {
				var c = this.data.y.vars;
				b.push([c[0] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotYY", [c[0], c[1]]]);
				b.push([c[0] + " as Variables; " + c[2] + " as Samples", "radioOff", "pivotYY", [c[0], c[2]]]);
				b.push([c[1] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotYY", [c[1], c[0]]]);
				b.push([c[1] + " as Variables; " + c[2] + " as Samples", "radioOff", "pivotYY", [c[1], c[2]]]);
				b.push([c[2] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotYY", [c[2], c[0]]]);
				b.push([c[2] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotYY", [c[2], c[1]]])
			} else {
				if (this.data.y.vars.length == 2) {
					var c = this.data.y.vars;
					var a = this.getKeys(this.data.x);
					b.push([a[0] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotXY", [a[0], c[0]]]);
					b.push([a[0] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotXY", [a[0], c[1]]]);
					b.push([c[0] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXY", [c[0], a[0]]]);
					b.push([c[1] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXY", [c[1], a[0]]])
				} else {
					var a = this.getKeys(this.data.x);
					b.push([a[0] + " as Variables; " + a[1] + " as Samples", "radioOff", "pivotXX", [a[0], a[1]]]);
					b.push([a[1] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXX", [a[1], a[0]]])
				}
			}
		}
		return b
	};
	this.getRdatasetsMenu = function() {
		var a = [];
		if (this.Rdatasets) {
			var c = this.sortObject(this.Rdatasets);
			c = c.sort(function(e, d) {
				return e.toLowerCase() > d.toLowerCase()
			});
			for (var b = 0; b < c.length; b++) {
				a.push([c[b], "radioOff", "getRLibraryDataSets", [c[b]]])
			}
		}
		return a
	};
	this.getRangeMenu = function() {
		var a = [];
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMinX"]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMaxX"]]);
		a.push(["Exact Range", "exactValue", "toggleAttribute", ["xAxisExact"]]);
		return a
	};
	this.getSummaryTypeMenu = function() {
		var c = [];
		var b = ["mean", "median", "min", "max", "sum"];
		c.push(["Raw", !this.summaryType || this.summaryType == "raw" ? "radioOn" : "radioOff", "modifySummaryType", ["raw"]]);
		for (var a = 0; a < b.length; a++) {
			c.push([this.capitalize(b[a]), this.summaryType == b[a] ? "radioOn" : "radioOff", "modifySummaryType", [b[a]]])
		}
		return c
	};
	this.getDataMenu = function() {
		var a = [];
		if (this.isBinConfigurations()) {
			a.push(["Configure Bins", "ub", false, false, false, "getSliderMenu", []])
		}
		if (this.data.x || this.data.z) {
			a.push(["Convert Annotations", "convert", false, false, false, "getConvertMenu", []])
		}
		if (this.graphType == "Heatmap") {
			a.push(["Range", "range", false, false, false, "getRangeMenu", []])
		}
		a.push(["Summary Type", "sum", false, false, false, "getSummaryTypeMenu", []]);
		a.push(["Switch Data", "switch", false, false, false, "getSwitchMenu", []]);
		if (!this.graphType.match(/Scatter/i)) {
			a.push(["Sort", "sortAsciiAsc", false, false, false, "getSortMenu", []])
		}
		a.push(["Transform", "transform", false, false, false, "getTransformMenu", []]);
		if (!this.layoutValid) {
			a.push(["Transpose", "transposeData", "transpose"])
		}
		if (this.isPivotable()) {
			a.push(["Pivot", "pivot", false, false, false, "getPivotMenu", []])
		}
		if (!this.layoutValid) {
			a.push(["Bin Data", "binData", false, false, false, "getBinDataMenu", []])
		}
		return a
	};
	this.getLoessMenu = function() {
		return [
			[this.showLoessFit ? "Hide Loess Fit" : "Show Loess Fit", this.showLoessFit ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showLoessFit"]]
		]
	};
	this.getHistogramDensityMenu = function() {
		var b = ["epanechnikovKernel", "uniformKernel", "triangularKernel", "quarticKernel", "triweightKernel", "gaussianKernel", "cosineKernel"];
		var a = [];
		for (var d = 0; d < b.length; d++) {
			var c = b[d].replace("Kernel", "");
			a.push([c, b[d] == this.histogramDensityKernel ? "radioOn" : "radioOff", "changeAttribute", ["histogramDensityKernel", b[d], false, "modifyHistogram"]])
		}
		return a
	};
	this.getHistogramMenu = function() {
		var a = [];
		a.push(["Bin Number", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", ["histogramBins", "modifyHistogram"]]]);
		a.push(["Density Kernel", "kernelHistogram", false, false, false, "getHistogramDensityMenu", []]);
		a.push(["Remove Histogram", "removeHistogram", "removeHistogram"]);
		a.push([this.showHistogramDensity ? "Hide Density" : "Show Density", this.showHistogramDensity ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showHistogramDensity", "modifyHistogram"]]);
		a.push(["Stagger Histograms", "histogramStagger", "toggleAttribute", ["histogramStagger", "modifyHistogram"]]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Histograms"]]);
		return a
	};
	this.getDOEMenu = function() {
		var d = [];
		var c = this.initialGraphType.match(/Scatter/) ? this.getKeys(this.dataStndBy.z) : this.getKeys(this.dataStndBy.x);
		var a = this.getObjectArray(this.includeDOE);
		for (var b = 0; b < c.length; b++) {
			d.push([c[b], a[c[b]] ? "checked" : "unchecked", "modifyDOE", [c[b]]])
		}
		return d
	};
	this.getCorrelationCatMenu = function(f, d) {
		var b = [];
		var e = this.sortObject(this.data[f]);
		for (var a = 0; a < e.length; a++) {
			if (this.isNumeric(this.data[f][e[a]])) {
				b.push([e[a], "radioOff", "correlateData", [d, e[a]]])
			}
		}
		return b
	};
	this.getCorrelationMenu = function() {
		var b = [];
		var a = [];
		if (this.data.y.vars.length > 3) {
			b.push(["Samples", "samples", "correlateData"])
		}
		if (this.data.y.smps.length > 3 && this.data.x && this.isNumericFactor("s")) {
			b.push(["Sample Annotation", "samples", false, false, false, "getCorrelationCatMenu", ["x", true]])
		}
		if (this.data.y.smps.length > 3) {
			b.push(["Variables", "variables", "correlateData", [true]])
		}
		if (this.data.y.vars.length > 3 && this.data.z && this.isNumericFactor("v")) {
			b.push(["Variable Annotation", "variables", false, false, false, "getCorrelationCatMenu", ["z", false]])
		}
		return b
	};
	this.getParametersMenu = function() {
		var a = [];
		a.push(["Load Parameters", "add2", true, []]);
		a.push(["Save as JSON", "disk", "save", []]);
		return a
	};
	this.getFileMenu = function() {
		var a = [];
		a.push(["Save as PNG", "camera", "print", [], "Ctrl + P"]);
		if (!this.graphType.match(/Venn|TagCloud|Map/)) {
			a.push(["Save as SVG", "cameraSVG", "saveSVG", []])
		}
		a.push(["Save as JSON", "disk", "save", []]);
		a.push(["-"]);
		a.push(["Reproducible Research", "RepRsrch", "clickRepResearch", []]);
		a.push(["Show JSON code", "purpleCode", "clickShowCode", []]);
		a.push(["Reproduce", "redo", "reproduce", [], "Ctrl + Alt + R"]);
		if (this.remoteService && this.remoteServiceType == "webService") {
			a.push(["Save customizations to server", "disk", "saveRemote", ["afterRender"]]);
			a.push(["Clear parameters from server", "deleteSaved", "clearRemote", []])
		}
		a.push(["-"]);
		a.push(["Load", "add2", true, []]);
		if (this.Rdatasets) {
			a.push(["R Datasets", "CRAN", false, false, false, "getRdatasetsMenu", []])
		}
		a.push(["-"]);
		a.push(["Parameters", "cog", false, false, false, "getParametersMenu", []]);
		a.push(["-"]);
		a.push(["Reset", "refreshForm", "masterReset", [], "ESC"]);
		return a
	};
	this.getExploreMenu = function() {
		var a = [];
		a.push(["Filters", "funnel", "clickDataFilters", []]);
		a.push(["Table", "table", "clickDataTable", []]);
		a.push(["Explorer", "data", "clickDataExplorer", []]);
		a.push(["-"]);
		a.push(["Search Parameters", "find", "addConfiguratorCloseMenus"]);
		return a
	};
	this.getConfigurationMenu = function() {
		var e = this.decorations;
		var b = {
			Bar: true,
			Line: true,
			Area: true,
			AreaLine: true,
			BarLine: true,
			Boxplot: true,
			Dotplot: true,
			DotLine: true,
			Heatmap: true,
			Treemap: true,
			TagCloud: true,
			ParallelCoordinates: true,
			Sankey: true,
			Stacked: true,
			StackedLine: true,
			StackedPercent: true,
			StackedPercentLine: true,
			Candlestick: true
		};
		var a = [];
		if (this.isMap || this.graphType == "Tree") {
			a.push(["Citation", this.graphType == "Heatmap" ? "citationH" : "citation1", false, false, false, "getGraphPartMenu", ["citation"]]);
			a.push(["Legend", "legends", false, false, false, "getLegendMenu", []]);
			a.push(["Title / Subtitle", this.graphType == "Heatmap" ? "titleSubtitleH" : "titleSubtitle", false, false, false, "getTitleSubtitleMenu", []])
		} else {
			if (b[this.graphType] && !this.is3DPlot) {
				if (this.graphType != "Heatmap") {
					a.push(["Axes", "axis1", false, false, false, "getAxesMenu", []]);
					a.push(["Axes Titles", "axisTitle1", false, false, false, "getAxesTitleMenu", []])
				}
				a.push(["Citation", this.graphType == "Heatmap" ? "citationH" : "citation1", false, false, false, "getGraphPartMenu", ["citation"]]);
				a.push(["General", this.graphType == "Heatmap" ? "generalH" : "general1", false, false, false, "getGeneralMenu", []]);
				a.push(["Grid", "grid", false, false, false, "getPlotAreaGridMenu", ["x"]]);
				if (this.graphType != "Heatmap") {
					a.push(["Plot Area", "plotArea", false, false, false, "getPlotAreaOneMenu", []]);
					if (e) {
						a.push(["Decorations", "decorationLines", false, false, false, "getDecorationsMenu", []])
					}
					a.push(["Legend", "legends", false, false, false, "getLegendMenu", []]);
					if (this.data.x) {
						a.push(["Overlays", "overlaysSamplesH", false, false, false, "getOverlaysMenu", []])
					}
				}
				if (this.graphType == "Heatmap") {
					a.push(["Indicator", "indicator", false, false, false, "getIndicatorMenu", []]);
					a.push(["Heatmap", "heatmap", false, false, false, "getHeatmapMenu", []]);
					if (this.data.x || this.data.z) {
						a.push(["Overlays", "overlaysSamplesH", false, false, false, "getOverlaysMenu", []])
					}
				}
				a.push(["Sample Labels", this.graphType == "Heatmap" ? "sampleLabelsH" : "sampleLabels1", false, false, false, "getSmpLabelMenu", []]);
				a.push(["Samples Title", this.graphType == "Heatmap" ? "sampleTitleH" : "sampleTitle1", false, false, false, "getGraphPartMenu", ["smpTitle", true]]);
				if (this.graphType == "Heatmap") {
					a.push(["Variable Labels", "variableLabelsH", false, false, false, "getVarLabelMenu", []]);
					a.push(["Variables Title", "variableTitleH", false, false, false, "getGraphPartMenu", ["varTitle", true]])
				}
				a.push(["Title / Subtitle", this.graphType == "Heatmap" ? "titleSubtitleH" : "titleSubtitle", false, false, false, "getTitleSubtitleMenu", []])
			} else {
				if (this.graphType.match(/scatter/i) || this.is3DPlot) {
					a.push(["Axes", "axesS", false, false, false, "getAxesMenu", []]);
					a.push(["Axes Titles", "axesTitlesS", false, false, false, "getAxesTitleMenu", []]);
					a.push(["Citation", "citationS", false, false, false, "getGraphPartMenu", ["citation"]]);
					a.push(["General", "generalS", false, false, false, "getGeneralMenu", []]);
					a.push(["Grid", "gridS", false, false, false, "getPlotAreaScatterGridMenu", []]);
					a.push(["Plot Area", "plotArea", false, false, false, "getPlotAreaScatterMenu", []]);
					if (e) {
						var c = e.nlfit ? "nonlinearFit" : e.line ? "decorationLine" : e.lines ? "decorationLines" : e.reg ? "regressionLine" : e.nor ? "normalDistribution" : e.area ? "decorationArea" : e.kaplanMeier ? "kaplanMeier" : false;
						a.push(["Decorations", c, false, false, false, "getDecorationsMenu", []])
					}
					a.push(["Legend", "legendS", false, false, false, "getLegendMenu", []]);
					a.push(["Title / Subtitle", "titleSubtitleS", false, false, false, "getTitleSubtitleMenu", []]);
					if (this.isSelectDataPoints) {
						a.push(["Show hidden data points", "showSelected", "showHideSelectedDataPoint", [false, 45], "Ctrl + Insert"]);
						a.push(["Hide data points", "hideSelected", "showHideSelectedDataPoint", [false, 46], "Ctrl + Delete"])
					}
				}
			}
		}
		return a
	};
	this.getAlignNetworkMenu = function() {
		var a = [];
		a.push(["Top", "alignTop", "alignDistributeSelectedNodes", [false, 84]]);
		a.push(["Right", "alignRight", "alignDistributeSelectedNodes", [false, 82]]);
		a.push(["Bottom", "alignBottom", "alignDistributeSelectedNodes", [false, 66]]);
		a.push(["Left", "alignLeft", "alignDistributeSelectedNodes", [false, 76]]);
		return a
	};
	this.getDistributeNetworkMenu = function() {
		var a = [];
		a.push(["Vertically", "distributeVertical", "alignDistributeSelectedNodes", [false, 86]]);
		a.push(["Horozontally", "distributeHorizontal", "alignDistributeSelectedNodes", [false, 72]]);
		return a
	};
	this.getRotateNetworkMenu = function() {
		var a = [];
		a.push(["Clockwise", "rotateClockwise", "arrowMove", [34]]);
		a.push(["Clockwise - Animate", "rotateClockwiseCont", "arrowMove", [39, true]]);
		a.push(["Anticlockwise", "rotateAnticlockwise", "arrowMove", [33]]);
		a.push(["Anticlockwise - Animate", "rotateAnticlockwiseCont", "arrowMove", [37, true]]);
		return a
	};
	this.getOrderNetworkMenu = function() {
		var a = [];
		a.push(["Send to back", "moveBack", "orderNodes", ["sendNodeToBack"]]);
		a.push(["Send backward", "moveBackwards", "orderNodes", ["sendNodeBackward"]]);
		a.push(["Bring to front", "moveFront", "orderNodes", ["bringNodeToFront"]]);
		a.push(["Bring forward", "moveForwards", "orderNodes", ["bringNodeForward"]]);
		return a
	};
	this.setMenu = function() {
		var a = {
			Bar: true,
			Line: true,
			Area: true,
			AreaLine: true,
			BarLine: true,
			Boxplot: true,
			Dotplot: true,
			DotLine: true,
			Heatmap: true,
			Treemap: true,
			TagCloud: true,
			ParallelCoordinates: true,
			Stacked: true,
			StackedLine: true,
			StackedPercent: true,
			StackedPercentLine: true,
			Candlestick: true
		};
		this.menu = [];
		this.menu.push(["File", "file", false, false, false, "getFileMenu", []]);
		this.menu.push(["-"]);
		if (this.graphType != "Map") {
			this.menu.push(["Explore", "find", false, false, false, "getExploreMenu", []]);
			this.menu.push(["-"])
		}
		if (this.graphType == "Network") {
			if (this.isNetworkConvexHull) {
				this.menu.push(["Remove Communities", "communitiesOff", "unsetNetworkCommunities"])
			} else {
				this.menu.push(["Show Communities", "communitiesOn", "drawNetworkCommunities"])
			}
			if (this.isSelectNodes) {
				this.menu.push(["Align", "alignBottom", false, false, false, "getAlignNetworkMenu", []]);
				this.menu.push(["Distribute", "distributeVertical", false, false, false, "getDistributeNetworkMenu", []]);
				this.menu.push(["Rotate", "rotateAnticlockwise", false, false, false, "getRotateNetworkMenu", []]);
				this.menu.push(["Order", "moveFront", false, false, false, "getOrderNetworkMenu", []]);
				this.menu.push(["-"]);
				this.menu.push(["Show conections", "connections", "showHideSelectedDataPoint", [false, 36], "Ctrl + Home"]);
				this.menu.push(["-"]);
				this.menu.push(["Show hidden nodes", "showSelected", "showHideSelectedDataPoint", [false, 45], "Ctrl + Insert"]);
				this.menu.push(["Hide nodes", "hideSelected", "showHideSelectedDataPoint", [false, 46], "Ctrl + Delete"]);
				this.menu.push(["-"]);
				this.menu.push(["Undo", "undo", "alignDistributeSelectedNodes", [false, 90], "Ctrl + z"]);
				this.menu.push(["Redo", "redo", "alignDistributeSelectedNodes", [false, 90, true], "Ctrl + y"]);
				this.menu.push(["-"]);
				this.menu.push(["Recalculate Layout", "network2", "recalculateLayoutSelectedNodes"])
			} else {
				this.menu.push(["Rotate", "rotateAnticlockwise", false, false, false, "getRotateNetworkMenu", []])
			}
		}
		if (this.graphType == "Map") {
			this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
			this.menu.push(["-"]);
			if (this.data.z) {
				this.menu.push(["Color By", "colors", false, false, false, "getDataPointAttributesPropertyMenu", ["colorBy"]])
			}
		} else {
			if (this.graphType == "Tree") {
				this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
				this.menu.push(["-"]);
				if (this.data.x) {
					this.menu.push(["Data Point Attributes", "colorShapeSize", false, false, false, "getDataPointAttributesMenu", []]);
					this.menu.push(["-"])
				}
				this.menu.push(["Layout", "cluster", false, false, false, "getDendrogramsMenu", []])
			}
		}
		if (this.isDOE) {
			this.menu.push(["Modify Meta-Data Plots", "doe", false, false, false, "getDOEMenu", []]);
			this.menu.push(["Remove Meta-Data Plots", "removeDoe", "removeDOE"]);
			this.menu.push(["-"])
		} else {
			if (a[this.graphType] && !this.is3DPlot) {
				this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
				this.menu.push(["-"]);
				this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
				this.menu.push(["-"]);
				if (this.data.x || this.graphType == "ParallelCoordinates" || this.graphType == "Line") {
					this.menu.push(["Data Point Attributes", "colorShapeSize", false, false, false, "getDataPointAttributesMenu", []]);
					this.menu.push(["-"])
				}
				if ((this.data.x || this.data.z) && this.isRawData) {
					if (this.data.x) {
						this.menu.push(["Group Samples", "groupSamples", false, false, false, "getGroupSamplesMenu", []])
					}
					if (this.data.x || this.data.z) {
						this.menu.push(["Segregate Data", "segregate", false, false, false, "getSegregationMenu", []])
					}
					this.menu.push(["-"])
				}
				if (!this.layoutValid && this.isRawData) {
					this.menu.push(["Cluster", "cluster", false, false, false, "getDendrogramsMenu", []]);
					this.menu.push(["-"]);
					if (this.isHistogram) {
						this.menu.push(["Histogram", "histogram", false, false, false, "getHistogramMenu", []])
					} else {
						if (!this.isCorrelate) {
							this.menu.push(["Correlate", "regressionLine", false, false, false, "getCorrelationMenu", []]);
							if (this.data.x) {
								this.menu.push(["Explore Meta-Data", "doe", "createDOE"])
							}
							this.menu.push(["Histogram", "histogram", "createHistogramTr"])
						}
					}
				}
			} else {
				if (this.graphType == "Circular") {
					this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
					this.menu.push(["-"]);
					if (this.data.x || this.data.z) {
						if (this.data.x || this.data.z) {
							this.menu.push(["Segregate Data", "segregate", false, false, false, "getSegregationMenu", []])
						}
						this.menu.push(["-"])
					}
				} else {
					if (this.graphType.match(/scatter/i) || this.is3DPlot) {
						this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
						this.menu.push(["-"]);
						this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
						this.menu.push(["-"]);
						if (this.graphType == "Scatter2D") {
							if (this.isHistogram) {
								this.menu.push(["Histogram", "histogram", false, false, false, "getHistogramMenu", []])
							} else {
								if (this.isCorrelate) {
									this.menu.push(["Remove Correlation", "removeRegressionLine", "removeCorrelation"])
								} else {
									if (this.decorations && this.decorations.reg) {
										this.menu.push(["Remove Correlation", "removeRegressionLine", "removeCorrelation"])
									} else {
										this.menu.push(["Loess", "nonlinearFit", false, false, false, "getLoessMenu", []]);
										this.menu.push(["Correlate", "regressionLine", "correlateData"])
									}
									if (this.data.z && !this.scatterPlotMatrix) {
										this.menu.push(["Explore Meta-Data", "doe", "createDOE"])
									}
									if (!this.scatterPlotMatrix) {
										this.menu.push(["Create Histogram", "histogram", "createHistogram"])
									}
								}
							}
						}
						if (this.data.z) {
							this.menu.push(["Data Point Attributes", "colorShapeSize", false, false, false, "getDataPointAttributesMenu", []])
						}
					}
				}
			}
		}
		return this.menu
	};
	this.resetMenus = function() {
		this.removeMenus()
	}
};
CanvasXpress.prototype.initLinks = function() {
	this.addLinkDiv = function() {
		if (this.$(this.target + "-cX-Link")) {
			this.resetLinkDiv();
			return
		}
		var b = this.$cX("div", {
			id: this.target + "-cX-Link",
			className: "CanvasXpressLink"
		}, {
			zIndex: 10002,
			display: "none"
		});
		var a = this.$cX("ul", {
			id: this.target + "-cX-Link-Content",
			className: "CanvasXpressList"
		});
		var c = this.$("north-wrapper-" + this.target);
		if (c) {
			b.appendChild(a);
			c.appendChild(b)
		}
	};
	this.showLinkDiv = function(J, b, D) {
		var K = this.$(this.target + "-cX-Link-Content");
		var k = this.$("west-container-" + this.target);
		var M = false;
		if (K) {
			this.resetLinkDiv();
			var L = this.adjustedCoordinates(J);
			if (L) {
				var h = L.x + k.offsetWidth;
				var f = L.y;
				for (var H = 0; H < b.length; H++) {
					var o = b[H].url;
					var C = b[H].name;
					var r = b[H].title;
					var E = b[H].icon;
					var v = b[H].source;
					var B = b[H].params;
					if (o) {
						M = true
					} else {
						if (v && this.data.links && this.data.links[v]) {
							o = this.data.links[v].url;
							M = true;
							if (B) {
								for (var G in B) {
									o = o.replace("$" + G + "$", B[G])
								}
							}
						}
					}
					var F = this.$cX("li", {
						className: "CanvasXpressListItem"
					});
					var c = r ? r : this.data.links && v && this.data.links[v] && this.data.links[v].title ? this.data.links[v].title : "";
					var N = this.$cX("a", {
						className: "CanvasXpressListItemA",
						href: o,
						alt: c,
						title: c,
						target: "_blank"
					});
					var I = this.$cX("img", {
						className: "CanvasXpressListIcon",
						src: E ? E : this.data.links && v && this.data.links[v] && this.data.links[v].icon ? this.data.links[v].icon : CanvasXpress.images.canvasXpress
					});
					var A = this.$cX("span", {
						className: "CanvasXpressListItemText",
						innerHTML: C ? C : this.data.links && v && this.data.links[v] && this.data.links[v].name ? this.data.links[v].name : H
					});
					N.appendChild(I);
					N.appendChild(A);
					F.appendChild(N);
					this.addRemoveLinkListeners("addEvtListener", F);
					K.appendChild(F)
				}
				K.parentNode.style.left = h + "px";
				K.parentNode.style.top = f + "px";
				K.parentNode.style.display = M ? "block" : "none"
			}
		}
	};
	this.addRemoveLinkListeners = function(b, a) {
		if (a) {
			this.addRemoveEvtListener(b, a, "click", this.clickLink, false);
			this.addRemoveEvtListener(b, a, "mouseover", this.mouseoverLink, false);
			this.addRemoveEvtListener(b, a, "mouseout", this.mouseoutLink, false)
		}
	};
	this.clickLink = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetLinkDiv();
			return false
		}
	}(this);
	this.mouseoverLink = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getMenuItemComp(c);
			if (b) {
				b[0].className = "CanvasXpressListItemActive";
				b[1].className = "CanvasXpressListItemAActive"
			}
			return false
		}
	}(this);
	this.mouseoutLink = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getMenuItemComp(c);
			if (b) {
				b[0].className = "CanvasXpressListItem";
				b[1].className = "CanvasXpressListItemA"
			}
			return false
		}
	}(this);
	this.resetLinkDiv = function() {
		var a = this.$(this.target + "-cX-Link-Content");
		if (a && a.childNodes) {
			while (a.childNodes.length > 0) {
				this.addRemoveLinkListeners("removeEvtListener", a.childNodes[0]);
				a.removeChild(a.childNodes[0])
			}
			a.parentNode.style.display = "none"
		}
	};
	this.resetLinks = function() {
		this.resetLinkDiv()
	};
	this.initializeLinks = function() {
		if (!this.disableEvents) {
			this.addLinkDiv()
		}
	};
	this.initializeLinks()
};
CanvasXpress.prototype.initTooltip = function() {
	this.addTooltipDiv = function(u, r, q, a, b) {
		this.resetInfoSpan();
		var f = 0;
		var j = this.target + "-cX-TooltipDiv" + f;
		var w = this.$(this.target + "-cX-Info");
		if (w && w.style.display != "none") {
			r = parseInt(w.style.left);
			q = parseInt(w.style.top)
		}
		var k = this.$(j);
		while (k) {
			f++;
			j = this.target + "-cX-TooltipDiv" + f;
			k = this.$(j)
		}
		var l = this.$cX("div", {
			id: j,
			className: "CanvasXpressTooltip draggable"
		}, {
			left: r + "px",
			top: q + "px"
		});
		var p = this.$cX("img", {
			id: j + "Close",
			className: "CanvasXpressTooltip",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		var g = this.$cX("img", {
			id: j + "Marker",
			className: "CanvasXpressTooltip",
			src: CanvasXpress.images.pencil,
			obj: b,
			alt: "Add Marker",
			title: "Add Marker"
		});
		if (!a) {
			a = {}
		}
		a.clear = "both";
		var v = this.$cX("div", {
			id: j + "HTML",
			innerHTML: u || ""
		}, a);
		l.appendChild(p);
		if (b) {
			l.appendChild(g)
		}
		l.appendChild(v);
		var h = this.$("center-wrapper-" + this.target);
		h.appendChild(l);
		return l
	};
	this.addRemoveTooltipDivsListeners = function(a, b) {
		this.addRemoveEvtListener(a, b, "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, b, "touchstart", this.registerMousemove, false);
		this.addRemoveEvtListener(a, b.childNodes[0], "click", this.closeTooltipDiv, false);
		if (b.childNodes[1] && b.childNodes[0].tagName.toUpperCase() == "IMG") {
			this.addRemoveEvtListener(a, b.childNodes[1], "click", this.addMarkerTooltipDiv, false)
		}
	};
	this.closeTooltipDiv = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (b) {
				var f = b.parentNode;
				a.addRemoveTooltipDivsListeners("removeEvtListener", f);
				f.parentNode.removeChild(f)
			}
			return false
		}
	}(this);
	this.addMarkerTooltipDiv = function(a) {
		return function(c) {
			var b = c.target || c.srcElement;
			if (b) {
				var g = b.parentNode;
				var f = b.obj;
				if (f) {
					a.addMarkerConfigurator(c, f)
				}
			}
			return false
		}
	}(this);
	this.showTooltipDiv = function(f, j, b, a, i, h, c) {
		var g;
		if (i && h) {
			g = this.addTooltipDiv(j, i, h, a, c);
			this.addRemoveTooltipDivsListeners("addEvtListener", g)
		} else {
			var l = this.$(this.target + "-cX-Info");
			var k = b ? this.regularCoordinates(f, b) : this.adjustedCoordinates(f, l);
			if (k) {
				i = k.x;
				h = f ? k.y : k.y + 25;
				g = this.addTooltipDiv(j, i, h, a, c);
				this.addRemoveTooltipDivsListeners("addEvtListener", g)
			}
		}
	};
	this.resetTooltipDivs = function() {
		var c = 0;
		var a = this.target + "-cX-TooltipDiv" + c;
		var b = this.$(a);
		while (b) {
			this.addRemoveTooltipDivsListeners("removeEvtListener", b);
			b.parentNode.removeChild(b);
			c++;
			a = this.target + "-cX-TooltipDiv" + c;
			b = this.$(a)
		}
	};
	this.addInfoSpan = function() {
		if (this.$(this.target + "-cX-Info")) {
			this.resetInfoSpan();
			return
		}
		var b = this.$("center-wrapper-" + this.target);
		var a = this.$cX("span", {
			id: this.target + "-cX-Info",
			className: "CanvasXpressTooltip"
		}, {
			display: "none"
		});
		b.appendChild(a)
	};
	this.resetInfoSpan = function(d, c) {
		var b = this.$(this.target + "-cX-Info");
		if (b && !this.noInfoSpanReset) {
			var a = new Date().getTime() - this.infoStartTime;
			if (a > this.infoTimeIn || c) {
				b.style.left = "0px";
				b.style.top = "0px";
				b.style.display = "none";
				b.innerHTML = ""
			}
		}
	};
	this.flashInfoSpan = function(l, k, o, d, a) {
		var g = this;
		if (d) {
			this.noInfoSpanReset = true
		}
		var q = new Date().getTime() - this.infoStartTime;
		var r = this.$(this.target + "-cX-Info");
		var j = this.$(this.target);
		var b = j.getClientRects();
		if (r) {
			r.innerHTML = o;
			r.style.display = "block";
			var n = parseInt(r.clientWidth);
			var f = parseInt(r.clientHeight);
			r.style.left = (l || 0) + "px";
			r.style.top = (k || 0) + "px";
			if (a) {
				for (var e in a) {
					r.style[e] = a[e]
				}
			}
			if (d) {
				this.noInfoSpanReset = true;
				var m = function() {
					this.update = function() {
						var c = new Date().getTime();
						if (c - g.infoStartTime > d) {
							g.noInfoSpanReset = false;
							g.resetInfoSpan();
							clearInterval(h)
						}
					};
					var h = this.setInterval(this.update, d)
				};
				m.call()
			}
		}
	};
	this.showInfoSpan = function(d, k, a) {
		if (this.draggingOn || this.remoteUpdating || this.noInfoSpanReset) {
			return
		}
		var m = new Date().getTime() - this.infoStartTime;
		var n = this.$(this.target + "-cX-Info");
		if (n && k && k != "" && m > this.infoTimeIn) {
			var l = a ? this.regularCoordinates(d, a) : this.adjustedCoordinates(d, n);
			if (l) {
				var g = l.x;
				var f = d ? l.y : l.y + 25;
				if (this.meta.system.isIE) {
					g += document.body.scrollLeft;
					f += document.body.scrollTop
				}
				if (!isNaN(k)) {
					k = k.toString()
				}
				if (k.match(/\w/)) {
					n.innerHTML = k;
					n.style.left = (g + 10) + "px";
					n.style.top = (f - 20) + "px";
					n.style.display = "inline";
					if (this.isMap) {
						n.style.zIndex = 10000
					}
					var j = parseInt(n.clientWidth);
					var b = parseInt(n.clientHeight);
					if (j < window.innerWidth && j > (window.innerWidth + window.pageXOffset) - g && (j + 20) < (g - window.pageXOffset)) {
						n.style.left = (g - (j + 20)) + "px";
						n.style.left = (g - (parseInt(n.clientWidth) + 20)) + "px"
					}
					if (b < window.innerHeight && b > (window.innerHeight + window.pageYOffset) - f && (b - 15) < (f - window.pageYOffset)) {
						n.style.top = (f - (b - 15)) + "px";
						n.style.top = (f - (parseInt(n.clientHeight) - 15)) + "px"
					}
					this.infoStartTime = new Date().getTime();
					var c = this;
					var i = function() {
						this.update = function() {
							var h = new Date().getTime();
							if (h - c.infoStartTime > c.infoTimeOut) {
								c.resetInfoSpan();
								clearInterval(e)
							}
						};
						var e = this.setInterval(this.update, 100)
					};
					i.call()
				}
			}
		}
	};
	this.addMarkerConfigurator = function(Q, H) {
		var y = this.$("center-wrapper-" + this.target);
		if (y) {
			var F = this.target + "-cX-Marker";
			if (this.$(F)) {
				this.closeMarkerConfigurator(false, this.$(F))
			}
			var O = Q.target || Q.srcElement;
			var D = O.parentNode;
			var R = this.adjustedCoordinates(Q);
			var z = H.y ? H.y.vars : H.w.vars;
			var C = H.y ? H.y.smps : H.w.smps;
			var k = this.graphType.match(/Treemap|Stacked/) ? true : false;
			var I = {};
			var E = false;
			var A = {
				id: this.newId(this.target + "-marker-"),
				vi: this.getVariableIndices(z),
				si: this.getSampleIndices(C, k),
				variable: z,
				sample: C,
				update: false
			};
			var L = false;
			var G = ["text", "color", "fontSize", "fontStyle", "align", "baseline", "type", "x", "y"];
			for (var N = 0; N < G.length; N++) {
				I[G[N]] = ""
			}
			I.align = "center";
			I.baseline = "middle";
			I.type = "line";
			if (this.decorations && this.decorations.marker) {
				for (var N = 0; N < this.decorations.marker.length; N++) {
					var J = this.decorations.marker[N];
					if (this.isSameObject(J.variable, z) && this.isSameObject(J.sample, C)) {
						for (var M = 0; M < G.length; M++) {
							I[G[M]] = J[G[M]]
						}
						L = true;
						A.update = true
					}
				}
			}
			var B = this.$cX("div", {
				id: F,
				className: "CanvasXpressMarker draggable",
				par: D.id,
				obj: A
			}, {
				left: R.x + "px",
				top: (R.y - this.height) + "px",
				display: "block",
				position: "relative"
			});
			var c = this.$cX("img", {
				id: F + "ConfiguratorMarkerClose",
				className: "CanvasXpressDataTableToolbarImage",
				src: CanvasXpress.images.cancel1,
				alt: "Close",
				title: "Close"
			});
			var f = this.$cX("div", {
				id: F + "Container",
				className: "CanvasXpressDataTableContainer"
			}, {
				left: "12px"
			});
			var d = this.$cX("table", {
				id: F + "MarkerTable",
				className: "CanvasXpressDataTable"
			});
			var a = this.$cX("tbody");
			for (var N = 0; N < G.length; N++) {
				var b = this.$cX("tr");
				var q = this.$cX("th", {
					className: "CanvasXpressTableCellHead"
				}, {
					height: G[N] == "text" ? "64px" : "18px",
					width: "80px",
					backgroundRepeat: "repeat"
				});
				var l = this.$cX("div", {
					className: "CanvasXpressTableCell",
					innerHTML: this.capitalize(G[N])
				}, {
					height: G[N] == "text" ? "64px" : "18px",
					width: "80px"
				});
				var u = this.$cX("td", {
					className: "CanvasXpressTableCell"
				}, {
					height: G[N] == "text" ? "64px" : "18px",
					width: "160px",
					border: "1px solid #ccc"
				});
				var t = this.$cX("div", {
					className: "CanvasXpressTableCell"
				}, {
					height: G[N] == "text" ? "64px" : "18px",
					width: "160px"
				});
				var h;
				if (G[N] == "text") {
					h = this.$cX("textarea", {
						id: F + "ConfiguratorMarker-" + G[N],
						className: "CanvasXpressMarker",
						name: G[N],
						value: I[G[N]],
						rows: 3
					}, {
						width: "100%",
						border: "none"
					})
				} else {
					if (G[N] == "color") {
						h = this.$cX("input", {
							id: F + "ConfiguratorMarker-" + G[N],
							className: "CanvasXpressMarker",
							type: "color",
							name: G[N],
							value: I[G[N]] ? this.validateColor(I[G[N]], null, true) : ""
						}, {
							width: "100%",
							border: "none"
						})
					} else {
						if (G[N] == "type") {
							h = this.$cX("select", {
								id: F + "ConfiguratorMarker-" + G[N],
								className: "CanvasXpressMarker",
								size: 1
							}, {
								width: "100%",
								border: "none",
								backgroundColor: "white"
							});
							var x = this.$cX("option", {
								text: "line",
								value: "line"
							});
							try {
								h.add(x, null)
							} catch (P) {
								h.add(x)
							}
							var g = this.$cX("option", {
								text: "annotation",
								value: "annotation"
							});
							try {
								h.add(g, null)
							} catch (P) {
								h.add(g)
							}
							if (I[G[N]] && I[G[N]] != "line") {
								h.options[1].selected = true;
								E = true
							}
						} else {
							if (G[N] == "x" || G[N] == "y") {
								h = this.$cX("input", {
									id: F + "ConfiguratorMarker-" + G[N],
									className: "CanvasXpressMarker",
									type: "number",
									name: G[N],
									value: I[G[N]] ? sprintf("%.2f", Number(I[G[N]])) : 0,
									min: 0,
									max: 1,
									step: 0.01
								}, {
									width: "100%",
									border: "none"
								});
								if (E) {
									h.disabled = true
								}
							} else {
								if (G[N].match(/fontSize/)) {
									h = this.$cX("input", {
										id: F + "ConfiguratorMarker-" + G[N],
										className: "CanvasXpressMarker",
										type: "number",
										name: G[N],
										value: I[G[N]] || 12
									}, {
										width: "100%",
										border: "none"
									})
								} else {
									h = this.$cX("input", {
										id: F + "ConfiguratorMarker-" + G[N],
										className: "CanvasXpressMarker",
										type: "text",
										name: G[N],
										value: I[G[N]] || ""
									}, {
										width: "100%",
										border: "none"
									})
								}
							}
						}
					}
				}
				var r = this.$cX("input", {
					id: F + "ConfiguratorMarkerRemove",
					value: "Remove",
					type: "button"
				}, {
					cssFloat: "left",
					borderRadius: "5px",
					position: "relative",
					top: "308px",
					left: "12px",
					width: "125px",
					height: "24px"
				});
				var K = this.$cX("input", {
					id: F + "ConfiguratorMarkerAdd",
					value: L ? "Update" : "Add",
					type: "button"
				}, {
					cssFloat: "left",
					borderRadius: "5px",
					position: "relative",
					top: "308px",
					left: "24px",
					width: "125px",
					height: "24px"
				});
				t.appendChild(h);
				u.appendChild(t);
				q.appendChild(l);
				b.appendChild(q);
				b.appendChild(u);
				a.appendChild(b)
			}
			d.appendChild(a);
			f.appendChild(d);
			B.appendChild(c);
			B.appendChild(f);
			B.appendChild(r);
			B.appendChild(K);
			y.appendChild(B);
			this.addRemoveMarkerConfiguratorListeners("addEvtListener")
		}
	};
	this.addRemoveMarkerConfiguratorListeners = function(e) {
		var b = this.$(this.target + "-cX-Marker");
		var h = this.$(this.target + "-cX-MarkerConfiguratorMarkerClose");
		var g = this.$(this.target + "-cX-MarkerConfiguratorMarkerRemove");
		var d = this.$(this.target + "-cX-MarkerConfiguratorMarkerAdd");
		var f = this.$(this.target + "-cX-MarkerConfiguratorMarker-type");
		if (b && h && g && d && f) {
			this[e](b, "mousedown", this.registerMousemove, false);
			this[e](h, "click", this.closeMarkerConfigurator, false);
			this[e](g, "click", this.removeMarker, false);
			this[e](d, "click", this.addMarker, false);
			this[e](f, "change", this.changeTypeMarker, false)
		}
	};
	this.closeMarkerConfigurator = function(a) {
		return function(f, b) {
			var c = f ? (f.target || f.srcElement) : false;
			var d = c ? a.$(c.parentNode.par) : b ? a.$(b.par) : false;
			if (d) {
				a.addRemoveTooltipDivsListeners("removeEvtListener", d);
				d.parentNode.removeChild(d)
			}
			if (!b) {
				b = c.parentNode
			}
			a.addRemoveMarkerConfiguratorListeners("removeEvtListener", b);
			b.parentNode.removeChild(b);
			return false
		}
	}(this);
	this.removeMarker = function(a) {
		return function(c) {
			var b = c.target || c.srcElement;
			a.modifyMarker(b.parentNode.obj, true);
			a.closeMarkerConfigurator(c);
			return false
		}
	}(this);
	this.addMarker = function(a) {
		return function(c) {
			var b = c.target || c.srcElement;
			a.modifyMarker(b.parentNode.obj);
			a.closeMarkerConfigurator(c);
			return false
		}
	}(this);
	this.changeTypeMarker = function(a) {
		return function(d) {
			var c = d.target || d.srcElement;
			var f = this.value;
			var b = c.parentNode.parentNode.parentNode.nextElementSibling;
			var g = b.nextElementSibling;
			b.childNodes[1].childNodes[0].childNodes[0].disabled = f == "line" ? false : true;
			g.childNodes[1].childNodes[0].childNodes[0].disabled = f == "line" ? false : true;
			return false
		}
	}(this);
	this.modifyMarker = function(e, a) {
		var d = ["text", "color", "fontSize", "fontStyle", "align", "baseline", "type", "x", "y"];
		for (var b = 0; b < d.length; b++) {
			var c = this.$(this.target + "-cX-MarkerConfiguratorMarker-" + d[b]);
			if (c) {
				e[d[b]] = c.value
			}
		}
		this.updateMarker(e, a)
	};
	this.updateMarker = function(e, b) {
		this.functionCaller = "updateMarker";
		if (this.isTransition()) {
			return
		}
		if (b) {
			if (e.update) {
				var d = [];
				for (var c = 0; c < this.decorations.marker.length; c++) {
					var a = this.decorations.marker[c];
					if (this.isSameObject(a.variable, e.variable) && this.isSameObject(a.sample, e.sample)) {
						continue
					}
					d.push(a)
				}
				this.decorations.marker = d
			} else {
				return false
			}
		} else {
			if (e.update) {
				for (var c = 0; c < this.decorations.marker.length; c++) {
					var a = this.decorations.marker[c];
					if (this.isSameObject(a.variable, e.variable) && this.isSameObject(a.sample, e.sample)) {
						a.text = e.text;
						a.color = e.color;
						a.fontSize = Number(e.fontSize);
						if (e.fontStyle != "") {
							a.fontStyle = e.fontStyle
						}
						a.align = e.align;
						a.baseline = e.baseline;
						a.x = Number(e.x);
						a.y = Number(e.y);
						a.type = e.type;
						break
					}
				}
			} else {
				if (!this.decorations) {
					this.decorations = {}
				}
				if (!this.decorations.marker) {
					this.decorations.marker = []
				}
				this.decorations.marker.push({
					vi: e.vi,
					si: e.si,
					variable: e.variable,
					sample: e.sample,
					text: e.text,
					color: e.color,
					fontSize: Number(e.fontSize),
					fontStyle: e.fontStyle,
					align: e.align,
					baseline: e.baseline,
					x: Number(e.x),
					y: Number(e.y),
					type: e.type
				})
			}
		}
		this.draw()
	};
	this.initializeTooltip = function() {
		this.setPixelImage();
		if (!this.disableEvents) {
			this.addInfoSpan()
		}
	};
	this.initializeTooltip()
};
CanvasXpress.prototype.initToolbar = function() {
	this.addToolbarDiv = function() {
		if (this.$(this.target + "-cX-Toolbar")) {
			return
		}
		var a = this.beaconImage;
		var s = this.meta.canvas.ctx.canvas.height < 350 && !this.meta.system.isTouchScreen;
		var n = this.meta.canvas.ctx.canvas.height >= 500 ? "20px" : "16px";
		var g = this.$cX("div", {
			id: this.target + "-cX-Toolbar"
		}, {
			position: "absolute",
			overflow: "hidden",
			width: this.width + "px",
			height: "0px",
			left: "7px",
			top: "4px",
			zIndex: 9000
		});
		var t = this.$cX("div", {
			id: this.target + "-cX-Toolbar-Custom"
		}, {
			cssFloat: "left"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-ToolbarSave",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.camera,
			alt: "Save as png",
			title: "Save as png"
		}, {
			width: n,
			height: n
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-ToolbarMove",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.move,
			alt: "Move Canvas (Grab here)",
			title: "Move Canvas (Grab here)",
			draggable: false
		}, {
			width: n,
			height: n,
			display: this.movable ? "none" : "block",
			cursor: "move"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-ToolbarLayout",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.funnel,
			alt: "Explore data",
			title: "Explore data"
		}, {
			width: n,
			height: n,
			display: this.disableDataFilters || this.disableDataTable || this.disableConfigurator || s ? "none" : "block"
		});
		var j = this.$cX("img", {
			id: this.target + "-cX-ToolbarDataExplorer",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.configure,
			alt: "Configure",
			title: "Configure"
		}, {
			width: n,
			height: n,
			display: this.isMap ? "none" : "block"
		});
		var o = this.$cX("img", {
			id: this.target + "-cX-ToolbarInformation",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.information1,
			alt: "Data Details",
			title: "Data Details"
		}, {
			width: n,
			height: n,
			display: this.info ? "block" : "none"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-ToolbarMaxMin",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.inout,
			alt: this.maximized ? "Minimize" : "Maximize",
			title: this.maximized ? "Minimize" : "Maximize"
		}, {
			marginRight: "13px",
			width: n,
			height: n
		});
		var r = this.$cX("div", {
			id: this.target + "-cX-ToolbarHelpDescription",
			className: "CanvasXpressToolbarHelp draggable"
		}, {
			cursor: "move",
			display: "none",
			padding: "10px",
			position: "absolute"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-ToolbarHelpClose",
			className: "CanvasXpressToolbarHelp",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		r.appendChild(document.createTextNode("Help"));
		r.appendChild(h);
		r.appendChild(this.$cX("br"));
		this.addHelp(r);
		g.appendChild(t);
		g.appendChild(a);
		g.appendChild(f);
		g.appendChild(o);
		g.appendChild(j);
		g.appendChild(l);
		g.appendChild(k);
		g.appendChild(b);
		g.appendChild(r);
		var r = this.$("north-wrapper-" + this.target);
		if (r) {
			r.appendChild(g);
			this.addRemoveToolbarListeners("addEvtListener")
		}
	};
	this.addRemoveToolbarListeners = function(c) {
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarSave"), "click", this.print, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarMove"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarLayout"), "click", this.clickLayout, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarDataExplorer"), "click", this.clickDataExplorer, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarInformation"), "click", this.clickDataDetails, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarMaxMin"), "click", this.clickGraphMaxMin, false);
		var a = this.$(this.target + "-cX-Toolbar-Custom");
		if (c == "removeEvtListener" && a) {
			for (var b = 0; b < a.childNodes.length; b++) {
				this.addRemoveEvtListener(c, a.childNodes[b], "click", this.addCustomToolbarMenu, false);
				this.addRemoveEvtListener(c, a.childNodes[b], "contextmenu", this.unpinFromToolbar, false)
			}
		}
	};
	this.clickHelp = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-Toolbar");
			var d = a.$(a.target + "-cX-ToolbarHelpDescription");
			if (c && d) {
				c.style.overflow = "visible";
				d.style.display = "block";
				d.style.left = ((f.layerX || f.x) - 400) + "px";
				d.style.top = (f.layerY || f.y) + "px"
			}
			return false
		}
	}(this);
	this.clickShowCode = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.showCodeDiv();
			return false
		}
	}(this);
	this.closeHelp = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-Toolbar");
			var d = a.$(a.target + "-cX-ToolbarHelpDescription");
			if (c && d) {
				d.style.display = "none";
				setTimeout(function() {
					c.style.overflow = "hidden"
				}, 300)
			}
			return false
		}
	}(this);
	this.clickLayoutNoAnimation = function(c) {
		if (this.appLayout && !c) {
			var b = this.showFadeResizeMoveAnimation;
			this.showFadeResizeMoveAnimation = false;
			this.hideTable();
			this.hideDataFilter();
			var a = this.$(this.target + "-cX-ToolbarLayout");
			a.src = CanvasXpress.images.funnel;
			a.alt = "Explore data";
			a.title = "Explore data";
			this.appLayout = false;
			this.activeAccordion = false;
			this.showFadeResizeMoveAnimation = b;
			return false
		}
	};
	this.clickLayoutShowDataFilter = function() {
		this.showDataFilter();
		if (!this.dataFilterLastState || (this.dataFilterLastState && this.dataFilterLastState != "docked")) {
			this.moveDataFilter(false, "dock");
			if (!this.activeAccordion) {
				var a = this;
				setTimeout(function() {
					if (a.graphType == "Genome") {
						a.activateAccordion(false, a.$(a.target + "-cX-DataFilterGenomeHeader"))
					} else {
						if (a.graphType == "Network") {
							a.activateAccordion(false, a.$(a.target + "-cX-DataFilterNodeHeader"))
						} else {
							a.activateAccordion(false, a.$(a.target + "-cX-DataFilterVariableHeader"))
						}
					}
				}, this.showFadeResizeMoveAnimation ? 500 : 0)
			}
		}
	};
	this.clickLayoutShowDataTable = function() {
		this.updateDataTable();
		if (!this.dataTableLastState || (this.dataTableLastState && this.dataTableLastState != "docked")) {
			this.moveDataTableDiv("dock")
		}
		var a = this;
		setTimeout(function() {
			var d = a.$("middle-container-" + a.target);
			var c = a.dataTableLastWidth || parseInt(d.style.width) + (a.dataFilterWidth + 6) - (a.appLayoutDataTable ? 20 : 2);
			var b = a.dataTableLastHeight || parseInt(a.dataTableTarget.style.height);
			a.dataTableTarget = a.$(a.target + "-cX-DataTable");
			a.updateDataTableResizerDiv(false, c, b);
			a.endDataTableResizerDiv();
			a.hideToolbar()
		}, this.showFadeResizeMoveAnimation ? 500 : 0)
	};
	this.backgroundMask = function(a) {
		var b = this.$("container-" + this.target);
		if (b) {
			if (a) {
				b.style.position = "fixed";
				b.style.left = 0;
				b.style.top = 0;
				b.style.width = a[0];
				b.style.height = a[1];
				b.style.overflow = "hidden";
				b.style.zIndex = 1000000;
				b.style.backgroundColor = "white"
			} else {
				b.style.position = "relative";
				b.style.left = "";
				b.style.top = "";
				b.style.width = "";
				b.style.height = "";
				b.style.overflow = "";
				b.style.zIndex = "";
				b.style.backgroundColor = ""
			}
		}
	};
	this.clickLayout = function(a) {
		return function(i, c, j) {
			if (!i) {
				i = window.event
			}
			if (a.appLayoutDataTable) {
				a.clickDataTable(i);
				setTimeout(function() {
					a.clickDataFilters(i)
				}, 1000)
			} else {
				if (a.appLayoutDataFilter) {
					a.clickDataFilters(i);
					setTimeout(function() {
						a.clickDataTable(i)
					}, 1000)
				} else {
					var f = a.showFadeResizeMoveAnimation ? 500 : 0;
					if (!c) {
						if (i) {
							c = i.target || i.srcElement
						} else {
							c = a.$(a.target + "-cX-ToolbarLayout")
						}
					}
					a.appLayout = a.appLayout ? false : true;
					c.src = CanvasXpress.images.funnel;
					c.alt = "Explore data";
					c.title = "Explore data";
					if (a.resizeHeightOnLayout) {
						a.setDataTableDimensions()
					}
					var b = a.isLayoutConfigurator ? a.configuratorWidth + a.dataFilterWidth - 14 : a.dataFilterWidth - 14;
					var d = a.dataTableLastHeight ? a.dataTableRowsHeight + 9 : a.dataTableRowsHeight + 53;
					if (a.appLayout) {
						if (a.resizeWidthOnLayout && a.width - b >= b * 1.3) {
							if (a.resizeHeightOnLayout && a.height - d >= d * 1) {
								a.setDimensions(a.width - b, a.height - d + 24, true);
								a.resizeWidthOnLayoutActive = true;
								a.resizeHeightOnLayoutActive = true
							} else {
								a.setDimensions(a.width - b, a.height + 18.5, true);
								a.resizeWidthOnLayoutActive = true
							}
							a.resizeViewport()
						} else {
							if (a.resizeHeightOnLayout && a.height - d >= d * 1) {
								a.setDimensions(a.width - 12, a.height - d + 24, true);
								a.resizeHeightOnLayoutActive = true;
								a.resizeViewport()
							}
						}
						var g = a.isLayoutConfigurator ? 500 : 1;
						if (a.isLayoutConfigurator) {
							a.addConfigurator();
							a.selectConfig(false, true);
							if (!a.configuratorLastState || (a.configuratorLastState && a.configuratorLastState != "docked")) {
								a.clickDockUndockConfigurator()
							}
						}
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - a.heigthOffsetDataFilter();
						setTimeout(function() {
							a.clickLayoutShowDataFilter();
							setTimeout(function() {
								a.clickLayoutShowDataTable()
							}, f)
						}, g)
					} else {
						if (a.isLayoutConfigurator) {
							a.closeConfigurator()
						}
						setTimeout(function() {
							if (a.activeAccordion) {
								a.activateAccordion(false, a.activeAccordion.previousSibling)
							}
							a.hideDataFilter();
							setTimeout(function() {
								a.hideTable();
								a.hideToolbar();
								setTimeout(function() {
									if (a.resizeWidthOnLayoutActive) {
										if (a.resizeHeightOnLayoutActive) {
											a.setDimensions(a.width + b + 36, a.height + d + 12, true)
										} else {
											a.setDimensions(a.width + b + 36, a.height + 18.5, true)
										}
									} else {
										if (a.resizeHeightOnLayoutActive) {
											a.setDimensions(a.width + 48, a.height + d + 12, true)
										}
									}
									a.resizeWidthOnLayoutActive = false;
									a.resizeHeightOnLayoutActive = false;
									setTimeout(function() {
										a.updateRemoteNavigationWindow()
									}, f * 0.2)
								}, f)
							}, f)
						}, f)
					}
				}
			}
			return false
		}
	}(this);
	this.clickDataTable = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			if (a.maximized) {
				if (a.appLayout) {
					a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"));
					setTimeout(function() {
						a.clickDataTable(d)
					}, 2000)
				} else {
					if (a.appLayoutDataFilter) {
						a.clickDataFilters(d);
						setTimeout(function() {
							a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"))
						}, 1500)
					} else {
						a.setDataTableDimensions();
						var b = -42;
						var c = a.dataTableLastHeight ? a.dataTableRowsHeight + 9 : a.dataTableRowsHeight + 53;
						a.appLayoutDataTable = a.appLayoutDataTable ? false : true;
						if (a.appLayoutDataTable) {
							a.setDimensions(a.width - b, a.height - c + 24, true);
							a.resizeHeightOnLayoutActive = true;
							a.clickLayoutShowDataTable()
						} else {
							a.hideTable();
							setTimeout(function() {
								a.setDimensions(a.width + b + 36, a.height + c + 12, true, 250);
								a.resizeHeightOnLayoutActive = false
							}, 250)
						}
					}
				}
			} else {
				a.updateDataTable()
			}
			return false
		}
	}(this);
	this.clickDataExplorer = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			a.addDataExplorer(b);
			return false
		}
	}(this);
	this.clickDataFilters = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			if (a.maximized) {
				if (a.appLayout) {
					a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"));
					setTimeout(function() {
						a.clickDataFilters(d)
					}, 2000)
				} else {
					if (a.appLayoutDataTable) {
						a.clickDataTable(d);
						setTimeout(function() {
							a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"))
						}, 1500)
					} else {
						var b = a.isLayoutConfigurator ? a.configuratorWidth + a.dataFilterWidth - 9 : a.dataFilterWidth - 9;
						var c = a.heigthOffsetDataFilter();
						a.appLayoutDataFilter = a.appLayoutDataFilter ? false : true;
						if (a.appLayoutDataFilter) {
							a.setDimensions(a.width - b, a.height + 18.5, true);
							a.resizeWidthOnLayoutActive = true;
							a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - c;
							a.clickLayoutShowDataFilter()
						} else {
							if (a.activeAccordion) {
								a.activateAccordion(false, a.activeAccordion.previousSibling)
							}
							a.hideDataFilter();
							setTimeout(function() {
								a.resizeViewportMiddle(a.width + b + 36, a.height + 18.5);
								a.setDimensions(a.width + b + 36, a.height + 18.5, true, 250);
								a.resizeWidthOnLayoutActive = false
							}, 250)
						}
					}
				}
			} else {
				a.showDataFilter()
			}
			return false
		}
	}(this);
	this.clickDataDetails = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = document.body.scrollLeft;
			var f = document.body.scrollTop;
			var c = {
				maxWidth: "500px",
				maxHeight: "500px",
				whiteSpace: "normal",
				overflow: "auto",
				textAlign: "left"
			};
			a.showTooltipDiv(d, a.info, false, c, d.clientX + b - a.width, d.clientY + f);
			return false
		}
	}(this);
	this.clickRepResearch = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var b = document.body.scrollLeft;
			var h = document.body.scrollTop;
			var c = a.prettyJSON(CanvasXpress.stack[a.target]);
			var f = '<pre class="CanvasXpressCode">\n' + c + "</pre>\n";
			var d = {
				maxWidth: "500px",
				maxHeight: "500px",
				whiteSpace: "normal",
				overflow: "auto",
				textAlign: "left"
			};
			a.showTooltipDiv(g, f, false, d, g.clientX + b - (a.width / 2), g.clientY + h);
			return false
		}
	}(this);
	this.clickGraphMaxMin = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = 1;
			if (a.appLayout) {
				a.clickLayout(c, a.$(a.target + "-cX-ToolbarLayout"));
				b = 2000
			} else {
				if (a.appLayoutDataTable) {
					a.clickDataTable(c);
					b = 1000
				} else {
					if (a.appLayoutDataFilter) {
						a.clickDataFilters(c);
						b = 1000
					}
				}
			}
			setTimeout(function() {
				var i = a.remoteService ? a.$(a.remoteParentId + "-canvasXpressRemoteWindow") : a.$("container-" + a.target);
				var h = a.$(a.target + "-cX-ToolbarMaxMin");
				var d = screen.width;
				var f = screen.height;
				var g = window.innerWidth;
				var e = window.innerHeight;
				if (i && h) {
					if (a.maximized) {
						a.backgroundMask();
						h.alt = "Maximize";
						h.title = "Maximize";
						h.src = CanvasXpress.images.inout;
						a.setDimensions(a.maximized[0], a.maximized[1]);
						i.style.left = a.maximized[2];
						i.style.top = a.maximized[3];
						a.maximized = false;
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - a.heigthOffsetDataFilter()
					} else {
						a.maximized = [a.width + 18, a.height + 18, i.style.left, i.style.top];
						a.backgroundMask([d, f]);
						h.alt = "Minimize";
						h.title = "Minimize";
						h.src = CanvasXpress.images.inout;
						a.setDimensions(g + 3, e + 19);
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - a.heigthOffsetDataFilter()
					}
				}
			}, b);
			return false
		}
	}(this);
	this.addHelp = function(l) {
		var i = this.$cX("div", false, {
			width: "400px"
		});
		i.appendChild(this.$cX("br"));
		var C = this.$cX("img", {
			src: CanvasXpress.images.help1
		});
		i.appendChild(C);
		i.appendChild(document.createTextNode(" Show this help"));
		i.appendChild(this.$cX("br"));
		var v = this.$cX("img", {
			src: CanvasXpress.images.camera
		});
		i.appendChild(v);
		i.appendChild(document.createTextNode(" Print"));
		i.appendChild(this.$cX("br"));
		var g = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Save the image as a 'png' file."
		});
		i.appendChild(g);
		var s = this.$cX("img", {
			src: CanvasXpress.images.disk
		});
		i.appendChild(s);
		i.appendChild(document.createTextNode(" Save"));
		i.appendChild(this.$cX("br"));
		var G = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Save save the data as a tab delimited file."
		});
		i.appendChild(G);
		var D = this.$cX("img", {
			src: CanvasXpress.images.funnel
		});
		i.appendChild(D);
		i.appendChild(document.createTextNode(" Filters"));
		i.appendChild(this.$cX("br"));
		var H = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Widget used to filter the data and metadata. Metadata will be automatically assigned as text, numeric or date."
		});
		i.appendChild(H);
		var D = this.$cX("img", {
			src: CanvasXpress.images.table
		});
		i.appendChild(D);
		i.appendChild(document.createTextNode(" Show data"));
		i.appendChild(this.$cX("br"));
		var b = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Show the data used for this visualization in an HTML table."
		});
		i.appendChild(b);
		var o = this.$cX("img", {
			src: CanvasXpress.images.transpose
		});
		i.appendChild(o);
		i.appendChild(document.createTextNode(" Transpose data table"));
		i.appendChild(this.$cX("br"));
		var C = this.$cX("img", {
			src: CanvasXpress.images.cog
		});
		i.appendChild(C);
		i.appendChild(document.createTextNode(" Show the configurator"));
		i.appendChild(this.$cX("br"));
		var f = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "This widget allows you to customize this graph. You may enter the name of the property you wish to customize in the text box (which filters as you type) or browse through a number of categories.<br>You will find a short description for the property you select along with its category and links to other relevant properties.<br>You will also see the current value for the seleced property along with a link to an additional widget to help you specifying the new value."
		});
		i.appendChild(f);
		var F = this.$cX("img", {
			src: CanvasXpress.images.configureShow
		});
		i.appendChild(F);
		i.appendChild(document.createTextNode(" Application mode (Filter and Table)"));
		i.appendChild(this.$cX("br"));
		var e = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Show both the data table and the data filters."
		});
		i.appendChild(e);
		var A = this.$cX("img", {
			src: CanvasXpress.images.pin
		});
		i.appendChild(A);
		i.appendChild(document.createTextNode(" Dock widget to the side"));
		i.appendChild(this.$cX("br"));
		var m = this.$cX("img", {
			src: CanvasXpress.images.unpin
		});
		i.appendChild(m);
		i.appendChild(document.createTextNode(" Undock widget from the side"));
		i.appendChild(this.$cX("br"));
		var y = this.$cX("img", {
			src: CanvasXpress.images.purpleCode
		});
		i.appendChild(y);
		i.appendChild(document.createTextNode(" Show visualization code"));
		i.appendChild(this.$cX("br"));
		var B = this.$cX("img", {
			src: CanvasXpress.images.menuDropdown
		});
		i.appendChild(B);
		i.appendChild(document.createTextNode(" Show configuration menus"));
		i.appendChild(this.$cX("br"));
		var r = this.$cX("img", {
			src: CanvasXpress.images.fullScreen
		});
		i.appendChild(r);
		i.appendChild(document.createTextNode(" Maximize window. Click again to restore."));
		i.appendChild(this.$cX("br"));
		var E = this.$cX("img", {
			src: CanvasXpress.images.cancel1
		});
		i.appendChild(E);
		i.appendChild(document.createTextNode(" Close widget"));
		i.appendChild(this.$cX("br"));
		i.appendChild(this.$cX("br"));
		var j = this.$cX("a", {
			href: "https://canvasxpress.org",
			target: "_blank",
			innerHTML: "canvasXpress"
		});
		i.appendChild(document.createTextNode("Additional documentation at "));
		i.appendChild(j);
		i.appendChild(this.$cX("br"));
		l.appendChild(i)
	};
	this.showToolbar = function(e) {
		if (!this.disableToolbar) {
			var b = this.$(this.target + "-cX-Toolbar");
			var d = this.$("west-container-" + this.target);
			var a = this.$(this.target + "-cX-ToolbarMove");
			if (b && parseInt(b.style.height) == 0 && d && a) {
				a.style.display = this.movable && !this.maximized ? "block" : "none";
				this.resizeMove(b, 0, 4, this.width, 24, 250);
				if (e) {
					var c = this;
					setTimeout(function() {
						c.hideToolbar(e)
					}, e)
				}
			}
		}
	};
	this.hideToolbar = function(d) {
		var a = this.$(this.target + "-cX-Toolbar");
		var c = this.$("west-container-" + this.target);
		if (a && parseInt(a.style.height) == 24 && c) {
			this.resizeMove(a, 0, 4, this.width, 0, 250)
		} else {
			if (d && a && parseInt(a.style.height) > 0) {
				var b = this;
				setTimeout(function() {
					b.hideToolbar(d)
				}, d)
			}
		}
	};
	this.isToolbar = function(c) {
		if (!c) {
			c = window.event
		}
		var b = this.adjustedCoordinates(c);
		if (b) {
			var a = b.x;
			var d = b.y;
			if (d > 0 && d < 24 && a > 0 && a < this.width) {
				this.showToolbar()
			} else {
				if (d > 24 && d < this.height && a > 0 && a < this.width) {
					this.hideToolbar()
				}
			}
		}
	};
	this.addTouchToolbarDiv = function() {
		if (this.$(this.target + "-cX-TouchToolbar")) {
			return
		}
		var n = 24;
		var j = this.meta.canvas.ctx.canvas.height >= 500 ? 16 : 11;
		var f = this.$cX("div", {
			id: this.target + "-cX-TouchToolbar"
		}, {
			position: "absolute",
			width: (n + j + 12) + "px",
			height: ((n * 6) + 12) + "px",
			left: 0 + "px",
			top: ((this.height - (n * 6)) / 2) + "px",
			display: "flex",
			zIndex: 9000
		});
		var g = this.$cX("div", {
			id: this.target + "-cX-TouchToolbarLeft"
		}, {
			width: 0,
			height: ((n * 6) + 12) + "px",
			overflow: "hidden"
		});
		var b = this.$cX("div", {
			id: this.target + "-cX-TouchToolbarRight"
		}, {
			width: (j - 1) + "px",
			height: "128px"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarMouse",
			className: "CanvasXpressToolbarImage",
			key: "mouse",
			src: CanvasXpress.images.hoverToolbar,
			swp: CanvasXpress.images.mouseLeft,
			title: "Toggle hover / drag"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var o = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarAlt",
			className: "CanvasXpressToolbarImage",
			key: "alt",
			src: CanvasXpress.images.alt24,
			swp: CanvasXpress.images.alt24,
			title: "Toggle Alt on / off"
		}, {
			width: n + "px",
			height: n + "px",
			opacity: 0.3,
			filter: "alpha(opacity=30)"
		});
		var q = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarShift",
			className: "CanvasXpressToolbarImage",
			key: "shift",
			src: CanvasXpress.images.shift24,
			swp: CanvasXpress.images.shift24,
			title: "Toggle Shift on / off"
		}, {
			width: n + "px",
			height: n + "px",
			opacity: 0.3,
			filter: "alpha(opacity=30)"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarCtrl",
			className: "CanvasXpressToolbarImage",
			key: "ctrl",
			src: CanvasXpress.images.ctrl24,
			swp: CanvasXpress.images.ctrl24,
			title: "Toggle Ctrl on / off"
		}, {
			width: n + "px",
			height: n + "px",
			opacity: 0.3,
			filter: "alpha(opacity=30)"
		});
		var p = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarWheel",
			className: "CanvasXpressToolbarImage",
			key: "wheel",
			src: CanvasXpress.images.mouseNone,
			swp: CanvasXpress.images.mouseScroll,
			title: "Toggle Ctrl on / off"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarEsc",
			className: "CanvasXpressToolbarImage",
			key: "esc",
			src: CanvasXpress.images.esc24,
			swp: CanvasXpress.images.esc24,
			title: "Click to ESC"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var i = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarMobileHandle",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.mobileHandle,
			title: "Interaction"
		}, {
			width: (j - 4) + "px",
			height: n + "px",
			position: "relative",
			top: ((n * 2.5) + 6) + "px"
		});
		g.appendChild(d);
		g.appendChild(o);
		g.appendChild(q);
		g.appendChild(l);
		g.appendChild(p);
		g.appendChild(k);
		b.appendChild(i);
		f.appendChild(g);
		f.appendChild(b);
		var p = this.$("west-wrapper-" + this.target);
		if (p) {
			p.appendChild(f);
			this.addRemoveTouchToolbarListeners("addEvtListener")
		}
	};
	this.addRemoveTouchToolbarListeners = function(a) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarMobileHandle"), "click", this.clickMobileHandle, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarMouse"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarAlt"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarShift"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarCtrl"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarWheel"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarEsc"), "click", this.clickMobileKey, false)
	};
	this.teaseMobileControls = function(a) {
		var b = this;
		if (!a) {
			a = 1000
		}
		if (!this.disableTouchToolbar && this.meta.system.isTouchScreen) {
			b.clickMobileHandle();
			setTimeout(function() {
				b.clickMobileHandle()
			}, a)
		}
	};
	this.clickMobileHandle = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-TouchToolbarLeft");
			var d = a.meta.canvas.ctx.canvas.height >= 500 ? 38 : 28;
			if (c) {
				var b = parseInt(c.clientWidth);
				if (b > 0) {
					a.resizeMove(c, 0, 0, 0, (d * 6) + 12, 250)
				} else {
					a.resizeMove(c, 0, 0, d, (d * 6) + 12, 250)
				}
			}
			return false
		}
	}(this);
	this.clickMobileKey = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var b = this.key;
			if (b == "wheel") {
				a.resetMobileKeys()
			} else {
				if (a.wheelKeyMobile) {
					var h = a.$(a.target + "-cX-TouchToolbarWheel");
					d = h.src;
					h.src = h.swp;
					h.swp = d;
					a.wheelKeyMobile = false
				}
			}
			a[b + "KeyMobile"] = a[b + "KeyMobile"] ? false : true;
			var d = this.src;
			this.src = this.swp;
			this.swp = d;
			var f = ["Alt", "Shift", "Ctrl"];
			for (var c = 0; c < f.length; c++) {
				var h = a.$(a.target + "-cX-TouchToolbar" + f[c]);
				if (a[f[c].toLowerCase() + "KeyMobile"]) {
					h.style.opacity = 1;
					h.style.filter = "alpha(opacity=100)"
				} else {
					h.style.opacity = 0.3;
					h.style.filter = "alpha(opacity=30)"
				}
			}
			if (b == "esc") {
				a.resetMobileKeys();
				a.masterReset(g)
			} else {
				var f = ["alt", "shift", "ctrl"];
				var h = a.$(a.target + "-cX-TouchToolbarMouse");
				for (var c = 0; c < f.length; c++) {
					if (a[f[c] + "KeyMobile"]) {
						if (!a.mouseKeyMobile) {
							d = h.src;
							h.src = h.swp;
							h.swp = d;
							a.mouseKeyMobile = true
						}
						break
					}
				}
			}
			return false
		}
	}(this);
	this.resetMobileKeys = function() {
		var d = ["Mouse", "Alt", "Shift", "Ctrl", "Wheel", "Esc"];
		for (var b = 0; b < d.length; b++) {
			var e = this.$(this.target + "-cX-TouchToolbar" + d[b]);
			var a = d[b].toLowerCase();
			if (e && this[a + "KeyMobile"]) {
				var c = e.src;
				e.src = e.swp;
				e.swp = c;
				this[a + "KeyMobile"] = false;
				if (a.match(/alt|shift|ctrl/)) {
					e.style.opacity = 0.3;
					e.style.filter = "alpha(opacity=30)"
				}
			}
		}
	};
	this.initializeToolbar = function() {
		this.setPixelImage();
		if (!this.disableEvents) {
			if (!this.disableToolbar) {
				this.addToolbarDiv()
			}
			if (!this.disableTouchToolbar && this.meta.system.isTouchScreen) {
				this.addTouchToolbarDiv()
			}
		}
	};
	this.initializeToolbar()
};
CanvasXpress.prototype.initConfigurator = function() {
	this.addConfigurator = function(a) {
		return function(af, D, N, M) {
			var w = false;
			if (!af) {
				af = window.event
			}
			if (a.isVML || a.disableConfigurator) {
				return
			}
			var ah = a.$(a.target + "-cX-Configurator");
			if (ah) {
				w = true;
				if (a.activeTarget) {
					a.activeTarget.style.zIndex = 10000
				}
				a.activeTarget = ah;
				a.activeTarget.style.zIndex = 10001
			}
			var F = "Search property or function";
			a.configuringOn = true;
			if (D) {
				if (a.isArray(D)) {
					D = D[0]
				}
				if (a.graphType == "Network") {
					a.configuringNetwork = D;
					if (a.data.nodes.length > D) {
						F = "Configure " + (a.data.nodes[D].label || a.data.nodes[D].name || a.data.nodes[D].id)
					} else {
						var A = a.data.edges[D - a.data.nodes.length];
						var I = a.data.nodes[a.data.nodeIndices[A.id1]];
						var H = a.data.nodes[a.data.nodeIndices[A.id2]];
						F = "Configure " + (I.label || I.name || I.id) + " - " + (H.label || I.name || H.id)
					}
				} else {
					if (a.graphType == "Genome") {
						a.configuringGenome = D;
						F = "Configure track " + D
					}
				}
			}
			var B = N != null && M != null ? {
				x: N,
				y: M
			} : a.adjustedCoordinates(af);
			if (B) {
				N = a.configuratorLastState == "docked" ? 0 : B.x;
				M = a.configuratorLastState == "docked" ? 0 : B.y;
				if (w) {
					ah.style.left = N + "px";
					ah.style.top = M + "px";
					return
				} else {
					ah = a.$cX("div", {
						id: a.target + "-cX-Configurator",
						className: "CanvasXpressConfigurator draggable"
					}, {
						cursor: "move",
						left: N + "px",
						top: M + "px",
						padding: "10px",
						position: "absolute",
						zIndex: 10001
					})
				}
				var ab = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorKeyText"
				}, {
					display: "block",
					marginBottom: "5px",
					width: a.configuratorWidth + "px"
				});
				var ac = a.$cX("span", {
					id: a.target + "-cX-ConfiguratorKeyTextSpan",
					className: "CanvasXpressConfigurator",
					innerHTML: F
				});
				var J = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyMenu",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.menuDropdown,
					alt: "Open menus",
					title: "Open menus"
				});
				var ad = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeySearch",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.find,
					alt: "Browse properties by category",
					title: "Browse properties by category"
				});
				var C = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyDock",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.pin,
					alt: "Dock",
					title: "Dock",
					state: "free"
				});
				var Z = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var aa = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorKey",
					className: "CanvasXpressConfigurator",
					type: "text"
				}, {
					display: "block",
					width: a.configuratorWidth + "px"
				});
				var Y = a.$cX("select", {
					id: a.target + "-cX-ConfiguratorCategories",
					className: "CanvasXpressConfigurator",
					size: 5
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var S = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSugestionsText",
					innerHTML: "Select property"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px"
				});
				var R = a.$cX("select", {
					id: a.target + "-cX-ConfiguratorSugestions",
					className: "CanvasXpressConfigurator",
					size: a.mobileApp ? 5 : 10
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var ag = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSugestionsDescription"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px",
					minHeight: "56px",
					overflow: "auto"
				});
				var P = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorValueText",
					innerHTML: "Current value"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px"
				});
				var aj = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSeeAlso"
				}, {
					display: "none",
					width: a.configuratorWidth + "px",
					minHeight: "20px",
					overflow: "auto"
				});
				var O = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorValue",
					className: "CanvasXpressConfigurator",
					type: "text"
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var E = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorApply",
					value: "Apply",
					type: "button"
				}, {
					display: "none",
					cssFloat: "left",
					borderRadius: "5px",
					top: "4px",
					position: "relative",
					width: (a.configuratorWidth / 2) + "px"
				});
				var ai = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorButton",
					value: "Draw",
					type: "button"
				}, {
					display: "none",
					cssFloat: "left",
					borderRadius: "5px",
					top: "4px",
					position: "relative",
					width: (a.configuratorWidth / 2) + "px"
				});
				var T = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorOptionsClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var L = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorOptions",
					className: "CanvasXpressConfigurator draggable"
				}, {
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var V = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorCurrent",
					className: "CanvasXpressConfiguratorColor"
				}, {
					width: "181px",
					height: "16px",
					cssFloat: "left",
					cursor: "default"
				});
				var U = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorColorClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var X = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColor",
					className: "CanvasXpressConfigurator draggable"
				}, {
					width: "204px",
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var G = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorFilter",
					className: "CanvasXpressConfiguratorFilter draggable",
					innerHTML: 'Build filter ("+" to set "-" to remove)'
				}, {
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var K = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorFilterClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var Q = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorExample",
					className: "CanvasXpressConfiguratorExample draggable"
				}, {
					width: (a.configuratorExamplesSize + 35) + "px",
					maxHeight: (a.configuratorExamplesSize) + "px",
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute",
					overflow: "hidden",
					paddingBottom: "35px"
				});
				var ae = a.$cX("span", {
					id: a.target + "-cX-ConfiguratorExampleSpan",
					className: "CanvasXpressConfiguratorExample",
					innerHTML: ""
				});
				var t = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorExampleClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var h = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorExampleContent",
					className: "CanvasXpressConfiguratorExampleContent"
				}, {
					maxWidth: (a.configuratorExamplesSize + 35) + "px",
					maxHeight: (a.configuratorExamplesSize) + "px",
					overflow: "auto"
				});
				ab.appendChild(ac);
				ab.appendChild(Z);
				ab.appendChild(C);
				ab.appendChild(ad);
				ab.appendChild(J);
				L.appendChild(document.createTextNode("Select option ..."));
				L.appendChild(T);
				L.appendChild(a.$cX("br"));
				X.appendChild(V);
				X.appendChild(U);
				X.appendChild(a.$cX("br"));
				G.appendChild(K);
				G.appendChild(a.$cX("br"));
				Q.appendChild(ae);
				Q.appendChild(t);
				Q.appendChild(a.$cX("br"));
				Q.appendChild(h);
				ah.appendChild(ab);
				ah.appendChild(aa);
				ah.appendChild(Y);
				ah.appendChild(S);
				ah.appendChild(R);
				ah.appendChild(ag);
				ah.appendChild(aj);
				ah.appendChild(P);
				ah.appendChild(O);
				ah.appendChild(E);
				ah.appendChild(ai);
				ah.appendChild(L);
				ah.appendChild(X);
				ah.appendChild(G);
				ah.appendChild(Q);
				var W = a.$("west-wrapper-" + a.target);
				if (W) {
					W.appendChild(ah);
					if (a.activeTarget) {
						a.activeTarget.style.zIndex = 10000
					}
					a.activeTarget = ah;
					a.addRemoveConfiguratorListeners("addEvtListener");
					if (a.configuringNetwork || a.configuringGenome) {
						a.selectConfig(false, true)
					}
					setTimeout(function() {
						aa.focus()
					}, 300)
				}
			}
		}
	}(this);
	this.addConfiguratorCloseMenus = function(a) {
		return function(d, c, b, f) {
			a.removeMenus();
			a.addConfigurator(d, c, b, f)
		}
	}(this);
	this.addRemoveConfiguratorListeners = function(h) {
		var B = this.$(this.target + "-cX-Configurator");
		var w = this.$(this.target + "-cX-ConfiguratorCategories");
		var j = this.$(this.target + "-cX-ConfiguratorSugestions");
		var d = this.$(this.target + "-cX-ConfiguratorApply");
		var C = this.$(this.target + "-cX-ConfiguratorButton");
		var x = this.$(this.target + "-cX-ConfiguratorKeyClose");
		var D = this.$(this.target + "-cX-ConfiguratorKeyDock");
		var A = this.$(this.target + "-cX-ConfiguratorKeySearch");
		var a = this.$(this.target + "-cX-ConfiguratorKeyMenu");
		var e = this.$(this.target + "-cX-ConfiguratorOptions");
		var k = this.$(this.target + "-cX-ConfiguratorOptionsClose");
		var v = this.$(this.target + "-cX-ConfiguratorColor");
		var u = this.$(this.target + "-cX-ConfiguratorColorClose");
		var g = this.$(this.target + "-cX-ConfiguratorFilter");
		var r = this.$(this.target + "-cX-ConfiguratorFilterClose");
		var y = this.$(this.target + "-cX-ConfiguratorExample");
		var o = this.$(this.target + "-cX-ConfiguratorExampleClose");
		if (B && w && j && C && d && x && D && A && a && e && k && v && u && g && r && y && o) {
			this[h](B, "mousedown", this.registerMousemove, false);
			this[h](w, "change", this.changeCategory, false);
			this[h](w, "click", this.changeCategory, false);
			this[h](j, "change", this.clickSuggestions, false);
			this[h](j, "click", this.clickSuggestions, false);
			this[h](d, "click", this.clickApplyConfigurator, false);
			this[h](C, "click", this.clickConfigurator, false);
			this[h](a, "click", this.clickMenuDropDown, false);
			this[h](A, "click", this.clickSearch, false);
			this[h](D, "click", this.clickDockUndockConfigurator, false);
			this[h](x, "click", this.closeConfigurator, false);
			this[h](e, "mousedown", this.registerMousemove, false);
			this[h](k, "click", this.closePropertyOptions, false);
			this[h](v, "mousedown", this.registerMousemove, false);
			this[h](u, "click", this.closePropertyColor, false);
			this[h](g, "mousedown", this.registerMousemove, false);
			this[h](r, "click", this.closePropertyFilter, false);
			this[h](y, "mousedown", this.registerMousemove, false);
			this[h](o, "click", this.closePropertyExample, false)
		}
	};
	this.getConfigurableProperties = function() {
		if (this.configuringNetwork) {
			if (this.data.nodes.length > this.configuringNetwork) {
				return this.getNodeConfigurableProperties(this.configuringNetwork)
			} else {
				return this.getEdgeConfigurableProperties(this.configuringNetwork - this.data.nodes.length)
			}
		} else {
			if (this.configuringGenome) {
				if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
					return this.featureConfigurableProperties
				} else {
					if (this.configuringGenome.match(/track/)) {
						return this.trackConfigurableProperties
					} else {
						this.configuringGenome = false
					}
				}
			}
		}
		var d = [];
		for (var c in CanvasXpress.doc.P) {
			if (!CanvasXpress.doc.P[c].Z) {
				var a = CanvasXpress.doc.P[c].M;
				var b = CanvasXpress.doc.P[c].U;
				if (CanvasXpress.doc.M[a].U) {
					if (CanvasXpress.doc.M[a].U.hasOwnProperty(this.graphType)) {
						d.push(c)
					}
				} else {
					if (b) {
						if (b.hasOwnProperty(this.graphType)) {
							d.push(c)
						}
					} else {
						d.push(c)
					}
				}
			}
		}
		return d
	};
	this.getConfigurableObjectDoc = function(a) {
		if (this.configuringNetwork) {
			if (this.data.nodes.length > this.configuringNetwork) {
				return CanvasXpress.doc.N[a] ? CanvasXpress.doc.N[a] : false
			} else {
				return CanvasXpress.doc.E[a] ? CanvasXpress.doc.E[a] : false
			}
		} else {
			if (this.configuringGenome) {
				if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
					return CanvasXpress.doc.F[a] ? CanvasXpress.doc.F[a] : false
				} else {
					if (this.configuringGenome.match(/track/)) {
						return CanvasXpress.doc.G[a] ? CanvasXpress.doc.G[a] : false
					} else {
						this.configuringGenome = false;
						return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
					}
				}
			} else {
				return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
			}
		}
	};
	this.selectConfig = function(D, F) {
		var z = this.$(this.target + "-cX-ConfiguratorKey");
		var q = this.$(this.target + "-cX-ConfiguratorSugestionsText");
		var n = this.$(this.target + "-cX-ConfiguratorSugestions");
		var E = this.$(this.target + "-cX-ConfiguratorSugestionsDescription");
		var l = this.$(this.target + "-cX-ConfiguratorValueText");
		var H = this.$(this.target + "-cX-ConfiguratorSeeAlso");
		var j = this.$(this.target + "-cX-ConfiguratorValue");
		var f = this.$(this.target + "-cX-ConfiguratorApply");
		var G = this.$(this.target + "-cX-ConfiguratorButton");
		var B = this.$(this.target + "-cX-ConfiguratorValueHREF");
		var m = document.activeElement;
		var y = this.getConfigurableProperties();
		var w = [];
		if (this.getKeyCode(D) == 13) {
			this.resetOptionColorFiltersExamples();
			if (this.editingDescriptionOn) {
				this.submitEditPropertyDescription()
			} else {
				if (n && j && j.value) {
					var g = false;
					for (var A = 0; A < y.length; A++) {
						if (n.value == y[A]) {
							g = true;
							break
						}
					}
					if (g) {
						this.clickConfigurator(D, n, j)
					} else {
						this.resetConfigurator()
					}
				}
			}
		} else {
			if (m.id.match(/canvasXpressConfiguratorFilterValue/)) {
				return
			} else {
				if (z && m.id == z.id || F) {
					this.resetOptionColorFiltersExamples();
					this.resetEditPropertyDescription();
					for (var A = 0; A < y.length; A++) {
						if (y[A].toLowerCase().indexOf(z.value.toLowerCase()) >= 0) {
							w.push(y[A])
						}
					}
					if (w.length > 0 && q && n && E && l && H && j && G && f) {
						this.resetSugestions();
						if (!this.configuringNetwork && !this.configuringGenome) {
							w.sort(function(d, c) {
								return CanvasXpress.doc.P[d].M > CanvasXpress.doc.P[c].M ? 1 : CanvasXpress.doc.P[c].M > CanvasXpress.doc.P[d].M ? -1 : d > c ? 1 : c > d ? -1 : 0
							});
							for (var A = 0; A < w.length; A++) {
								var y = this.$cX("option", {
									text: CanvasXpress.doc.P[w[A]].M ? CanvasXpress.doc.P[w[A]].M + " : " + w[A] : "NA : " + w[A],
									value: w[A]
								});
								try {
									n.add(y, null)
								} catch (C) {
									n.add(y)
								}
							}
						} else {
							w.sort();
							for (var A = 0; A < w.length; A++) {
								var y = this.$cX("option", {
									text: w[A],
									value: w[A]
								});
								try {
									n.add(y, null)
								} catch (C) {
									n.add(y)
								}
							}
						}
						n.options[0].selected = true;
						this.setConfiguratorPropertyValue(n, E, l, H, j);
						q.innerHTML = "Select property (" + w.length + ")";
						q.style.display = "block";
						n.style.display = "block";
						E.style.display = "block";
						l.style.display = "block";
						H.style.display = "block";
						j.style.display = "block";
						G.style.display = "block";
						f.style.display = "block"
					} else {
						z.value = z.value.slice(0, z.value.length - 1)
					}
				} else {
					if (j && m.id == j.id) {
						this.resetOptionColorFiltersExamples();
						this.resetEditPropertyDescription();
						if (B && B.innerHTML == "color") {
							B.style.color = j.value ? this.rgbToHex(this.validateColor(j.value.replace(/[\'\"]/g, ""))) : this.foreground
						}
					} else {
						if (this.remoteService) {
							this.resetOptionColorFiltersExamples();
							this.selectDataSet(D)
						}
					}
				}
			}
		}
		return false
	};
	this.clickSearch = function(a) {
		return function(G) {
			if (!G) {
				G = window.event
			}
			a.configuringNetwork = false;
			a.configuringGenome = false;
			a.resetEditOptionColorFiltersExamples();
			var E = a.$(a.target + "-cX-ConfiguratorKeyTextSpan");
			var C = a.$(a.target + "-cX-ConfiguratorKey");
			var A = a.$(a.target + "-cX-ConfiguratorCategories");
			var w = a.$(a.target + "-cX-ConfiguratorSugestionsText");
			var t = a.$(a.target + "-cX-ConfiguratorSugestions");
			var H = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
			var q = a.$(a.target + "-cX-ConfiguratorValueText");
			var J = a.$(a.target + "-cX-ConfiguratorSeeAlso");
			var p = a.$(a.target + "-cX-ConfiguratorValue");
			var I = a.$(a.target + "-cX-ConfiguratorButton");
			var c = a.$(a.target + "-cX-ConfiguratorApply");
			var f = a.$(a.target + "-cX-ConfiguratorOptions");
			var y = a.$(a.target + "-cX-ConfiguratorColor");
			var h = a.$(a.target + "-cX-ConfiguratorFilter");
			var B = a.getKeys(CanvasXpress.doc.M).sort();
			var j = [];
			if (C && C.style.display == "none") {
				if (E) {
					E.innerText = "Search property or function"
				}
				if (A) {
					A.style.display = "none"
				}
				C.value = "";
				C.style.display = "block"
			} else {
				if (E) {
					for (var D = 0; D < B.length; D++) {
						if (CanvasXpress.doc.M[B[D]].U) {
							if (CanvasXpress.doc.M[B[D]].U.hasOwnProperty(a.graphType)) {
								j.push(B[D])
							}
						} else {
							j.push(B[D])
						}
						E.innerText = "Select category (" + j.length + ")"
					}
				}
				if (C) {
					C.style.display = "none"
				}
				if (A) {
					a.resetCategories();
					for (var D = 0; D < j.length; D++) {
						var x = a.$cX("option", {
							text: j[D],
							value: j[D]
						});
						try {
							A.add(x, null)
						} catch (F) {
							A.add(x)
						}
					}
					A.style.display = "block"
				}
			}
			if (w && t && H && q && J && p && I && c && f && y && h) {
				w.style.display = "none";
				t.style.display = "none";
				H.style.display = "none";
				q.style.display = "none";
				J.style.display = "none";
				p.style.display = "none";
				I.style.display = "none";
				c.style.display = "none";
				f.style.display = "none";
				y.style.dysplay = "none";
				h.style.dysplay = "none"
			}
			return false
		}
	}(this);
	this.clickMenuDropDown = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.closeConfigurator(b);
			a.addMenu(b, false, false, false, 8, 8);
			return false
		}
	}(this);
	this.clickDockUndockConfigurator = function(a) {
		return function(m, f) {
			if (!m) {
				m = window.event
			}
			var p = a.$(a.target + "-cX-Configurator");
			var n = a.$(a.target + "-cX-ConfiguratorKeyDock");
			var q = a.$(a.target + "-cX-ConfiguratorButton");
			var t = a.$(a.target + "-cX-ConfiguratorApply");
			var s = a.$("middle-container-" + a.target);
			var g = a.$("west-container-" + a.target);
			var l = a.$("east-container-" + a.target);
			var k = this.showFadeResizeMoveAnimation ? 500 : 0;
			if (p && n && s && g && l) {
				if (n.state == "free" && !f) {
					var o = (parseInt(p.style.padding) * 2) + 2;
					var j = p.clientHeight - o;
					a.configuringOn = "docked";
					a.resizeViewportWest();
					p.className = "CanvasXpressConfigurator fixed";
					p.style.cursor = "default";
					n.src = CanvasXpress.images.unpin;
					n.alt = "Undock";
					n.title = "Undock";
					n.state = "docked";
					a.configuratorLastState = "docked";
					s.style.width = p.clientWidth + a.meta.canvas.ctx.canvas.width + l.clientWidth + 2;
					a.resizeMove(g, 0, 0, p.clientWidth, a.meta.canvas.ctx.canvas.height, k, null);
					a.resizeMove(p, 0, 0, a.configuratorWidth, a.meta.canvas.ctx.canvas.height - o, k, null);
					q.style.left = ((a.configuratorWidth / 2) + 10) + "px";
					t.style.left = "10px";
					q.style.position = "absolute";
					t.style.position = "absolute";
					setTimeout(function() {
						a.resizeViewportWest();
						q.style.top = (a.meta.canvas.ctx.canvas.height - (o + 10)) + "px";
						t.style.top = (a.meta.canvas.ctx.canvas.height - (o + 10)) + "px";
						q.style.position = "absolute";
						t.style.position = "absolute"
					}, k)
				} else {
					a.configuringOn = "free";
					p.className = "CanvasXpressConfigurator draggable";
					p.style.cursor = "move";
					q.style.left = "0px";
					t.style.left = "0px";
					q.style.top = "4px";
					t.style.top = "4px";
					q.style.position = "relative";
					t.style.position = "relative";
					n.src = CanvasXpress.images.pin;
					n.alt = "Dock";
					n.title = "Dock";
					n.state = "free";
					a.configuratorLastState = "free";
					a.resizeMove(g, 0, 0, 0, a.meta.canvas.ctx.canvas.height, k, function() {
						s.style.width = a.meta.canvas.ctx.canvas.width + l.clientWidth
					});
					a.resizeViewportWest();
					setTimeout(function() {
						p.style.height = ""
					}, k)
				}
			}
			return false
		}
	}(this);
	this.closeConfigurator = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetViewportOverflow("west");
			a.clickDockUndockConfigurator(b, true);
			a.resetConfigurator();
			return false
		}
	}(this);
	this.changeCategory = function(a) {
		return function(G, D, I) {
			if (!G) {
				G = window.event
			}
			a.resetEditOptionColorFiltersExamples();
			var C = a.$(a.target + "-cX-ConfiguratorCategories");
			var w = a.$(a.target + "-cX-ConfiguratorSugestionsText");
			var t = a.$(a.target + "-cX-ConfiguratorSugestions");
			var H = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
			var q = a.$(a.target + "-cX-ConfiguratorValueText");
			var K = a.$(a.target + "-cX-ConfiguratorSeeAlso");
			var l = a.$(a.target + "-cX-ConfiguratorValue");
			var f = a.$(a.target + "-cX-ConfiguratorApply");
			var J = a.$(a.target + "-cX-ConfiguratorButton");
			var g = a.$(a.target + "-cX-ConfiguratorOptions");
			var B = a.$(a.target + "-cX-ConfiguratorColor");
			var h = a.$(a.target + "-cX-ConfiguratorFilter");
			var k = CanvasXpress.doc.M;
			if (I) {
				C.value = I
			}
			if (C && C.value && w && t && H && q && K && l && J && g && B && h) {
				var y = k[C.value].P.sort();
				a.resetSugestions();
				for (var E = 0; E < y.length; E++) {
					if (I && y[E] == I) {
						D = E
					}
					var A = a.$cX("option", {
						text: y[E],
						value: y[E]
					});
					try {
						t.add(A, null)
					} catch (F) {
						t.add(A)
					}
				}
				t.options[D || 0].selected = true;
				w.innerHTML = "Select property (" + y.length + ")";
				a.setConfiguratorPropertyValue(t, H, q, K, l);
				w.style.display = "block";
				t.style.display = "block";
				H.style.display = "block";
				q.style.display = "block";
				K.style.display = "block";
				l.style.display = "block";
				f.style.display = "block";
				J.style.display = "block";
				g.style.display = "none";
				B.style.display = "none";
				h.style.display = "none"
			}
			return false
		}
	}(this);
	this.hideCategories = function() {
		var a = this.$(this.target + "-cX-ConfiguratorCategories");
		var b = this.$(this.target + "-cX-ConfiguratorKeyTextSpan");
		var c = this.$(this.target + "-cX-ConfiguratorKeySearch");
		var e = this.$(this.target + "-cX-ConfiguratorKeyDock");
		if (a && b && c && e) {
			a.style.display = "none";
			b.innerHTML = "";
			c.style.display = "none";
			e.style.display = "none"
		}
	};
	this.resetCategories = function() {
		var a = this.$(this.target + "-cX-ConfiguratorCategories");
		if (a) {
			if (a.hasChildNodes()) {
				while (a.childNodes.length >= 1) {
					a.removeChild(a.firstChild)
				}
			}
			a.style.display = "none"
		}
	};
	this.clickSuggestions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditOptionColorFiltersExamples();
			a.setConfiguratorPropertyValue();
			return false
		}
	}(this);
	this.setConfiguratorPropertyValue = function(l, e, j, g, h) {
		if (!l) {
			l = this.$(this.target + "-cX-ConfiguratorSugestions")
		}
		if (!e) {
			e = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
		}
		if (!j) {
			j = this.$(this.target + "-cX-ConfiguratorValueText")
		}
		if (!g) {
			g = this.$(this.target + "-cX-ConfiguratorSeeAlso")
		}
		if (!h) {
			h = this.$(this.target + "-cX-ConfiguratorValue")
		}
		var k;
		var f = this.$(this.target + "-cX-ConfiguratorOptions");
		var c = this.getConfigurableObjectDoc(l.value);
		h.value = "";
		h.style.readonly = false;
		if (this.configuringNetwork) {
			if (typeof(this[l.value]) == "function") {
				h.style.disabled = "disabled";
				h.style.readonly = false
			} else {
				if (this.configuringNetwork < this.data.nodes.length) {
					k = this.data.nodes[this.configuringNetwork][l.value]
				} else {
					k = this.data.edges[this.configuringNetwork - this.data.nodes.length][l.value]
				}
			}
		} else {
			if (this.configuringGenome) {
				var b = this.subtracksInfo;
				if (!isNaN(this.configuringGenome)) {
					k = this.data.tracks[b[this.configuringGenome].track].data[b[this.configuringGenome].index][l.value]
				} else {
					if (this.configuringGenome.match(/:/)) {
						k = parseInt(this.configuringGenome.split(":")[1]);
						k = this.data.tracks[b[k].track].data[b[k].index][l.value]
					} else {
						k = parseInt(this.configuringGenome.replace("track-", ""));
						k = this.data.tracks[b[k].track][l.value]
					}
				}
			} else {
				if (typeof(this[l.value]) == "function") {
					j.innerHTML = "Current&nbsp;value&nbsp;[&nbsp;<i>function</i>&nbsp;]&nbsp;" + this[l.value].length + "&nbsp;parameter(s)";
					if (this[l.value].length == 0) {
						h.style.disabled = "disabled";
						h.style.readonly = false
					}
				} else {
					k = this[l.value]
				}
			}
		}
		h.value = k ? JSON.stringify(k) : "";
		this.addPropertyDescription(e, c, l.value);
		this.addPropertySeeAlsoLinks(g, c);
		this.addPropertyOptions(j, f, c, l.value, k);
		if (this.showConfiguratorExamplesOnSelect) {
			this.resetPropertyExample();
			this.clickExamplePropertyDescription(false, l.value)
		}
	};
	this.resetSugestions = function() {
		var a = this.$(this.target + "-cX-ConfiguratorSugestions");
		if (a) {
			if (a.hasChildNodes()) {
				while (a.childNodes.length >= 1) {
					a.removeChild(a.firstChild)
				}
			}
			a.style.display = "none"
		}
	};
	this.addPropertyDescription = function(r, g, f) {
		var t = g && g.C ? g.C : "";
		var j = g && g.M ? g.M : "";
		var v = g && g.H ? true : false;
		this.resetPropertyDescription(r);
		var n = this.$cX("img", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionEdit",
			src: CanvasXpress.images.pencil,
			alt: "Edit description",
			title: "Edit description"
		}, {
			cursor: "default",
			margin: "2px",
			width: "10px",
			height: "10px"
		});
		var a = this.$cX("i", {
			innerHTML: f
		});
		var w = this.$cX("span", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan",
			className: "CanvasXpressConfigurator",
			prop: f,
			innerHTML: " : " + t
		});
		var k = this.$cX("i", {
			innerHTML: j
		});
		var l = this.$cX("a", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionExample",
			href: "javascript:void(0)",
			alt: "Show examples",
			title: "Show examples"
		});
		var u = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		l.appendChild(a);
		u.appendChild(document.createTextNode("Description [ "));
		u.appendChild(k);
		u.appendChild(document.createTextNode(" ]"));
		r.appendChild(u);
		r.appendChild(this.$cX("br"));
		r.appendChild(v ? l : a);
		r.appendChild(w);
		r.appendChild(n);
		this.addEvtListener(l, "click", this.clickExamplePropertyDescription, false);
		this.addEvtListener(n, "click", this.clickEditPropertyDescription, false)
	};
	this.resetPropertyDescription = function(f, b, a) {
		if (!f) {
			f = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
		}
		if (!b) {
			b = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionEdit")
		}
		if (f && b) {
			this.removeEvtListener(b, "click", this.clickEditPropertyDescription, false);
			if (!a) {
				a = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionExample")
			}
			if (a) {
				this.removeEvtListener(a, "click", this.clickExamplePropertyDescription, false)
			}
			while (f.childNodes.length > 0) {
				var g = f.childNodes[0];
				f.removeChild(g)
			}
		}
	};
	this.getExamplesDocObject = function(l, z) {
		var c = [];
		if (l) {
			var n = this.getConfigurableObjectDoc(l);
			var e = n.U ? this.getKeys(n.U) : CanvasXpress.doc.M[n.M]["U"] ? this.getKeys(CanvasXpress.doc.M[n.M]["U"]) : ["Bar"];
			for (var t = 0; t < n.H.length; t++) {
				if (n.H[t].match(/\*/)) {
					var a = [];
					var r = n.H[t] == "{*}" ? {} : JSON.parse(String(n.H[t].replace("*,", "")));
					var h = r.data ? this.getDataSet(r.data) : false;
					var y = r.skipExample ? this.getObjectArray(r.skipExample) : {};
					var b = r.functions ? r.functions : false;
					var g = r.conditional ? r.conditional : false;
					if (h) {
						delete(r.data)
					}
					if (y) {
						delete(r.skipExample)
					}
					if (b) {
						delete(r.functions)
					}
					if (g) {
						delete(r.conditional)
					}
					if (n.T == "option") {
						a = n.O
					} else {
						if (n.T == "boolean") {
							a = [true, false]
						} else {
							if (n.T == "color") {
								a = ["rgb(255,125,51)", "rgb(51,255,125)", "rgb(125,51,255)"];
								a.unshift(n.D)
							} else {
								if (n.T == "float") {
									a = n.D == "null" ? [null, 0.5] : [parseFloat(n.D), Math.max(parseFloat(n.D) * 1.5, 1)]
								} else {
									if (n.T == "integer") {
										a = n.D == 0 ? [0, 1] : [parseInt(n.D), parseInt((parseInt(n.D) * 1.5) + 0.5)]
									}
								}
							}
						}
					}
					for (var s = 0; s < a.length; s++) {
						if (y.hasOwnProperty(a[s])) {
							continue
						}
						var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + String(a[s]).replace(/\s/m, "-") + "-" + t;
						var v = this.cloneObject(r);
						v.title = l + " : " + a[s];
						v[l] = a[s];
						if (v[l] == "false") {
							v[l] = false
						} else {
							if (v[l] == "true") {
								v[l] = true
							} else {
								if (v[l] == "null") {
									v[l] = null
								}
							}
						}
						if (!v.graphType) {
							v.graphType = e[0]
						}
						if (g) {
							for (var k in g) {
								v[k] = g[k][s % g[k].length]
							}
						}
						if (b && s == 0) {
							c.push([m, h, v, b])
						} else {
							c.push([m, h, v])
						}
					}
				} else {
					var s = JSON.parse(String(n.H[t]));
					var x = s.data ? this.getDataSet(s.data) : false;
					var w = s.functions ? s.functions : false;
					if (x) {
						delete(s.data)
					}
					if (w) {
						delete(s.functions)
					}
					var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + t;
					if (!s.graphType) {
						s.graphType = e[0]
					}
					if (w) {
						c.push([m, x, s, w])
					} else {
						c.push([m, x, s])
					}
				}
			}
		}
		return c
	};
	this.clickExamplePropertyDescription = function(a) {
		return function(u, n, y) {
			a.resetPropertyExample();
			var t = y ? a.$(n + "-cX-API-Example") : a.$(a.target + "-cX-ConfiguratorExample");
			var d = y ? a.$(n + "-cX-API-ExampleSpan") : a.$(a.target + "-cX-ConfiguratorExampleSpan");
			var m = y ? a.$(n + "-cX-API-ExampleContent") : a.$(a.target + "-cX-ConfiguratorExampleContent");
			if (t && d && m) {
				t.style.display = "block";
				if (!n) {
					n = this.firstChild.innerHTML
				}
				var f = a.getExamplesDocObject(n);
				d.innerHTML = n;
				for (var r = 0; r < f.length; r++) {
					var o = f[r][0];
					var l = f[r][1] || a.dataSetExample;
					var s = f[r][2];
					var g = f[r][3];
					var w = a.$cX("canvas", {
						id: o,
						width: y ? 500 : a.configuratorExamplesSize,
						height: y ? 500 : a.configuratorExamplesSize
					});
					m.appendChild(w);
					var h = new CanvasXpress(o, l, s);
					if (g) {
						for (var q = 0; q < g.length; q++) {
							if (g[q].match(/:/)) {
								var b = g[q].split(":");
								h[b.shift()].apply(h, b)
							} else {
								h[g[q]]()
							}
						}
					}
				}
				if (!y) {
					if (a.alignConfiguratorExamples || a.configuratorLastState == "docked") {
						var k = a.$(a.target + "-cX-Configurator");
						t.style.left = k.offsetWidth + "px";
						t.style.top = "-1px";
						t.style.height = (k.clientHeight - 45) + "px";
						m.style.maxHeight = (k.clientHeight - 45) + "px";
						a.removeClass(t, "draggable")
					} else {
						var x = a.adjustedCoordinates(u, t);
						t.style.left = x.x + "px";
						t.style.top = x.y + "px";
						delete(t.style.height);
						m.style.Maxheight = "500px";
						a.addClass(t, "draggable")
					}
				}
			}
		}
	}(this);
	this.clickEditPropertyDescription = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.resetPropertyColor();
			a.resetPropertyFilter();
			a.resetPropertyExample();
			var f = a.$(a.target + "-cX-Configurator");
			var g = a.$(a.target + "-cX-ConfiguratorSugestions");
			var u = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
			var m = a.$(a.target + "-cX-ConfiguratorOptions");
			if (f && g && u && m) {
				m.style.display = "none";
				var t = a.adjustedCoordinates(h, g);
				if (t) {
					a.editingDescriptionOn = true;
					var r = t.x;
					var o = t.y;
					var j = a.$cX("div", {
						id: a.target + "-cX-ConfiguratorEditForm",
						className: "CanvasXpressConfigurator draggable"
					}, {
						cursor: "move",
						left: r + "px",
						top: o + "px",
						padding: "10px",
						position: "absolute",
						width: (a.configuratorWidth * 0.8) + "px"
					});
					var l = a.$cX("img", {
						id: a.target + "-cX-ConfiguratorEditFormClose",
						className: "CanvasXpressConfigurator",
						src: CanvasXpress.images.cancel1,
						alt: "Close",
						title: "Close"
					});
					var q = a.$cX("textarea", {
						id: a.target + "-cX-ConfiguratorEditFormValue",
						className: "CanvasXpressConfigurator",
						value: u.prop + u.innerHTML,
						rows: 10
					}, {
						width: "100%",
						maxWidth: (a.configuratorWidth * 0.8) + "px"
					});
					var n = a.$cX("input", {
						id: a.target + "-cX-ConfiguratorEditFormButton",
						value: "Submit",
						type: "button"
					}, {
						width: "100%",
						borderRadius: "5px",
						maxWidth: (a.configuratorWidth * 0.8) + "px"
					});
					j.appendChild(document.createTextNode("Editing " + g.value));
					j.appendChild(l);
					j.appendChild(a.$cX("br"));
					j.appendChild(q);
					j.appendChild(n);
					a.addEvtListener(l, "click", a.closeEditPropertyDescription, false);
					a.addEvtListener(n, "click", a.submitEditPropertyDescription, false);
					f.appendChild(j)
				}
			}
		}
	}(this);
	this.submitEditPropertyDescription = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-ConfiguratorSugestions");
			var b = a.$(a.target + "-cX-ConfiguratorEditFormValue");
			var d = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
			if (c && b && d) {
				b.value = b.value.replace(/\n/g, "");
				CanvasXpress.doc.P[c.value].C = b.value;
				d.innerHTML = b.value;
				alert("New description for:\n - " + c.value + " -\nwas submitted and may apppear\nin new versions of CanvasXpress\nThank you for your contribution")
			}
			a.resetEditPropertyDescription()
		}
	}(this);
	this.closeEditPropertyDescription = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditPropertyDescription()
		}
	}(this);
	this.resetEditPropertyDescription = function() {
		var e = this.$(this.target + "-cX-ConfiguratorEditForm");
		var f = this.$(this.target + "-cX-ConfiguratorEditFormClose");
		var a = this.$(this.target + "-cX-ConfiguratorEditFormButton");
		if (e && f && a) {
			this.addEvtListener(f, "click", this.closeEditPropertyDescription, false);
			this.addEvtListener(a, "click", this.submitEditPropertyDescription, false);
			e.parentNode.removeChild(e)
		}
		this.editingDescriptionOn = false
	};
	this.addPropertySeeAlsoLinks = function(e, g) {
		this.resetPropertySeeAlsoLinks(e);
		var d = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		d.appendChild(document.createTextNode("See Also: "));
		e.appendChild(d);
		if (g && g.S) {
			for (var f = 0; f < g.S.length; f++) {
				var h = this.$cX("a", {
					href: "javascript:void(0)",
					innerHTML: g.S[f]
				});
				this.addEvtListener(h, "click", this.clickPropertySeeAlsoLinks, false);
				e.appendChild(h);
				if (f < g.S.length - 1) {
					e.appendChild(document.createTextNode(", "))
				}
			}
		}
	};
	this.clickPropertySeeAlsoLinks = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			var f = a.$(a.target + "-cX-ConfiguratorKey");
			var b = a.$(a.target + "-cX-ConfiguratorCategories");
			var g = a.$(a.target + "-cX-ConfiguratorSugestions");
			var c = h.target || h.srcElement;
			if (b && b.style.display == "block") {
				var l = CanvasXpress.doc.P[c.innerHTML];
				var j = CanvasXpress.doc.M[l.M].P.sort();
				b.value = l.M;
				for (i = 0; i < j.length; i++) {
					if (j[i] == c.innerHTML) {
						a.changeCategory(h, i);
						return false
					}
				}
				a.changeCategory(h)
			} else {
				if (f) {
					f.value = c.innerHTML;
					a.selectConfig(h, true)
				}
			}
			return false
		}
	}(this);
	this.resetPropertySeeAlsoLinks = function(b) {
		if (!b) {
			b = this.$(this.target + "-cX-ConfiguratorSeeAlso")
		}
		if (b && b.childNodes) {
			while (b.childNodes.length > 0) {
				var d = b.childNodes[0];
				if (d.nodeName.toLowerCase() == "a") {
					this.removeEvtListener(d, "click", this.clickPropertySeeAlsoLinks, false)
				}
				b.removeChild(d)
			}
		}
	};
	this.addPropertyOptions = function(w, p, f, g, s) {
		this.resetPropertyOptions(w, p);
		var q = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		var l = this.$cX("i");
		q.appendChild(document.createTextNode("Current value"));
		if (f && f.T && (f.T == "option" || f.T == "array" || f.T == "boolean")) {
			var x = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorOptionsContainer",
				className: "CanvasXpressConfiguratorOptions"
			});
			var r = this.$cX("a", {
				href: "javascript:void(0)",
				innerHTML: f.T,
				alt: "Modify property",
				title: "Modify property"
			});
			this.addEvtListener(r, "click", this.clickPropertyOptions, false);
			q.appendChild(document.createTextNode(" ["));
			l.appendChild(r);
			q.appendChild(document.createTextNode(" "));
			q.appendChild(l);
			q.appendChild(document.createTextNode(" ]"));
			if (f.T == "array") {
				var n = f.X ? this[f.X]() : f.O ? f.O : [];
				var m = this.getObjectArray(s);
				if (n.length > 0) {
					for (var h = 0; h < n.length; h++) {
						var g = this.$cX("input", {
							type: "checkbox",
							value: n[h],
							checked: m.hasOwnProperty(n[h]) ? true : false
						}, {
							marginLeft: "0px"
						});
						this.addEvtListener(g, "change", this.updatePropertyValue, false);
						x.appendChild(document.createTextNode((h + 1) + ". "));
						x.appendChild(g);
						x.appendChild(document.createTextNode(n[h]));
						x.appendChild(this.$cX("br"))
					}
				} else {
					x.appendChild(this.$cX("br"));
					x.appendChild(document.createTextNode("This array is user defined"));
					x.appendChild(this.$cX("br"))
				}
			} else {
				var n = f.T == "boolean" ? ["true", "false"] : f.X ? this[f.X]() : f.O ? f.O : [];
				if (f.X && f.O) {
					n = n.concat(f.O)
				}
				for (var h = 0; h < n.length; h++) {
					var g = this.$cX("a", {
						href: "javascript:void(0)",
						innerHTML: n[h],
						alt: "Modify property",
						title: "Modify property"
					}, {
						padding: "2px"
					});
					this.addEvtListener(g, "click", this.updatePropertyValue, false);
					x.appendChild(document.createTextNode((h + 1) + ". "));
					x.appendChild(g);
					x.appendChild(this.$cX("br"))
				}
			}
			p.appendChild(x)
		} else {
			if (f && f.T) {
				q.appendChild(document.createTextNode(" ["));
				if (f.T == "color") {
					var n;
					if (this.configuringNetwork) {
						if (this.configuringNetwork < this.data.nodes.length) {
							n = this.data.nodes[this.configuringNetwork][g]
						} else {
							n = this.data.edges[this.configuringNetwork - this.data.nodes.length][g]
						}
					} else {
						if (this.configuringGenome) {
							var e = this.subtracksInfo;
							if (!isNaN(this.configuringGenome)) {
								n = this.data.tracks[e[this.configuringGenome].track].data[e[this.configuringGenome].index]
							} else {
								if (this.configuringGenome.match(/:/)) {
									n = parseInt(this.configuringGenome.split(":")[1]);
									n = this.data.tracks[e[n].track].data[e[n].index]
								} else {
									n = parseInt(this.configuringGenome.replace("track-", ""));
									n = this.data.tracks[e[n].track]
								}
							}
						} else {
							n = this[g]
						}
					}
					var r = this.$cX("a", {
						id: this.target + "-cX-ConfiguratorValueHREF",
						href: "javascript:void(0)",
						innerHTML: f.T,
						alt: "Modify color",
						title: "Modify color"
					}, {
						color: n ? this.rgbToHex(this.validateColor(n)) : this.foreground
					});
					this.addEvtListener(r, "click", this.addPropertyColor, false);
					l.appendChild(r)
				} else {
					if (f && f.T == "filter") {
						var r = this.$cX("a", {
							id: this.target + "-cX-ConfiguratorValueFilter",
							href: "javascript:void(0)",
							innerHTML: f.T,
							name: g
						});
						r.opts = f.X ? this[f.X]() : f.O ? f.O : [];
						r.opts.unshift("");
						this.addEvtListener(r, "click", this.addPropertyFilter, false);
						l.appendChild(r)
					} else {
						l.appendChild(document.createTextNode(f.T))
					}
				}
				q.appendChild(document.createTextNode(" "));
				q.appendChild(l);
				q.appendChild(document.createTextNode(" ]"))
			}
		}
		w.appendChild(q)
	};
	this.clickPropertyOptions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditPropertyDescription();
			var c = a.$(a.target + "-cX-ConfiguratorOptions");
			if (c) {
				c.style.display = "block";
				c.style.left = b.layerX + "px";
				c.style.top = b.layerY + "px"
			}
			return false
		}
	}(this);
	this.closePropertyOptions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorOptions")
		}
	}(this);
	this.resetPropertyOptions = function(a, e, b) {
		if (!a) {
			a = this.$(this.target + "-cX-ConfiguratorValueText")
		}
		if (!e) {
			e = this.$(this.target + "-cX-ConfiguratorOptions")
		}
		if (a && a.childNodes && !b) {
			while (a.childNodes.length > 0) {
				var f = a.childNodes[0];
				if (f.nodeName.toLowerCase() == "a") {
					this.removeEvtListener(f, "click", this.clickPropertyOptions, false)
				}
				a.removeChild(f)
			}
		}
		if (e) {
			var d = this.$(this.target + "-cX-ConfiguratorOptionsContainer");
			if (d) {
				while (d.childNodes.length > 0) {
					var f = d.childNodes[0];
					if (f.nodeName.toLowerCase() == "a") {
						this.removeEvtListener(f, "click", this.updatePropertyValue, false)
					} else {
						if (f.nodeName.toLowerCase() == "input" && f.type == "checkbox") {
							this.removeEvtListener(f, "change", this.updatePropertyValue, false)
						}
					}
					d.removeChild(f)
				}
				e.removeChild(d)
			}
			e.style.display = "none"
		}
	};
	this.addPropertyFilter = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.resetEditPropertyDescription();
			var b = d.target || d.srcElement;
			var c = a.$(a.target + "-cX-ConfiguratorFilter");
			a.addAllPropertyFilters(b.name, b.opts);
			c.style.display = "block";
			c.opts = b.opts;
			c.style.left = d.layerX + "px";
			c.style.top = d.layerY + "px"
		}
	}(this);
	this.addAllPropertyFilters = function(c, d) {
		var b = this.$(this.target + "-cX-ConfiguratorFilter");
		for (var a = 0; a < this[c].length; a++) {
			this.insertPropertyFilterRow(b, a, c, d)
		}
		this.insertPropertyFilterRow(b, this[c].length, c, d)
	};
	this.insertPropertyFilterRow = function(F, B, r, y) {
		if (!F) {
			F = this.$(this.target + "-cX-ConfiguratorFilter")
		}
		if (F) {
			var e = this.configuratorWidth * 0.25;
			var G = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorFilterContainer" + B
			}, {
				width: (this.configuratorWidth * 1.05) + "px"
			});
			var q = this.$cX("select", {
				id: this.target + "-cX-ConfiguratorFilterSelect" + B,
				className: "CanvasXpressConfiguratorFilter",
				param: r,
				idx: B
			}, {
				marginRight: "2px",
				marginLeft: "1px",
				width: e + "px"
			});
			if (!y) {
				y = F.opts
			}
			y.sort();
			for (var A = 0; A < y.length; A++) {
				var d = this.$cX("option", {
					text: y[A],
					value: y[A]
				});
				try {
					q.add(d, null)
				} catch (E) {
					q.add(d)
				}
				if (this[r][B] && y[A] == this[r][B]) {
					d.selected = true
				}
			}
			this.addEvtListener(q, "change", this.unsetPropertyFilterRow, false);
			var t = this.$cX("select", {
				id: this.target + "-cX-ConfiguratorFilterOp" + B,
				className: "CanvasXpressConfiguratorFilter",
				param: r,
				idx: B
			}, {
				marginRight: "2px",
				width: e + "px"
			});
			var x = this.getOperators();
			for (var A = 0; A < x.length; A++) {
				var d = this.$cX("option", {
					text: x[A],
					value: x[A]
				});
				try {
					t.add(d, null)
				} catch (E) {
					t.add(d)
				}
				if (this[r + "Op"][B] && x[A] == this[r + "Op"][B]) {
					d.selected = true
				}
			}
			this.addEvtListener(t, "change", this.unsetPropertyFilterRow, false);
			var I = this.$cX("img", {
				src: CanvasXpress.images.caseSensitive
			}, {
				width: "10px"
			});
			var H = this.$cX("input", {
				id: this.target + "-cX-ConfiguratorFilterCase" + B,
				type: "checkbox",
				param: r,
				idx: B,
				alt: "Check for case sensitive",
				title: "Check for case sensitive"
			}, {
				width: "10px"
			});
			if (this[r + "Case"][B]) {
				H.checked = true
			}
			this.addEvtListener(H, "change", this.unsetPropertyFilterRow, false);
			var n = this.$cX("input", {
				id: this.target + "-cX-ConfiguratorFilterValue" + B,
				param: r,
				idx: B,
				type: "text"
			}, {
				width: e + "px"
			});
			if (this[r + "Value"][B]) {
				n.value = this[r + "Value"][B]
			}
			this.addEvtListener(n, "change", this.unsetPropertyFilterRow, false);
			var u = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterMinus" + B,
				src: CanvasXpress.images.minus,
				alt: "Remove Filter",
				title: "Remove Filter",
				param: r,
				idx: B
			}, {
				padding: "9px 2px 2px 2px",
				cssFloat: "left",
				cursor: "default",
				width: "10px"
			});
			this.addEvtListener(u, "click", this.removePropertyFilterRow, false);
			var e = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterPlus" + B,
				src: CanvasXpress.images.add1,
				alt: "Set Filter",
				title: "Set Filter",
				param: r,
				idx: B
			}, {
				padding: "7px 2px 2px 2px",
				cssFloat: "right",
				cursor: "default",
				width: "10px"
			});
			this.addEvtListener(e, "click", this.addPropertyFilterRow, false);
			var D = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterCheck" + B,
				src: CanvasXpress.images.accept,
				alt: "Filter added",
				title: "Filter added"
			}, {
				padding: "7px 2px 2px 2px",
				cssFloat: "right",
				cursor: "default",
				width: "10px",
				display: this[r][B] ? "block" : "none"
			});
			var C = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorFilterCheckEmpty" + B
			}, {
				cssFloat: "right",
				cursor: "default",
				width: "10px",
				display: this[r][B] ? "none" : "block"
			});
			G.appendChild(u);
			G.appendChild(q);
			G.appendChild(t);
			G.appendChild(I);
			G.appendChild(H);
			G.appendChild(n);
			G.appendChild(C);
			G.appendChild(D);
			G.appendChild(e);
			F.appendChild(G)
		}
	};
	this.addPropertyFilterRow = function(a) {
		return function(q) {
			if (!q) {
				q = window.event
			}
			var b = q.target || q.srcElement;
			var d = b.parentNode;
			var r = b.param;
			var l = b.idx;
			var t = a.$(a.target + "-cX-ConfiguratorValue");
			var n = a.$(a.target + "-cX-ConfiguratorFilterCheck" + l);
			var m = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + l);
			if (d && r && l != null && t && n && m) {
				var j = d.childNodes[1].value;
				var f = d.childNodes[2].value;
				var s = d.childNodes[4].checked;
				var u = d.childNodes[5].value;
				if (j != "" && ((f != "" && u != "") || f.match("null"))) {
					if (a[r].length > 0 && a[r][l] != null) {
						a[r][l] = j;
						a[r + "Op"][l] = f;
						a[r + "Value"][l] = u;
						a[r + "Case"][l] = s
					} else {
						a[r].push(j);
						a[r + "Op"].push(f);
						a[r + "Value"].push(u);
						a[r + "Case"].push(s);
						a.insertPropertyFilterRow(false, l + 1, r)
					}
					t.value = '["' + a[r].join('", "') + '"]';
					n.style.display = "block";
					m.style.display = "none"
				}
			}
		}
	}(this);
	this.removePropertyFilterRow = function(a) {
		return function(k) {
			if (!k) {
				k = window.event
			}
			var d = k.target || k.srcElement;
			var j = d.parentNode;
			var h = j.parentNode;
			var l = d.param;
			var f = d.idx;
			var b = a.$(a.target + "-cX-ConfiguratorValue");
			if (j && l && f != null && b) {
				a.resetFilters(l, f);
				a.resetPropertyFilter(true);
				a.addAllPropertyFilters(l, h.opts);
				b.value = a[l].length > 0 ? '["' + a[l].join('", "') + '"]' : "[]"
			}
		}
	}(this);
	this.unsetPropertyFilterRow = function(a) {
		return function(m) {
			if (!m) {
				m = window.event
			}
			var p = [];
			var b = m.target || m.srcElement;
			var n = b.param;
			var f = b.idx;
			if (n && f != null) {
				if (a[n].length > 0 && a[n][f]) {
					a[n][f] = false;
					a[n + "Op"][f] = false;
					a[n + "Value"][f] = false;
					a[n + "Case"][f] = false;
					for (var d = 0; d < a[n].length; d++) {
						if (d != f) {
							p.push(a[n][d])
						}
					}
					var l = a.$(a.target + "-cX-ConfiguratorFilterCheck" + f);
					var k = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + f);
					var o = a.$(a.target + "-cX-ConfiguratorValue");
					if (l && k && o) {
						l.style.display = "none";
						k.style.display = "block";
						o.value = p.length > 0 ? '["' + p.join('", "') + '"]' : "[]"
					}
				}
			}
		}
	}(this);
	this.closePropertyFilter = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorFilter");
			a.resetPropertyFilter()
		}
	}(this);
	this.closePropertyExample = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorExample");
			a.resetPropertyExample()
		}
	}(this);
	this.resetPropertyFilter = function(a) {
		var b = this.$(this.target + "-cX-ConfiguratorFilter");
		if (b) {
			if (b && b.childNodes) {
				while (b.childNodes.length > 3) {
					var c = b.childNodes[3];
					this.removeEvtListener(c.childNodes[0], "click", this.removePropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[1], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[2], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[4], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[5], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[8], "click", this.addPropertyFilterRow, false);
					b.removeChild(b.childNodes[3])
				}
			}
			if (!a) {
				b.style.display = "none"
			}
		}
	};
	this.resetPropertyExample = function(a) {
		var b = this.$(this.target + "-cX-ConfiguratorExample");
		if (b) {
			var c = b.getElementsByTagName("canvas");
			while (c.length > 0) {
				this.destroy(c[0].id)
			}
			if (!a) {
				b.style.display = "none"
			}
		}
	};
	this.addPropertyColor = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			a.resetEditPropertyDescription();
			var d = a.$(a.target + "-cX-ConfiguratorColor");
			var t = a.$(a.target + "-cX-ConfiguratorValue");
			if (d && t) {
				var g = t.value ? a.rgbToHex(a.validateColor(t.value.replace(/[\'\"]/g, ""))) : a.foreground;
				a.colorRGBfromString(g);
				var r = Math.round(a.colorHSV[0] / 6 * 180);
				var q = Math.round((1 - a.colorHSV[1]) * 100);
				var m = Math.round((1 - a.colorHSV[2]) * 100);
				var l = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorContainer"
				}, {
					width: "210px",
					height: "101px",
					marginTop: "7px"
				});
				var b = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorPalette",
					className: "CanvasXpressConfiguratorColorMain"
				}, {
					position: "relative",
					left: "0px",
					top: "0px",
					width: "181px",
					height: "101px"
				});
				var o = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorPaletteCurrent",
					className: "CanvasXpressConfiguratorColorExtra"
				}, {
					position: "relative",
					left: (r - 7) + "px",
					top: (q - 7) + "px",
					width: "195px",
					height: "115px"
				});
				b.appendChild(o);
				var w = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorSaturation",
					className: "CanvasXpressConfiguratorColor"
				}, {
					position: "relative",
					left: "188px",
					width: "15px",
					height: "100px",
					border: "1px solid rgb(51,122,183)",
					cursor: "crosshair"
				});
				for (var f = 0; f < 100; f += 4) {
					var u = a.$cX("div", false, {
						height: "4px",
						position: "relative",
						left: "0px",
						cursor: "crosshair"
					});
					w.appendChild(u)
				}
				var k = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorSaturationCurrent",
					className: "CanvasXpressConfiguratorColorExtra"
				}, {
					position: "relative",
					left: "0px",
					top: (m - 108) + "px",
					width: "29px",
					height: "115px"
				});
				w.appendChild(k);
				l.appendChild(b);
				l.appendChild(w);
				d.appendChild(l);
				a.colorizeCurrentColorDiv();
				a.colorizeSaturationColorDiv();
				a.addEvtListener(b, "mousedown", a.registerPalette, false);
				a.addEvtListener(w, "mousedown", a.registerSaturation, false);
				d.style.display = "block";
				d.style.left = j.layerX + "px";
				d.style.top = j.layerY + "px"
			}
			return false
		}
	}(this);
	this.registerPalette = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingColorOn = "palette";
			if (a.colorHSV[2] == 0) {
				a.colorFromHsv(null, null, 1);
				a.colorizeCurrentColorDiv();
				var c = a.$(a.target + "-cX-ConfiguratorColorSaturationCurrent");
				if (c) {
					c.style.top = "-108px"
				}
			}
			a.updateColorValue(b);
			a.colorizeSaturationColorDiv();
			return false
		}
	}(this);
	this.registerSaturation = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingColorOn = "saturation";
			a.updateColorValue(b);
			return false
		}
	}(this);
	this.updateColorValue = function(g) {
		if (this.changingColorOn) {
			if (this.changingColorOn == "palette") {
				var f = this.$(this.target + "-cX-ConfiguratorColorPalette");
				var b = this.$(this.target + "-cX-ConfiguratorColorPaletteCurrent");
				if (f && b) {
					var d = this.adjustedCoordinates(g, f);
					if (d) {
						var a = Math.min(Math.max(0, d.x), 181);
						var j = Math.min(Math.max(0, d.y), 101);
						b.style.left = (a - 7) + "px";
						b.style.top = (j - 7) + "px";
						this.colorFromHsv(a * 6 / 180, 1 - j / 100, null);
						this.colorizeCurrentColorDiv();
						this.colorizeSaturationColorDiv()
					}
				}
			} else {
				var c = this.$(this.target + "-cX-ConfiguratorColorSaturation");
				var h = this.$(this.target + "-cX-ConfiguratorColorSaturationCurrent");
				if (c && h) {
					var d = this.adjustedCoordinates(g, c);
					if (d) {
						var j = Math.min(Math.max(0, d.y), 101);
						h.style.top = (j - 108) + "px";
						this.colorFromHsv(null, null, 1 - j / 100);
						this.colorizeCurrentColorDiv()
					}
				}
			}
		}
	};
	this.colorizeCurrentColorDiv = function() {
		var f = this.$(this.target + "-cX-ConfiguratorColorCurrent");
		var a = this.$(this.target + "-cX-ConfiguratorValue");
		var d = this.$(this.target + "-cX-ConfiguratorValueHREF");
		if (f && a && d) {
			var e = this.colorRGBToString();
			var b = this.hexToRgb("#" + e);
			f.style.backgroundColor = "#" + e;
			f.innerHTML = "&nbsp;&nbsp;" + b;
			f.style.color = this.complementaryColor(b, true);
			a.value = '"' + b + '"';
			d.style.color = "#" + e
		}
	};
	this.colorizeSaturationColorDiv = function() {
		var b = function(m, k, c, j, h) {
			return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
		};
		var e = this.$(this.target + "-cX-ConfiguratorColorSaturation");
		if (e && this.colorHSV) {
			var f = e.childNodes;
			var a = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
			if (a) {
				for (var d = 0; d < f.length - 1; d++) {
					f[d].style.backgroundColor = b(a[0], a[1], a[2], d, f.length - 1)
				}
			}
		}
	};
	this.endColorChange = function(a) {
		this.changingColorOn = false
	};
	this.closePropertyColor = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorColor");
			a.resetPropertyColor()
		}
	}(this);
	this.resetPropertyColor = function() {
		var c = this.$(this.target + "-cX-ConfiguratorColor");
		var b = this.$(this.target + "-cX-ConfiguratorColorPalette");
		var a = this.$(this.target + "-cX-ConfiguratorColorSaturation");
		if (c && b && a) {
			if (c && c.childNodes) {
				while (c.childNodes.length > 3) {
					c.removeChild(c.childNodes[3])
				}
				this.removeEvtListener(b, "mousedown", this.registerPalette, false);
				this.removeEvtListener(a, "mousedown", this.registerSaturation, false)
			}
			c.style.display = "none"
		}
	};
	this.updatePropertyValue = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.resetEditPropertyDescription();
			var f = a.$(a.target + "-cX-ConfiguratorValue");
			var j = a.$(a.target + "-cX-ConfiguratorOptions");
			var d = h.target || h.srcElement;
			if (d.nodeName.toLowerCase() == "input") {
				var b = [];
				for (var g = 0; g < d.parentNode.childNodes.length; g++) {
					var k = d.parentNode.childNodes[g];
					if (k.checked) {
						b.push(k.value)
					}
				}
				f.value = b.length > 0 ? '["' + b.join('", "') + '"]' : "[]"
			} else {
				if (f && j) {
					if (d.innerHTML == "true") {
						f.value = d.innerHTML
					} else {
						if (d.innerHTML == "false") {
							f.value = d.innerHTML
						} else {
							if (d.innerHTML == "null") {
								f.value = d.innerHTML
							} else {
								f.value = '"' + d.innerHTML + '"'
							}
						}
					}
					j.style.display = "none"
				}
			}
			return false
		}
	}(this);
	this.clickApplyConfigurator = function(a) {
		return function(b) {
			return a.clickConfigurator(b, false, false, true)
		}
	}(this);
	this.clickConfigurator = function(a) {
		return function(g, d, c, b) {
			if (!g) {
				g = window.event
			}
			if (!d) {
				d = a.$(a.target + "-cX-ConfiguratorSugestions")
			}
			if (!c) {
				c = a.$(a.target + "-cX-ConfiguratorValue")
			}
			if (d && c) {
				var f = a.getConfigurableObjectDoc(d.value);
				if (c.value) {
					var h = JSON.parse(c.value);
					if (f.T == "color" && !a.validateColor(h)) {
						alert('"' + h + '" is NOT a valid color');
						return false
					}
				}
			}
			a.updateClickConfigurator(d.value, c.value, b);
			return false
		}
	}(this);
	this.updateClickConfigurator = function(h, d, b) {
		this.functionCaller = "updateClickConfigurator";
		if (this.isTransition()) {
			return
		}
		if (this.configuringNetwork) {
			if (this.configuringNetwork < this.data.nodes.length) {
				if (typeof(this[h]) == "function") {
					this[h](this.data.nodes[this.configuringNetwork])
				} else {
					this.data.nodes[this.configuringNetwork][h] = JSON.parse(d)
				}
			} else {
				if (typeof(this[h]) == "function") {
					this[h](this.data.edges[this.configuringNetwork - this.data.nodes.length])
				} else {
					this.data.edges[this.configuringNetwork - this.data.nodes.length][h] = JSON.parse(d)
				}
			}
		} else {
			if (this.configuringGenome) {
				var g = this.subtracksInfo;
				if (!isNaN(this.configuringGenome)) {
					this.data.tracks[g[this.configuringGenome].track].data[g[this.configuringGenome].index][h] = JSON.parse(d)
				} else {
					if (this.configuringGenome.match(/:/)) {
						var k = parseInt(this.configuringGenome.split(":")[1]);
						this.data.tracks[g[k].track].data[g[k].index][h] = JSON.parse(d)
					} else {
						var k = parseInt(this.configuringGenome.replace("track-", ""));
						this.data.tracks[k][h] = JSON.parse(d)
					}
				}
			} else {
				if (typeof(this[h]) == "function") {
					if (this[h].length > 0 && d) {
						var c = JSON.parse(d);
						this[h](c)
					} else {
						this[h]()
					}
					this.resetConfigurator();
					return false
				} else {
					if (h == "summaryType" && this.isGroupedData && this[h] != JSON.parse(d)) {
						var e = this.groupingFactors;
						this.ungroupSamples(true);
						this[h] = JSON.parse(d);
						this.meta.config.user[h] = this[h];
						this.groupSamples(e, false, false, false, true)
					} else {
						this[h] = JSON.parse(d);
						this.meta.config.user[h] = this[h]
					}
				}
			}
		}
		if (!b) {
			this.resetConfigurator()
		}
		var j = h.match(/filter(.+)By/);
		if (j) {
			this.reset();
			this.filterData()
		}
		this.resetPropertyExample();
		this.draw()
	};
	this.handleHideDiv = function(a) {
		var b = this.$(a);
		if (b) {
			b.style.display = "none"
		}
		return false
	};
	this.resetOptionColorFiltersExamples = function() {
		this.resetPropertyOptions(false, false, true);
		this.resetPropertyColor();
		this.resetPropertyFilter();
		this.resetPropertyExample()
	};
	this.resetEditOptionColorFiltersExamples = function() {
		this.resetEditPropertyDescription();
		this.resetPropertyOptions(false, false, true);
		this.resetPropertyFilter();
		this.resetPropertyExample()
	};
	this.resetConfigurator = function() {
		if (this.configuringOn && this.configuringOn != "docked") {
			this.resetEditOptionColorFiltersExamples();
			this.resetPropertyDescription();
			this.resetPropertySeeAlsoLinks();
			this.editingDescriptionOn = false;
			this.configuratorLastState = false;
			this.configuringOn = false;
			this.configuringNetwork = false;
			this.configuringGenome = false;
			this.addRemoveConfiguratorListeners("removeEvtListener");
			this.removeTarget(this.target + "-cX-Configurator")
		}
	}
};
CanvasXpress.prototype.initAcknowlegments = function() {
	this.addAcknowledgmentDiv = function() {
		if (this.$(this.target + "canvasXpressAcknowledgmentDiv")) {
			this.setAcknowledgmentVisibility();
			return
		}
		var f = this.$cX("div", {
			id: this.target + "canvasXpressAcknowledgmentDiv"
		}, {
			display: this.acknowledgment ? "block" : "none",
			width: this.width + "px",
			cssFloat: "left",
			position: "relative",
			zIndex: 9999,
			display: this.acknowledgment ? "block" : "none",
			top: this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px",
			right: "3px"
		});
		var c = this.$cX("img", {
			src: CanvasXpress.images.cx,
			alt: "Graphs powered by canvasXpress",
			title: "Graphs powered by canvasXpress"
		}, {
			margin: "2px",
			cssFloat: "right"
		});
		var b = this.$cX("a", {
			href: "https://canvasxpress.org",
			target: "_blank"
		}, {
			cssFloat: "right"
		});
		b.appendChild(c);
		f.appendChild(b);
		var e = this.$("south-wrapper-" + this.target);
		if (e) {
			e.appendChild(f)
		}
	};
	this.resizeAcknowledgmentDiv = function() {
		var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
		if (b) {
			b.style.width = this.width + "px"
		}
	};
	this.setAcknowledgmentVisibility = function() {
		var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
		if (b) {
			b.style.display = this.acknowledgment ? "block" : "none";
			b.style.top = this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px";
			b.style.right = "3px"
		}
	};
	this.addAcknowledgmentDiv()
};
CanvasXpress.prototype.initCodeInfo = function() {
	this.addInfoCodeDiv = function() {
		if (this.$(this.target + "-cX-Code")) {
			return
		}
		var h = this.$cX("div", {
			id: this.target + "-cX-Code",
			className: "CanvasXpressCode draggable"
		}, {
			left: "25px",
			top: "-" + (this.height - 25) + "px",
			display: "none"
		});
		var j = this.$cX("img", {
			id: this.target + "-cX-CodeCloseImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.cancel1,
			alt: "Close Code",
			title: "Close Code"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-CodePrettyImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.blueCode,
			alt: "Pretty Code",
			title: "Pretty Code"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-CodeCompactImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.greenCode,
			alt: "Compact Code",
			title: "Compact Code"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-CodeTabImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.yellowCode,
			alt: "Tab Code",
			title: "Tab Code"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-CodeParamsImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.redCode,
			alt: "Params Code",
			title: "Params Code"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-CodeSelectImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.selectAll,
			alt: "Select Code",
			title: "Select Code"
		});
		var g = this.$cX("div", {
			id: this.target + "-cX-CodeContainer",
			className: "CanvasXpressCodeContainer"
		});
		var a = this.$("north-wrapper-" + this.target);
		var l = this.$("south-wrapper-" + this.target);
		if (a) {
			a.appendChild(g)
		}
		if (l) {
			h.appendChild(j);
			h.appendChild(f);
			h.appendChild(e);
			h.appendChild(d);
			h.appendChild(b);
			h.appendChild(k);
			h.appendChild(g);
			l.appendChild(h);
			this.addRemoveCodeListeners("addEvtListener")
		}
	};
	this.addRemoveCodeListeners = function(a) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-Code"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCloseImage"), "click", this.clickCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodePrettyImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCompactImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeTabImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeParamsImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeSelectImage"), "click", this.clickSelectCode, false)
	};
	this.clickCode = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.hideCodeDiv();
			return false
		}
	}(this);
	this.clickChangeCode = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			switch (b.id) {
				case a.target + "-cX-CodePrettyImage":
					a.codeType = "pretty";
					break;
				case a.target + "-cX-CodeCompactImage":
					a.codeType = "compact";
					break;
				case a.target + "-cX-CodeTabImage":
					a.codeType = "tab";
					break;
				case a.target + "-cX-CodeParamsImage":
					a.codeType = "params";
					break;
				default:
					break
			}
			a.updateCodeDiv();
			return false
		}
	}(this);
	this.clickSelectCode = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b;
			var c = a.$(a.target + "-cX-CodeContent");
			if (c) {
				if (document.selection) {
					b = document.body.createTextRange();
					b.moveToElementText(c);
					b.select()
				} else {
					if (window.getSelection) {
						b = document.createRange();
						b.selectNode(c);
						window.getSelection().addRange(b)
					}
				}
			}
			return false
		}
	}(this);
	this.clearCodeDiv = function() {
		var b = this.$(this.target + "-cX-Code");
		var a = this.$(this.target + "-cX-CodeContent");
		if (b && a) {
			a.parentNode.removeChild(a);
			b.style.display = "none"
		}
	};
	this.getDataJSON = function(b) {
		var a = {
			x: true,
			y: true,
			z: true,
			market: true,
			venn: true,
			nodes: true,
			edges: true,
			tracks: true,
			video: true
		};
		var d = this.cloneObject(this.data, true);
		for (var c in d) {
			if (!a.hasOwnProperty(c)) {
				delete(d[c])
			}
		}
		return b ? this.prettyJSON(d) : JSON.stringify(d)
	};
	this.getConfigJSON = function(a) {
		return a ? this.prettyJSON(this.getConfig()) : JSON.stringify(this.getConfig())
	};
	this.getCodeJSONJS = function(a) {
		var b = this.getDataJSON(a);
		var e = this.getConfigJSON(a);
		return 'new CanvasXpress("canvas", ' + b + ", " + e + ");\n"
	};
	this.updateCodeDiv = function(i) {
		var j = this.$(this.target + "-cX-Code");
		var d = this.$(this.target + "-cX-CodeContainer");
		var g = this.getDataJSON(this.codeType == "pretty");
		var e = this.codeType == "params" ? "{\n  ...\n}" : g;
		var f = this.getConfigJSON(this.codeType == "pretty" || this.codeType == "params");
		if (j && d) {
			this.clearCodeDiv();
			var a = this.codeType == "tab" || this.codeType == "compact" ? "span" : "pre";
			var b = this.codeType == "tab" ? "canvasID\t" + e + "\t" + f + "\n" : 'new CanvasXpress("canvasID", ' + e + ", " + f + ")\n";
			d.appendChild(this.$cX(a, {
				id: this.target + "-cX-CodeContent",
				className: "CanvasXpressCodeContent",
				innerHTML: b
			}));
			j.style.display = "block";
			if (i) {
				j.style.zIndex = i
			}
		}
	};
	this.updateInfoDiv = function(a) {
		var b = this.$(this.target + "-cX-Info");
		if (b && a) {
			b.innerHTML = a
		}
	};
	this.showDiv = function(a) {
		var b = this.$(this.target + "-cX-" + a);
		if (b) {
			b.style.display = "block"
		}
	};
	this.hideDiv = function(a) {
		var b = this.$(this.target + "-cX-" + a);
		if (b) {
			b.style.display = "none"
		}
	};
	this.showCodeDiv = function() {
		this.updateCodeDiv();
		this.removeMenus();
		this.showDiv("Code")
	};
	this.hideCodeDiv = function() {
		this.hideDiv("Code")
	};
	this.showInfoDiv = function() {
		this.removeMenus();
		this.showDiv("Info")
	};
	this.hideInfoDiv = function() {
		this.hideDiv("Info")
	};
	this.initializeCodeInfo = function() {
		this.addInfoCodeDiv()
	};
	this.initializeCodeInfo()
};
CanvasXpress.prototype.initBin = function() {
	this.addBinConfigurator = function(M, B) {
		this.removeMenus();
		var z = this.target + "-" + M + "-cX-Bin";
		var f = this.range(this.data.y.data[M]);
		var E = (f[1] - f[0]) / B;
		var w = this.getAxisDecimals(f[0]) + 1;
		this.binConfigurations[z] = {};
		this.binConfigurations[z]["apply"] = false;
		this.binConfigurations[z]["n"] = B;
		this.binConfigurations[z]["vi"] = M;
		this.binConfigurations[z]["min"] = f[0];
		this.binConfigurations[z]["max"] = f[1];
		this.binConfigurations[z]["dec"] = w;
		this.binConfigurations[z]["name"] = "Custom-" + this.data.y.vars[M] + "-Bin";
		this.binConfigurations[z]["bins"] = [];
		for (var H = 0; H < B; H++) {
			this.binConfigurations[z]["bins"][H] = {
				name: "Bin-" + (H + 1),
				value: Number(f[0] + ((H + 1) * E))
			}
		}
		var I = this.$cX("div", {
			id: z,
			className: "CanvasXpressBin draggable"
		}, {
			left: "20px",
			top: "-200px",
			display: "block"
		});
		var g = this.$cX("img", {
			id: z + "CloseImage",
			className: "CanvasXpressBin",
			src: CanvasXpress.images.cancel1,
			alt: "Close Bin Configurator",
			title: "Close Bin Configurator"
		});
		var J = this.$cX("div", {
			id: z + "Container",
			className: "CanvasXpressBinContainer"
		});
		var C = this.$cX("input", {
			id: z + "Name",
			className: "CanvasXpressBin",
			type: "text",
			value: "Custom-" + this.data.y.vars[M] + "-Bin"
		}, {
			width: "100%"
		});
		var A = this.$cX("div", {
			id: z + "NameSegmentContainer",
			className: "CanvasXpressBinNameContainer"
		});
		var y = this.$cX("table", {
			id: z + "NameSegment",
			className: "CanvasXpressBinTable"
		}, {
			width: "100%"
		});
		var v = this.$cX("tbody");
		var G = this.$cX("th");
		var F = this.$cX("th", {
			innerHTML: "Name"
		});
		var D = this.$cX("th", {
			innerHTML: "Max"
		});
		var o = this.$cX("tr");
		o.appendChild(G);
		o.appendChild(F);
		o.appendChild(D);
		v.appendChild(o);
		for (var H = 0; H < B; H++) {
			var G = this.$cX("td", {
				innerHTML: H + 1
			}, {
				width: (this.configuratorWidth * 0.1) + "px"
			});
			var F = this.$cX("td");
			var D = this.$cX("td");
			var e = this.$cX("input", {
				id: z + "Name" + H,
				className: "CanvasXpressBin",
				type: "text",
				value: "Bin-" + (H + 1)
			}, {
				width: (this.configuratorWidth * 0.65) + "px"
			});
			var h = this.$cX("input", {
				id: z + "Value" + H,
				className: "CanvasXpressBin",
				type: "text",
				value: this.formatNumber(f[0] + ((H + 1) * E), w)
			}, {
				width: (this.configuratorWidth * 0.25) + "px"
			});
			var o = this.$cX("tr");
			D.appendChild(h);
			F.appendChild(e);
			o.appendChild(G);
			o.appendChild(F);
			o.appendChild(D);
			v.appendChild(o)
		}
		y.appendChild(v);
		A.appendChild(y);
		var L = this.$cX("input", {
			id: z + "Apply",
			value: "Apply",
			type: "button"
		}, {
			cssFloat: "left",
			borderRadius: "5px",
			top: "4px",
			position: "relative",
			width: "50%"
		});
		var K = this.$cX("input", {
			id: z + "Button",
			value: "Done",
			type: "button"
		}, {
			cssFloat: "left",
			borderRadius: "5px",
			top: "4px",
			position: "relative",
			width: "50%"
		});
		var u = this.$("south-wrapper-" + this.target);
		if (u) {
			J.appendChild(this.$cX("span", {
				className: "CanvasXpressBin",
				innerHTML: "Edit Name"
			}));
			J.appendChild(this.$cX("br"));
			J.appendChild(C);
			J.appendChild(this.$cX("br"));
			J.appendChild(this.$cX("br"));
			J.appendChild(this.$cX("span", {
				className: "CanvasXpressBin",
				innerHTML: "Edit Bin Name and Range"
			}));
			J.appendChild(this.$cX("br"));
			J.appendChild(A);
			J.appendChild(L);
			J.appendChild(K);
			J.appendChild(this.$cX("br"));
			I.appendChild(g);
			I.appendChild(J);
			u.appendChild(I);
			this.addRemoveBinListeners("addEvtListener", z)
		}
	};
	this.addRemoveBinListeners = function(b, d) {
		var c = d ? [d] : this.getKeys(this.binConfigurations);
		for (var a = 0; a < c.length; a++) {
			this.addRemoveEvtListener(b, this.$(c[a]), "mousedown", this.registerMousemove, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "CloseImage"), "click", this.closeBinConfigurator, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "Apply"), "click", this.applyBinConfigurator, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "Button"), "click", this.doneBinConfigurator, false);
			if (b == "removeEvtListener" && this.binConfigurations[c[a]] && !this.binConfigurations[c[a]]["apply"]) {
				delete(this.binConfigurations[c[a]])
			}
		}
	};
	this.closeBinConfigurator = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var f = b.id.replace("CloseImage", "");
			var d = a.$(f);
			if (d) {
				a.addRemoveBinListeners("removeEvtListener", f);
				d.parentNode.removeChild(d)
			}
			return false
		}
	}(this);
	this.validateBinning = function(a) {
		var e = false;
		var h = this.$(a + "Name0").value;
		var m = this.$(a + "Value0").value;
		for (var k = 1; k < this.binConfigurations[a]["n"]; k++) {
			var p = this.$(a + "Name" + k).value;
			var b = this.$(a + "Value" + k).value;
			if (h == "" || h == null) {
				e = "Value for Bin " + k + " CANNOT be null";
				break
			} else {
				if (p == "" || p == null) {
					e = "Value for Bin " + (k + 1) + " CANNOT be null";
					break
				} else {
					if (m == "" || m == null) {
						e = "Value for " + h + " (" + m + ") CANNOT be null";
						break
					} else {
						if (b == "" || b == null) {
							e = "Value for " + p + " (" + b + ") CANNOT be null";
							break
						} else {
							if (isNaN(m)) {
								e = "Value for " + h + " (" + m + ") is NOT a number";
								break
							} else {
								if (isNaN(b)) {
									e = "Value for " + p + " (" + b + ") is NOT a number";
									break
								} else {
									if (m > b) {
										e = "Value for " + h + " (" + m + ")CANNOT be greater that value for " + p + " (" + b + ")";
										break
									}
									h = p;
									m = b
								}
							}
						}
					}
				}
			}
		}
		if (e) {
			alert(e);
			return false
		} else {
			for (var k = 0; k < this.binConfigurations[a]["n"]; k++) {
				var c = this.$(a + "Name" + k).value;
				var o = this.$(a + "Value" + k).value;
				this.binConfigurations[a]["bins"][k] = {
					name: c,
					value: o
				}
			}
			var d = this.binConfigurations[a]["name"];
			var g = this.binConfigurations[a]["vi"];
			this.data.x[d] = [];
			for (var k = 0; k < this.data.y.data[g].length; k++) {
				var o = this.data.y.data[g][k];
				if (!isNaN(o) && o != "" && o != null) {
					for (var f = 0; f < this.binConfigurations[a]["n"]; f++) {
						if (o <= this.binConfigurations[a]["bins"][f].value) {
							this.data.x[d][k] = this.binConfigurations[a]["bins"][f].name;
							break
						}
					}
				} else {
					this.data.x[d][k] = ""
				}
			}
			if (this.isGroupedData) {
				this.ungroupSamples(true)
			}
			this.updateData(this.data);
			this.groupSamples([d]);
			this.sortSamplesByCategory([d]);
			this.binConfigurations[a]["apply"] = true;
			return true
		}
	};
	this.applyBinConfigurator = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var d = b.id.replace("Apply", "");
			a.validateBinning(d)
		}
	}(this);
	this.doneBinConfigurator = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			var g = b.id.replace("Button", "");
			var c = a.validateBinning(g);
			var f = a.$(g);
			if (f && c) {
				a.addRemoveBinListeners("removeEvtListener", g);
				f.parentNode.removeChild(f)
			}
			return false
		}
	}(this)
};
CanvasXpress.prototype.initDataExplorer = function() {
	this.addDataExplorer = function(f) {
		var a = this.target + "-cX-DataExplorer";
		var j = this.$(a);
		if (j) {
			return
		}
		var g = this.$cX("div", {
			id: this.target + "-cX-DataExplorer",
			className: "CanvasXpressBin draggable"
		}, {
			left: "20px",
			top: "-" + (this.height - 20) + "px",
			display: "block"
		});
		var m = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCloseImage",
			className: "CanvasXpressBin",
			src: CanvasXpress.images.cancel1,
			alt: "Close Data Explorer",
			title: "Close Data Explorer"
		});
		var h = this.$cX("div", {
			id: this.target + "-cX-DataExplorerContainer",
			className: "CanvasXpressBinContainer"
		});
		var k = this.$("south-wrapper-" + this.target);
		if (k) {
			g.appendChild(m);
			var o = this.loadDataExplorerTopPanel();
			h.appendChild(o);
			var i = this.$cX("img", {
				id: this.target + "-cX-DataExplorerMinimizeImage1",
				className: "CanvasXpressBin",
				src: CanvasXpress.images.collapseFolder,
				srt: CanvasXpress.images.expandFolder,
				alt: "Collapse Variables and Sample Metadata",
				title: "Collapse Variables and Sample Metadata"
			});
			h.appendChild(i);
			var n = this.loadDataExplorerMiddlePanel();
			h.appendChild(n);
			h.appendChild(this.$cX("br"));
			h.appendChild(this.$cX("hr", {
				className: "CanvasXpressDataExplorer"
			}, {
				width: "201px"
			}));
			var b = this.$cX("img", {
				id: this.target + "-cX-DataExplorerMinimizeImage2",
				className: "CanvasXpressBin",
				src: CanvasXpress.images.collapseFolder,
				srt: CanvasXpress.images.expandFolder,
				alt: "Collapse Samples and Variable Metadata",
				title: "Collapse Samples and Variable Metadata"
			});
			h.appendChild(b);
			var l = this.loadDataExplorerBottomPanel();
			h.appendChild(l);
			g.appendChild(h);
			k.appendChild(g);
			this.addRemoveDataExplorerListeners("addEvtListener")
		}
	};
	this.loadDataExplorerTopPanel = function() {
		var g = this.loadFormatDataExplorerDiv();
		var c = this.loadLayoutDataExplorerDiv();
		var a = this.loadMetadataDataExplorerDiv();
		var h = this.loadPropertiesDataExplorerDiv();
		var f = this.loadOrientationDataExplorerDiv();
		var b = this.loadGraphTypesDataExplorerDiv();
		var e = this.loadAxesDataExplorerDiv();
		var d = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		d.appendChild(g);
		d.appendChild(c);
		d.appendChild(a);
		d.appendChild(this.$cX("br"));
		d.appendChild(h);
		d.appendChild(f);
		d.appendChild(this.$cX("br"));
		d.appendChild(b);
		d.appendChild(e);
		d.appendChild(this.$cX("br"));
		d.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "201px"
		}));
		return d
	};
	this.loadDataExplorerMiddlePanel = function() {
		var b = this.loadVariablesDataExplorerDiv();
		var a = this.loadAnnotationsDataExplorerDiv();
		var c = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		c.appendChild(this.$cX("br"));
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Variables / Data Series"
		}));
		c.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortVariables",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Variables",
			title: "Sort Variables"
		}, {
			border: "none",
			padding: 0
		}));
		c.appendChild(this.$cX("br"));
		c.appendChild(b);
		c.appendChild(this.$cX("br"));
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Sample Metadata"
		}));
		c.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortAnnotations",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Sample Metadata",
			title: "Sort Sample Metadata"
		}, {
			border: "none",
			padding: 0
		}));
		c.appendChild(this.$cX("br"));
		c.appendChild(a);
		return c
	};
	this.loadDataExplorerBottomPanel = function() {
		var a = this.loadSamplesDataExplorerDiv();
		var c = this.loadDescriptionsDataExplorerDiv();
		var b = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		b.appendChild(this.$cX("br"));
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Samples"
		}));
		b.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortSamples",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Samples",
			title: "Sort Samples"
		}, {
			border: "none",
			padding: 0
		}));
		b.appendChild(this.$cX("br"));
		b.appendChild(a);
		b.appendChild(this.$cX("br"));
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Variable Metadata"
		}));
		b.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortDescriptions",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Variable Metadata",
			title: "Sort Variable Metadata"
		}, {
			border: "none",
			padding: 0
		}));
		b.appendChild(this.$cX("br"));
		b.appendChild(c);
		return b
	};
	this.loadFormatDataExplorerDiv = function() {
		var b = this.$cX("div", {
			id: this.target + "-cX-DataExplorerFormat",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "47px",
			height: "46px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTranspose",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.transposeData,
			params: ["transpose"],
			alt: "Transpose data",
			title: "Transpose data"
		});
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Format",
			title: "Click in icons to reformat data",
			alt: "Click in icons to reformat data"
		}, {
			width: "47px",
			cursor: "pointer"
		}));
		b.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "53px"
		}));
		b.appendChild(a);
		return b
	};
	this.loadLayoutDataExplorerDiv = function() {
		var c = this.$cX("div", {
			id: this.target + "-cX-DataExplorerLayout",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "60px",
			height: "46px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerGroupSamples",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.groupSamples,
			params: ["groupSamples"],
			alt: "Group Samples",
			title: "Group Samples"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerSegregate",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.segregate,
			params: ["segregate"],
			alt: "Segregate Data",
			title: "Segregate Data"
		});
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Layout",
			title: "Drag sample metadata to change layout",
			alt: "Drag sample metadata to change layout"
		}, {
			width: "60px",
			cursor: "pointer"
		}));
		c.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "66px"
		}));
		c.appendChild(a);
		c.appendChild(b);
		return c
	};
	this.loadMetadataDataExplorerDiv = function() {
		var a = this.$cX("div", {
			id: this.target + "-cX-DataExplorerMetadata",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "45px",
			height: "46px",
			textAlign: "center",
			cssFloat: "left"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerDOE",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.doe,
			params: ["createDOE"],
			alt: "Explore Meta Data",
			title: "Explore Meta Data"
		});
		a.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "DOE",
			title: "Click in icon to explore meta data",
			alt: "Click in icon to explore meta data"
		}, {
			width: "45px",
			cursor: "pointer"
		}));
		a.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "51px"
		}));
		a.appendChild(b);
		return a
	};
	this.loadPropertiesDataExplorerDiv = function() {
		var g = this.$cX("div", {
			id: this.target + "-cX-DataExplorerProperties",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "90px",
			height: "83px",
			textAlign: "center",
			cssFloat: "left"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerColor",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.colors,
			params: ["colorBy"],
			alt: "Color Data",
			title: "Color Data"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-DataExplorerShape",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.shapes,
			params: ["shapeBy"],
			alt: "Shape Data",
			title: "Shape Data"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerSize",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sizes,
			params: ["sizeBy"],
			alt: "Size Data",
			title: "Size Data"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerPattern",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.patterns,
			params: ["patternBy"],
			alt: "Pattern Data",
			title: "Pattern Data"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerConnect",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.connects,
			params: ["connectBy"],
			alt: "Connect Data",
			title: "Connect Data"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTreemapBy",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.treemap,
			params: ["treemapBy"],
			alt: "Treemap Data",
			title: "Treemap Data"
		});
		g.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Properties",
			title: "Drag metadata to change propeties",
			alt: "Drag metadata to change properties"
		}, {
			width: "90px",
			cursor: "pointer"
		}));
		g.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "96px"
		}));
		g.appendChild(d);
		g.appendChild(f);
		g.appendChild(b);
		g.appendChild(c);
		g.appendChild(a);
		g.appendChild(e);
		return g
	};
	this.loadOrientationDataExplorerDiv = function() {
		var c = this.$cX("div", {
			id: this.target + "-cX-DataExplorerOrientation",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "77px",
			height: "46px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerVertical",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.graphOrientationVertical,
			params: ["changeAttribute", ["graphOrientation", "vertical"]],
			alt: "Vertical Graph",
			title: "Vertical Graph"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerHorizontal",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.graphOrientationHorizontal,
			params: ["changeAttribute", ["graphOrientation", "horizontal"]],
			alt: "Horizontal Graph",
			title: "Horizontal Graph"
		});
		var b = this.loadFileUploadDataExplorerDiv();
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Orientation",
			title: "Click icon to change graph orientation",
			alt: "Click icon to change graph orientation"
		}, {
			width: "77px",
			cursor: "pointer"
		}));
		c.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "83px"
		}));
		c.appendChild(a);
		c.appendChild(d);
		c.appendChild(b);
		return c
	};
	this.loadFileUploadDataExplorerDiv = function() {
		var e = this.$cX("div", {
			id: this.target + "-cX-DataExplorerFileUploadDiv"
		});
		var a = this.$cX("label", {
			htmlFor: this.target + "-cX-DataExplorerFileUpload"
		}, {
			maxWidth: "inherit"
		});
		var b = this.$cX("span", {
			innerHTML: "Upload",
			className: "CanvasXpressDataExplorer",
			title: "Click to upload a new file",
			alt: "Click to upload a new file",
			params: ["fileUpload"]
		});
		var c = this.$cX("input", {
			id: this.target + "-cX-DataExplorerFileUpload",
			type: "file"
		}, {
			display: "none"
		});
		a.appendChild(b);
		e.appendChild(a);
		e.appendChild(c);
		return e
	};
	this.loadGraphTypesDataExplorerDiv = function() {
		var j = this.$cX("div", {
			id: this.target + "-cX-DataExplorerGraphs",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "120px",
			height: "144px",
			textAlign: "center",
			cssFloat: "left",
			marginBottom: "15px"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerArea",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.area,
			params: ["changeAttribute", ["graphType", "Area"]],
			alt: "Area",
			title: "Area"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-DataExplorerBar",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.bar,
			params: ["changeAttribute", ["graphType", "Bar"]],
			alt: "Bar",
			title: "Bar"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-DataExplorerBoxplot",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.boxplot,
			params: ["changeAttribute", ["graphType", "Boxplot"]],
			alt: "Boxplot",
			title: "Boxplot"
		});
		var p = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCorrelation",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.correlation,
			params: ["changeAttribute", ["graphType", "Correlation"]],
			alt: "Correlation",
			title: "Correlation"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCircular",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.circular,
			params: ["changeAttribute", ["graphType", "Circular"]],
			alt: "Circular",
			title: "Circular"
		});
		var i = this.$cX("img", {
			id: this.target + "-cX-DataExplorerHeatmap",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.heatmap,
			params: ["changeAttribute", ["graphType", "Heatmap"]],
			alt: "Heatmap",
			title: "Heatmap"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataExplorerDotplot",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.dotplot,
			params: ["changeAttribute", ["graphType", "Dotplot"]],
			alt: "Dotplot",
			title: "Dotplot"
		});
		var o = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLine",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.line,
			params: ["changeAttribute", ["graphType", "Line"]],
			alt: "Line",
			title: "Line"
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataExplorerPie",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.pie,
			params: ["changeAttribute", ["graphType", "Pie"]],
			alt: "Pie Chart",
			title: "Pie Chart"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatter2D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatter2d,
			params: ["changeAttribute", ["graphType", "Scatter2D"]],
			alt: "Scatter 2D",
			title: "Scatter 2D"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatterBubble2D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatterBubble2d,
			params: ["changeAttribute", ["graphType", "ScatterBubble2D"]],
			alt: "Scatter Bubble 2D",
			title: "Scatter Bubble 2D"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatter3D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatter3d,
			params: ["changeAttribute", ["graphType", "Scatter3D"]],
			alt: "Scatter 3D",
			title: "Scatter 3D"
		});
		var q = this.$cX("img", {
			id: this.target + "-cX-DataExplorerStacked",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.stacked,
			params: ["changeAttribute", ["graphType", "Stacked"]],
			alt: "Stacked",
			title: "Stacked"
		});
		var m = this.$cX("img", {
			id: this.target + "-cX-DataExplorerStackedPercent",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.stackedPercent,
			params: ["changeAttribute", ["graphType", "StackedPercent"]],
			alt: "Stacked Percent",
			title: "Stacked Percent"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTagCloud",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.tagCloud,
			params: ["changeAttribute", ["graphType", "TagCloud"]],
			alt: "Tag Cloud",
			title: "Tag Cloud"
		});
		var n = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTreemap",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.treemap,
			params: ["changeAttribute", ["graphType", "Treemap"]],
			alt: "Treemap",
			title: "Treemap"
		});
		j.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Graph Types",
			title: "Click in icons to change graph type",
			alt: "Click in icons to change graph type"
		}, {
			width: "120px",
			cursor: "pointer"
		}));
		j.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "126px"
		}));
		j.appendChild(b);
		j.appendChild(k);
		j.appendChild(l);
		j.appendChild(a);
		j.appendChild(p);
		j.appendChild(i);
		j.appendChild(h);
		j.appendChild(o);
		j.appendChild(g);
		j.appendChild(f);
		j.appendChild(d);
		j.appendChild(e);
		j.appendChild(q);
		j.appendChild(m);
		j.appendChild(c);
		j.appendChild(n);
		return j
	};
	this.loadAxesDataExplorerDiv = function() {
		var f = this.$cX("div", {
			id: this.target + "-cX-DataExplorerAxes",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "46px",
			height: "144px",
			textAlign: "center",
			cssFloat: "left",
			marginBottom: "15px"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerXAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.xAxis,
			params: ["addToAxis", ["xAxis"]],
			alt: "X-Axis",
			title: "X-Axis"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogXAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["xAxis"]],
			alt: "X-Axis Lin / Log",
			title: "X-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataExplorerYAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.yAxis,
			params: ["addToAxis", ["yAxis"]],
			alt: "Y-Axis",
			title: "Y-Axis"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogYAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["yAxis"]],
			alt: "Y-Axis Lin / Log",
			title: "Y-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataExplorerZAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.zAxis,
			params: ["addToAxis", ["zAxis"]],
			alt: "Z-Axis",
			title: "Z-Axis"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogZAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["zAxis"]],
			alt: "Z-Axis Lin / Log",
			title: "Z-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerMotion",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.motion,
			params: ["motion"],
			alt: "Motion",
			title: "Motion"
		});
		f.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Axes",
			title: "Drag Samples to assign to Axis",
			alt: "Drag Samples to assign to Axis"
		}, {
			width: "46px",
			cursor: "pointer"
		}));
		f.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "52px"
		}));
		f.appendChild(b);
		f.appendChild(e);
		f.appendChild(h);
		f.appendChild(d);
		f.appendChild(g);
		f.appendChild(c);
		f.appendChild(a);
		return f
	};
	this.loadVariablesDataExplorerDiv = function(b) {
		if (!b) {
			b = this.$cX("div", {
				id: this.target + "-cX-DataExplorerVariables",
				className: "CanvasXpressDataExplorer",
				type: "vars"
			}, {
				width: "180px",
				height: "58px",
				overflowY: "auto"
			})
		}
		for (var c = 0; c < this.data.y.vars.length; c++) {
			var a = this.$cX("img", {
				src: CanvasXpress.images.canvasXpress,
				className: "CanvasXpressDataExplorerMask"
			});
			var d = this.$cX("span", {
				id: this.target + "-cX-DataExplorerVariables-" + this.data.y.vars[c],
				innerHTML: this.data.y.vars[c],
				className: "CanvasXpressDataExplorerNumeric draggable",
				type: "vars",
				numeric: true,
				params: ["switchVarToAnnotation"],
				draggable: true,
				spellcheck: false
			});
			d.appendChild(a);
			b.appendChild(d)
		}
		return b
	};
	this.loadSamplesDataExplorerDiv = function(c) {
		if (!c) {
			c = this.$cX("div", {
				id: this.target + "-cX-DataExplorerSamples",
				className: "CanvasXpressDataExplorer",
				type: "smps"
			}, {
				width: "180px",
				height: "58px",
				overflowY: "auto"
			})
		}
		for (var b = 0; b < this.data.y.smps.length; b++) {
			var a = this.$cX("img", {
				src: CanvasXpress.images.canvasXpress,
				className: "CanvasXpressDataExplorerMask"
			});
			var d = this.$cX("span", {
				id: this.target + "-cX-DataExplorerSamples-" + this.data.y.smps[b],
				innerHTML: this.data.y.smps[b],
				className: "CanvasXpressDataExplorerNumeric draggable",
				type: "smps",
				numeric: true,
				params: ["switchSmpToAnnotation"],
				draggable: true,
				spellcheck: false
			});
			d.appendChild(a);
			c.appendChild(d)
		}
		return c
	};
	this.loadAnnotationsDataExplorerDiv = function(b) {
		var d = this.meta.data.x;
		if (!b) {
			b = this.$cX("div", {
				id: this.target + "-cX-DataExplorerAnnotations",
				className: "CanvasXpressDataExplorer",
				type: "x"
			}, {
				width: "180px",
				height: "58px",
				overflowY: "auto"
			})
		}
		if (this.data.x) {
			for (var e in this.data.x) {
				var c = d[e].unique ? "CanvasXpressDataExplorerUnique draggable" : d[e].type == "String" ? "CanvasXpressDataExplorerString draggable" : "CanvasXpressDataExplorerNumeric draggable";
				var a = this.$cX("img", {
					src: CanvasXpress.images.canvasXpress,
					className: "CanvasXpressDataExplorerMask"
				});
				var f = this.$cX("span", {
					id: this.target + "-cX-DataExplorerAnnotations-" + e,
					innerHTML: e,
					className: c,
					type: "x",
					unique: d[e].unique,
					numeric: d[e].type == "String" ? false : true,
					params: ["switchAnnotationToVar"],
					draggable: true,
					spellcheck: false
				});
				if (d[e].unique) {
					f.alt = "Double-click to convert to Sample Id";
					f.title = "Double-click to convert to Sample Id"
				}
				f.appendChild(a);
				b.appendChild(f)
			}
		}
		return b
	};
	this.loadDescriptionsDataExplorerDiv = function(f) {
		var c = this.meta.data.z;
		if (!f) {
			f = this.$cX("div", {
				id: this.target + "-cX-DataExplorerDescriptions",
				className: "CanvasXpressDataExplorer",
				type: "z"
			}, {
				width: "180px",
				height: "58px",
				overflowY: "auto"
			})
		}
		if (this.data.z) {
			for (var d in this.data.z) {
				var b = c[d].unique ? "CanvasXpressDataExplorerUnique draggable" : c[d].type == "String" ? "CanvasXpressDataExplorerString draggable" : "CanvasXpressDataExplorerNumeric draggable";
				var a = this.$cX("img", {
					src: CanvasXpress.images.canvasXpress,
					className: "CanvasXpressDataExplorerMask"
				});
				var e = this.$cX("span", {
					id: this.target + "-cX-DataExplorerDescriptions-" + d,
					innerHTML: d,
					className: b,
					type: "z",
					unique: c[d].unique,
					numeric: c[d].type == "String" ? false : true,
					params: ["switchAnnotationToSmp"],
					draggable: true,
					spellcheck: false
				});
				if (c[d].unique) {
					e.alt = "Double-click to convert to Variable Id";
					e.title = "Double-click to convert to Variable Id"
				}
				e.appendChild(a);
				f.appendChild(e)
			}
		}
		return f
	};
	this.addRemoveDataExplorerListeners = function(q) {
		var e;
		var F = this.$(this.target + "-cX-DataExplorerFormat");
		var w = this.$(this.target + "-cX-DataExplorerMetadata");
		var G = this.$(this.target + "-cX-DataExplorerOrientation");
		var E = this.$(this.target + "-cX-DataExplorerGraphs");
		var H = this.$(this.target + "-cX-DataExplorerAxes");
		var A = this.$(this.target + "-cX-DataExplorerLayout");
		var u = this.$(this.target + "-cX-DataExplorerProperties");
		var o = this.$(this.target + "-cX-DataExplorerVariables");
		var B = this.$(this.target + "-cX-DataExplorerSortVariables");
		var r = this.$(this.target + "-cX-DataExplorerSamples");
		var y = this.$(this.target + "-cX-DataExplorerSortSamples");
		var n = this.$(this.target + "-cX-DataExplorerAnnotations");
		var k = this.$(this.target + "-cX-DataExplorerSortAnnotations");
		var h = this.$(this.target + "-cX-DataExplorerDescriptions");
		var c = this.$(this.target + "-cX-DataExplorerSortDescriptions");
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerMinimizeImage1"), "click", this.collapseExpandDataExplorerPanel, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerMinimizeImage2"), "click", this.collapseExpandDataExplorerPanel, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorer"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerCloseImage"), "click", this.closeDataExplorer, false);
		e = [F, w, G, E];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClick, false);
				if (e[D].childNodes.length == 5 && e[D].childNodes[4].id == this.target + "-cX-DataExplorerFileUploadDiv") {
					this[q](e[D].childNodes[4].childNodes[1], "change", this.loadFile, false)
				}
			}
		}
		e = [H, A, u, o, r, n, h];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "drop", this.dropDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragover", this.dragOverDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragenter", this.dragEnterDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragleave", this.dragLeaveDataExplorer, false);
				for (var C = 0; C < e[D].childNodes.length; C++) {
					var b = e[D].childNodes[C];
					if (b.tagName == "SPAN") {
						this.addRemoveEvtListener(q, b, "dragstart", this.dragStartDataExplorer, false);
						this.addRemoveEvtListener(q, b, "dragend", this.dragEndDataExplorer, false)
					}
				}
			}
		}
		e = [n, h];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "dblclick", this.dataExplorerDblclick, false)
			}
		}
		e = [A, u];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClickReset, false)
			}
		}
		e = [B, y, k, c];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClickSort, false)
			}
		}
		e = [H];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				for (var C = 0; C < e[D].childNodes.length; C++) {
					var b = e[D].childNodes[C];
					if (b.tagName == "IMG") {
						if (b.id.match(/LinLog/)) {
							this.addRemoveEvtListener(q, b, "click", this.dataExplorerClickLinLog, false)
						} else {
							this.addRemoveEvtListener(q, b, "click", this.dataExplorerClickReset, false)
						}
					}
				}
			}
		}
	};
	this.collapseExpandDataExplorerPanel = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var b = a.getTargetEvent(f);
			var d = b.nextElementSibling;
			var c = b.title;
			if (c.match("Collapse")) {
				b.title = c.replace("Collapse", "Expand");
				d.style.display = "none"
			} else {
				b.title = c.replace("Expand", "Collapse");
				d.style.display = "block"
			}
			b.alt = b.title;
			var g = b.src;
			b.src = b.srt;
			b.srt = g;
			return false
		}
	}(this);
	this.dragStartDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c).parentNode;
			b.style.opacity = "0.3";
			c.dataTransfer.setDragImage(b, 0, 0);
			c.dataTransfer.setData("text", b.id);
			return false
		}
	}(this);
	this.dragEnterDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b.parentNode.tagName == "SPAN") {
				b = b.parentNode
			}
			if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName != "IMG") {
				b.parentNode.className = "CanvasXpressDataExplorerActive"
			} else {
				if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName == "IMG") {
					b.parentNode.className = "CanvasXpressDataExplorer"
				} else {
					if ((b.tagName == "DIV" && b.lastChild && b.lastChild.tagName != "IMG") || b.tagName == "IMG") {
						b.className = "CanvasXpressDataExplorerActive"
					}
				}
			}
			return false
		}
	}(this);
	this.dragOverDataExplorer = function(a) {
		return function(c) {
			a.cancelEvent(c);
			var b = a.getTargetEvent(c);
			if (b.parentNode.tagName == "SPAN") {
				b = b.parentNode
			}
			if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName != "IMG") {
				b.parentNode.className = "CanvasXpressDataExplorerActive"
			} else {
				if (b.tagName == "DIV" && b.lastChild && b.lastChild.tagName != "IMG") {
					b.className = "CanvasXpressDataExplorerActive"
				}
			}
			return false
		}
	}(this);
	this.dragLeaveDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b.parentNode.tagName == "SPAN") {
				b = b.parentNode
			}
			if (b.tagName == "DIV" || b.tagName == "IMG") {
				b.className = "CanvasXpressDataExplorer"
			}
			return false
		}
	}(this);
	this.dragEndDataExplorer = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var c = a.getTargetEvent(g);
			if (c.parentNode.tagName == "SPAN") {
				c.blur();
				c = c.parentNode;
				c.focus()
			}
			c.style.opacity = "1.0";
			var d = c.parentNode;
			if (d.tagName == "SPAN") {
				d = d.parentNode
			}
			d.className = "CanvasXpressDataExplorer";
			var f = d.type;
			var b = c.type;
			if (f == b) {
				return false
			}
			return false
		}
	}(this);
	this.dropDataExplorer = function(a) {
		return function(s) {
			a.cancelEvent(s);
			var p, l, c, m;
			var t = s.dataTransfer.getData("text");
			var g = a.$(t);
			if (g) {
				var w = g.innerText;
				var v = g.type;
				var h = g.numeric;
				var u = g.params[0];
				if (s.target.tagName == "IMG") {
					s.target.className = "CanvasXpressDataExplorer";
					p = a.getTargetEvent(s);
					m = p.title.split(" : ")[0];
					l = p.params[0];
					switch (l) {
						case "treemapBy":
							if (v == "x") {
								var r = a.treemapBy;
								if (a.isInArray(w, r)) {
									var b = [];
									for (var o = 0; o < r.length; o++) {
										if (r[o] != w) {
											b.push(r[o])
										}
									}
									r = b
								} else {
									r.push(w)
								}
								if (r.length > 0) {
									p.title = m + " : " + a.treemapBy.join(", ");
									p.alt = p.title
								} else {
									p.title = m;
									p.alt = p.title
								}
							} else {
								alert("Ooops! Only Sample factors")
							}
							a.draw();
							return false;
						case "groupSamples":
							if (v == "x") {
								var f = a.groupingFactors;
								if (a.isInArray(w, f)) {
									var b = [];
									for (var o = 0; o < f.length; o++) {
										if (f[o] != w) {
											b.push(f[o])
										}
									}
									f = b
								} else {
									f.push(w)
								}
								if (f.length > 0) {
									a.groupSamples(f);
									p.title = m + " : " + a.groupingFactors.join(", ");
									p.alt = p.title
								} else {
									a.ungroupSamples();
									p.title = m;
									p.alt = p.title
								}
							} else {
								alert("Ooops! Only Sample factors")
							}
							return false;
						case "segregate":
							if (v == "x") {
								var q = a.segregateSamplesBy;
								if (a.isInArray(w, q)) {
									var b = [];
									for (var o = 0; o < q.length; o++) {
										if (q[o] != w) {
											b.push(q[o])
										}
									}
									if (b.length > 0) {
										a.segregateSamplesBy = b;
										a.segregate("Samples", b)
									} else {
										a.segregateSamplesBy = [];
										a.desegregate("Samples")
									}
								} else {
									if (a.segregateSamplesBy.length + a.segregateVariablesBy.length < 2) {
										q.push(w);
										a.segregate("Samples", q)
									} else {
										alert("Ooops! Only 2 segregation factors")
									}
								}
							} else {
								if (v == "z") {
									var q = a.segregateVariablesBy;
									if (a.isInArray(w, q)) {
										var b = [];
										for (var o = 0; o < q.length; o++) {
											if (q[o] != w) {
												b.push(q[o])
											}
										}
										if (b.length > 0) {
											a.segregateVariablesBy = b;
											a.segregate("Variables", b)
										} else {
											a.segregateVariablesBy = [];
											a.desegregate("Variables")
										}
									} else {
										if (a.segregateSamplesBy.length + a.segregateVariablesBy.length < 2) {
											q.push(w);
											a.segregate("Variables", q)
										} else {
											alert("Ooops! Only 2 segregation factors")
										}
									}
								} else {
									alert("Ooops! Only Sample or Variable factors");
									return false
								}
							}
							var b = a.segregateVariablesBy;
							b = b.concat(a.segregateSamplesBy);
							p.title = b.length > 0 ? m + " : " + b.join(", ") : m;
							p.alt = p.title;
							return false;
						case "addToAxis":
							var n = p.params[1][0];
							if (v == "smps") {
								if (s.shiftKey) {
									a.changeSampleInAxis(w, n)
								} else {
									a.changeSampleInAxis(w, n, true)
								}
								p.title = m + " : " + a[n].join(", ");
								p.alt = p.title
							} else {
								alert("Ooops! Only samples allowed")
							}
							return false;
						case "motion":
							if (v == "smps") {
								c = p.type;
								g.type = c;
								a[u](w);
								g.params[0] = "switchAnnotationToSmp";
								var j = a.$(a.target + "-cX-DataExplorerDescriptions");
								if (j) {
									j.appendChild(g)
								}
							} else {
								if (v == "vars") {
									g.type = c;
									a[u](w);
									g.params[0] = "switchAnnotationToVar";
									var k = a.$(a.target + "-cX-DataExplorerAnnotations");
									if (k) {
										k.appendChild(g)
									}
								}
							}
							a.changeAttribute("motionBy", w);
							p.title = m + " : " + w;
							p.alt = p.title;
							return false;
						case "linLog":
							return false;
						default:
							a.changeAttribute(l, w);
							p.title = m + " : " + w;
							p.alt = p.title;
							return false
					}
				} else {
					if (s.target.tagName == "SPAN" && s.target.parentNode.lastChild && s.target.parentNode.lastChild.tagName != "IMG") {
						p = s.target.parentNode
					} else {
						if (s.target.tagName == "DIV") {
							p = s.target
						}
					}
					c = p.type;
					if (v == c) {
						return false
					} else {
						if (v == "smps" && c == "z") {
							g.type = c;
							a[u](w);
							g.params[0] = "switchAnnotationToSmp"
						} else {
							if (v == "z" && c == "smps") {
								g.type = c;
								a[u](w);
								g.params[0] = "switchSmpToAnnotation"
							} else {
								if (v == "vars" && c == "x") {
									g.type = c;
									a[u](w);
									g.params[0] = "switchAnnotationToVar"
								} else {
									if (v == "x" && c == "vars") {
										g.type = c;
										a[u](w);
										g.params[0] = "switchVarToAnnotation"
									} else {
										alert("Ooops! Only changes between data and ortogonal numeric metadata");
										return false
									}
								}
							}
						}
					}
					p.appendChild(g)
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClick = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var c = a.getTargetEvent(d);
			var b = c.params;
			if (c.tagName.match(/input/i)) {
				return true
			} else {
				if (b[1]) {
					a[b[0]].apply(a, b[1])
				} else {
					if (b[0] == "createDOE" && a.isDOE) {
						a.removeDOE()
					} else {
						if (b[0] == "fileUpload") {
							return false
						} else {
							a[b[0]]()
						}
					}
				}
			}
			return false
		}
	}(this);
	this.dataExplorerDblclick = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.getTargetEvent(f).parentNode;
			var d = c.type;
			var b = c.innerText;
			if (d == "z") {
				if (a.unique(a.data.z[b])) {
					a.switchVarAnnotationToId(b);
					a.resetDataExplorer()
				}
			} else {
				if (a.unique(a.data.x[b])) {
					a.switchSmpAnnotationToId(b);
					a.resetDataExplorer()
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClickSort = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var b = a.getTargetEvent(f);
			var j = b.id.replace("-cX-DataExplorerSort", "-cX-DataExplorer");
			var d = a.$(j);
			if (d) {
				var h = d.childNodes.length - 1;
				for (var c = h; c > 0; c--) {
					d.insertBefore(d.lastChild, d.childNodes[h - c])
				}
				var g = b.src;
				b.src = b.asr;
				b.asr = g
			}
			return false
		}
	}(this);
	this.dataExplorerClickLinLog = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.getTargetEvent(f);
			var b = c.params;
			if (c && b) {
				var d = b[1][0] + "Transform";
				if (a[d]) {
					a.changeAttribute(d, false)
				} else {
					a.changeAttribute(d, a.transformBase == 2 ? "log2" : "log10")
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClickReset = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var c = a.getTargetEvent(j);
			var f = c.title.split(" : ")[0];
			var b = c.params;
			c.title = f;
			c.alt = f;
			switch (b[0]) {
				case "treemapBy":
					if (a.treemapBy.length > 0) {
						a.treemapBy = []
					}
					a.draw();
					return false;
				case "groupSamples":
					if (a.groupingFactors.length > 0) {
						a.ungroupSamples()
					}
					return false;
				case "segregate":
					for (var g = 0; g < a.segregateSamplesBy.length; g++) {
						a.showSampleSegregation(a.segregateSamplesBy[g])
					}
					for (var g = 0; g < a.segregateVariablesBy.length; g++) {
						a.showVariableSegregation(a.segregateVariablesBy[g])
					}
					return false;
				case "addToAxis":
					var h = c.params[1][0];
					var d = a[h];
					a.changeSampleInAxis(d[0], h, true);
					c.title = f + " : " + a[h].join(", ");
					c.alt = c.title;
					return false;
				case "motion":
					a.changeAttribute("motionBy", false);
					return false;
				default:
					if (a[b[0]]) {
						a.changeAttribute(b[0], false)
					}
					return false
			}
		}
	}(this);
	this.closeDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var f = b.id.replace("CloseImage", "");
			var d = a.$(f);
			if (d) {
				a.addRemoveDataExplorerListeners("removeEvtListener");
				d.parentNode.removeChild(d)
			}
			return false
		}
	}(this);
	this.resetDataExplorer = function() {
		var j = this.$(this.target + "-cX-DataExplorerContainer");
		var b = this.$(this.target + "-cX-DataExplorerVariables");
		var g = this.$(this.target + "-cX-DataExplorerSamples");
		var a = this.$(this.target + "-cX-DataExplorerAnnotations");
		var h = this.$(this.target + "-cX-DataExplorerDescriptions");
		this.addRemoveDataExplorerListeners("removeEvtListener");
		var e = [b, g, a, h];
		for (var d = 0; d < e.length; d++) {
			var f = e[d];
			while (f.childNodes.length > 0) {
				f.removeChild(f.childNodes[0])
			}
		}
		this.loadVariablesDataExplorerDiv(b);
		this.loadSamplesDataExplorerDiv(g);
		this.loadAnnotationsDataExplorerDiv(a);
		this.loadDescriptionsDataExplorerDiv(h);
		this.addRemoveDataExplorerListeners("addEvtListener")
	}
};
CanvasXpress.prototype.initDataFilter = function() {
	this.heigthOffsetDataFilter = function() {
		return this.graphType == "Genome" ? 66 : 95
	};
	this.addDataFilterDiv = function() {
		if (this.$(this.target + "-cX-DataFilter")) {
			return
		}
		var j = this.dataFilterLastX != null ? parseInt(this.dataFilterLastX) : -this.meta.canvas.ctx.canvas.width * 0.5;
		var h = this.dataFilterLastY != null ? parseInt(this.dataFilterLastY) : this.meta.canvas.ctx.canvas.height * 0.5;
		var u = this.heigthOffsetDataFilter();
		this.dataFilterHeight = this.meta.canvas.ctx.canvas.height - u;
		this.activeAccordion = null;
		var B = this.$cX("div", {
			id: this.target + "-cX-DataFilter",
			className: "CanvasXpressDataFilter draggable-container"
		}, {
			top: h + "px",
			left: j + "px",
			display: "none",
			zIndex: 10000,
			marginLeft: "3px"
		});
		var o = this.$cX("div", {
			id: this.target + "-cX-DataFilterToolbar",
			className: "CanvasXpressDataFilterToolbar draggable"
		}, {
			width: this.dataFilterWidth + "px"
		});
		var b = this.$cX("span", {
			innerHTML: "Filters",
			className: "CanvasXpressDataFilterToolbarText"
		});
		var s = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyFlash",
			className: "CanvasXpressDataFilterToolbarImage",
			src: this.filterFlashingOn ? CanvasXpress.images.lightbulb : CanvasXpress.images.lightbulbOff,
			alt: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing",
			title: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing"
		}, {
			display: this.graphType == "Network" ? "block" : "none"
		});
		if (this.meta.system.isIE) {
			s.style.marginTop = "-10px"
		}
		var g = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyReset",
			className: "CanvasXpressDataFilterToolbarImage",
			src: CanvasXpress.images.funnelCross,
			alt: "Reset filters",
			title: "Reset filters"
		});
		if (this.meta.system.isIE) {
			g.style.marginTop = "-10px"
		}
		var v = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyDock",
			className: "CanvasXpressDataFilterToolbarImage",
			src: this.dataFilterLastState && this.dataFilterLastState == "docked" ? CanvasXpress.images.unpin : CanvasXpress.images.pin,
			alt: this.dataFilterLastState && this.dataFilterLastState == "docked" ? "Undock" : "Dock",
			title: this.dataFilterLastState && this.dataFilterLastState == "docked" ? "Undock" : "Dock",
			state: this.dataFilterLastState && this.dataFilterLastState == "docked" ? "docked" : "free"
		});
		if (this.meta.system.isIE) {
			v.style.marginTop = "-10px"
		}
		var x = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyClose",
			className: "CanvasXpressDataFilterToolbarImage",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		if (this.meta.system.isIE) {
			x.style.marginTop = "-10px"
		}
		var C = this.$cX("div", {
			id: this.target + "-cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainer"
		}, {
			width: this.dataFilterWidth + "px"
		});
		var m = this.$cX("div", {
			id: this.target + "-cX-DataFilterVariableHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType.match(/Genome|Network/) ? "none" : "block"
		});
		var r = this.$cX("div", {
			id: this.target + "-cX-DataFilterVariableContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var e = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variables",
			className: "CanvasXpressDataFilterText"
		});
		var k = this.$cX("div", {
			id: this.target + "-cX-DataFilterSampleHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType.match(/Genome|Network/) ? "none" : "block"
		});
		var q = this.$cX("div", {
			id: this.target + "-cX-DataFilterSampleContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var c = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Samples",
			className: "CanvasXpressDataFilterText"
		});
		var y = this.$cX("div", {
			id: this.target + "-cX-DataFilterNodeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Network" ? "block" : "none"
		});
		var A = this.$cX("div", {
			id: this.target + "-cX-DataFilterNodeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var n = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nodes",
			className: "CanvasXpressDataFilterText"
		});
		var t = this.$cX("div", {
			id: this.target + "-cX-DataFilterEdgeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Network" ? "block" : "none"
		});
		var z = this.$cX("div", {
			id: this.target + "-cX-DataFilterEdgeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var i = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edges",
			className: "CanvasXpressDataFilterText"
		});
		var f = this.$cX("div", {
			id: this.target + "-cX-DataFilterGenomeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Genome" ? "block" : "none"
		});
		var l = this.$cX("div", {
			id: this.target + "-cX-DataFilterGenomeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var a = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Features",
			className: "CanvasXpressDataFilterText"
		});
		o.appendChild(b);
		o.appendChild(x);
		o.appendChild(v);
		o.appendChild(g);
		o.appendChild(s);
		m.appendChild(e);
		k.appendChild(c);
		y.appendChild(n);
		t.appendChild(i);
		f.appendChild(a);
		C.appendChild(m);
		C.appendChild(r);
		C.appendChild(k);
		C.appendChild(q);
		C.appendChild(y);
		C.appendChild(A);
		C.appendChild(t);
		C.appendChild(z);
		C.appendChild(f);
		C.appendChild(l);
		B.appendChild(o);
		B.appendChild(C);
		var p = this.$("east-wrapper-" + this.target);
		if (p) {
			p.appendChild(B);
			this.addRemoveDataFilterListeners("addEvtListener")
		}
	};
	this.addRemoveDataFilterListeners = function(k) {
		var e = this.$(this.target + "-cX-DataFilterToolbar");
		var a = this.$(this.target + "-cX-DataFilterKeyFlash");
		var g = this.$(this.target + "-cX-DataFilterKeyReset");
		var b = this.$(this.target + "-cX-DataFilterKeyDock");
		var c = this.$(this.target + "-cX-DataFilterKeyClose");
		var h = this.$(this.target + "-cX-DataFilterVariableHeader");
		var i = this.$(this.target + "-cX-DataFilterSampleHeader");
		var d = this.$(this.target + "-cX-DataFilterNodeHeader");
		var f = this.$(this.target + "-cX-DataFilterEdgeHeader");
		var j = this.$(this.target + "-cX-DataFilterGenomeHeader");
		if (e && a && g && b && c && h && i && d && f && j) {
			this[k](e, "mousedown", this.registerMousemove, false);
			this[k](a, "click", this.flashDataFilter, false);
			this[k](g, "click", this.resetDataFilter, false);
			this[k](b, "click", this.dockUndockDataFilter, false);
			this[k](c, "click", this.hideDataFilter, false);
			this[k](h, "click", this.activateAccordion, false);
			this[k](i, "click", this.activateAccordion, false);
			this[k](d, "click", this.activateAccordion, false);
			this[k](f, "click", this.activateAccordion, false);
			this[k](j, "click", this.activateAccordion, false)
		}
	};
	this.flashDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (a.filterFlashingOn) {
				a.filterFlashingOn = false;
				b.src = CanvasXpress.images.lightbulbOff;
				b.alt = "Turn on Flashing";
				b.title = "Turn on Flashing"
			} else {
				a.filterFlashingOn = true;
				b.src = CanvasXpress.images.lightbulb;
				b.alt = "Turn off Flashing";
				b.title = "Turn off Flashing"
			}
			return false
		}
	}(this);
	this.activateAccordion = function(a) {
		return function(f, b) {
			if (!f) {
				f = window.event
			}
			var d = a;
			if (!b) {
				b = a.getTargetEvent(f)
			}
			if (b) {
				if (b.tagName.toLowerCase() == "span") {
					b = b.parentNode
				}
				b.className = "CanvasXpressDataFilterHeadActive";
				b.firstChild.className = "CanvasXpressDataFilterTextActive";
				var c = b.nextSibling;
				if (c) {
					setTimeout(function() {
						if (d.activeAccordion && c.id == d.activeAccordion.id) {
							c = false
						}
						d.transitionAccordion(new Date().getTime(), 250, c, d.activeAccordion);
						if (d.activeAccordion) {
							var e = d.activeAccordion.previousSibling;
							e.className = "CanvasXpressDataFilterHead";
							e.firstChild.className = "CanvasXpressDataFilterText"
						}
						d.activeAccordion = c
					}, 33)
				}
			}
			return false
		}
	}(this);
	this.resizeDataFilterForScroller = function(s) {
		var p = this.$(this.target + "-cX-DataFilterVariableContentSearchItems");
		var q = this.$(this.target + "-cX-DataFilterSampleContentSearchItems");
		var l = this.$(this.target + "-cX-DataFilterNodeContentSearchItems");
		var n = this.$(this.target + "-cX-DataFilterEdgeContentSearchItems");
		var b = this.$(this.target + "-cX-DataFilterGenomeContentSearchItems");
		this.dataFilterScroller = s ? true : false;
		var k = [p, q, l, n, b];
		var e = s ? -18 : 18;
		var f = this.meta.system.isIE ? 44 : 42;
		var d = s ? (this.dataFilterWidth - (f + 18)) / (this.dataFilterWidth - f) : (this.dataFilterWidth - f) / (this.dataFilterWidth - (f + 18));
		if (s && this.dataFilterScrollerResized) {
			return
		}
		for (var h = 0; h < k.length; h++) {
			if (k[h]) {
				for (var g = 0; g < k[h].childNodes.length; g++) {
					var m = k[h].childNodes[g];
					if (m.type == "numeric") {
						m.childNodes[0].style.width = (parseInt(m.childNodes[0].style.width) + e) + "px";
						m.childNodes[1].style.width = (parseInt(m.childNodes[1].style.width) + e) + "px";
						m.childNodes[2].style.width = (parseInt(m.childNodes[2].style.width) + e) + "px";
						var a = m.childNodes[2].childNodes[1];
						var o = parseInt(a.style.width) * d;
						a.units /= d;
						a.style.width = o + "px"
					}
				}
			}
		}
		this.dataFilterScrollerResized = s ? true : false
	};
	this.moveDataFilter = function(l, m) {
		var k, n;
		var p = this.$(this.target + "-cX-DataFilter");
		var i = this.$(this.target + "-cX-DataFilterToolbar");
		var e = this.$(this.target + "-cX-DataFilterKeyDock");
		var d = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
		var f = this.$("north-container-" + this.target);
		var a = this.$("south-container-" + this.target);
		var j = this.$("west-container-" + this.target);
		var t = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var o = this.$("east-wrapper-" + this.target);
		var b = 64;
		var r = 0;
		var q = this.showFadeResizeMoveAnimation ? 500 : 0;
		var g = this;
		if (p && i && e && f && a && j && t && c && o) {
			var s = (i.clientWidth - this.dataFilterWidth) + 2;
			n = parseInt(f.clientHeight) + this.meta.canvas.ctx.canvas.height + parseInt(a.clientHeight);
			if (e.getAttribute("state") == "free" && !l) {
				e.setAttribute("state", "docked");
				this.dataFilterLastState = "docked";
				this.dataFilterLastX = p.style.left;
				this.dataFilterLastY = p.style.top;
				var k = parseInt(j.style.width) + this.meta.canvas.ctx.canvas.width + i.clientWidth + 2;
				if (d) {
					this.resizeMove(d, 0, 0, Math.max(k, parseInt(a.clientWidth)) + r, n + b)
				}
				this.resizeMove(t, 0, 0, k, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(c, 0, 0, this.dataFilterWidth + s, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(o, 0, 0, this.dataFilterWidth + s, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(p, 0, 0, this.dataFilterWidth, this.meta.canvas.ctx.canvas.height)
			} else {
				e.setAttribute("state", "free");
				this.dataFilterLastState = "free";
				if (l) {
					delete(this.dataFilterLastState);
					this.dataFilterLastX = null;
					this.dataFilterLastY = null;
					this.fade(p, 500, function() {
						g.resetFade(p);
						p.style.display = "none";
						p.style.width = g.dataFilterWidth + "px";
						p.style.height = g.meta.canvas.ctx.canvas.height + "px"
					})
				}
				k = parseInt(j.style.width) + this.meta.canvas.ctx.canvas.width;
				if (d) {
					this.resizeMove(d, 0, 0, Math.max(k, parseInt(a.clientWidth)) + r, n + b)
				}
				this.resizeMove(t, 0, 0, k, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(c, 0, 0, 0, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(o, 0, 0, 0, this.meta.canvas.ctx.canvas.height);
				if (!l) {
					this.resizeMove(p, 0, 0, 0, this.meta.canvas.ctx.canvas.height)
				}
			}
			if (m) {
				e.setAttribute("state", m)
			}
			if (e.getAttribute("state") == "dock") {
				e.src = CanvasXpress.images.unpin;
				e.alt = "Undock";
				e.title = "Undock"
			} else {
				e.src = CanvasXpress.images.pin;
				e.alt = "Dock";
				e.title = "Dock"
			}
		}
	};
	this.updateDataFilter = function(a) {
		this.functionCaller = "updateDataFilter";
		if (this.isTransition()) {
			return
		}
		var m = this;
		var c = this.isDOE;
		var g, j;
		var b = function(u, p, w, i, s) {
			var q = {
				min: ">=",
				max: "<=",
				like: "like",
				exact: "exact"
			};
			if (q[w]) {
				m[u].push(s != null ? i + ":::" + s : i);
				m[u + "Op"].push(q[w]);
				m[u + "Case"].push(false);
				m[u + "Value"].push(m.toDoFilter[p][i][w])
			}
		};
		if (this.filteringStringOn || this.filteringNumericOn || a) {
			this.resetFilters();
			var n = false;
			if (c) {
				this.removeDOE(true)
			}
			for (var k in this.toDoFilter) {
				for (var e in this.toDoFilter[k]) {
					for (var l in this.toDoFilter[k][e]) {
						var d = this.toDoFilter[k][e]["ref"];
						if (l != "ref") {
							if (k == "sample") {
								b("filterSmpBy", k, l, e, d)
							} else {
								if (k == "variable") {
									b("filterVarBy", k, l, e, d)
								} else {
									if (k == "node") {
										b("filterNodeBy", k, l, e, d)
									} else {
										if (k == "edge") {
											b("filterEdgeBy", k, l, e, d)
										} else {
											if (k == "feature") {
												b("filterFeatureBy", k, l, e, d)
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.reset(true);
			this.filterData(true);
			if (this.layoutComb) {
				g = this.varIndices;
				j = this.smpIndices
			}
			if (c) {
				this.createDOE(true)
			}
			if (this.decorations && this.decorations.reg) {
				this.updateCorrelation()
			}
			if (this.validateAxesOnFilterData()) {
				if (this.graphType == "Network" && this.filterFlashingOn) {
					var f = [];
					for (var h = 0; h < this.data.nodes.length; h++) {
						if (!this.data.nodes[h].hide) {
							f.push(this.data.nodes[h].id)
						}
					}
					this.flashNode(f, false, 5)
				} else {
					if (this.isGroupedData && this.smpIndices.length > 0) {
						this.groupSamples(this.groupingFactors, false, false, true, true)
					}
					this.draw();
					if (this.layoutComb) {
						this.varIndices = g;
						this.smpIndices = j
					}
				}
			} else {
				if (!this.scatterPlotMatrix) {
					this.reset(true)
				}
				this.draw()
			}
		}
	};
	this.refreshDataFilters = function(e, C, n, A, b) {
		if (e && C) {
			var y;
			switch (C) {
				case "variable":
					y = this.getSampleVariableData("vars");
					break;
				case "sample":
					y = this.getSampleVariableData("smps");
					break
			}
			if (y) {
				if (!this.lastRefreshedFilter) {
					this.lastRefreshedFilter = []
				}
				var m = this.lastRefreshedFilter.length > 0 ? this.lastRefreshedFilter[this.lastRefreshedFilter.length - 1] : "";
				var x = false;
				while (m == n) {
					this.lastRefreshedFilter.pop();
					m = this.lastRefreshedFilter[this.lastRefreshedFilter.length - 1];
					x = true
				}
				for (var u = 0; u < e.childNodes.length; u++) {
					var z = e.childNodes[u];
					var D = this.$(z.id.replace("DataFilterContainer", "DataFilterScroll"));
					var h = this.$(z.id.replace("DataFilterContainer", "DataFilterOptions"));
					if (D && h) {
						if (D.uvalue != n && !A) {
							var B = this.sortObject(y[D.uvalue]["o"]);
							D.fvalues = ["(All) " + B.length + " values"];
							for (var q = 0; q < B.length; q++) {
								D.fvalues.push(B[q])
							}
							D.fvalues.push("")
						} else {
							if (A && x && (m == D.uvalue || this.lastRefreshedFilter.length == 0)) {
								D.fvalues = D.values
							}
						}
						while (h.childNodes.length > 0) {
							h.removeChild(h.childNodes[0])
						}
						if ((D.uvalue == n && !A) || (A && m == D.uvalue)) {
							this.loadStringFilter(D.fvalues, D.uvalue, h, y[D.uvalue]["o"])
						} else {
							this.loadStringFilter(D.fvalues, D.uvalue, h)
						}
					}
				}
				if (!A) {
					this.lastRefreshedFilter.push(n)
				}
			}
		} else {
			if (b) {
				var x = this.$(this.target + "-cX-DataFilterContainer");
				if (x) {
					this.lastRefreshedFilter = [];
					for (var u = 0; u < x.childNodes.length; u++) {
						if (x.childNodes[u].id.match("Content")) {
							var z = x.childNodes[u];
							for (var q = 0; q < z.childNodes.length; q++) {
								if (z.childNodes[q].id.match("Items")) {
									var w = z.childNodes[q];
									for (var n = 0; n < w.childNodes.length; n++) {
										if (w.childNodes[n].id.match("Container")) {
											var y = w.childNodes[n];
											var D = this.$(y.id.replace("DataFilterContainer", "DataFilterScroll"));
											var h = this.$(y.id.replace("DataFilterContainer", "DataFilterOptions"));
											if (D && h) {
												D.fvalues = D.values;
												while (h.childNodes.length > 0) {
													h.removeChild(h.childNodes[0])
												}
												this.loadStringFilter(D.fvalues, D.uvalue, h)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.validateAxesOnFilterData = function() {
		if (!this.startingXAxisIndices) {
			this.startingXAxis = this.xAxis;
			this.startingXAxisIndices = this.graphType.match(/Scatter/i) ? this.xAxisIndices : this.xAxisVarIndices
		}
		if (!this.startingXAxis2Indices) {
			this.startingXAxis2 = this.xAxis2;
			this.startingXAxis2Indices = this.xAxis2VarIndices
		}
		if (!this.startingYAxisIndices) {
			this.startingYAxis = this.yAxis;
			this.startingYAxisIndices = this.yAxisIndices
		}
		if (!this.startingZAxisIndices) {
			this.startingZAxis = this.zAxis;
			this.startingZAxisIndices = this.zAxisIndices
		}
		if (this.graphType.match(/Scatter/i)) {
			var a = this.getObjectArray(this.smpIndices);
			this.xAxis = [];
			this.xAxisIndices = [];
			for (var b = 0; b < this.startingXAxisIndices.length; b++) {
				if (a.hasOwnProperty(this.startingXAxisIndices[b])) {
					this.xAxis.push(this.data.y.smps[this.startingXAxisIndices[b]]);
					this.xAxisIndices.push(this.startingXAxisIndices[b])
				}
			}
			if (this.xAxisIndices.length < 1) {
				this.xAxis = this.startingXAxis;
				this.xAxisIndices = this.startingXAxisIndices;
				if (this.debug) {
					alert("Cannot filter since there are no samples left in X-Axis")
				}
				return false
			}
			this.yAxis = [];
			this.yAxisIndices = [];
			for (var b = 0; b < this.startingYAxisIndices.length; b++) {
				if (a.hasOwnProperty(this.startingYAxisIndices[b])) {
					this.yAxis.push(this.data.y.smps[this.startingYAxisIndices[b]]);
					this.yAxisIndices.push(this.startingYAxisIndices[b])
				}
			}
			if (this.yAxisIndices.length < 1) {
				this.yAxis = this.startingYAxis;
				this.yAxisIndices = this.startingYAxisIndices;
				if (this.debug) {
					alert("Cannot filter since there are no samples left in Y-Axis")
				}
				return false
			}
			if (this.graphType == "Scatter3D" || this.graphType == "ScatterBubble2D") {
				this.zAxis = [];
				this.zAxisIndices = [];
				for (var b = 0; b < this.startingZAxisIndices.length; b++) {
					if (a.hasOwnProperty(this.startingZAxisIndices[b])) {
						this.zAxis.push(this.data.y.smps[this.startingZAxisIndices[b]]);
						this.zAxisIndices.push(this.startingZAxisIndices[b])
					}
				}
				if (this.zAxisIndices.length < 1) {
					this.zAxis = this.startingZAxis;
					this.zAxisIndices = this.startingZAxisIndices;
					if (this.debug) {
						alert("Cannot filter since there are no samples left in Z-Axis")
					}
					return false
				}
			}
		} else {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
				var a = this.getObjectArray(this.varIndices);
				this.xAxis = [];
				this.xAxisIndices = [];
				for (var b = 0; b < this.startingXAxisIndices.length; b++) {
					if (a.hasOwnProperty(this.startingXAxisIndices[b])) {
						this.xAxis.push(this.data.y.vars[this.startingXAxisIndices[b]]);
						this.xAxisIndices.push(this.startingXAxisIndices[b])
					}
				}
				if (this.xAxisIndices.length < 1) {
					this.xAxis = this.startingXAxis;
					this.xAxisIndices = this.startingXAxisIndices;
					if (this.debug) {
						alert("Cannot filter since there are no variables left in X-Axis")
					}
					return false
				}
				this.xAxis2 = [];
				this.xAxis2Indices = [];
				for (var b = 0; b < this.startingXAxis2Indices.length; b++) {
					if (a.hasOwnProperty(this.startingXAxis2Indices[b])) {
						this.xAxis2.push(this.data.y.vars[this.startingXAxis2Indices[b]]);
						this.xAxis2Indices.push(this.startingXAxis2Indices[b])
					}
				}
				if (this.xAxis2Indices.length < 1) {
					this.xAxis2 = this.startingXAxis2;
					this.xAxisIndices2 = this.startingXAxis2Indices;
					if (this.debug) {
						alert("Cannot filter since there are no variables left in X-Axis2")
					}
					return false
				}
			}
		}
		return true
	};
	this.showDataFilter = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var f = a.$(a.target + "-cX-DataFilter");
			if (f) {
				if (f.style.left == "0px" && f.style.top == "0px") {
					var b = a.$("west-container-" + a.target);
					var c = a.$("middle-container-" + a.target);
					if (b && c) {
						c.style.width = (parseInt(b.clientWidth) + a.meta.canvas.ctx.canvas.width + a.dataFilterWidth) + "px"
					}
				}
				if (a.activeTarget) {
					a.activeTarget.style.zIndex = 10000
				}
				a.activeTarget = f;
				f.style.display = "block";
				a.loadDataFilter();
				f.style.zIndex = 10001
			}
			return false
		}
	}(this);
	this.removeGenericDataFilterListenersOrReset = function(y) {
		var x = [];
		var v = [];
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Boxplot":
			case "Correlation":
			case "Pie":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
			case "Map":
				var k = this.$(this.target + "-cX-DataFilterSampleContent");
				var l = this.$(this.target + "-cX-DataFilterVariableContent");
				if (k && l) {
					x.push(k, l);
					v.push(this.getSampleVariableData("smps", true));
					v.push(this.getSampleVariableData("vars", true))
				}
				break;
			case "Venn":
				return;
			case "Network":
				var s = this.$(this.target + "-cX-DataFilterNodeContent");
				var o = this.$(this.target + "-cX-DataFilterEdgeContent");
				if (s && o) {
					x.push(s, o);
					v.push(this.getNodeData(true));
					v.push(this.getEdgeData(true))
				}
				break;
			case "Genome":
				var g = this.$(this.target + "-cX-DataFilterGenomeContent");
				if (g) {
					x.push(g);
					v.push(this.getFeatureData(true))
				}
				break
		}
		for (var t = 0; t < v.length; t++) {
			var f = x[t];
			var m = v[t];
			var A = this.getKeys(m);
			A.sort();
			for (var q = 0; q < A.length; q++) {
				var z = m[A[q]]["t"];
				var w = A[q].replace(/\W/g, "_");
				if (z == "string") {
					var a = this.$(this.target + ":" + w + ":cX-DataFilterInput");
					var p = this.$(this.target + ":" + w + ":cX-DataFilterScroll");
					if (p && a) {
						if (y) {
							a.value = "";
							this.resetSelectStringFilter(p)
						} else {
							this.addRemoveNumericDataFilterListeners("removeEvtListener", p)
						}
					}
				} else {
					var n = this.$(this.target + ":" + w + ":cX-DataFilterMin");
					var h = this.$(this.target + ":" + w + ":cX-DataFilterMinLabel");
					var e = this.$(this.target + ":" + w + ":cX-DataFilterRange");
					var r = this.$(this.target + ":" + w + ":cX-DataFilterMax");
					var u = this.$(this.target + ":" + w + ":cX-DataFilterMaxLabel");
					var b = this.meta.system.isIE ? 44 : 42;
					if (this.dataFilterScroller) {
						b += 18
					}
					if (n && h && e && r && u) {
						if (y) {
							n.style.left = "0px";
							h.value = this.bestFormatNumber(e.min, e.decis);
							e.style.left = "0px";
							e.style.width = (this.dataFilterWidth - b) + "px";
							r.style.left = "0px";
							u.value = this.bestFormatNumber(e.max, e.decis)
						} else {
							this.addRemoveNumericDataFilterListeners("removeEvtListener", n, r, h, u)
						}
					}
				}
			}
		}
	};
	this.loadDataFilter = function() {
		if (!this.toDoFilter) {
			this.toDoFilter = {}
		}
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Boxplot":
			case "Correlation":
			case "Pie":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
			case "Map":
				return this.loadDataFilterSmpVar();
			case "Venn":
				return;
			case "Network":
				return this.loadDataFilterNetwork();
			case "Genome":
				return this.loadDataFilterGenome()
		}
	};
	this.loadDataFilterGeneric = function(b, r, j) {
		var o = this.graphType == "Genome" ? 95 : 116;
		var p = this.getKeys(j);
		p.sort();
		if (!r.loaded) {
			r.loaded = {}
		}
		var a = r.id + "Search";
		if (!this.$(a)) {
			var k = this.$cX("div", {
				id: a,
				className: "CanvasXpressDataFilterContainerHoverable"
			}, {
				width: "97%"
			});
			var q = this.$cX("input", {
				id: a + "Input",
				type: "text",
				placeholder: " Search filters"
			}, {
				cursor: "default",
				width: "97%",
				margin: "3px",
				border: "none"
			});
			var m = this.$cX("div", {
				id: a + "Items"
			}, {
				overflow: "auto"
			});
			k.appendChild(q);
			r.appendChild(k);
			r.appendChild(m)
		}
		var h = this.$(a + "Items");
		if (h) {
			h.style.height = this.meta.canvas.ctx.canvas.height - o
		}
		for (var g = 0; g < p.length; g++) {
			var l = j[p[g]]["t"];
			var e = j[p[g]]["r"];
			var n = this.getKeys(j[p[g]]["o"]);
			var f = this.target + ":" + p[g].replace(/\W/g, "_") + ":cX-DataFilterContainer";
			if (!this.$(f)) {
				if (n.length > 0) {
					if (l == "string") {
						if (!r.loaded[p[g]]) {
							m.appendChild(this.createStringFilter(b, p[g], n, e));
							r.loaded[p[g]] = true
						}
					} else {
						if (!r.loaded[p[g]]) {
							if (n[0] == "min" && n[1] == "max") {
								n = [j[p[g]]["o"]["min"], j[p[g]]["o"]["max"]]
							}
							m.appendChild(this.createNumericFilter(b, p[g], n, e));
							r.loaded[p[g]] = true
						}
					}
				}
			}
		}
	};
	this.loadDataFilterSmpVar = function() {
		var b = this.$(this.target + "-cX-DataFilterSampleContent");
		var a = this.$(this.target + "-cX-DataFilterVariableContent");
		if (b && a) {
			this.loadDataFilterGeneric("sample", b, this.getSampleVariableData("smps", true));
			this.loadDataFilterGeneric("variable", a, this.getSampleVariableData("vars", true))
		}
	};
	this.loadDataFilterNetwork = function() {
		var b = this.$(this.target + "-cX-DataFilterNodeContent");
		var a = this.$(this.target + "-cX-DataFilterEdgeContent");
		if (b && a) {
			this.loadDataFilterGeneric("node", b, this.getNodeData(true));
			this.loadDataFilterGeneric("edge", a, this.getEdgeData(true))
		}
	};
	this.loadDataFilterGenome = function() {
		var a = this.$(this.target + "-cX-DataFilterGenomeContent");
		if (a) {
			this.loadDataFilterGeneric("feature", a, this.getFeatureData(true))
		}
	};
	this.createNumericFilter = function(g, x, f, n) {
		var a = function(d) {
			var b = 1000000;
			return (((d * b) - (parseInt(d) * b)) / b).toString().replace(/\./, "").length - 1
		};
		var c = this.meta.system.isIE ? 44 : 42;
		var u = [];
		for (var z = 0; z < f.length; z++) {
			if (f[z] != null && f[z] != "") {
				u.push(f[z])
			}
		}
		f = u;
		f.sort(function(e, d) {
			return e - d
		});
		var C = x.replace(/\W/g, "_");
		var o = this.target + ":" + C;
		var E = this.$cX("div", {
			id: o + ":cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainerHoverable",
			type: "numeric",
			args: [g, x, f, n]
		});
		var w = this.$cX("div", {
			id: o + ":cX-DataFilterScale",
			className: f[0] <= 0 ? "CanvasXpressDataFilterContainerScaleNone" : "CanvasXpressDataFilterContainerScaleLinearLog",
			innerHTML: x,
			draggable: true
		}, {
			width: (this.dataFilterWidth - 12) + "px",
			margin: "5px"
		});
		var m = this.$cX("div", false, {
			width: (this.dataFilterWidth - 12) + "px",
			height: "14px",
			margin: "2px"
		});
		var A = parseFloat(f[0]) < 0 ? false : parseFloat(f[0]) == 0 ? 0 : Math.log(parseFloat(f[0]));
		var D = parseFloat(f[f.length - 1]) < 0 ? false : parseFloat(f[f.length - 1]) == 0 ? 0 : Math.log(parseFloat(f[f.length - 1]));
		var G = A != null && D != null ? (D - A) / (this.dataFilterWidth - c) : false;
		var j = this.$cX("div", {
			id: o + ":cX-DataFilterRange",
			className: "CanvasXpressDataFilterContainerRange",
			min: parseFloat(f[0]),
			max: parseFloat(f[f.length - 1]),
			range: f[f.length - 1] - f[0],
			units: (f[f.length - 1] - f[0]) / (this.dataFilterWidth - c),
			decis: a(f[f.length - 1] - f[0]),
			lmin: A,
			lmax: D,
			lunits: G,
			scale: G ? "linear" : false,
			filter: g,
			ref: n,
			uvalue: x
		}, {
			width: (this.dataFilterWidth - c) + "px"
		});
		var y = this.$cX("input", {
			id: o + ":cX-DataFilterMinLabel",
			className: "CanvasXpressDataFilterContainerMinValue",
			type: "text",
			value: this.bestFormatNumber(f[0], j.decis)
		});
		var h = this.$cX("input", {
			id: o + ":cX-DataFilterMaxLabel",
			className: "CanvasXpressDataFilterContainerMaxValue",
			type: "text",
			value: this.bestFormatNumber(f[f.length - 1], j.decis)
		});
		var F = this.$cX("div", {
			className: "CanvasXpressDataFilterContainerNumeric"
		}, {
			width: (this.dataFilterWidth - 14) + "px"
		});
		var B = this.$cX("div", {
			id: o + ":cX-DataFilterMin",
			className: "CanvasXpressDataFilterContainerMin"
		}, {
			left: "0px"
		});
		var p = this.$cX("div", {
			id: o + ":cX-DataFilterMax",
			className: "CanvasXpressDataFilterContainerMax"
		}, {
			left: "0px"
		});
		m.appendChild(y);
		m.appendChild(h);
		F.appendChild(B);
		F.appendChild(j);
		F.appendChild(p);
		E.appendChild(w);
		E.appendChild(m);
		E.appendChild(F);
		this.addRemoveNumericDataFilterListeners("addEvtListener", B, p, y, h, w);
		return E
	};
	this.addRemoveNumericDataFilterListeners = function(e, d, a, f, c, b) {
		if (e && d && a) {
			this[e](d, "mousedown", this.mousedownNumericFilter, false);
			this[e](a, "mousedown", this.mousedownNumericFilter, false);
			this[e](f, "change", this.changeNumericFilter, false);
			this[e](c, "change", this.changeNumericFilter, false);
			this[e](b, "click", this.clickNumericFilter, false);
			this[e](b, "dragstart", this.dragStartDataFilter, false);
			this[e](b, "dragend", this.dragEndDataFilter, false)
		}
	};
	this.dragStartDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			c.acs = a.adjustedCoordinates(c);
			var b = a.getTargetEvent(c);
			if (b) {
				c.dataTransfer.setDragImage(b.parentNode, -5, -5);
				b.parentNode.style.opacity = "0.3";
				c.dataTransfer.setData("text", b.parentNode.id);
				a.xMouseDown = c.screenX;
				a.yMouseDown = c.screenY
			}
			return false
		}
	}(this);
	this.dragEndDataFilter = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			f.ace = a.adjustedCoordinates(f);
			var c = a.getTargetEvent(f);
			if (c) {
				a.addRemoveDataFilter(f.srcElement.parentNode);
				var d = f.screenX - a.xMouseDown;
				var b = f.screenY - a.yMouseDown
			}
			return false
		}
	}(this);
	this.addRemoveDataFilter = function(e, o, g, j, n) {
		var h = false;
		if (!e) {
			this.loadDataFilter();
			if (o && g && j) {
				if (j == "string") {
					g[2].shift();
					g[2].pop()
				}
				e = n ? this.$(n) : this[o].apply(this, g)
			} else {
				return
			}
			h = true
		}
		if (!o) {
			o = e.type == "string" ? "createStringFilter" : "createNumericFilter"
		}
		if (!g) {
			g = e.args
		}
		if (!e) {
			return
		}
		e.style.opacity = "1.0";
		e.style.cssFloat = "left";
		var a = e.parentNode;
		if ((h && !n) || a.id.match(/DataFilter/)) {
			var k = this.$("northest-wrapper-" + this.target);
			if (k) {
				k.appendChild(e)
			}
			if (!h) {
				CanvasXpress.stack[this.target].afterRender.push(["addRemoveDataFilter", [false, o, g, e.type]])
			}
		} else {
			var c = e.id.split(":")[1];
			var b;
			if (e.type == "string") {
				var d = this.$(this.target + ":" + c + ":cX-DataFilterScroll");
				if (d) {
					b = this.rebuildDataTableFilter();
					this.addRemoveNumericDataFilterListeners("removeEvtListener", d)
				}
			} else {
				var i = this.$(this.target + ":" + c + ":cX-DataFilterMin");
				var m = this.$(this.target + ":" + c + ":cX-DataFilterMinLabel");
				var l = this.$(this.target + ":" + c + ":cX-DataFilterMax");
				var f = this.$(this.target + ":" + c + ":cX-DataFilterMaxLabel");
				var q = this.$(this.target + ":" + c + ":cX-DataFilterScale");
				if (i && m && l && f) {
					b = this.rebuildDataTableFilter();
					this.addRemoveNumericDataFilterListeners("removeEvtListener", i, l, m, f, q)
				}
			}
			if (!h) {
				CanvasXpress.stack[this.target].afterRender.push(["addRemoveDataFilter", [false, o, g, e.type, c]])
			}
			a.removeChild(e);
			if (b) {
				this.rebuildDataTableFilter(b)
			}
		}
	};
	this.changeNumericFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b) {
				a.filteringNumericOn = b;
				a.updateNumericFilter(c)
			}
			return false
		}
	}(this);
	this.mousedownNumericFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b) {
				a.filteringNumericOn = b;
				a.xMouseDown = c.clientX;
				a.yMouseDown = c.clientY
			}
			return false
		}
	}(this);
	this.clickNumericFilter = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			var d = a.getTargetEvent(h);
			if (d) {
				var c = a.$(d.id.replace("cX-DataFilterScale", "cX-DataFilterRange"));
				var g = a.adjustedCoordinates(h, d);
				if (c && g && c.scale) {
					var f = a.isIE ? 44 : 42;
					var b = a.dataFilterScroller ? parseInt(a.dataFilterWidth * 0.98) - 18 : parseInt(a.dataFilterWidth * 0.98);
					if (g.x > b - 13) {
						d.className = "CanvasXpressDataFilterContainerScaleLogLinear";
						c.scale = "log"
					} else {
						if (g.x > b - 26) {
							d.className = "CanvasXpressDataFilterContainerScaleLinearLog";
							c.scale = "linear"
						}
					}
				}
			}
			return false
		}
	}(this);
	this.updateNumericFilter = function(t) {
		if (this.filteringNumericOn) {
			this.cancelEvent(t);
			var r = this.filteringNumericOn;
			var v, o, p, h, i, u, b;
			if (r.id.match(/cX-DataFilterMin(Label)?/)) {
				b = RegExp.$1;
				v = true;
				o = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMin");
				p = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMax");
				h = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterRange");
				i = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMinLabel");
				u = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMaxLabel")
			} else {
				if (r.id.match(/cX-DataFilterMax(Label)?/)) {
					b = RegExp.$1;
					v = false;
					p = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMax");
					o = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMin");
					h = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterRange");
					i = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMinLabel");
					u = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMaxLabel")
				}
			}
			o = this.$(o);
			p = this.$(p);
			h = this.$(h);
			i = this.$(i);
			u = this.$(u);
			if (o && p && h && i && u) {
				var k, s;
				var c = this.meta.system.isIE ? 44 : 42;
				var l = this.dataFilterWidth - c;
				if (this.dataFilterScroller) {
					l -= 18
				}
				if (b) {
					var z = r.value - 0,
						m, g = i.value - 0,
						d = u.value - 0;
					var q = false;
					if (r === u && z < g) {
						z = g;
						q = true
					}
					if (r === i && z > d) {
						z = d;
						q = true
					}
					if (z < h.min) {
						z = h.min;
						q = true
					}
					if (z > h.max) {
						z = h.max;
						q = true
					}
					if (q) {
						r.value = this.bestFormatNumber(z, h.decis)
					}
					if (h.scale == "log") {
						s = z ? (Math.log(z) - h.lmin) / h.lunits : 0
					} else {
						s = (z - h.min) / h.units
					}
					s = Math.ceil(s);
					if (v) {
						s = Math.ceil(s);
						h.style.width = (parseInt(h.style.width) - s + parseInt(o.style.left)) + "px";
						o.style.left = s + "px";
						h.style.left = s + "px";
						p.style.left = s + "px"
					} else {
						h.style.width = Math.max(0, Math.floor(s) - parseInt(o.style.left)) + "px"
					}
				} else {
					k = t.clientX - this.xMouseDown;
					s = parseInt(o.style.left) + k;
					var a = v ? parseInt(h.style.width) - k : parseInt(h.style.width) + k;
					var n = this.absoluteCoordinates(o);
					var j = this.absoluteCoordinates(p);
					if (v) {
						if (s > 0 && a > 0) {
							this.xMouseDown = t.clientX;
							s = Math.max(0, Math.min(l, s));
							a = Math.max(0, Math.min(l, a))
						} else {
							if (s > 0) {
								s -= k;
								a = (j.x - n.x) - 29
							} else {
								a += s;
								s = 0
							}
						}
						o.style.left = s + "px";
						h.style.left = s + "px";
						h.style.width = a + "px";
						p.style.left = s + "px";
						var x;
						if (h.scale == "log") {
							x = s != 0 ? Math.exp((h.lunits * s) + h.lmin) : 0
						} else {
							x = (h.units * s) + h.min
						}
						x = Math.min(Math.max(x, h.min), parseFloat(u.value));
						i.value = this.bestFormatNumber(x, h.decis)
					} else {
						if (s + a <= l && a >= 0) {
							this.xMouseDown = t.clientX;
							s = Math.max(0, Math.min(l, s));
							a = Math.max(0, Math.min(l - s, a))
						} else {
							if (s + a > l) {
								s -= k;
								a = l - s
							}
						}
						h.style.width = Math.max(0, a) + "px";
						var y;
						if (h.scale == "log") {
							y = a != l ? Math.exp((h.lunits * (s + a)) + h.lmin) : h.max
						} else {
							y = (h.units * (s + a)) + h.min
						}
						y = Math.max(Math.min(y, h.max), parseFloat(i.value));
						u.value = this.bestFormatNumber(y, h.decis)
					}
				}
				var w = h.uvalue;
				var f = h.filter;
				if (!this.toDoFilter[f]) {
					this.toDoFilter[f] = {}
				}
				if (!this.toDoFilter[f][w]) {
					this.toDoFilter[f][w] = {}
				}
				if (b) {
					if (v) {
						this.toDoFilter[f][w]["min"] = z
					} else {
						this.toDoFilter[f][w]["max"] = z
					}
				} else {
					if (x != null) {
						this.toDoFilter[f][w]["min"] = x
					}
					if (y != null) {
						this.toDoFilter[f][w]["max"] = y
					}
				}
				if (h.ref != null) {
					this.toDoFilter[f][w]["ref"] = h.ref
				}
				this.updateDataFilter();
				this.refreshDataFilters(r.parentNode.parentNode.parentNode, f, w);
				if (b) {
					this.endNumericFilter(t)
				}
			}
		}
		return false
	};
	this.endNumericFilter = function(a) {
		if (this.filteringNumericOn) {
			this.filteringNumericOn = false
		}
	};
	this.createStringFilter = function(u, h, r, a) {
		r.sort();
		r.unshift("(All) " + r.length + " values");
		r.push("");
		var n = h.replace(/\W/g, "_");
		var b = this.target + ":" + n;
		var p = this.$cX("div", {
			id: b + ":cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainerHoverable",
			type: "string",
			args: [u, h, r, a]
		});
		var g = this.$cX("div", {
			id: b + ":cX-DataFilterLabel",
			innerHTML: h,
			draggable: true
		}, {
			width: "98%",
			margin: "5px"
		});
		var j = this.$cX("input", {
			id: b + ":cX-DataFilterInput",
			type: "text",
			placeholder: " Search values"
		}, {
			cursor: "default",
			width: "97%",
			marginLeft: "3px"
		});
		var f = this.$cX("div", {
			id: b + ":cX-DataFilterMask",
			className: r.length - 2 > this.maxItemMenuCheckbox ? "CanvasXpressDataFilterContainerMask" : "CanvasXpressDataFilterContainerMaskNoOverflow"
		}, {
			width: "96%",
			height: r.length - 2 > this.maxItemMenuCheckbox ? "80px" : (((r.length - 1) * 19) + 4) + "px"
		});
		var w = this.$cX("div", {
			id: b + ":cX-DataFilterScroll",
			type: (r.length - 2) > this.maxItemMenuCheckbox ? "long" : "short",
			filter: u,
			uvalue: h,
			values: r,
			fvalues: r,
			selected: {
				0: true
			},
			ref: a,
			skey: n,
			last: 0
		}, {
			width: "96%",
			height: r.length - 2 > this.maxItemMenuCheckbox ? ((r.length + 1) * 16) + "px" : (((r.length - 1) * 19) + 4) + "px"
		});
		var c = this.$cX("div", {
			id: b + ":cX-DataFilterOptions"
		}, {
			width: r.length - 2 > this.maxItemMenuCheckbox ? "110%" : "100%",
			margin: "2px",
			position: "relative"
		});
		this.loadStringFilter(r, n, c);
		w.appendChild(c);
		f.appendChild(w);
		p.appendChild(g);
		if (r.length - 2 > this.maxItemMenuCheckbox) {
			p.appendChild(j)
		}
		p.appendChild(f);
		this.addRemoveStringDataFilterListeners("addEvtListener", f);
		return p
	};
	this.loadStringFilter = function(p, g, e, q) {
		if (p && g && e) {
			if (p.length - 2 > this.maxItemMenuCheckbox) {
				for (var h = 0; h < Math.min(5, p.length); h++) {
					var b = p[h].length > 30 ? p[h].substr(0, 30) + " ..." : p[h];
					var m = (!q && h == 0) || (q && q.hasOwnProperty(p[h])) ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem";
					var n = this.$cX("div", {
						id: this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: m,
						innerHTML: b,
						alt: p[h],
						title: p[h],
						index: h
					});
					e.appendChild(n)
				}
			} else {
				for (var h = 0; h < p.length - 1; h++) {
					var b = p[h].length > 30 ? p[h].substr(0, 30) + " ..." : p[h];
					var j = this.$cX("div", {
						id: this.target + ":" + g + ":cX-DataFilterDivItem-" + h,
						alt: p[h],
						title: p[h],
						value: b,
						index: h
					});
					var n = this.$cX("input", {
						id: this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: "CanvasXpressCheckbox",
						type: "checkbox",
						checked: q && !q.hasOwnProperty(p[h]) ? false : true,
						value: b,
						index: h,
						name: ""
					});
					var f = this.$cX("label", {
						"for": this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: "CanvasXpressCheckboxLabel",
						innerHTML: p[h]
					});
					j.appendChild(n);
					j.appendChild(f);
					e.appendChild(j)
				}
			}
		}
	};
	this.addRemoveStringDataFilterListeners = function(c, b) {
		if (c && b) {
			var a = b.parentNode.firstElementChild;
			if (b.firstChild.type == "long") {
				this[c](b, "scroll", this.scrollStringFilter, false)
			}
			this[c](b, "mousedown", this.registerStringFilter, false);
			this[c](b, "mouseup", this.endStringFilter, false);
			this[c](a, "dragstart", this.dragStartDataFilter, false);
			this[c](a, "dragend", this.dragEndDataFilter, false)
		}
	};
	this.scrollStringFilter = function(a) {
		return function(j, c, n) {
			if (!j) {
				j = window.event
			}
			if (!c) {
				c = a.getTargetEvent(j)
			}
			var p = c.firstChild;
			var f = p.firstChild;
			var g = p.skey;
			var m = Math.max(0, Math.min(Math.floor(c.scrollTop / 16), p.fvalues.length - 5));
			f.style.top = c.scrollTop + "px";
			for (var h = 0; h < Math.min(5, p.fvalues.length); h++) {
				var l = a.$(a.target + ":" + g + ":cX-DataFilterItem-" + h);
				if (l) {
					var c = p.fvalues[m + h].length > 30 ? p.fvalues[m + h].substr(0, 30) + " ..." : p.fvalues[m + h];
					l.className = p.selected[m + h] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem";
					l.innerHTML = c;
					l.alt = p.fvalues[m + h];
					l.title = p.fvalues[m + h];
					l.index = m + h
				}
			}
			if (a.filteringStringOn && !n) {
				a.updateSelectStringFilter(false, a.$(a.target + ":" + g + ":cX-DataFilterItem-4"), true)
			}
			return false
		}
	}(this);
	this.registerStringFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (!b.id) {
				b = b.parentNode
			}
			if (!b.id.match(/cX-DataFilterMask/)) {
				if (!b.id.match(/cX-DataFilterDivItem/)) {
					if (b.parentNode.id.match(/cX-DataFilterDivItem/)) {
						a.updateSelectStringFilter(false, b, false, true);
						a.filteringStringOn = b.parentNode
					} else {
						a.$(b.parentNode.id.replace("cX-DataFilterOptions", "cX-DataFilterInput")).value = "";
						a.updateSelectStringFilter(false, b, c.shiftKey, c.ctrlKey);
						a.filteringStringOn = b
					}
				} else {
					a.updateSelectStringFilter(false, b.firstChild, false, true);
					a.filteringStringOn = b
				}
			}
			return false
		}
	}(this);
	this.endStringFilter = function(a) {
		return function(k, d, g) {
			if (!k) {
				k = window.event
			}
			if (!d && a.filteringStringOn && a.filteringStringOn.parentNode) {
				d = a.filteringStringOn.parentNode.parentNode
			}
			if (!d) {
				return
			}
			var t = d.selected;
			var j = d.filter;
			var p = d.uvalue;
			var b = d.ref;
			var n = d.fvalues;
			var c = g ? "like" : "exact";
			var m;
			if (!t[0]) {
				if (!a.toDoFilter[j]) {
					a.toDoFilter[j] = {}
				}
				if (!a.toDoFilter[j][p]) {
					a.toDoFilter[j][p] = {}
				}
				a.toDoFilter[j][p][c] = [];
				for (var h in t) {
					a.toDoFilter[j][p][c].push(n[h])
				}
				if (b != null) {
					a.toDoFilter[j][p]["ref"] = b
				}
			} else {
				if (a.toDoFilter[j] && a.toDoFilter[j][p]) {
					delete(a.toDoFilter[j][p])
				}
			}
			a.filteringStringOn = true;
			a.updateDataFilter();
			a.refreshDataFilters(d.parentNode.parentNode.parentNode, j, p, t[0]);
			a.scrollStringFilter(false, d.parentNode, true);
			a.filteringStringOn = false;
			return false
		}
	}(this);
	this.updateStringFilter = function(b) {
		var a = this.getTargetEvent(b);
		var c = this.filteringStringOn && this.filteringStringOn.id ? this.filteringStringOn.id.replace(/-\d$/, "") : "";
		if (a.id.match(c) && !b.ctrlKey) {
			this.updateSelectStringFilter(false, a, true)
		}
	};
	this.updateSelectStringFilter = function(j, E, B, c) {
		if (j) {
			var D = this.$(j);
			var t = this.$(j.replace("cX-DataFilterInput", "cX-DataFilterScroll"));
			if (D.value) {
				var u = 0;
				var r = t.firstChild;
				var F = r.childNodes[0].index;
				var C = null;
				var k = 0;
				t.selected = {};
				for (var y = 1; y < t.fvalues.length - 1; y++) {
					if (t.fvalues[y].toLowerCase().match(D.value.toLowerCase())) {
						if (!C) {
							C = y;
							k = y * 16
						}
						t.selected[y] = true;
						u++
					}
				}
				if (u + 2 == t.fvalues.length) {
					t.selected = {
						0: true
					};
					C = 0
				}
				if (C != null) {
					t.parentNode.scrollTop = k;
					this.scrollStringFilter(false, t.parentNode)
				}
				this.endStringFilter(false, t, true)
			} else {
				this.resetSelectStringFilter(t);
				this.endStringFilter(false, t)
			}
		} else {
			if (E) {
				var d = E.index;
				var r = E.parentNode;
				var m = false;
				if (!r.id) {
					return false
				}
				while (!r.id.match(/cX-DataFilterOptions/)) {
					r = r.parentNode;
					m = true;
					if (!r.id) {
						return false
					}
				}
				var k = r.parentNode;
				var w = k.last;
				var A = k.selected;
				var g = k.fvalues;
				var F = r.childNodes[0].index;
				var u = 0;
				var a = c && k.selected[d];
				k.selected = {};
				if (!a) {
					k.selected[d] = true
				}
				if (B) {
					if (d > w) {
						for (var y = w; y <= d; y++) {
							k.selected[y] = true;
							if (y) {
								u++
							}
						}
					} else {
						for (var y = d; y <= w; y++) {
							k.selected[y] = true;
							if (y) {
								u++
							}
						}
					}
				} else {
					if (c) {
						if (!a) {
							k.last = d
						}
						if (m && d == 0) {
							for (var y = 0; y < g.length - 1; y++) {
								k.selected[y] = true
							}
						} else {
							for (var y in A) {
								if (y == d && a) {
									continue
								}
								k.selected[y] = true;
								if (y) {
									u++
								}
							}
						}
					} else {
						k.last = d
					}
				}
				if (u > 0) {
					delete(k.selected[0])
				}
				if (!m) {
					delete(k.selected[g.length - 1]);
					for (var y = 0; y < r.childNodes.length; y++) {
						r.childNodes[y].className = k.selected[y + F] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem"
					}
				}
			}
		}
	};
	this.resetSelectStringFilter = function(a) {
		if (a) {
			a.selected = {
				0: true
			};
			var b = a.parentNode;
			b.scrollTop = 0;
			this.scrollStringFilter(false, b)
		}
	};
	this.updateSearchFilters = function(e) {
		var g = this.$(e).parentNode.parentNode;
		if (g) {
			var h = g.childNodes;
			var b = new RegExp(h[0].firstChild.value, "i");
			for (var d = 0; d < h[1].childNodes.length; d++) {
				var a = h[1].childNodes[d].id.split(":");
				if (a[1].match(b)) {
					h[1].childNodes[d].style.display = "block"
				} else {
					h[1].childNodes[d].style.display = "none"
				}
			}
		}
	};
	this.hideDataFilterNoAnimation = function() {
		var a = this.showFadeResizeMoveAnimation;
		this.showFadeResizeMoveAnimation = false;
		this.hideDataFilter();
		this.showFadeResizeMoveAnimation = a;
		return false
	};
	this.hideDataFilter = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataFilter(true);
			return false
		}
	}(this);
	this.dockUndockDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.$(a.target + "-cX-DataFilter");
			if (b) {
				a.moveDataFilter()
			}
			return false
		}
	}(this);
	this.resizeDataFilter = function() {
		this.dataFilterHeight = this.meta.canvas.ctx.canvas.height - this.heigthOffsetDataFilter();
		if (this.activeAccordion) {
			this.activeAccordion.style.height = this.dataFilterHeight + "px"
		}
	};
	this.resetDataFilter = function(a) {
		return function(d, g, b) {
			a.functionCaller = "resetDataFilter";
			if (a.isTransition()) {
				return
			}
			a.resetFilters();
			a.refreshDataFilters(false, false, false, false, true);
			a.toDoFilter = {};
			a.reset();
			if (b) {
				var c = a.$(a.target + "-cX-DataFilter");
				if (c) {
					a.removeGenericDataFilterListenersOrReset();
					c.parentNode.removeChild(c);
					a.addDataFilterDiv()
				}
			} else {
				a.removeGenericDataFilterListenersOrReset(true)
			}
			if (a.isOncoprint) {
				a.sortIndices("onc", "desc")
			}
			if (!g) {
				if (a.isGroupedData) {
					a.groupSamples(a.groupingFactors)
				} else {
					a.draw()
				}
			}
			return false
		}
	}(this);
	this.rebuildDataFilter = function() {
		this.resetDataFilter(false, true, true)
	};
	this.initializeDataFilterEvents = function() {
		this.addDataFilterDiv()
	};
	this.initializeDataFilterEvents()
};
CanvasXpress.prototype.initDataTable = function() {
	this.addDataTableDiv = function(E, F) {
		if (this.$(this.target + "-cX-DataTable")) {
			return
		}
		var p = this;
		var O = function(n, d, b) {
			var o = p.$cX(d == 0 || b == 0 ? "th" : "td", {
				id: p.target + "-cX-DataTableCell." + d + "." + b,
				className: d == 0 || b == 0 ? "CanvasXpressTableCellHead" : "CanvasXpressTableCell"
			}, {
				width: p.colWidth + "px",
				height: p.rowHeight + "px"
			});
			n.appendChild(o)
		};
		if (!F) {
			this.setDataTableDimensions(E)
		}
		var C = 52;
		var f = 46;
		var m = this.dataTableLastX != null ? parseInt(this.dataTableLastX) : this.meta.canvas.ctx.canvas.width * 0.1;
		var k = this.dataTableLastY != null ? parseInt(this.dataTableLastY) : -this.meta.canvas.ctx.canvas.height * 0.9;
		var q = this.dataTableLastWidth || this.dataTableColsWidth + C;
		var G = this.dataTableLastHeight || this.dataTableRowsHeight + f;
		var v = ((this.colWidth + 8) * 3) + 6;
		var M = ((this.rowHeight + 4) * 3) + 8;
		var L = this.$cX("div", {
			id: this.target + "-cX-DataTable",
			className: "CanvasXpressDataTable draggable-container"
		}, {
			top: k + "px",
			left: m + "px",
			width: q + "px",
			height: G + "px",
			minWidth: (v + C) + "px",
			minHeight: (M + f + 20) + "px",
			display: "none",
			marginTop: "3px"
		});
		var l = this.$cX("div", {
			id: this.target + "-cX-DataTableToolbar",
			className: "CanvasXpressDataTableToolbar draggable"
		}, {
			width: q + "px",
			minWidth: (v + C) + "px"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataTableSaveImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.disk,
			alt: "Save data",
			title: "Save data"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataTableTransposeImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.transpose,
			alt: "Transpose data",
			title: "Transpose data"
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataTableNetworkImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: this.networkShowDataTable == "nodes" ? CanvasXpress.images.edges : CanvasXpress.images.nodes,
			alt: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data",
			title: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data"
		}, {
			display: this.graphType == "Network" ? "block" : "none"
		});
		var x = this.$cX("img", {
			id: this.target + "-cX-DataTableDockImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: this.dataTableLastState && this.dataTableLastState == "docked" ? CanvasXpress.images.unpin : CanvasXpress.images.pin,
			alt: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock",
			title: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock"
		});
		var D = this.$cX("img", {
			id: this.target + "-cX-DataTableCloseImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.cancel1,
			alt: "Close table",
			title: "Close table"
		});
		var H = this.$cX("div", {
			id: this.target + "-cX-DataTableContainer",
			className: "CanvasXpressDataTableContainer"
		}, {
			width: q + "px",
			height: (G - 20) + "px",
			minWidth: (v + C) + "px",
			minHeight: (M + f) + "px"
		});
		var a = this.$cX("div", {
			id: this.target + "-cX-DataTableTableMask",
			className: "CanvasXpressDataTableMask"
		}, {
			width: (q - C) + "px",
			height: (G - f) + "px",
			minWidth: v + "px",
			minHeight: (M + 20) + "px"
		});
		var A = this.$cX("table", {
			id: this.target + "-cX-DataTableTable",
			className: "CanvasXpressDataTable"
		});
		var N = this.$cX("tbody");
		for (var J = 0; J < this.maxRows; J++) {
			var B = this.$cX("tr");
			for (var I = 0; I < this.maxCols; I++) {
				O(B, J, I)
			}
			N.appendChild(B)
		}
		var z = this.$cX("div", {
			id: this.target + "-cX-DataTableVer",
			className: "CanvasXpressDataTableVertical"
		}, {
			height: (G - f) + "px",
			minHeight: (M + 20) + "px"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataTableVerImage",
			src: CanvasXpress.images.canvasXpress,
			width: 1,
			height: this.dataTableTotalHeight
		}, {
			maxHeight: this.dataTableTotalHeight + "px"
		});
		z.appendChild(e);
		var K = this.$cX("div", {
			id: this.target + "-cX-DataTableHor",
			className: "CanvasXpressDataTableHorizontal"
		}, {
			width: (q - C) + "px",
			minWidth: v + "px"
		});
		var y = this.$cX("img", {
			id: this.target + "-cX-DataTableHorImage",
			src: CanvasXpress.images.canvasXpress,
			width: this.dataTableTotalWidth,
			height: 1
		}, {
			maxWidth: this.dataTableTotalWidth + "px"
		});
		K.appendChild(y);
		var s = this.$cX("div", {
			id: this.target + "-cX-DataTableResizer",
			className: "CanvasXpressDataTableResizer resizable"
		});
		l.appendChild(D);
		l.appendChild(x);
		l.appendChild(c);
		l.appendChild(h);
		l.appendChild(g);
		A.appendChild(N);
		a.appendChild(A);
		H.appendChild(a);
		H.appendChild(z);
		H.appendChild(K);
		H.appendChild(s);
		L.appendChild(l);
		L.appendChild(H);
		var u = this.$("south-wrapper-" + this.target);
		if (u) {
			u.appendChild(L);
			this.addRemoveDataTableListeners("addEvtListener")
		}
	};
	this.addRemoveDataTableListeners = function(a, f) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableHor"), "scroll", this.scrollTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableVer"), "scroll", this.scrollTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableToolbar"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableSaveImage"), "click", this.saveTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableNetworkImage"), "click", this.networkUpdateTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableTransposeImage"), "click", this.transposeDataTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableDockImage"), "click", this.dockUndockTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCloseImage"), "click", this.hideTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableResizer"), "mousedown", this.mousedownDataTableResizer, false);
		var e = f ? f[0] : this.maxRows;
		var g = f ? f[1] : this.maxCols;
		for (var d = 0; d < g; d++) {
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "click", this.clickDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousemove", this.mousemoveDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousedown", this.mousedownDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseover", this.mouseoverDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseout", this.mouseoutDataTableHeader, false)
		}
		for (var d = 0; d < e; d++) {
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseover", this.mouseoverDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseout", this.mouseoutDataTableHeader, false)
		}
		for (var d = 1; d < e; d++) {
			for (var b = 1; b < g; b++) {
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseover", this.mouseoverDataTableCell, false);
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseout", this.mouseoutDataTableCell, false);
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "click", this.clickDataTableCell, false)
			}
		}
	};
	this.scrollTable = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.removeMenus();
			var j = a.$(a.target + "-cX-DataTable");
			var b = a.$(a.target + "-cX-DataTableVer");
			var f = a.$(a.target + "-cX-DataTableHor");
			if (j && b && f && !a.resizingDataTableOn) {
				var i = Math.ceil(f.scrollLeft / (f.scrollWidth / a.totalCols));
				var c = Math.ceil(b.scrollTop / (b.scrollHeight / a.totalRows));
				a.dataTableLastScrollLeft = f.scrollLeft;
				a.dataTableLastScrollTop = b.scrollTop;
				a.dataTableLastScrollWidth = f.scrollWidth;
				a.dataTableLastScrollHeight = b.scrollHeight;
				if (i != a.startCol || c != a.startRow) {
					a.startCol = i;
					a.startRow = c;
					a.updateDataTable(false, false, false, true)
				}
			}
			return false
		}
	}(this);
	this.saveTable = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.removeMenus();
			var b = a.maxCols;
			var f = a.maxRows;
			var c = a.startCol;
			var i = a.startRow;
			a.maxCols = a.totalCols;
			a.maxRows = a.totalRows;
			a.startCol = 0;
			a.startRow = 0;
			var h = a.updateDataTable(false, false, true);
			a.exportToExcel(h);
			a.maxCols = b;
			a.maxRows = f;
			a.startCol = c;
			a.startRow = i;
			return false
		}
	}(this);
	this.dockUndockTable = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			var c = a.dataTableLastState && a.dataTableLastState == "docked" ? "undock" : "dock";
			var b = a.getTargetEvent(d);
			if (c == "dock") {
				b.src = CanvasXpress.images.unpin;
				b.alt = "Undock";
				b.title = "Undock"
			} else {
				b.src = CanvasXpress.images.pin;
				b.alt = "Dock";
				b.title = "Dock"
			}
			a.moveDataTableDiv(c);
			return false
		}
	}(this);
	this.transposeDataTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			a.startRow = 0;
			a.startCol = 0;
			a.dataTableTransposed = a.dataTableTransposed ? false : true;
			a.sortDataTableHead = false;
			a.updateDataTable(false, true, false, false, true);
			a.resizeDataTable();
			return false
		}
	}(this);
	this.minimizeTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataTableDiv("min");
			return false
		}
	}(this);
	this.maximizeTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataTableDiv("max");
			return false
		}
	}(this);
	this.hideTableNoAnimation = function() {
		var a = this.showFadeResizeMoveAnimation;
		this.showFadeResizeMoveAnimation = false;
		this.hideTable();
		this.showFadeResizeMoveAnimation = a;
		return false
	};
	this.hideTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			var c = a.$(a.target + "-cX-DataTable");
			if (c) {
				a.showDataTable = false;
				a.moveDataTableDiv("hide");
				setTimeout(function() {
					a.hideUnhideDataTable(true);
					a.resetFade(c);
					a.resetDataTable(true)
				}, 500)
			}
			return false
		}
	}(this);
	this.networkUpdateTable = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			a.removeMenus();
			var b = a.getTargetEvent(c);
			a.networkShowDataTable = a.networkShowDataTable == "nodes" ? "edges" : "nodes";
			a.updateDataTable(false, true, false, true);
			return false
		}
	}(this);
	this.mousedownDataTableResizer = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			var b = d.target || d.srcElement;
			if (a.hasClass(b, "resizable")) {
				var f = a.$(a.target + "-cX-DataTable");
				if (f) {
					a.dataTableTarget = f;
					a.xMouseDown = d.clientX;
					a.yMouseDown = d.clientY;
					a.dataTableWidth = parseInt(a.dataTableTarget.style.width);
					a.dataTableHeight = parseInt(a.dataTableTarget.style.height);
					a.resizingDataTableOn = true
				}
			}
			return false
		}
	}(this);
	this.mousemoveDataTableHeader = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var c = a.resizingDataTableColumnOn ? a.dataTableColumnTarget : a.getTargetEvent(j);
			var n = a.adjustedCoordinates(j, c);
			var l = a.$(a.target + "-cX-DataTableHorImage");
			if (n && l) {
				if (a.resizingDataTableColumnOn) {
					var b = a.dataTableColumnTarget.id.split(".");
					var g = parseInt(b[2]);
					var k = n.x - a.xMouseDown;
					var m = Math.max(a.colWidth, (a.dataTableColumnWidth[a.startCol + g] || a.colWidth) + k);
					a.dataTableColumnTarget.firstChild.style.width = m + "px";
					l.width += k;
					l.style.maxWidth = l.width + "px";
					for (var h = a.startRow; h < a.startRow + a.totalRows; h++) {
						var d = a.$(a.target + "-cX-DataTableCell." + h + "." + g);
						if (d) {
							d.style.width = m + "px";
							d.firstChild.style.width = m + "px"
						}
					}
					a.dataTableColumnWidth[a.startCol + g] = m;
					a.xMouseDown = n.x;
					a.yMouseDown = n.y;
					document.body.style.cursor = "col-resize"
				} else {
					var f = (c.offsetLeft + c.clientWidth) - n.x;
					if (f < 5 && c.nodeName.toLowerCase() == "th") {
						c.style.cursor = "col-resize"
					} else {
						c.style.cursor = a.isResizeDataTable(c, n) ? "col-resize" : "default"
					}
				}
			}
			return false
		}
	}(this);
	this.mousedownDataTableHeader = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			b = b.nodeName.toLowerCase() == "th" || !a.isIE ? b : b.parentNode;
			var c = a.adjustedCoordinates(d, b);
			if (c) {
				if (a.isResizeDataTable(b, c)) {
					a.dataTableColumnTarget = b;
					a.xMouseDown = c.x;
					a.yMouseDown = c.y;
					a.resizingDataTableColumnOn = true;
					document.body.style.cursor = "col-resize"
				}
			}
			return false
		}
	}(this);
	this.isResizeDataTable = function(a, b) {
		return (a.offsetLeft + a.offsetWidth) - b.x < (this.meta.system.isIE ? 10 : 5) && (a.nodeName.toLowerCase() == "th" || (this.meta.system.isIE && a.parentNode && a.parentNode.nodeName.toLowerCase() == "th"))
	};
	this.getColumnsDataTableHeaderMenu = function() {
		var a = this.maxCols;
		var g = this.maxRows;
		var e = this.startCol;
		var j = this.startRow;
		var b = this.dataTableColumnHide;
		this.maxCols = this.totalCols;
		this.maxRows = 0;
		this.startCol = 0;
		this.startRow = 0;
		this.dataTableColumnHide = {};
		var h = this.updateDataTable(false, false, true);
		this.maxCols = a;
		this.maxRows = g;
		this.startCol = e;
		this.startRow = j;
		this.dataTableColumnHide = b;
		var k = [];
		for (var f = 1; f < h[0].length; f++) {
			k.push([h[0][f], this.dataTableColumnHide[h[0][f]] ? "unchecked" : "checked", "hideUnhideDataTableColumn", [h[0][f]]])
		}
		return k
	};
	this.clickDataTableHeader = function(a) {
		return function(l, f) {
			if (!l) {
				l = window.event
			}
			if (a.noSorting) {
				return
			}
			if (!f) {
				a.cancelEvent(l);
				f = a.getTargetEvent(l)
			}
			var b = a.target + "-cX-DataTableCell.0.0";
			if (f.tagName.match(/th/i)) {
				f = f.firstChild
			}
			if (f.tagName.match(/^a$/i)) {
				if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
					a.removeMenus();
					return false
				}
				var o = a.maxCols;
				var w = a.maxRows;
				var j = a.startCol;
				var q = a.startRow;
				var u = a.dataTableColumnHide;
				a.maxCols = a.totalCols;
				a.maxRows = 0;
				a.startCol = 0;
				a.startRow = 0;
				a.dataTableColumnHide = {};
				var n = a.updateDataTable(false, false, true);
				a.maxCols = o;
				a.maxRows = w;
				a.startCol = j;
				a.startRow = q;
				a.dataTableColumnHide = u;
				var p = [];
				for (var k = 1; k < n[0].length; k++) {
					p.push([n[0][k], a.dataTableColumnHide[n[0][k]] ? "unchecked" : "checked", "hideUnhideDataTableColumn", [n[0][k]]])
				}
				var h = [];
				h.push(["Sort Ascending", "sortAsciiAsc", "sortDataTableByColumn", ["asc", f.parentNode]]);
				h.push(["Sort Descending", "sortAsciiDesc", "sortDataTableByColumn", ["desc", f.parentNode]]);
				h.push(["-"]);
				h.push(["Columns", "table", false, false, false, "getColumnsDataTableHeaderMenu", []]);
				var g = a.absoluteCoordinates(f);
				var r = a.absoluteCoordinates(a.$(a.target + "-cX-DataTable"));
				var t = a.absoluteCoordinates(a.$(a.target));
				a.addMenu(l, false, false, h, (g.x - r.x) + (r.x - t.x), g.y - (t.y - 18), this);
				a.skipHeaderMouseout = this
			} else {
				if (f.className == "CanvasXpressTableCellSortDesc") {
					f.className = "CanvasXpressTableCellSortAsc"
				} else {
					f.className = "CanvasXpressTableCellSortDesc"
				}
				if (a.sortDataTableHead) {
					if (a.sortDataTableHead.id != f.id) {
						var v = a.$(a.sortDataTableHead.id);
						if (v) {
							if (f.parentNode.id == b) {
								a.sortDataTableHead.id = a.target + "-cX-DataTableCellContent.0.0"
							}
							v.className = "CanvasXpressTableCell"
						}
					}
				}
				a.removeMenus();
				a.sortDataTableHead = f;
				a.sortDataTable()
			}
			return false
		}
	}(this);
	this.mouseoverDataTableHeader = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCellHeadActive";
			this.firstChild.firstChild.className = "CanvasXpressTableCellHeadActive";
			return false
		}
	}(this);
	this.mouseoutDataTableHeader = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
				return false
			} else {
				this.className = "CanvasXpressTableCellHead";
				this.firstChild.firstChild.className = "CanvasXpressTableCellHead"
			}
			return false
		}
	}(this);
	this.mouseoverDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCellActive";
			return false
		}
	}(this);
	this.mouseoutDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCell";
			return false
		}
	}(this);
	this.clickDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			return false
		}
	}(this);
	this.hideUnhideDataTableColumn = function(a) {
		if (this.dataTableColumnHide[a]) {
			delete(this.dataTableColumnHide[a])
		} else {
			this.dataTableColumnHide[a] = true
		}
		this.updateDataTable(false, false, false, true)
	};
	this.sortDataTableByColumn = function(b, a) {
		if (b == "asc") {
			a.className = "CanvasXpressTableCellSortDesc"
		} else {
			a.className = "CanvasXpressTableCellSortAsc"
		}
		this.sortDataTableHead = a;
		this.clickDataTableHeader(false, a)
	};
	this.setDataTableDimensions = function(d, k) {
		var b = 0;
		var p = 0;
		var e = 0;
		var l = false;
		var j = function() {
			for (var a = 0; a < d.w.grps.length; a++) {
				e += d.w.grps[a].length
			}
			return e
		};
		if (!d) {
			d = this.data
		}
		if (!this.dataTableColumnHide) {
			this.dataTableColumnHide = {}
		}
		var s = 0;
		if (d.x) {
			for (var h in d.x) {
				if (!this.dataTableColumnHide[h]) {
					s++
				}
			}
		}
		var m = 0;
		if (d.z) {
			for (var h in d.z) {
				if (!this.dataTableColumnHide[h]) {
					m++
				}
			}
		}
		var w = this.getDataTableDimensions();
		if (w[0] != this.maxRows || w[1] != this.maxCols) {
			this.initialMaxRows = this.maxRows;
			this.initialMaxCols = this.maxCols
		}
		if (this.graphType == "Network") {
			var q = this.getAllNetworkAttributes(d);
			b = this.dataTableTransposed ? 1 + d[this.networkShowDataTable].length : 1 + q[1];
			p = this.dataTableTransposed ? 1 + q[1] : 1 + d[this.networkShowDataTable].length
		} else {
			if (this.graphType == "Genome") {
				b = 1;
				p = 1
			} else {
				if (this.graphType == "Venn") {
					var u = this.getVennCompartments(d);
					b = this.dataTableTransposed ? 1 + u[1] : 2;
					p = this.dataTableTransposed ? 2 : 1 + u[1]
				} else {
					if (this.graphType == "Correlation") {
						b = this.correlationAxis == "samples" ? 1 + d.y.smps.length : 1 + d.y.vars.length;
						p = b
					} else {
						if (this.graphType == "Candlestick") {
							if (d.y) {
								b = this.dataTableTransposed ? 1 + (d.y.smps.length * d.y.vars.length) : 6;
								p = this.dataTableTransposed ? 6 : 1 + (d.y.smps.length * d.y.vars.length)
							} else {
								if (d.market) {
									b = this.dataTableTransposed ? 1 + (d.market.smps.length * d.market.vars.length) : 6;
									p = this.dataTableTransposed ? 6 : 1 + (d.market.smps.length * d.market.vars.length)
								}
							}
						} else {
							if (d.y && d.y.vars && d.y.smps) {
								b = this.dataTableTransposed ? 1 + m + d.y.smps.length : 1 + s + d.y.vars.length;
								p = this.dataTableTransposed ? 1 + s + d.y.vars.length : 1 + m + d.y.smps.length
							} else {
								if (d.w && d.w.vars && d.w.grps) {
									e = j();
									b = this.dataTableTransposed ? 1 + m + e : 1 + s + d.w.vars.length;
									p = this.dataTableTransposed ? 1 + s + d.w.vars.length : 1 + m + e
								}
							}
						}
					}
				}
			}
		}
		if (this.maxRows > b) {
			this.initialMaxRows = this.maxRows;
			this.maxRows = b
		}
		if (this.maxCols > p) {
			this.initialMaxCols = this.maxCols;
			this.maxCols = p
		}
		if (this.totalRows == null || this.totalCols == null) {
			this.totalRows = b;
			this.totalCols = p
		} else {
			if (k || b != this.totalRows || p != this.totalCols || w[0] != this.maxRows || w[1] != this.maxCols || w[2] != this.rowHeight || w[3] != this.colWidth) {
				this.totalRows = b;
				this.totalCols = p;
				l = true
			} else {
				this.totalRows = b;
				this.totalCols = p;
				if (this.showDataTable) {
					this.hideUnhideDataTable()
				}
			}
		}
		this.dataTableTotalHeight = this.rowHeight / 2;
		for (var h = 0; h < this.totalRows; h++) {
			this.dataTableTotalHeight += (this.setDataTableRowHeight(h) + 8)
		}
		this.dataTableRowsHeight = this.rowHeight / 2;
		for (var h = this.startRow; h < this.startRow + this.maxRows; h++) {
			this.dataTableRowsHeight += (this.setDataTableRowHeight(h) + 8)
		}
		this.dataTableTotalWidth = -this.colWidth;
		for (var h = 0; h < this.totalCols; h++) {
			this.dataTableTotalWidth += (this.setDataTableColumnWidth(h) + 12)
		}
		this.dataTableColsWidth = this.dataTableTotalWidth;
		if (l) {
			this.resetDataTable(true, w)
		}
	};
	this.setDataTableColumnWidth = function(b, a) {
		if (!this.dataTableColumnWidth[b]) {
			this.dataTableColumnWidth[b] = this.colWidth
		} else {
			if (a) {
				this.dataTableColumnWidth[b] = Math.max(a, this.colWidth)
			}
		}
		return this.dataTableColumnWidth[b]
	};
	this.setDataTableRowHeight = function(a, b) {
		if (!this.dataTableRowHeight[a]) {
			this.dataTableRowHeight[a] = this.rowHeight
		} else {
			if (b) {
				this.dataTableRowHeight[a] = Math.max(b, this.rowHeight)
			}
		}
		return this.dataTableRowHeight[a]
	};
	this.getAllNetworkAttributes = function(c) {
		var b = this.getNetworkData(this.networkShowDataTable, true);
		var d = this.getKeys(b).length;
		return [b, d]
	};
	this.getVennCompartments = function(c) {
		var b = {};
		var d = 0;
		if (c.venn && c.venn.data) {
			for (var a in c.venn.data) {
				b[a] = 1;
				d++
			}
		}
		return [b, d]
	};
	this.getDataTableDimensions = function() {
		var f = 0;
		var i = 0;
		var e = 0;
		var b = 0;
		var d = this.$(this.target + "-cX-DataTableTable");
		var g = this.$(this.target + "-cX-DataTableCell.0.0");
		if (d) {
			var a = d.childNodes[0].rows;
			if (a) {
				f = a.length;
				i = a[0].cells.length;
				e = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.height) : 0;
				b = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.width) : 0
			}
		}
		return [f, i, e, b]
	};
	this.resetDataTable = function(b, a) {
		this.addRemoveDataTableListeners("removeEvtListener", a);
		this.removeTarget(this.target + "-cX-DataTable");
		this.addDataTableDiv(false, b)
	};
	this.rebuildDataTable = function(b, a) {
		this.resetDataTable()
	};
	this.hideUnhideDataTable = function(a) {
		if (this.initialMaxRows) {
			this.maxRows = this.initialMaxRows
		}
		if (this.initialMaxCols) {
			this.maxCols = this.initialMaxCols
		}
		var b = this.$(this.target + "-cX-DataTable");
		if (b) {
			if (a == true) {
				b.style.display = "none"
			} else {
				b.style.display = "block"
			}
		}
	};
	this.resizeDataTable = function() {
		var g = this.$(this.target + "-cX-DataTableContainer");
		var d = this.$(this.target + "-cX-DataTableVer");
		var f = this.$(this.target + "-cX-DataTableHor");
		if (g && d && f) {
			var b = 0;
			this.maxCols = 0;
			for (var e = this.startCol; e < this.totalCols; e++) {
				b += this.dataTableColumnWidth[e] + 8;
				if (parseInt(g.style.width) < b) {
					this.maxCols++;
					break
				} else {
					this.maxCols++
				}
			}
			if (b < parseInt(g.style.width) && this.startCol > 0) {
				for (var e = this.startCol; e >= 0; e--) {
					if (b + this.dataTableColumnWidth[e] + 8 < parseInt(g.style.width)) {
						b += this.dataTableColumnWidth[e] + 8;
						this.maxCols++;
						this.startCol--
					} else {
						break
					}
				}
			}
			if (parseInt(g.style.width) > this.dataTableTotalWidth) {
				this.maxCols = (this.totalCols - this.startCol)
			}
			this.maxCols = Math.max(3, Math.min(this.maxCols, (this.totalCols - this.startCol)));
			var a = 0;
			this.maxRows = 0;
			for (var e = this.startRow; e < this.totalRows; e++) {
				a += this.dataTableRowHeight[e] + 4;
				if (parseInt(g.style.height) < a) {
					this.maxRows++;
					break
				} else {
					this.maxRows++
				}
			}
			if (a < parseInt(g.style.height) && this.startRow > 0) {
				for (var e = this.startRow; e >= 0; e--) {
					if (a + this.dataTableRowHeight[e] + 4 < parseInt(g.style.height)) {
						a += this.dataTableRowHeight[e] + 4;
						this.maxRows++;
						this.startRow--
					} else {
						break
					}
				}
			}
			if (parseInt(g.style.height) > this.dataTableTotalHeight) {
				this.totalRows = (this.totalRows - this.startRow)
			}
			this.maxRows = Math.max(3, Math.min(this.maxRows, (this.totalRows - this.startRow)));
			this.updateDataTable(false, true, false, true);
			d = this.$(this.target + "-cX-DataTableVer");
			f = this.$(this.target + "-cX-DataTableHor");
			if (d && f) {
				if (!this.meta.system.isIE) {
					d.scrollHeight = this.dataTableLastScrollHeight
				}
				d.scrollTop = this.dataTableLastScrollTop ? this.dataTableLastScrollTop : d.scrollTop;
				if (!this.meta.system.isIE) {
					f.scrollWidth = this.dataTableLastScrollWidth
				}
				f.scrollLeft = this.dataTableLastScrollLeft ? this.dataTableLastScrollLeft : f.scrollLeft
			}
			if (this.dataTableLastState == "docked") {
				this.resizeViewportSouth(true)
			}
		}
	};
	this.sortDataTable = function() {
		this.sortDir = this.sortDataTableHead.className == "CanvasXpressTableCellSortDesc" ? "descending" : "ascending";
		var a = this.sortDataTableHead.innerText ? this.sortDataTableHead.innerText : this.sortDataTableHead.textContent;
		if (this.graphType == "Network") {
			if (this.dataTableTransposed) {
				if (this.sortDataTableHead.type == "cxb") {
					this.sortDataTableHead.className = "CanvasXpressTableCell";
					this.sortDataTableHead = false;
					return
				} else {
					this.sortNetworkIndices(a)
				}
			} else {
				this.sortDataTableHead.className = "CanvasXpressTableCell";
				this.sortDataTableHead = false;
				return
			}
		} else {
			if (this.graphType == "Genome") {
				this.sortDataTableHead.className = "CanvasXpressTableCell";
				this.sortDataTableHead = false;
				return
			} else {
				if (this.graphType == "Venn") {
					this.sortDataTableHead.className = "CanvasXpressTableCell";
					this.sortDataTableHead = false;
					return
				} else {
					if (this.graphType == "Correlation") {
						if (this.correlationAxis == "samples") {
							if (this.sortDataTableHead.type == "cxb") {
								this.sortSamples()
							} else {
								this.sortSamples(false, false, a, "cor", true);
								this.sortDataTableHead.className = "CanvasXpressTableCell";
								this.sortDataTableHead = false
							}
						} else {
							if (this.sortDataTableHead.type == "cxb") {
								this.sortVariables()
							} else {
								this.sortVariables(false, false, a, "cor", true);
								this.sortDataTableHead.className = "CanvasXpressTableCell";
								this.sortDataTableHead = false
							}
						}
					} else {
						if (this.graphType == "Candlestick") {
							this.sortDataTableHead.className = "CanvasXpressTableCell";
							this.sortDataTableHead = false;
							return
						} else {
							if (this.data.y.vars && this.data.y.smps) {
								if (this.dataTableTransposed) {
									if (this.sortDataTableHead.type == "cxx") {
										this.sortSamplesByCategory([a])
									} else {
										if (this.sortDataTableHead.type == "cxv") {
											this.sortSamplesByVariable(a)
										} else {
											if (this.sortDataTableHead.type == "cxb") {
												this.sortSamples()
											}
										}
									}
								} else {
									if (this.sortDataTableHead.type == "cxz") {
										this.sortVariablesByCategory([a])
									} else {
										if (this.sortDataTableHead.type == "cxs") {
											this.sortVariablesBySample(a)
										} else {
											if (this.sortDataTableHead.type == "cxb") {
												this.sortVariables()
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		this.updateDataTable(false, true, false, false, true)
	};
	this.getDataClassAsArray = function(A, b, M, E, B, e) {
		var m = 0;
		var h = 0;
		var z = 0;
		var t = 0;
		var J = [];
		var K = [];
		var x = [];
		var w = [];
		var f = function(r, s, d, N) {
			if (s.hasOwnProperty(r)) {
				return s[r] != null ? s[r] : ""
			} else {
				if (d[0][r] && d[0][r].hasOwnProperty("r")) {
					var v = d[0][r]["r"];
					for (var l = 0; l < N[v].length; l++) {
						var k = N[v][l];
						if (s.hasOwnProperty(k)) {
							s = s[k]
						} else {
							return ""
						}
					}
					if (s.hasOwnProperty(r)) {
						return s[r] != null ? s[r] : ""
					}
				}
				return ""
			}
		};
		if (b == null) {
			b = 0
		}
		if (M == null) {
			M = 999
		}
		if (E == null) {
			E = 0
		}
		if (B == null) {
			B = 999
		}
		if (this.graphType == "Network") {
			var L = this.getAllNetworkAttributes(A);
			x.push("");
			w.push("cxb");
			if (this.dataTableTransposed) {
				for (var G in L[0]) {
					if (h < M && t >= b && !this.dataTableColumnHide[G]) {
						x.push(G);
						w.push("cxx");
						h++
					}
					t++
				}
				J.push(x);
				K.push(w);
				for (var G = 0; G < A[this.networkShowDataTable].length; G++) {
					if (m < B && z >= E) {
						h = 0;
						t = 0;
						x = [G + 1];
						w = ["cxz"];
						for (var F in L[0]) {
							if (h < M && t >= b && !this.dataTableColumnHide[F]) {
								var q = f(F, A[this.networkShowDataTable][G], L, this[this.networkShowDataTable + "Properties"]);
								x.push(q);
								w.push("cxy");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						m++
					}
					z++
				}
			} else {
				for (var G = 0; G < A[this.networkShowDataTable].length; G++) {
					if (h < M && t >= b && !this.dataTableColumnHide[G + 1]) {
						x.push(G + 1);
						w.push("cxz");
						h++
					}
					t++
				}
				J.push(x);
				K.push(w);
				for (var G in L[0]) {
					if (m < B && z >= E) {
						h = 0;
						t = 0;
						x = [G];
						w = ["cxx"];
						for (var F = 0; F < A[this.networkShowDataTable].length; F++) {
							if (h < M && t >= b && !this.dataTableColumnHide[G + 1]) {
								var q = f(G, A[this.networkShowDataTable][F], L, this[this.networkShowDataTable + "Properties"]);
								x.push(q);
								w.push("cxy");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						m++
					}
					z++
				}
			}
		} else {
			if (this.graphType == "Genome") {
				J = [
					["Not implemented"]
				];
				K = [
					["cxb"]
				]
			} else {
				if (this.graphType == "Venn") {
					var q = this.getVennCompartments(A);
					x.push("");
					w.push("cxb");
					if (this.dataTableTransposed) {
						x.push("No");
						w.push("cxz");
						J.push(x);
						K.push(w);
						for (var G in q[0]) {
							if (m < B && z >= E) {
								h = 0;
								t = 0;
								x = [G];
								w = ["cxx"];
								if (h < M && t >= b) {
									x.push(A.venn.data[G]);
									w.push("cxy");
									h++
								}
								t++;
								J.push(x);
								K.push(w);
								m++
							}
							z++
						}
					} else {
						for (var G in q[0]) {
							if (h < M && t >= b) {
								x.push(G);
								w.push("cxx");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						if (m < B && z >= E) {
							h = 0;
							t = 0;
							x = ["No"];
							w = ["cxz"];
							for (var G in q[0]) {
								if (h < M && t >= b) {
									x.push(A.venn.data[G]);
									w.push("cxy");
									h++
								}
								t++
							}
							J.push(x);
							K.push(w)
						}
					}
				} else {
					if (this.graphType == "Correlation") {
						var p = this.correlationAxis == "samples" ? A.y.smps : A.y.vars;
						var g = this.correlationAxis == "samples" ? this.smpIndices : this.varIndices;
						var n = this.correlationAxis == "samples" ? "cxs" : "cxv";
						x.push("");
						w.push("cxb");
						for (var G = 0; G < p.length; G++) {
							if (h < M && t >= b && !this.dataTableColumnHide[e ? p[g[G]] : p[G]]) {
								x.push(e ? p[g[G]] : p[G]);
								w.push(n);
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						for (var G = 0; G < p.length; G++) {
							if (m < B && z >= E) {
								h = 0;
								t = 0;
								x = [e ? p[g[G]] : p[G]];
								w = [n];
								for (var F = 0; F < p.length; F++) {
									if (h < M && t >= b && !this.dataTableColumnHide[e ? p[g[F]] : p[F]]) {
										if (A.y.cor) {
											x.push(e ? A.y.cor[g[G]][g[F]] : A.y.cor[G][F])
										} else {
											x.push(G == F ? 1 : A.y.data)
										}
										w.push("cxy");
										h++
									}
									t++
								}
								J.push(x);
								K.push(w);
								m++
							}
							z++
						}
					} else {
						if (this.graphType == "Candlestick") {
							var L = ["open", "low", "high", "close", "volume"];
							x.push("");
							w.push("cxb");
							if (this.dataTableTransposed) {
								for (var G = 0; G < A.y.vars.length; G++) {
									for (var F = 0; F < L.length; F++) {
										var C = A.y.vars.length > 1 ? A.y.vars[G] + ":" + L[F] : L[F];
										if (h < M && t >= b && !this.dataTableColumnHide[C]) {
											x.push(C);
											w.push("cxv");
											h++
										}
										t++
									}
								}
								J.push(x);
								K.push(w);
								for (var G = 0; G < A.y.smps.length; G++) {
									if (m < B && z >= E) {
										h = 0;
										t = 0;
										x = [A.y.smps[G]];
										w = ["cxs"];
										for (var F = 0; F < A.y.vars.length; F++) {
											for (var D = 0; D < L.length; D++) {
												var C = A.y.vars.length > 1 ? A.y.vars[F] + ":" + L[D] : L[D];
												if (h < M && t >= b && !this.dataTableColumnHide[C]) {
													x.push(A.y[L[D]][F][G] != null ? A.y[L[D]][F][G] : A.y[L[D]][G]);
													w.push("cxy");
													h++
												}
												t++
											}
										}
										J.push(x);
										K.push(w);
										m++
									}
									z++
								}
							} else {
								for (var G = 0; G < A.y.smps.length; G++) {
									if (h < M && t >= b && !this.dataTableColumnHide[A.y.smps[G]]) {
										x.push(A.y.smps[G]);
										w.push("cxs");
										h++
									}
									t++
								}
								J.push(x);
								K.push(w);
								for (var G = 0; G < A.y.vars.length; G++) {
									for (var F = 0; F < L.length; F++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											var C = A.y.vars.length > 1 ? A.y.vars[G] + ":" + L[F] : L[F];
											x = [C];
											w = ["cxv"];
											for (var D = 0; D < A.y.smps.length; D++) {
												if (h < M && t >= b && !this.dataTableColumnHide[A.y.smps[D]]) {
													x.push(A.y[L[F]][G][D] != null ? A.y[L[F]][G][D] : A.y[L[F]][D]);
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								}
							}
						} else {
							if (A.y.vars && A.y.smps) {
								var I = e ? this.varIndices.length : A.y.vars.length;
								var H = e ? this.smpIndices.length : A.y.smps.length;
								var y = A.x ? this.sortObject(A.x) : false;
								var u = A.z ? this.sortObject(A.z) : false;
								x.push("");
								w.push("cxb");
								if (this.dataTableTransposed) {
									if (A.x) {
										for (var G = 0; G < y.length; G++) {
											if (h < M && t >= b && !this.dataTableColumnHide[y[G]]) {
												x.push(y[G]);
												w.push("cxx");
												h++
											}
											t++
										}
									}
									for (var G = 0; G < I; G++) {
										if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[G]] : A.y.vars[G]]) {
											x.push(e ? A.y.vars[this.varIndices[G]] : A.y.vars[G]);
											w.push("cxv");
											h++
										}
										t++
									}
									J.push(x);
									K.push(w);
									if (A.z) {
										for (var G = 0; G < u.length; G++) {
											if (m < B && z >= E) {
												h = 0;
												t = 0;
												x = [u[G]];
												w = ["cxz"];
												if (A.x) {
													for (var F = 0; F < y.length; F++) {
														if (h < M && t >= b && !this.dataTableColumnHide[y[F]]) {
															x.push("");
															w.push("cxb");
															h++
														}
														t++
													}
												}
												for (var F = 0; F < I; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[F]] : A.y.vars[F]]) {
														x.push(e ? A.z[u[G]][this.varIndices[F]] : A.z[u[G]][F]);
														w.push("cxz");
														h++
													}
													t++
												}
												J.push(x);
												K.push(w);
												m++
											}
											z++
										}
									}
									for (var G = 0; G < H; G++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											x = [e ? (G + 1) + ". " + A.y.smps[this.smpIndices[G]] : (G + 1) + ". " + A.y.smps[G]];
											w = ["cxs"];
											if (A.x) {
												for (var F = 0; F < y.length; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[y[F]]) {
														x.push(e ? A.x[y[F]][this.smpIndices[G]] : A.x[y[F]][G]);
														w.push("cxx");
														h++
													}
													t++
												}
											}
											for (var F = 0; F < I; F++) {
												if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[F]] : A.y.vars[F]]) {
													if (e) {
														x.push(A.y.data[this.varIndices[F]][this.smpIndices[G]] != null ? A.y.data[this.varIndices[F]][this.smpIndices[G]] : A.y.data[this.smpIndices[G]])
													} else {
														x.push(A.y.data[F][G] != null ? A.y.data[F][G] : A.y.data[G])
													}
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								} else {
									if (A.z) {
										for (var G = 0; G < u.length; G++) {
											if (h < M && t >= b && !this.dataTableColumnHide[u[G]]) {
												x.push(u[G]);
												w.push("cxz");
												h++
											}
											t++
										}
									}
									for (var G = 0; G < H; G++) {
										if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[G]] : A.y.smps[G]]) {
											x.push(e ? A.y.smps[this.smpIndices[G]] : A.y.smps[G]);
											w.push("cxs");
											h++
										}
										t++
									}
									J.push(x);
									K.push(w);
									if (A.x) {
										for (var G = 0; G < y.length; G++) {
											if (m < B && z >= E) {
												h = 0;
												t = 0;
												x = [y[G]];
												w = ["cxx"];
												if (A.z) {
													for (var F = 0; F < u.length; F++) {
														if (h < M && t >= b && !this.dataTableColumnHide[u[F]]) {
															x.push("");
															w.push("cxb");
															h++
														}
														t++
													}
												}
												for (var F = 0; F < H; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[F]] : A.y.smps[F]]) {
														x.push(e ? A.x[y[G]][this.smpIndices[F]] : A.x[y[G]][F]);
														w.push("cxx");
														h++
													}
													t++
												}
												J.push(x);
												K.push(w);
												m++
											}
											z++
										}
									}
									for (var G = 0; G < I; G++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											x = [e ? (G + 1) + ". " + A.y.vars[this.varIndices[G]] : (G + 1) + ". " + A.y.vars[G]];
											w = ["cxv"];
											if (A.z) {
												for (var F = 0; F < u.length; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[u[F]]) {
														x.push(e ? A.z[u[F]][this.varIndices[G]] : A.z[u[F]][G]);
														w.push("cxz");
														h++
													}
													t++
												}
											}
											for (var F = 0; F < H; F++) {
												if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[F]] : A.y.smps[F]]) {
													if (e) {
														x.push(A.y.data[this.varIndices[G]][this.smpIndices[F]] != null ? A.y.data[this.varIndices[G]][this.smpIndices[F]] : A.y.data[this.smpIndices[F]])
													} else {
														x.push(A.y.data[G][F] != null ? A.y.data[G][F] : A.y.data[F])
													}
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								}
							}
						}
					}
				}
			}
		}
		return [J, K]
	};
	this.updateDataTable = function(g, c, d, h, b) {
		if (this.dataTableLastState && this.dataTableLastState == "docked" && h) {
			this.dataTableLastX = 0;
			this.dataTableLastY = 0
		}
		if (!this.dataTableLastState) {
			this.dataTableLastState = "visible"
		}
		if (!g) {
			g = this.data
		} else {
			g = this.getUngroupedDataObject(g)
		}
		if (!d) {
			this.setDataTableDimensions(g, c)
		}
		var a = this.getDataClassAsArray(g, this.startCol, this.maxCols, this.startRow, this.maxRows, true);
		if (d) {
			return a[0]
		} else {
			this.loadDataTableValues(a[0], a[1], h, b)
		}
	};
	this.loadDataTableValues = function(B, C, u, p) {
		var m = this.$(this.target + "-cX-DataTable");
		if (m) {
			var l = this.startRow;
			for (var x = 0; x < B.length; x++) {
				var y = this.startCol;
				for (var v = 0; v < B[x].length + this.startCol; v++) {
					var r = this.target + "-cX-DataTableCell." + x + "." + v;
					var D = this.target + "-cX-DataTableCellContent." + l + "." + y;
					var g = this.target + "-cX-DataTableCellContentA." + l + "." + y;
					var A = this.$(r);
					if (A) {
						if (A.hasChildNodes()) {
							while (A.childNodes.length >= 1) {
								A.removeChild(A.firstChild)
							}
						}
						var F = B[x][v] != null ? B[x][v] : "";
						var b = C[x][v] != null ? C[x][v] : "";
						if (!isNaN(F) && b == "cxy") {
							F = this.bestFormatNumber(F)
						}
						var f = this.$cX("div", {
							id: D,
							className: "CanvasXpressTableCell ",
							title: F,
							alt: F,
							type: b
						});
						if (x == 0) {
							var E = this.$cX("a", {
								id: g,
								className: "CanvasXpressTableCellHead ",
								href: "#"
							});
							f.appendChild(E)
						}
						f.appendChild(document.createTextNode(F));
						if (x != 0) {
							f.style.height = this.setDataTableRowHeight(l) + "px";
							A.style.height = this.setDataTableRowHeight(l) + "px"
						} else {
							f.style.height = this.setDataTableRowHeight(0) + "px";
							A.style.height = this.setDataTableRowHeight(0) + "px"
						}
						if (v != 0) {
							f.style.width = this.setDataTableColumnWidth(y) + "px";
							A.style.width = this.setDataTableColumnWidth(y) + "px"
						} else {
							f.style.width = this.setDataTableColumnWidth(0) + "px";
							A.style.width = this.setDataTableColumnWidth(0) + "px"
						}
						A.appendChild(f);
						y++
					}
				}
				l++
			}
			if (this.sortDataTableHead) {
				var o = this.$(this.sortDataTableHead.id);
				var h = this.$(this.target + "-cX-DataTableCell.0.0").firstChild;
				var k = this.target + "-cX-DataTableCellContent.0.0";
				if (o) {
					o.className = this.sortDataTableHead.className
				}
				if (h) {
					h.className = this.sortDataTableHead.id == k ? this.sortDataTableHead.className : "CanvasXpressTableCell"
				}
			}
			this.activeTarget = m;
			m.style.display = "block"
		}
	};
	this.moveDataTableDiv = function(e) {
		var n = this.$(this.target + "-cX-DataTable");
		if (n) {
			var p, r, j;
			var a = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
			var g = this.$("north-container-" + this.target);
			var c = this.$("west-container-" + this.target);
			var m = this.$("east-container-" + this.target);
			var o = this.$("south-container-" + this.target);
			var q = this.$("south-wrapper-" + this.target);
			var b = 64;
			var f = 0;
			var i = this.showFadeResizeMoveAnimation ? 500 : 0;
			var k = this;
			if (c && m && o && q) {
				if (e && e == "dock") {
					this.dataTableLastState = "docked";
					this.dataTableLastHeight = n.clientHeight;
					this.dataTableLastX = n.offsetLeft;
					this.dataTableLastY = n.offsetTop;
					r = Math.max(n.clientWidth, parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width) + 2;
					j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height + n.clientHeight + 2;
					if (a) {
						this.resizeMove(a, 0, 0, r + f, j + b)
					}
					this.resizeMove(o, 0, 0, r, n.clientHeight + 2);
					this.resizeMove(q, 0, 0, r, n.clientHeight + 2);
					this.resizeMove(n, 0, 0, n.clientWidth, n.clientHeight)
				} else {
					if (e && e == "hide") {
						delete(this.dataTableLastState);
						delete(this.dataTableLastX);
						delete(this.dataTableLastY);
						r = parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width;
						j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height;
						if (a) {
							this.resizeMove(a, 0, 0, r + f, j + b)
						}
						this.fade(n);
						this.resizeMove(q, 0, 0, r, 0);
						this.resizeMove(o, 0, 0, r, 0)
					} else {
						if (e && (e == "max" || e == "release" || e == "undock")) {
							this.dataTableLastState = "free";
							r = parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width;
							j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height;
							if (a) {
								this.resizeMove(a, 0, 0, r + r, j + b)
							}
							if (e == "max" || e == "undock") {
								this.resizeMove(n, parseInt(this.dataTableLastX), parseInt(this.dataTableLastY), n.clientWidth, parseInt(this.dataTableLastHeight) || (this.dataTableRowsHeight + 42))
							}
							this.resizeMove(q, 0, 0, r, 0);
							this.resizeMove(o, 0, 0, r, 0)
						} else {
							this.dataTableLastX = n.offsetLeft;
							this.dataTableLastY = n.offsetTop;
							return
						}
					}
				}
			}
		}
	};
	this.updateDataTableResizerDiv = function(g, l, k) {
		if (!g) {
			g = window.event
		}
		if (g && (l == null || k == null)) {
			l = Math.abs(this.dataTableWidth) - (this.xMouseDown - g.clientX);
			k = Math.abs(this.dataTableHeight) - (this.yMouseDown - g.clientY)
		}
		if (this.dataTableTarget && this.dataTableTarget.style) {
			var i = this.$(this.target + "-cX-DataTable");
			var j = this.$(this.target + "-cX-DataTableContainer");
			var a = this.$(this.target + "-cX-DataTableTableMask");
			var n = this.$(this.target + "-cX-DataTableVer");
			var b = this.$(this.target + "-cX-DataTableHor");
			var o = this.$(this.target + "-cX-DataTableToolbar");
			var f = 52;
			var p = 46;
			if (i && j && a && n && b && o) {
				this.dataTableTarget.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				j.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				a.style.width = this.meta.system.isIE ? Math.max(0, (l - f)) + "px" : (l - f) + "px";
				b.style.width = this.meta.system.isIE ? Math.max(0, (l - f)) + "px" : (l - f) + "px";
				o.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				this.dataTableTarget.style.height = this.meta.system.isIE ? Math.max(0, k) + "px" : k + "px";
				j.style.height = this.meta.system.isIE ? Math.max(0, (k - 20)) + "px" : (k - 20) + "px";
				a.style.height = this.meta.system.isIE ? Math.max(0, (k - p)) + "px" : (k - p) + "px";
				n.style.height = this.meta.system.isIE ? Math.max(0, (k - p)) + "px" : (k - p) + "px";
				this.dataTableLastWidth = l;
				this.dataTableLastHeight = k
			}
		}
	};
	this.endDataTableResizerDiv = function(a) {
		if (this.dataTableTarget != null) {
			this.resizeDataTable();
			this.xMouseDown = null;
			this.yMouseDown = null;
			this.dataTableWidth = null;
			this.dataTableHeight = null;
			this.dataTableTarget = false;
			this.resizingDataTableOn = false
		}
	};
	this.endDataTableColumnResize = function(a) {
		that = this;
		this.xMouseDown = null;
		this.yMouseDown = null;
		this.resizingDataTableColumnOn = false;
		this.dataTableColumnTarget = false;
		document.body.style.cursor = "default";
		this.noSorting = true;
		setTimeout(function() {
			that.noSorting = false
		}, 200)
	};
	this.initializeDataTableEvents = function() {
		this.addDataTableDiv()
	};
	this.initializeDataTableEvents()
};
CanvasXpress.prototype.initCanvasResizerEvents = function() {
	this.addCanvasResizerDiv = function(a) {
		if (a) {
			if (this.$("canvasXpressCanvasResize")) {
				return
			}
		} else {
			if (this.$(this.target + "canvasXpressCanvasResize")) {
				return
			}
		}
		var b = this.$cX("div", {
			id: a ? "canvasXpressCanvasResize" : this.target + "canvasXpressCanvasResize",
			className: "CanvasXpressCanvasResizer"
		}, {
			left: "0px",
			top: "0px",
			width: "0.5px",
			height: "0.5px",
			position: "absolute",
			display: "none",
			zIndex: 100001
		});
		if (a) {
			b.style.opacity = 0.5;
			b.style.filter = "alpha(opacity = 50)";
			b.style.backgroundColor = this.resizerBackgroundColor
		}
		if (a) {
			document.body.appendChild(b);
			return b
		} else {
			this.meta.canvas.ctx.canvas.parentNode.appendChild(b)
		}
	};
	this.isCanvasResize = function(c) {
		if (this.resizable) {
			if (!c) {
				c = window.event
			}
			var b = this.adjustedCoordinates(c);
			if (b) {
				var a = b.x;
				var d = b.y;
				if (a > this.width - 18 && this.resizableX && d > this.height - 18 && this.resizableY) {
					this.resizeCanvasCursorShow = "se-resize";
					return true
				} else {
					if (a > this.width - 18 && this.resizableX && d > 20) {
						this.resizeCanvasCursorShow = "e-resize";
						return true
					} else {
						if (d > this.height - 18 && this.resizableY) {
							this.resizeCanvasCursorShow = "s-resize";
							return true
						} else {
							this.resizeCanvasCursorShow = false;
							return false
						}
					}
				}
			}
		}
	};
	this.updateCanvasResizerCursor = function(d) {
		if (this.resizable) {
			if (!d) {
				d = window.event
			}
			var b = this.$(this.target2);
			if (b) {
				var c = this.adjustedCoordinates(d);
				if (c) {
					var a = c.x;
					var f = c.y;
					if (a > this.width - 18 && this.resizableX && f > this.height - 18 && this.resizableY) {
						b.style.cursor = "se-resize";
						this.resizeCanvasCursorShow = "se-resize"
					} else {
						if (a > this.width - 18 && this.resizableX && f > 20) {
							b.style.cursor = "e-resize";
							this.resizeCanvasCursorShow = "e-resize"
						} else {
							if (f > this.height - 18 && this.resizableY) {
								b.style.cursor = "s-resize";
								this.resizeCanvasCursorShow = "s-resize"
							} else {
								if (!this.movingOn) {
									b.style.cursor = "default";
									this.resizeCanvasCursorShow = false
								}
							}
						}
					}
				}
			}
		}
	};
	this.updateCanvasResizer = function(f) {
		if (this.resizingCanvasOn && this.resizeCanvasCursorShow) {
			document.body.style.cursor = this.resizeCanvasCursorShow;
			var c = this.$(this.target + "canvasXpressCanvasResize");
			var a = this.$("canvasXpressCanvasResize");
			var b = this.adjustedCoordinates(f);
			var d = this.relativeCoordinates(this.meta.canvas.ctx.canvas);
			if (c && b && d) {
				if (this.resizeCanvasCursorShow == "se-resize") {
					w = b.x;
					h = b.y
				} else {
					if (this.resizeCanvasCursorShow == "e-resize") {
						w = b.x;
						h = this.height
					} else {
						if (this.resizeCanvasCursorShow == "s-resize") {
							w = this.width;
							h = b.y
						}
					}
				}
				if (!a) {
					a = this.addCanvasResizerDiv(true)
				}
				this.preventSelection();
				dx = b.x - this.meta.canvas.ctx.canvas.width;
				dy = b.y - this.meta.canvas.ctx.canvas.height;
				c.style.width = w + "px";
				c.style.height = h + "px";
				c.style.display = "block";
				a.style.left = d.x + "px";
				a.style.top = d.y + "px";
				a.style.width = w + "px";
				a.style.height = h + "px";
				a.style.display = "block";
				CanvasXpress.resizing = true
			}
		}
	};
	this.showMask = function() {
		var a = this.$(this.target + "canvasXpressCanvasResize");
		if (a) {
			a.className = "CanvasXpressCanvasResizer" + this.loadingImage;
			a.style.width = this.meta.canvas.ctx.canvas.width + "px";
			a.style.height = this.meta.canvas.ctx.canvas.height + "px";
			a.style.display = "block"
		}
	};
	this.hideMask = function() {
		var b = this.hexToString("686578546f537472696e67");
		var a = this;
		var c = this.$(this.target + "canvasXpressCanvasResize");
		if (c) {
			c.style.width = "0.5px";
			c.style.height = "0.5px";
			c.style.display = "none"
		}
		setTimeout(function() {
			var d = a.beaconImage.width;
			if (d == 256) {
				a[a[b]("6d657461")][a[b]("666163746f7279")][a[b]("76616c6964")] = 2
			} else {
				if (d == 250) {
					a[a[b]("6d657461")][a[b]("666163746f7279")][a[b]("76616c6964")] = 1
				} else {
					a[a[b]("6d657461")][a[b]("666163746f7279")][a[b]("76616c6964")] = 0
				}
			}
			a.drawCx()
		}, 1000)
	};
	this.endCanvasResizer = function(f) {
		this.functionCaller = "endCanvasResizer";
		if (this.resizingCanvasOn) {
			if (this.isTransition()) {
				return
			}
			var c = this.$(this.target);
			var a = this.$(this.target + "canvasXpressCanvasResize");
			var l = this.$("canvasXpressCanvasResize");
			var b = this.$("west-container-" + this.target);
			var j = this.$("middle-container-" + this.target);
			var d = this.$("east-container-" + this.target);
			if (c && a && l) {
				this.clickLayoutNoAnimation();
				var k = parseInt(a.style.width);
				var g = parseInt(a.style.height);
				j.style.width = (parseInt(b.style.width) + parseInt(a.style.width) + parseInt(d.style.width)) + "px";
				j.style.height = a.style.height;
				this.resetAxesResizer();
				this.draw(k, g);
				this.resizeAcknowledgmentDiv();
				a.style.width = "0.5px";
				a.style.height = "0.5px";
				a.style.display = "none";
				c.style.cursor = "default";
				this.updateRemoteNavigationWindow();
				document.body.removeChild(l);
				this.resizeCanvasCursorShow = false;
				this.resizingCanvasOn = false;
				CanvasXpress.resizing = false
			}
		}
	};
	this.initializeCanvasResizerEvents = function() {
		if (!this.disableEvents) {
			this.addCanvasResizerDiv();
			this.showMask()
		}
	};
	this.initializeCanvasResizerEvents()
};
CanvasXpress.prototype.initAxisResizerEvents = function() {
	this.addAxesResizeDiv = function() {
		if (this.$(this.target + "canvasXpressAxesResize")) {
			return
		}
		var c = ["Previous", "Next", "Current", "Middle", "Min", "Max", "Close"];
		var b = 9001;
		var e = this.$cX("div", {
			id: this.target + "canvasXpressAxesResize"
		}, {
			position: "absolute",
			display: "none",
			zIndex: b
		});
		if (this.resizerTransparency) {
			e.style.opacity = 0.85;
			e.style.filter = "alpha(opacity = 85)"
		}
		for (var a = 0; a < c.length; a++) {
			b++;
			var f = this.$cX("div", {
				id: this.target + "canvasXpressAxesResize" + c[a]
			}, {
				zIndex: b
			});
			if (this.resizerTransparency) {
				f.style.opacity = 0.85;
				f.style.filter = "alpha(opacity = 85)"
			}
			e.appendChild(f)
		}
		this.meta.canvas.ctx.canvas.parentNode.appendChild(e)
	};
	this.clickAxesResizeClose = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.stopEvent(b);
			a.resetAxesResizer(b);
			a.resetFlags(b)
		}
	}(this);
	this.mousemoveActiveAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.activateDeactivateAxesResizer(b)
		}
	}(this);
	this.mousedownAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			a.registerAxesResizer(b);
			return false
		}
	}(this);
	this.mousemoveAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			a.updateAxesResizer(b);
			return false
		}
	}(this);
	this.addRemoveAxesResizerListeners = function(p) {
		var a = this.$(this.target + "canvasXpressAxesResize");
		var d = this.$(this.target + "canvasXpressAxesResizeMin");
		var k = this.$(this.target + "canvasXpressAxesResizeMax");
		var e = this.$(this.target + "canvasXpressAxesResizeMiddle");
		var i = this.$(this.target + "canvasXpressAxesResizeCurrent");
		var g = this.$(this.target + "canvasXpressAxesResizeClose");
		var b = [a, d, k, e, i];
		if (a) {
			this[p](a, "mousemove", this.mousemoveActiveAxesResize, false);
			this[p](a, "mouseout", this.mousemoveActiveAxesResize, false)
		}
		if (g) {
			this[p](g, "click", this.clickAxesResizeClose, false)
		}
		for (var f = 0; f < b.length; f++) {
			if (b[f]) {
				this[p](b[f], "mousedown", this.mousedownAxesResize, false)
			}
		}
	};
	this.showAxesResizer = function(f, e, c, q, o, m, b, g, t, u, n, j, i) {
		if (!this.axesResizerShow) {
			var a = this.$(this.target + "canvasXpressAxesResize");
			var k = this.$(this.target + "canvasXpressAxesResizeClose");
			if (a && k) {
				this.updateResizerEventData(null, null, f, e, c, q, o, m, b, g, t, u, n, j, i);
				this.refreshAxesResizer();
				a.style.display = "block";
				if (this.resizerType && this.layoutValid) {
					k.style.display = "none"
				}
				this.addRemoveAxesResizerListeners("addEvtListener");
				if (this.layoutValid) {
					this.layoutValidR = j;
					this.layoutValidC = i;
					this.layoutValidN = n
				}
				this.axesResizerShow = true
			}
		}
	};
	this.refreshAxesResizer = function() {
		if (this.resizerEventData) {
			var b = this.$(this.target + "canvasXpressAxesResize");
			var e = this.$(this.target + "canvasXpressAxesResizeMin");
			var o = this.$(this.target + "canvasXpressAxesResizeMax");
			var f = this.$(this.target + "canvasXpressAxesResizeMiddle");
			var i = this.$(this.target + "canvasXpressAxesResizeCurrent");
			var g = this.$(this.target + "canvasXpressAxesResizeClose");
			var k = this.$(this.target + "canvasXpressAxesResizePrevious");
			var j = this.$(this.target + "canvasXpressAxesResizeNext");
			if (b && e && o && i && g && k && j) {
				var s = this.resizerEventData.areas.org[1] - this.resizerEventData.areas.org[0];
				var p = this.resizerEventData.areas.org[3] - this.resizerEventData.areas.org[2];
				var d = 14;
				var a = 9;
				var q = parseInt(a / 2);
				if (this.resizerEventData.pos == "h") {
					l = this.resizerEventData.l.match(/^t/) ? "Top" : "Bottom";
					b.key = "CanvasXpressCanvasResizerScrollerEmptyHor" + l;
					b.className = b.key;
					b.style.left = (this.resizerEventData.areas.org[0] - q) + "px";
					b.style.top = this.resizerEventData.areas.org[2] + "px";
					b.style.width = ((s + a) - 1) + "px";
					b.style.height = d + "px";
					b.style.backgroundRepeat = "repeat-x";
					k.key = "CanvasXpressCanvasResizerPrev" + l;
					k.className = k.key;
					k.style.left = "0px";
					k.style.top = "0px";
					k.style.width = a + "px";
					k.style.height = d + "px";
					e.key = "CanvasXpressCanvasResizerHandleLeft" + l;
					e.className = e.key;
					e.style.left = this.resizerEventData.areas.min[0] + "px";
					e.style.top = "0px";
					e.style.width = a + "px";
					e.style.height = d + "px";
					e.style.cursor = "e-resize";
					i.key = "CanvasXpressCanvasResizerScrollerBodyHor" + l;
					i.className = i.key;
					i.style.left = this.resizerEventData.areas.cur[0] + "px";
					i.style.top = "0px";
					i.style.width = this.resizerEventData.areas.cur[1] + "px";
					i.style.height = d + "px";
					i.style.cursor = "move";
					i.style.backgroundRepeat = "repeat-x";
					o.key = "CanvasXpressCanvasResizerHandleRight" + l;
					o.className = o.key;
					o.style.left = this.resizerEventData.areas.max[0] + "px";
					o.style.top = "0px";
					o.style.width = a + "px";
					o.style.height = d + "px";
					o.style.cursor = "e-resize";
					o.style.backgroundRepeat = "no-repeat";
					f.key = "CanvasXpressCanvasResizerScrollerHandleHor" + l;
					f.className = f.key;
					f.style.left = (this.resizerEventData.areas.min[0] + ((this.resizerEventData.areas.cur[1] - 1) / 2)) + "px";
					f.style.top = "0px";
					f.style.width = "8px";
					f.style.height = d + "px";
					f.style.cursor = "move";
					j.key = "CanvasXpressCanvasResizerNext" + l;
					j.className = j.key;
					j.style.left = (s - 1) + "px";
					j.style.top = "0px";
					j.style.width = a + "px";
					j.style.height = d + "px";
					g.key = "CanvasXpressCanvasResizerClose";
					g.className = g.key;
					g.style.left = (s + a) + "px";
					g.style.top = "0px";
					g.style.width = a + "px";
					g.style.height = d + "px"
				} else {
					l = this.resizerEventData.l.match(/^l/) ? "Left" : "Right";
					b.key = "CanvasXpressCanvasResizerScrollerEmptyVer" + l;
					b.className = b.key;
					b.style.left = this.resizerEventData.areas.org[0] + "px";
					b.style.top = (this.resizerEventData.areas.org[2] - q) + "px";
					b.style.width = d + "px";
					b.style.height = (p + a) + "px";
					b.style.backgroundRepeat = "repeat-y";
					k.key = "CanvasXpressCanvasResizerPrev" + l;
					k.className = k.key;
					k.style.left = "0px";
					k.style.top = p + "px";
					k.style.width = d + "px";
					k.style.height = a + "px";
					e.key = "CanvasXpressCanvasResizerHandleBottom" + l;
					e.className = e.key;
					e.style.left = "0px";
					e.style.top = this.resizerEventData.areas.min[2] + "px";
					e.style.width = d + "px";
					e.style.height = a + "px";
					e.style.cursor = "n-resize";
					e.style.backgroundRepeat = "no-repeat";
					i.key = "CanvasXpressCanvasResizerScrollerBodyVer" + l;
					i.className = i.key;
					i.style.left = "0px";
					i.style.top = this.resizerEventData.areas.cur[2] + "px";
					i.style.width = d + "px";
					i.style.height = this.resizerEventData.areas.cur[3] + "px";
					i.style.cursor = "move";
					i.style.backgroundRepeat = "repeat-y";
					o.key = "CanvasXpressCanvasResizerHandleTop" + l;
					o.className = o.key;
					o.style.left = "0px";
					o.style.top = this.resizerEventData.areas.max[2] + "px";
					o.style.width = d + "px";
					o.style.height = a + "px";
					o.style.cursor = "n-resize";
					o.style.backgroundRepeat = "no-repeat";
					f.key = "CanvasXpressCanvasResizerScrollerHandleVer" + l;
					f.className = f.key;
					f.style.left = "0px";
					f.style.top = (this.resizerEventData.areas.max[2] + (this.resizerEventData.areas.cur[3] / 2)) + "px";
					f.style.width = d + "px";
					f.style.height = d + "px";
					f.style.cursor = "move";
					f.style.backgroundRepeat = "no-repeat";
					j.key = "CanvasXpressCanvasResizerNext" + l;
					j.className = j.key;
					j.style.left = "0px";
					j.style.top = "0px";
					j.style.width = d + "px";
					j.style.height = a + "px";
					g.key = "CanvasXpressCanvasResizerClose";
					g.className = g.key;
					g.style.left = (d + 1) + "px";
					g.style.top = -a + "px";
					g.style.width = a + "px";
					g.style.height = d + "px"
				}
				this.drawAxesResizerMasks()
			}
		}
	};
	this.updateResizerEventData = function(h, F, z, o, n, a, V, S, I, M, G, H, x, r, q) {
		var i, E, D, k, j, y, w, f, c, O, N, C, B, m, U;
		z = z ? z : this.resizerEventData.axis;
		o = o ? o : this.resizerEventData.areas.org[0];
		n = n ? n : this.resizerEventData.areas.org[1];
		a = a ? a : this.resizerEventData.areas.org[2];
		V = V ? V : this.resizerEventData.areas.org[3];
		S = S ? S : this.resizerEventData.dim;
		I = I ? I : this.resizerEventData.pos;
		M = M ? M : this.resizerEventData.l;
		G = G ? G : this.resizerEventData.vals;
		H = H ? H : this.resizerEventData.set ? this.resizerEventData.set : "";
		x = x ? x : this.resizerEventData.c;
		r = r ? r : this.resizerEventData.i;
		q = q ? q : this.resizerEventData.j;
		var Q = G.graphType;
		var e = n - o;
		var b = V - a;
		if (Q == "Heatmap") {
			if (S == "y") {
				i = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0
			} else {
				i = this.data.y ? this.data.y.vars.length : 0
			}
		} else {
			i = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0
		}
		var T = this.resizerType == "samples" || Q == "Heatmap" ? 0 : G[z + "AbsMin"];
		var A = this.resizerType == "samples" || Q == "Heatmap" ? i : G[z + "AbsMax"];
		var t = I == "h" ? e : b;
		var P = t / (A - T);
		if (h == null || isNaN(h)) {
			if (this.resizerType == "samples") {
				h = this.isGroupedData ? this.grpIndices[0] : this.smpIndices[0]
			} else {
				if (Q == "Heatmap") {} else {
					h = Q.match(/Scatter/) ? G["setMin" + S.toUpperCase()] : (Q == "BarLine" || Q == "DotLine") && M.match(/b|r/) ? G.setMin2 : G.setMin
				}
				if (h == null || isNaN(h)) {
					h = T
				}
			}
		}
		h = Math.max(h, T);
		if (F == null || isNaN(F)) {
			if (this.resizerType == "samples") {
				F = this.isGroupedData ? this.grpIndices[this.grpIndices.length - 1] : this.smpIndices[this.smpIndices.length - 1]
			} else {
				if (Q == "Heatmap") {
					F = S == "x" ? G.varIndices.length : this.isGroupedData ? G.grpIndices.length : G.smpIndices.length;
					F += h
				} else {
					F = Q.match(/Scatter/) ? G["setMax" + S.toUpperCase()] : (Q == "BarLine" || Q == "DotLine") && M.match(/b|r/) ? G.setMax2 : G.setMax
				}
				if (F == null || isNaN(F)) {
					F = A
				}
			}
		}
		F = Math.min(F, A);
		var u = (h - T) * P;
		var R = (F - T) * P;
		var L = 14;
		var K = 9;
		var J = parseInt(K / 2);
		if (I == "h") {
			E = parseInt(u);
			D = K;
			k = 0;
			j = L;
			O = parseInt(u + J + 1);
			N = parseInt(R - (u + 1));
			C = 0;
			B = L;
			y = parseInt(R - 1);
			w = K;
			f = 0;
			c = L;
			m = n + (K - 1);
			U = V
		} else {
			E = 0;
			D = L;
			k = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(R) : parseInt(b - (u + 1));
			j = K;
			O = 0;
			N = L;
			C = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(u + J) : parseInt((b - R) + J);
			B = parseInt(R - u);
			y = 0;
			w = L;
			f = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(u + 1) : parseInt(b - R);
			c = K;
			m = n;
			U = V + (K - 1)
		}
		this.resizerEventData = {
			g: Q,
			axis: z,
			dim: S,
			pos: I,
			l: M,
			vals: G,
			min: T,
			max: A,
			smin: h,
			smax: F,
			len: t,
			unit: P,
			width: L,
			set: H,
			c: x,
			i: r,
			j: q,
			areas: {
				org: [o, n, a, V],
				lim: [o, m, a, U],
				min: [E, D, k, j],
				max: [y, w, f, c],
				cur: [O, N, C, B]
			}
		}
	};
	this.updateAxesResizer = function(u) {
		if (this.axesResizingOn) {
			if (!u) {
				u = window.event
			}
			var p = this.resizerEventData.areas;
			var w = this.adjustedCoordinates(u);
			if (w) {
				var m, z, b, c, a;
				var f = this.xMouseDown - w.x;
				var d = this.yMouseDown - w.y;
				var i, h;
				var r = null;
				var t = null;
				var v = "";
				var D = 14;
				var C = 9 - 1;
				var A = parseInt(C / 2);
				if (this.resizerEventData.g == "Heatmap") {
					if (this.resizerEventData.dim == "y") {
						m = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0;
						b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length : this.data.y.smps.length
					} else {
						m = this.data.y ? this.data.y.vars.length : 0;
						b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.data.y.vars.length
					}
					z = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
					a = this.resizerEventData.pos == "h" ? (p.org[1] - p.org[0]) / m : (p.org[3] - p.org[2]) / m
				} else {
					m = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0;
					z = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
					b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
					a = this.resizerEventData.pos == "h" ? (p.org[1] - p.org[0]) / m : (p.org[3] - p.org[2]) / m
				}
				if (this.resizerEventData.active == "min") {
					i = f > p.min[0] ? this.xMouseDown - p.min[0] : f < (p.min[0] + p.min[1]) - p.max[0] ? this.xMouseDown - ((p.min[0] + p.min[1]) - p.max[0]) : w.x;
					h = d > p.min[2] - (p.max[2] + p.max[3]) ? this.yMouseDown - (p.min[2] - (p.max[2] + p.max[3])) : d < (p.lim[2] + p.min[2] + p.min[3]) - p.lim[3] ? (p.lim[3] - (p.lim[2] + p.min[2] + p.min[3])) + this.yMouseDown : w.y
				} else {
					if (this.resizerEventData.active == "max") {
						i = f > p.max[0] - (p.min[0] + p.min[1]) ? this.xMouseDown - (p.max[0] - (p.min[0] + p.min[1])) : f < (p.lim[0] + p.max[0] + p.max[1]) - p.lim[1] ? (p.lim[1] - (p.lim[0] + p.max[0] + p.max[1])) + this.xMouseDown : w.x;
						h = d > p.max[2] ? this.yMouseDown - p.max[2] : d < (p.lim[2] + p.max[2] + p.max[3]) - (p.lim[2] + p.min[2]) ? ((p.lim[2] + p.min[2]) - (p.lim[2] + p.max[2] + p.max[3])) + this.yMouseDown : w.y
					} else {
						if (this.resizerEventData.active == "cur") {
							i = f > p.min[0] ? this.xMouseDown - p.min[0] : f < (p.lim[0] + p.max[0] + p.max[1]) - p.lim[1] ? (p.lim[1] - (p.lim[0] + p.max[0] + p.max[1])) + this.xMouseDown : w.x;
							h = d > p.max[2] ? this.yMouseDown - p.max[2] : d < (p.lim[2] + p.min[2] + p.min[3]) - p.lim[3] ? (p.lim[3] - (p.lim[2] + p.min[2] + p.min[3])) + this.yMouseDown : w.y
						} else {
							return
						}
					}
				}
				var k = i - this.xMouseDown;
				var j = h - this.yMouseDown;
				if (this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") {
					k -= k % a;
					j -= j % a
				}
				var q = k / this.resizerEventData.unit;
				var o = j / this.resizerEventData.unit;
				var s = this.$(this.target + "canvasXpressAxesResizeMin");
				var n = this.$(this.target + "canvasXpressAxesResizeMax");
				var B = this.$(this.target + "canvasXpressAxesResizeMiddle");
				var g = this.$(this.target + "canvasXpressAxesResizeCurrent");
				if (s && n && B && g) {
					if (this.resizerEventData.active == "min") {
						if (this.resizerEventData.pos == "h") {
							s.style.left = (p.min[0] + k) + "px";
							B.style.left = ((p.min[0] + k) + ((p.cur[1] - k) / 2)) + "px";
							g.style.left = (p.min[0] + k + A + 1) + "px";
							g.style.width = (p.cur[1] - k) + "px";
							z = parseInt((p.min[0] + C + k) / a);
							if (this.resizerType == "samples") {
								r = dateFormat(this.data.y.smps[z], this.timeFormat)
							} else {
								if (this.resizerEventData.g == "Heatmap") {
									r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]]
								} else {
									r = this.formatNumber(this.resizerEventData.smin + q)
								}
							}
						} else {
							s.style.top = (p.min[2] + j) + "px";
							B.style.top = ((p.min[2] + j) - ((p.cur[3] + j) / 2)) + "px";
							g.style.height = ((p.cur[3] + j)) + "px";
							b = parseInt((p.min[2] + C + j) / a);
							if (this.resizerType == "samples") {
								r = dateFormat(this.data.y.smps[b], this.timeFormat)
							} else {
								if (this.resizerEventData.g == "Heatmap") {
									r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
								} else {
									r = this.formatNumber(this.resizerEventData.smin - o)
								}
							}
						}
						this.showInfoSpan(u, r)
					} else {
						if (this.resizerEventData.active == "max") {
							if (this.resizerEventData.pos == "h") {
								n.style.left = (p.max[0] + k) + "px";
								B.style.left = ((p.min[0] + k) + ((p.cur[1] - k) / 2)) + "px";
								g.style.width = (p.cur[1] + k) + "px";
								b = parseInt((p.max[0] + C + k) / a);
								if (this.resizerType == "samples") {
									t = dateFormat(this.data.y.smps[b], this.timeFormat)
								} else {
									if (this.resizerEventData.g == "Heatmap") {
										t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
									} else {
										t = this.formatNumber(this.resizerEventData.smax + q)
									}
								}
							} else {
								n.style.top = (p.max[2] + j) + "px";
								B.style.top = ((p.max[2] + j) + ((p.cur[3] - j) / 2)) + "px";
								g.style.top = (p.max[2] + j + A) + "px";
								g.style.height = (p.cur[3] - j) + "px";
								z = parseInt((p.max[2] + C + j) / a);
								if (this.resizerType == "samples") {
									t = dateFormat(this.data.y.smps[z], this.timeFormat)
								} else {
									if (this.resizerEventData.g == "Heatmap") {
										t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]]
									} else {
										t = this.formatNumber(this.resizerEventData.smax - o)
									}
								}
							}
							this.showInfoSpan(u, t)
						} else {
							if (this.resizerEventData.active == "cur") {
								if (this.resizerEventData.pos == "h") {
									s.style.left = (p.min[0] + k) + "px";
									B.style.left = ((p.min[0] + k) + (p.cur[1] / 2)) + "px";
									n.style.left = (p.max[0] + k) + "px";
									g.style.left = (p.min[0] + k + A + 1) + "px";
									z = parseInt((p.min[0] + C + k) / a);
									b = parseInt((p.max[0] + C + k) / a);
									if (this.resizerType == "samples") {
										r = dateFormat(this.data.y.smps[z], this.timeFormat);
										t = dateFormat(this.data.y.smps[b], this.timeFormat)
									} else {
										if (this.resizerEventData.g == "Heatmap") {
											r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]];
											t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
										} else {
											r = this.formatNumber(this.resizerEventData.smin + q);
											t = this.formatNumber(this.resizerEventData.smax + q)
										}
									}
									this.showInfoSpan(u, r + "--" + t)
								} else {
									s.style.top = (p.min[2] + j) + "px";
									B.style.top = ((p.max[2] + j) + (p.cur[3] / 2)) + "px";
									n.style.top = (p.max[2] + j) + "px";
									g.style.top = (p.max[2] + j + A) + "px";
									b = parseInt((p.min[2] + C + j) / a);
									z = parseInt((p.max[2] + C + j) / a);
									if (this.resizerType == "samples") {
										r = dateFormat(this.data.y.smps[b], this.timeFormat);
										t = dateFormat(this.data.y.smps[z], this.timeFormat);
										this.showInfoSpan(u, t + "--" + r)
									} else {
										if (this.resizerEventData.g == "Heatmap") {
											r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]];
											t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]];
											this.showInfoSpan(u, t + "--" + r)
										} else {
											r = this.formatNumber(this.resizerEventData.smin - o);
											t = this.formatNumber(this.resizerEventData.smax - o);
											this.showInfoSpan(u, r + "--" + t)
										}
									}
								}
							}
						}
					}
					this.resizerEventData.lastMin = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? z : r;
					this.resizerEventData.lastMax = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? b : t;
					if (this.resizerDraw) {
						this.drawAxesResizerUpdate()
					}
				}
			}
		}
	};
	this.drawAxesResizerUpdate = function(d) {
		this.functionCaller = "drawAxesResizerUpdate";
		if (this.isTransition()) {
			return
		}
		var b = this.resizerEventData.lastMin != null ? parseFloat(this.resizerEventData.lastMin) : parseFloat(this.resizerEventData.smin);
		var g = this.resizerEventData.lastMax != null ? parseFloat(this.resizerEventData.lastMax) : parseFloat(this.resizerEventData.smax);
		var j = this.resizerEventData.c || 0;
		if (this.resizerType == "samples") {
			var a = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
			var h = [];
			var f = [];
			for (var e = 0; e < b; e++) {
				f.push(true)
			}
			for (var e = b; e <= g; e++) {
				h.push(e);
				f.push(false)
			}
			for (var e = g + 1; e < a; e++) {
				f.push(true)
			}
			if (this.isGroupedData) {
				this.grpIndices = h;
				this.hiddenGrps = f
			} else {
				this.smpIndices = h;
				this.hiddenSmps = f
			}
		} else {
			if (this.resizerEventData.g == "Heatmap") {} else {
				if (this.resizerEventData.lastMin) {
					this["setMin" + this.resizerEventData.set] = b
				}
				if (this.resizerEventData.lastMax) {
					this["setMax" + this.resizerEventData.set] = g
				}
			}
		}
		if (d) {
			this.updateResizerEventData(b, g)
		}
		this.draw()
	};
	this.drawAxesResizerBackgroundData = function(d, o, b, n) {
		if (this.resizerType && this.resizerDataIndex > -1) {
			this.setAllSamplesVisible();
			var a, j, c, m;
			var k = this.graphType == "Candlestick" ? "close" : false;
			var g = [];
			var e = [];
			var p = [];
			for (var f = 0; f < this.smpIndices.length; f++) {
				g.push(this.getDataAtPos(this.resizerDataIndex, f, k))
			}
			var h = this.range(g);
			if (this.resizerPosition.match(/top|bottom/)) {
				a = b / (this.smpIndices.length - 1);
				j = n / ((h[1] - h[0]) * 1.2);
				c = (h[1] - h[0]) * 0.1 * j;
				m = o + n;
				e.push(d);
				p.push(m);
				for (var f = 0; f < g.length; f++) {
					e.push(d);
					p.push(m - (((g[f] - h[0]) * j) + c));
					d += a
				}
				d -= a;
				e.push(d);
				p.push(m)
			} else {
				a = n / (this.smpIndices.length - 1);
				j = b / ((h[1] - h[0]) * 1.2);
				c = (h[1] - h[0]) * 0.1 * j;
				e.push(d);
				p.push(o);
				for (var f = 0; f < g.length; f++) {
					e.push(d + ((g[f] - h[0]) * j) + c);
					p.push(o);
					o += a
				}
				o -= a;
				e.push(d);
				p.push(o)
			}
			this.addToRender(["drawShape", "polygon", e, p, false, false, this.resizerBackgroundColorCurrent, this.resizerBackgroundColorOutlineCurrent, "closed"])
		}
	};
	this.drawAxesResizerMasks = function() {
		this.functionCaller = "drawAxesResizerMasks";
		if (this.resizerType) {
			var e, h, d, f;
			var c = this.resizerEventData.areas;
			var b = this.isGroupedData ? this.data.w.grps.length - 1 : this.data.y.smps.length - 1;
			var a = this.resizerEventData.pos == "h" ? (c.org[1] - c.org[0]) / b : (c.org[3] - c.org[2]) / b;
			var g = 9 - 1;
			if (this.resizerEventData.pos == "h") {
				if (this.resizerEventData.smin > 0) {
					e = c.org[0] - 1;
					h = c.org[2] - this.resizerWidth;
					d = a * this.resizerEventData.smin;
					f = this.resizerWidth;
					this.addToRender(["drawShape", "rectangle", e + (d / 2), h + (f / 2), d, f, this.resizerBackgroundColor, this.resizerBackgroundColor]);
					this.addToRender(["drawLine", "line", e, h, e + d + 1, h, this.foreground]);
					this.addToRender(["drawLine", "line", e + d, h, e + d, h + f, this.foreground])
				}
				if (this.resizerEventData.smax < b) {
					e = c.org[0] + c.max[0] + 1;
					h = c.org[2] - this.resizerWidth;
					d = (a * (b - this.resizerEventData.smax)) + 1;
					f = this.resizerWidth;
					this.addToRender(["drawShape", "rectangle", e + (d / 2), h + (f / 2), d, f, this.resizerBackgroundColor, this.resizerBackgroundColor]);
					this.addToRender(["drawLine", "line", e - 1, h, e + d + 2, h, this.foreground]);
					this.addToRender(["drawLine", "line", e - 1, h, e - 1, h + f, this.foreground])
				}
				e = c.org[0] + c.max[0];
				h = c.org[2] - 1;
				d = c.org[0] + a * this.resizerEventData.smin;
				this.addToRender(["drawLine", "line", e, h, d, h, this.foreground])
			} else {
				if (this.resizerEventData.smin > 0) {
					e = c.org[0] + 14;
					h = c.org[2];
					d = this.resizerWidth;
					f = a * this.resizerEventData.smin;
					this.addToRender(["drawShape", "rectangle", e + (d / 2), h + (f / 2), d, f, this.resizerBackgroundColor, this.resizerBackgroundColor]);
					this.addToRender(["drawLine", "line", e, h + f, e + d, h + f, this.foreground]);
					this.addToRender(["drawLine", "line", e + d, h, e + d, h + f, this.foreground])
				}
				if (this.resizerEventData.smax < b) {
					e = c.org[0] + 14;
					h = c.org[2] + c.min[2];
					d = this.resizerWidth;
					f = (b - this.resizerEventData.smax) * a;
					this.addToRender(["drawShape", "rectangle", e + (d / 2), h + (f / 2), d, f, this.resizerBackgroundColor, this.resizerBackgroundColor]);
					this.addToRender(["drawLine", "line", e, h, e + d, h, this.foreground]);
					this.addToRender(["drawLine", "line", e + d, h, e + d, h + f, this.foreground])
				}
				e = c.org[0] + 14;
				h = c.org[2] + c.min[2];
				f = c.org[2] + (a * this.resizerEventData.smin);
				this.addToRender(["drawLine", "line", e, h, e, f, this.foreground])
			}
		}
	};
	this.registerAxesResizer = function(d) {
		if (!d) {
			d = window.event
		}
		var h = this.adjustedCoordinates(d);
		if (h) {
			var g = h.x;
			var f = h.y;
			var c = this.resizerEventData.areas;
			var j = c.lim[1] - c.lim[0];
			var i = c.lim[3] - c.lim[2];
			var a = 5;
			var b = j > i ? "h" : "v";
			if (g >= c.min[0] + c.lim[0] && g <= c.min[0] + c.min[1] + c.lim[0] && f >= c.min[2] + c.lim[2] && f <= c.min[2] + c.min[3] + c.lim[2]) {
				this.resizerEventData.active = "min";
				this.axesResizingOn = true
			} else {
				if (g >= c.max[0] + c.lim[0] && g <= c.max[0] + c.max[1] + c.lim[0] && f >= c.max[2] + c.lim[2] && f <= c.max[2] + c.max[3] + c.lim[2]) {
					this.resizerEventData.active = "max";
					this.axesResizingOn = true
				} else {
					if (g >= c.cur[0] + c.lim[0] && g <= c.cur[0] + c.cur[1] + c.lim[0] && f >= c.cur[2] + c.lim[2] && f <= c.cur[2] + c.cur[3] + c.lim[2]) {
						this.resizerEventData.active = "cur";
						this.axesResizingOn = true
					} else {
						if (b == "h") {
							if (g >= c.lim[0] && g < c.min[0] + c.lim[0]) {
								this.resizerEventData.active = "prev";
								this.axesResizingOn = true
							} else {
								if (g > c.lim[0] + c.max[0] + c.max[1] && g <= c.lim[1] - a) {
									this.resizerEventData.active = "next";
									this.axesResizingOn = true
								}
							}
						} else {
							if (f >= c.lim[2] + c.min[2] + c.min[3] && f <= c.lim[2] + c.lim[3]) {
								this.resizerEventData.active = "prev";
								this.axesResizingOn = true
							} else {
								if (f >= c.lim[2] && f <= c.lim[2] + c.max[2]) {
									this.resizerEventData.active = "next";
									this.axesResizingOn = true
								}
							}
						}
					}
				}
			}
			this.xMouseDown = g;
			this.yMouseDown = f
		}
	};
	this.activateDeactivateAxesResizer = function(i) {
		if (!i) {
			i = window.event
		}
		var r = this.adjustedCoordinates(i);
		if (r) {
			var m;
			var q = r.x;
			var j = r.y;
			var g = this.resizerEventData.areas;
			var t = g.lim[1] - g.lim[0];
			var s = g.lim[3] - g.lim[2];
			var b = 5;
			var d = t > s ? "h" : "v";
			if (d == "h") {
				if (q >= g.lim[0] && q <= g.lim[0] + g.min[0]) {
					m = "prev"
				} else {
					if (q >= g.lim[0] + g.max[0] + g.max[1] && q <= g.lim[1] - b) {
						m = "next"
					}
				}
			} else {
				if (j >= g.lim[2] + g.min[2] + g.min[3] && j <= g.lim[2] + g.lim[3]) {
					m = "prev"
				} else {
					if (j >= g.lim[2] && j <= g.lim[2] + g.max[2]) {
						m = "next"
					}
				}
			}
			var c = this.$(this.target + "canvasXpressAxesResizePrevious");
			var f = this.$(this.target + "canvasXpressAxesResizeNext");
			if (c && f) {
				if (m == "prev") {
					var h = c.key;
					if (i.type.match(/mouseout|touchcancel/i)) {
						if (h.match(/Active/)) {
							c.key = h.replace("Active", "");
							c.className = c.key
						}
					} else {
						if (!h.match(/Active/)) {
							c.key += "Active";
							c.className = c.key
						}
					}
				} else {
					if (m == "next") {
						var h = f.key;
						if (i.type.match(/mouseout|touchcancel/i)) {
							if (h.match(/Active/)) {
								f.key = h.replace("Active", "");
								f.className = f.key
							}
						} else {
							if (!h.match(/Active/)) {
								f.key += "Active";
								f.className = f.key
							}
						}
					} else {
						var h = c.key;
						if (h.match(/Active/)) {
							c.key = h.replace("Active", "");
							c.className = c.key
						}
						h = f.key;
						if (h.match(/Active/)) {
							f.key = h.replace("Active", "");
							f.className = f.key
						}
					}
				}
			}
			return false
		}
	};
	this.moveAxesResizer = function(j) {
		var g = this.resizerEventData.smin;
		var k = this.resizerEventData.smax;
		var c = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? 1 : (k - g) / 10;
		if ((this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") && this.resizerEventData.pos == "v") {
			if (this.resizerEventData.active == "prev") {
				if (g + c < this.resizerEventData.min) {
					c = g - this.resizerEventData.min;
					this.resizerEventData.lastMin = this.resizerEventData.min;
					this.resizerEventData.lastMax = k + c
				} else {
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = k + c
				}
			} else {
				if (k - c > this.resizerEventData.max) {
					c = this.resizerEventData.max - k;
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = this.resizerEventData.max
				} else {
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = k - c
				}
			}
		} else {
			if (this.resizerEventData.active == "prev") {
				if (g - c < this.resizerEventData.min) {
					c = g - this.resizerEventData.min;
					this.resizerEventData.lastMin = this.resizerEventData.min;
					this.resizerEventData.lastMax = k - c
				} else {
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = k - c
				}
			} else {
				if (k + c > this.resizerEventData.max) {
					c = this.resizerEventData.max - k;
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = this.resizerEventData.max
				} else {
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = k + c
				}
			}
		}
		var f = this.resizerEventData.areas;
		var d = this.$(this.target + "canvasXpressAxesResizeMin");
		var n = this.$(this.target + "canvasXpressAxesResizeMax");
		var m = this.$(this.target + "canvasXpressAxesResizeMiddle");
		var i = this.$(this.target + "canvasXpressAxesResizeCurrent");
		var b = 14;
		var a = 9 - 1;
		var o = parseInt(a / 2);
		var h = c * this.resizerEventData.unit;
		if ((this.resizerEventData.pos == "h" && this.resizerEventData.active == "prev") || (this.resizerEventData.pos == "v" && this.resizerEventData.active == "next")) {
			h *= -1
		}
		if (this.resizerEventData.pos == "h") {
			d.style.left = (f.min[0] + h + 1) + "px";
			m.style.left = ((f.min[0] + h) + (f.cur[1] / 2)) + "px";
			n.style.left = (f.max[0] + h) + "px";
			i.style.left = (f.min[0] + h + o + 1) + "px"
		} else {
			d.style.top = (f.min[2] + h + 1) + "px";
			m.style.top = ((f.max[2] + h) + (f.cur[3] / 2)) + "px";
			n.style.top = (f.max[2] + h) + "px";
			i.style.top = (f.max[2] + h + o + 1) + "px"
		}
	};
	this.getAxesVals = function(e) {
		var d = ["minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "graphType", "x", "y", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart"];
		var b = {};
		if (this.layoutComb) {
			for (var a = 0; a < d.length; a++) {
				b[d[a]] = this.layoutParams[e][d[a]]
			}
		} else {
			for (var a = 0; a < d.length; a++) {
				b[d[a]] = this[d[a]]
			}
		}
		return b
	};
	this.isAxis = function(k) {
		return false;
		if (!k) {
			k = window.event
		}
		if ((this.resizerType && this.layoutValid) || this.disableAxisResizer) {
			return false
		}
		var u = this.adjustedCoordinates(k);
		if (u) {
			var s = u.x;
			var p = u.y;
			var n = 0;
			var t = (this.margin * 1);
			var r = (this.margin * 2);
			var b = 18;
			for (var f = 0; f < this.layoutRows; f++) {
				for (var d = 0; d < this.layoutCols; d++) {
					var a = this.layoutComb ? n < this.data.l.weight.length : true;
					if (a) {
						var h = this.layoutComb ? this.layoutParams[n].graphType : this.graphType;
						if (h.match(/Network|Pie|Venn|Stacked|Area|Correlation|Circular/)) {
							return false
						}
						var m = this.getBoundsXY(n);
						if (h.match(/Scatter/)) {
							if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
								var o = this.getAxesVals(n);
								this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "X", n, f, d);
								return true
							} else {
								if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
									var o = this.getAxesVals(n);
									this.showAxesResizer("yAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "Y", n, f, d);
									return true
								}
							}
						} else {
							if (h.match(/Heatmap/)) {
								if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
									var o = this.getAxesVals(n);
									this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "", n, f, d);
									return true
								} else {
									if (s >= m[1] && s <= m[1] + b && p >= m[2] && p <= m[3]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "", n, f, d);
										return true
									} else {
										if (s >= m[0] && s <= m[1] && p >= m[2] - b && p <= m[2]) {
											var o = this.getAxesVals(n);
											this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + r), m[2] - t, "x", "h", "t", o, "", n, f, d);
											return true
										} else {
											if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
												var o = this.getAxesVals(n);
												this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "", n, f, d);
												return true
											}
										}
									}
								}
							} else {
								if (this.graphOrientation == "vertical") {
									if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "", n, f, d);
										return true
									} else {
										if (s >= m[1] && s <= m[1] + b && p >= m[2] && p <= m[3]) {
											var o = this.getAxesVals(n);
											if (h == "BarLine" || h == "DotLine") {
												this.showAxesResizer("xAxis2", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "2", n, f, d)
											} else {
												this.showAxesResizer("xAxis", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "", n, f, d)
											}
											return true
										}
									}
								} else {
									if (s >= m[0] && s <= m[1] && p >= m[2] - b && p <= m[2]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + r), m[2] - t, "x", "h", "t", o, "", n, f, d);
										return true
									} else {
										if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
											var o = this.getAxesVals(n);
											if (h == "BarLine" || h == "DotLine") {
												this.showAxesResizer("xAxis2", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "2", n, f, d)
											} else {
												this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "", n, f, d)
											}
											return true
										}
									}
								}
							}
						}
					}
					n++
				}
			}
		}
		return false
	};
	this.endAxesResizer = function(a) {
		if (this.axesResizingOn) {
			this.resetInfoSpan(a);
			if (this.resizerEventData.active == "prev" || this.resizerEventData.active == "next") {
				this.moveAxesResizer(a)
			}
			this.drawAxesResizerUpdate(true);
			this.axesResizingOn = false
		} else {
			if (this.resizerType) {
				this.updateResizerEventData();
				this.refreshAxesResizer()
			}
		}
	};
	this.resetAxesResizer = function(b) {
		if (this.axesResizerShow) {
			var a = this.$(this.target + "canvasXpressAxesResize");
			if (a) {
				this.addRemoveAxesResizerListeners("removeEvtListener");
				a.style.display = "none";
				this.resizerEventData = {};
				this.resetInfoSpan(b);
				this.axesResizerShow = false
			}
		}
	};
	this.initializeAxisResizerEvents = function() {
		if (!this.disableEvents && !this.disableAxisResizer) {
			this.addAxesResizeDiv()
		}
	};
	this.initializeAxisResizerEvents()
};
CanvasXpress.prototype.initMotionEvents = function() {
	this.addMotionDiv = function() {
		var e = this.target + "-cX-Motion";
		if (this.$(e) || !this.motionBy) {
			return
		}
		this.setMotionObject();
		var h = this.width - this.motionControlHeight;
		var a = this.motionObject;
		var o = this.$cX("div", {
			id: e,
			className: "CanvasXpressMotion"
		}, {
			position: "absolute",
			left: 0,
			top: (this.height - 40) + "px",
			width: this.width + "px",
			height: "40px"
		});
		var g = this.$cX("img", {
			id: e + "Play",
			src: CanvasXpress.images.playButton,
			className: "CanvasXpressMotion"
		}, {
			width: "30px",
			height: "30px",
			cssFloat: "left"
		});
		var v = this.$cX("div", {
			id: e + "Scale",
			className: "CanvasXpressMotion"
		}, {
			width: h + "px",
			height: "14px",
			cssFloat: "left",
			margin: "2px"
		});
		var r = this.$cX("div", {
			id: e + "Container",
			className: "CanvasXpressDataFilterContainerNumeric"
		}, {
			width: h + "px",
			cssFloat: "left",
			clear: "none"
		});
		var q = this.$cX("div", {
			id: e + "Current",
			className: "CanvasXpressDataFilterContainerMax"
		});
		var n = this.$cX("div", {
			id: e + "Range",
			className: "CanvasXpressDataFilterContainerRange"
		}, {
			width: 0
		});
		if (a.type == "String") {
			for (var k = 0; k < a.levels.length; k++) {
				var m = this.measureText(a.levels[k].toString(), " 11px Arial");
				var u = this.$cX("div", {
					innerHTML: a.levels[k]
				}, {
					left: (30 + parseInt((k * a.unit) - (m / 2))) + "px",
					cssFloat: "left",
					position: "absolute"
				});
				v.appendChild(u)
			}
		} else {
			for (var k = 0; k < a.values.length; k++) {
				var m = this.measureText(a.values[k].toString(), " 11px Arial");
				var u = this.$cX("div", {
					innerHTML: a.values[k]
				}, {
					left: (30 + parseInt(((a.values[k] - a.min) * a.unit) - (m / 2))) + "px",
					cssFloat: "left",
					position: "absolute"
				});
				v.appendChild(u)
			}
		}
		r.appendChild(n);
		r.appendChild(q);
		o.appendChild(g);
		o.appendChild(v);
		o.appendChild(r);
		this.updateMotionIndices();
		var j = this.$("center-wrapper-" + this.target);
		if (j) {
			j.appendChild(o);
			this.addRemoveMotionListeners("addEvtListener")
		}
	};
	this.setMotionObject = function() {
		var b = {};
		var e = [];
		var c = {};
		var f = this.data.x && this.data.x[this.motionBy] ? this.meta.data.x[this.motionBy] : this.meta.data.z[this.motionBy];
		var a = this.width - (this.motionControlHeight + 14);
		if (f.type == "Numeric") {
			if (this.data.x && this.data.x[this.motionBy]) {
				for (var d = 0; d < this.data.x[this.motionBy].length; d++) {
					var g = this.data.x[this.motionBy][d];
					if (!c.hasOwnProperty(g)) {
						e.push(g);
						c[g] = true
					}
				}
				b.meta = "x"
			} else {
				for (var d = 0; d < this.data.z[this.motionBy].length; d++) {
					var g = this.data.z[this.motionBy][d];
					if (!c.hasOwnProperty(g)) {
						e.push(g);
						c[g] = true
					}
				}
				b.meta = "z"
			}
			if (e.length > 20) {
				b.type = "Numeric";
				b.values = [];
				b.min = f.rmin;
				b.max = f.rmax;
				b.unit = a / (f.vals[f.vals.length - 1] - f.rmin);
				b.current = f.rmin;
				for (var d = 0; d < f.vals.length; d++) {
					if (f.vals[d] >= f.rmin) {
						b.values.push(f.vals[d])
					}
				}
			} else {
				b.type = "String";
				b.levels = e.sort(function(i, h) {
					return i - h
				});
				b.unit = a / (e.length - 1);
				b.current = e[0]
			}
		} else {
			b.type = "String";
			b.levels = f.levels;
			b.unit = a / (f.levels.length - 1);
			b.current = f.levels[0]
		}
		b.varIndices = this.cloneObject(this.varIndices);
		b.smpIndices = this.cloneObject(this.smpIndices);
		b.grpIndices = this.cloneObject(this.grpIndices);
		b.varIndicesMotion = [];
		b.smpIndicesMotion = [];
		b.grpIndicesMotion = [];
		this.motionObject = b
	};
	this.updateMotionIndices = function(g, a) {
		if (this.motionBy && this.motionObject) {
			var c = [];
			var h = this.motionObject.meta == "x" ? this.motionObject.smpIndices : this.motionObject.varIndices;
			var k = this.motionObject.meta == "x" ? this.data.x[this.motionBy] : this.data.z[this.motionBy];
			if (this.motionObject.type == "String") {
				var b = g && g[0] != null ? g[0] : this.motionObject.levels[0];
				for (var e = 0; e < h.length; e++) {
					var j = h[e];
					if (k[j] == b) {
						c.push(j)
					}
				}
			} else {
				var d = g && g[0] != null ? g[0] : this.motionObject.min;
				var f = g && g[1] != null ? g[1] : this.motionObject.values[0];
				for (var e = 0; e < h.length; e++) {
					var j = h[e];
					if (k[j] > d && k[j] <= f) {
						c.push(j)
					}
				}
			}
			if (this.motionObject.meta == "x") {
				this.smpIndices = c
			} else {
				this.varIndices = c
			}
			if (g && g.length > 0 && !a) {
				this.motionObject.varIndicesMotion.push(this.cloneObject(this.varIndices));
				this.motionObject.smpIndicesMotion.push(this.cloneObject(this.smpIndices));
				this.motionObject.grpIndicesMotion.push(this.cloneObject(this.grpIndices))
			}
			if (this.motionObject.varIndicesMotion.length > 3) {
				this.motionObject.varIndicesMotion.shift()
			}
			if (this.motionObject.smpIndicesMotion.length > 3) {
				this.motionObject.smpIndicesMotion.shift()
			}
			if (this.motionObject.grpIndicesMotion.length > 3) {
				this.motionObject.grpIndicesMotion.shift()
			}
		}
	};
	this.addRemoveMotionListeners = function(a) {
		var b = this.$(this.target + "-cX-MotionPlay");
		var d = this.$(this.target + "-cX-MotionCurrent");
		if (a && b && d) {
			this[a](b, "click", this.clickMotion, false);
			this[a](d, "mousedown", this.mousedownMotion, false)
		}
	};
	this.mousedownMotion = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			if (b) {
				var c = a.$(a.target + "-cX-MotionRange");
				if (c) {
					a.motionOn = c.style.width + "px";
					a.xMouseDown = d.clientX;
					a.yMouseDown = d.clientY
				}
			}
			return false
		}
	}(this);
	this.updateMotion = function(h, k, g) {
		this.functionCaller = "updateMotion";
		if (this.isTransition()) {
			return
		}
		var a = this.$(this.target + "-cX-MotionRange");
		if (a) {
			var j = this.width - (this.motionControlHeight + 14);
			var l = k != null ? Math.min(Math.max(0, k), j) : Math.min(Math.max(0, h.clientX + parseInt(this.motionOn) - this.xMouseDown), j);
			var d = l / this.motionObject.unit;
			a.style.width = l + "px";
			if (this.motionObject.type == "String") {
				var b = parseInt(d);
				if (this.motionObject.levels[b] != this.motionObject.current || g) {
					this.updateMotionIndices([this.motionObject.levels[b]], g);
					this.motionObject.current = this.motionObject.levels[b];
					this.draw()
				}
			} else {
				var b = d + this.motionObject.min;
				for (var c = 1; c < this.motionObject.values.length; c++) {
					if (this.motionObject.values[c] > b) {
						this.updateMotionIndices([this.motionObject.values[c - 1], b, g]);
						this.motionObject.current = b;
						this.draw();
						break
					}
				}
			}
		}
	};
	this.endMotion = function() {
		this.motionOn = false;
		return false
	};
	this.clickMotion = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var f = a.getTargetEvent(g);
			if (f) {
				a.motionOn = true;
				var d = a.width - (a.motionControlHeight + 14);
				var c = d / 100;
				var h = 0;
				var b = function() {
					if (h >= d) {
						var j = function() {
							var k = a.motionObject.varIndicesMotion.length;
							if (k < 1) {
								a.motionOn = false;
								clearInterval(e);
								return
							}
							a.motionObject.varIndicesMotion.shift();
							a.motionObject.smpIndicesMotion.shift();
							a.motionObject.grpIndicesMotion.shift();
							a.updateMotion(g, d, true)
						};
						clearInterval(i);
						var e = a.setInterval(j, 50)
					}
					h += c;
					a.updateMotion(g, h)
				};
				a.updateMotion(g, h);
				var i = a.setInterval(b, 50)
			}
		};
		return false
	}(this);
	this.removeMotionDiv = function() {
		var a = this.$(this.target + "-cX-Motion");
		if (a) {
			a.parentNode.removeChild(a);
			this.addRemoveMotionListeners("removeEvtListener")
		}
	};
	this.resetMotionDiv = function() {
		if (this.motionBy) {
			this.removeMotionDiv();
			this.addMotionDiv()
		}
	}
};
CanvasXpress.prototype.initDraggingEvents = function() {
	this.getActiveLayout = function(k) {
		if (k) {
			var h = {};
			if (k && k.type == "keydown") {
				h.x = (this.layoutComb ? this.layoutParams[0].width : this.width) / 2;
				h.y = (this.layoutComb ? this.layoutParams[0].height : this.height) / 2
			} else {
				h = this.adjustedCoordinates(k)
			}
			if (this.layoutValid) {
				var a = h.x;
				var g = h.y;
				var m = 0;
				for (var f = 0; f < this.layoutRows; f++) {
					for (var d = 0; d < this.layoutCols; d++) {
						if (m < this.data.l.weight.length) {
							var b = this.getBoundsXY(m);
							if (a >= b[0] && a <= b[1] && g >= b[2] && g <= b[3]) {
								this.layoutValidR = f;
								this.layoutValidC = d;
								this.layoutValidN = m;
								m = {
									idx: m,
									row: f,
									col: d,
									ac: h
								};
								return m
							}
							m++
						} else {
							return false
						}
					}
				}
			} else {
				return {
					idx: 0,
					row: 0,
					col: 0,
					ac: h
				}
			}
		}
		return false
	};
	this.setActiveLayout = function(a) {
		var b = this.getActiveLayout(a);
		if (b && b.row && b.col && b.idx) {
			this.layoutValidR = b.row;
			this.layoutValidC = b.col;
			this.layoutValidN = b.idx
		}
	};
	this.getActiveLayoutIndicesMetadata = function(f) {
		var g = this.getActiveLayout(f);
		if (g) {
			var q = this.layoutComb ? this.layoutParams[g.idx] : this;
			var a = this.cloneObject(q.varIndices);
			var h = this.isGroupedData ? this.cloneObject(q.grpIndices) : this.cloneObject(q.smpIndices);
			if (a && h) {
				this.setOriginalIndices(g.idx, a, h);
				var n = g.ac.x - (q.offsetX + this.marginLeft + q.left);
				var k = g.ac.y - (q.offsetY + this.marginTop + q.top);
				var m = Math.min(Math.max(n, 0), q.x) / q.x;
				var l = Math.ceil(a.length / 10) * 2;
				var d = Math.round(m * l);
				var p = l - d;
				var j = Math.min(Math.max(k, 0), q.y) / q.y;
				var i = Math.ceil(h.length / 10) * 2;
				var b = Math.round(j * i);
				var o = i - b;
				return {
					ac: g.ac,
					row: g.row,
					col: g.col,
					idx: g.idx,
					lcx: m,
					stx: d,
					edx: p,
					lcy: j,
					sty: b,
					edy: o,
					vin: a,
					sin: h
				}
			} else {
				var n = g.ac.x - (q.offsetX + this.marginLeft + q.left);
				var k = g.ac.y - (q.offsetY + this.marginTop + q.top);
				var m = Math.min(Math.max(n, 0), q.x) / q.x;
				var j = Math.min(Math.max(k, 0), q.y) / q.y;
				return {
					ac: g.ac,
					row: g.row,
					col: g.col,
					idx: g.idx,
					lcx: m,
					lcy: j
				}
			}
		}
		return false
	};
	this.setIndicesAfterWheelEvent = function(k, l) {
		var h, a, p, j, n, f, o;
		var c = false;
		var b = this.getActiveLayoutIndicesMetadata(k);
		if (b) {
			var q = this.layoutComb ? this.layoutParams[b.idx] : this;
			if (this.graphType == "Correlation") {
				h = this.correlationAxis == "variables" ? true : false;
				a = this.correlationAxis == "samples" ? true : false;
				p = b.stx;
				j = b.edx;
				n = b.stx;
				f = b.edx;
				o = false
			} else {
				if (this.graphType == "Heatmap") {
					h = !this.zoomVariablesDisable ? true : false;
					a = !this.zoomSamplesDisable ? true : false;
					p = b.stx;
					j = b.edx;
					n = b.sty;
					f = b.edy;
					o = false
				} else {
					if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
						h = false;
						a = true;
						p = false;
						j = false;
						n = this.graphOrientation == "vertical" ? b.stx : b.sty;
						f = this.graphOrientation == "vertical" ? b.edx : b.edy;
						o = true
					}
				}
			}
			if (l > 0) {
				if (h && b.vin.length > 3) {
					if (q.varIndicesStart < 0) {
						q.varIndicesStart++
					}
					for (var g = 0; g < p; g++) {
						b.vin.shift();
						q.varIndicesStart++
					}
					for (var g = 0; g < j; g++) {
						b.vin.pop()
					}
					c = true
				}
				if (a && b.sin.length > 3) {
					if (q.smpIndicesStart < 0) {
						q.smpIndicesStart++
					}
					for (var g = 0; g < n; g++) {
						b.sin.shift();
						q.smpIndicesStart++
					}
					for (var g = 0; g < f; g++) {
						b.sin.pop()
					}
					c = true
				}
			} else {
				if (h) {
					for (var g = 0; g < p; g++) {
						if (q.varIndicesStart >= 0 && q.varIndicesStart + b.vin.length < q.startingVarIndices.length) {
							b.vin.push(q.startingVarIndices[q.varIndicesStart + b.vin.length]);
							c = true
						} else {
							if (q.varIndicesStart > 0) {
								q.varIndicesStart--;
								b.vin.unshift(q.startingVarIndices[q.varIndicesStart]);
								c = true
							}
						}
					}
					for (var g = 0; g < j; g++) {
						if (q.varIndicesStart > 0) {
							q.varIndicesStart--;
							b.vin.unshift(q.startingVarIndices[q.varIndicesStart]);
							c = true
						} else {
							if (q.varIndicesStart >= 0 && q.varIndicesStart + b.vin.length < q.startingVarIndices.length) {
								b.vin.push(q.startingVarIndices[q.varIndicesStart + b.vin.length]);
								c = true
							}
						}
					}
				}
				if (a) {
					for (var g = 0; g < n; g++) {
						if (q.smpIndicesStart >= 0 && q.smpIndicesStart + b.sin.length < q.startingSmpIndices.length) {
							b.sin.push(q.startingSmpIndices[q.smpIndicesStart + b.sin.length]);
							c = true
						} else {
							if (q.smpIndicesStart > 0) {
								q.smpIndicesStart--;
								b.sin.unshift(q.startingSmpIndices[q.smpIndicesStart]);
								c = true
							}
						}
					}
					for (var g = 0; g < f; g++) {
						if (q.smpIndicesStart > 0) {
							q.smpIndicesStart--;
							b.sin.unshift(q.startingSmpIndices[q.smpIndicesStart]);
							c = true
						} else {
							if (q.smpIndicesStart >= 0 && q.smpIndicesStart + b.sin.length < q.startingSmpIndices.length) {
								b.sin.push(q.startingSmpIndices[q.smpIndicesStart + b.sin.length]);
								c = true
							}
						}
					}
				}
			}
			if (c) {
				this.drawIndicesAfterWheelEvent(h, b.vin, a, b.sin, o, b.idx)
			}
		}
	};
	this.drawIndicesAfterWheelEvent = function(g, e, c, f, b, a) {
		this.functionCaller = "drawIndicesAfterWheelEvent";
		if (this.isTransition()) {
			return
		}
		var d = this.layoutComb ? this.layoutParams[a] : this;
		if (g) {
			d.varIndices = e
		}
		if (c) {
			if (b) {
				this.setSamplesVisible(f, true)
			}
			if (d.isGroupedData) {
				d.grpIndices = f
			} else {
				d.smpIndices = f
			}
		}
		this.draw()
	};
	this.setRangesAfterWheelEvent = function(i, k) {
		this.functionCaller = "setRangesAfterWheelEvent";
		var c = this.getActiveLayoutIndicesMetadata(i);
		if (c) {
			var p, j, n, h;
			var q = this.layoutComb ? this.layoutParams[c.idx] : this;
			var l = c.ac.x > (this.marginLeft + q.offsetX + q.left) && c.ac.x < (this.marginLeft + q.offsetX + q.left + q.x);
			var f = c.ac.y > (this.marginTop + q.offsetY + q.top) && c.ac.y < (this.marginTop + q.offsetY + q.top + q.y);
			var b = q.xAxisRange * this.zoomStep * c.lcx;
			var a = q.yAxisRange * this.zoomStep * c.lcy;
			var o = q.xAxisRange * this.zoomStep * (1 - c.lcx);
			var g = q.yAxisRange * this.zoomStep * (1 - c.lcy);
			if (k > 0) {
				if (l) {
					p = this.setMinX = q.setMinX != null ? q.setMinX + b : q.xAxisMin + b;
					j = this.setMaxX = q.setMaxX != null ? q.setMaxX - o : q.xAxisMax - o
				}
				if (f && this.graphType != "Genome") {
					n = this.setMinY = q.setMinY != null ? q.setMinY + g : q.yAxisMin + g;
					h = this.setMaxY = q.setMaxY != null ? q.setMaxY - a : q.yAxisMax - a
				}
			} else {
				if (l) {
					p = this.setMinX = q.setMinX != null ? q.setMinX - b : q.xAxisMin - b;
					j = this.setMaxX = q.setMaxX != null ? q.setMaxX + o : q.xAxisMax + o
				}
				if (f && this.graphType != "Genome") {
					n = this.setMinY = q.setMinY != null ? q.setMinY - g : q.yAxisMin - g;
					h = this.setMaxY = q.setMaxY != null ? q.setMaxY + a : q.yAxisMax + a
				}
			}
			this.isTransformedAxis("xAxis", "X");
			this.isTransformedAxis("yAxis", "Y");
			if (q.setMinX == "Infinity" || q.setMaxX == "Infinity") {
				this.setMinX = p;
				this.setMaxX = j
			}
			if (q.setMinY == "Infinity" || q.setMaxY == "Infinity") {
				this.setMinY = n;
				this.setMaxY = h
			}
			this.drawRangesAfterWheelEvent(this.setMinX, this.setMaxX, this.setMinY, this.setMaxY, c.idx)
		}
	};
	this.drawRangesAfterWheelEvent = function(f, c, e, b, a) {
		this.functionCaller = "drawRangesAfterWheelEvent";
		if (this.isTransition()) {
			return
		}
		var d = this.layoutComb ? this.layoutParams[a] : this;
		d.setMinX = f;
		d.setMaxX = c;
		d.setMinY = e;
		d.setMaxY = b;
		this.draw();
		this.isTransformedAxis("xAxis", "X", true);
		this.isTransformedAxis("yAxis", "Y", true)
	};
	this.setIndicesAfterPannEvent = function(j, b) {
		var a, p;
		var h = 0;
		var o = this.layoutComb ? this.layoutParams[this.layoutValidN || 0] : this;
		var c = this.cloneObject(o.varIndices);
		var n = o.isGroupedData ? this.cloneObject(o.grpIndices) : this.cloneObject(o.smpIndices);
		this.setOriginalIndices(this.layoutComb ? this.layoutValidN : 0, c, n);
		if (this.graphType == "Correlation") {
			h = 1;
			switch (b) {
				case 37:
					p = o.varIndicesStart > 0 ? 3 : o.smpIndicesStart > 0 ? 4 : 1;
					break;
				case 39:
					p = o.varIndicesStart > -1 ? 5 : o.smpIndicesStart > -1 ? 6 : 1;
					break
			}
		} else {
			if (this.graphType == "Heatmap") {
				h = 2
			} else {
				if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
					h = 3
				}
			}
		}
		switch (b) {
			case 33:
				a = h == 1 ? 1 : h == 2 ? 4 : h == 3 ? 4 : 1;
				break;
			case 34:
				a = h == 1 ? 1 : h == 2 ? 6 : h == 3 ? 6 : 1;
				break;
			case 35:
				a = h == 1 ? 1 : h == 2 ? 1 : h == 3 ? 1 : 1;
				break;
			case 36:
				a = h == 1 ? 1 : h == 2 ? 2 : h == 3 ? 1 : 1;
				break;
			case 37:
				a = h == 1 ? p : h == 2 ? 3 : h == 3 ? 4 : 1;
				break;
			case 38:
				a = h == 1 ? 1 : h == 2 ? 4 : h == 3 ? 4 : 1;
				break;
			case 39:
				a = h == 1 ? p : h == 2 ? 5 : h == 3 ? 6 : 1;
				break;
			case 40:
				a = h == 1 ? 1 : h == 2 ? 6 : h == 3 ? 6 : 1;
				break
		}
		var l = false;
		if (a == 1) {
			return false
		} else {
			if (a == 2) {
				o.varIndicesStart = -1;
				o.smpIndicesStart = -1;
				o.varIndices = o.startingVarIndices;
				if (o.isGroupedData) {
					o.grpIndices = o.startingSmpIndices
				} else {
					o.smpIndices = o.startingSmpIndices
				}
				l = true
			} else {
				if (a == 3) {
					if (o.varIndicesStart > 0) {
						c.unshift(o.startingVarIndices[o.varIndicesStart - 1]);
						c.pop();
						o.varIndicesStart--;
						l = true
					}
				} else {
					if (a == 4) {
						for (var f = 0; f < (b == 33 ? 5 : 1); f++) {
							if (o.smpIndicesStart > 0) {
								n.unshift(o.startingSmpIndices[o.smpIndicesStart - 1]);
								n.pop();
								o.smpIndicesStart--;
								l = true
							}
						}
					} else {
						if (a == 5) {
							if (o.varIndicesStart > -1 && o.varIndicesStart + c.length < o.startingVarIndices.length) {
								c.push(o.startingVarIndices[o.varIndicesStart + c.length]);
								c.shift();
								o.varIndicesStart++;
								l = true
							}
						} else {
							if (a == 6) {
								for (var f = 0; f < (b == 34 ? 5 : 1); f++) {
									if (o.smpIndicesStart > -1 && o.smpIndicesStart + n.length < o.startingSmpIndices.length) {
										n.push(o.startingSmpIndices[o.smpIndicesStart + n.length]);
										n.shift();
										o.smpIndicesStart++;
										l = true
									}
								}
							}
						}
					}
				}
			}
		}
		if (l) {
			this.drawIndicesAfterPannEvent(c, n, this.layoutValidN || 0)
		}
	};
	this.drawIndicesAfterPannEvent = function(b, c, a) {
		this.functionCaller = "drawIndicesAfterPannEvent";
		if (this.isTransition()) {
			return
		}
		var d = this.layoutComb ? this.layoutParams[a] : this;
		d.varIndices = b;
		if (d.isGroupedData) {
			d.grpIndices = c
		} else {
			d.smpIndices = c
		}
		this.draw()
	};
	this.addDragDiv = function() {
		if (this.$(this.target + "-cX-Drag")) {
			return
		}
		var a = this.$cX("div", {
			id: this.target + "-cX-Drag",
			className: "CanvasXpressDrag"
		}, {
			width: "0px",
			height: "0px",
			zIndex: 9000
		});
		this.meta.canvas.ctx.canvas.parentNode.appendChild(a)
	};
	this.registerDragNetwork = function(n) {
		var d, l, g;
		var m = this.isEventIndices(n);
		var b = this.getTargetEvent(n);
		var h = n.shiftKey || this.shiftKeyMobile;
		var p = this.adjustBackNetworkObjectX(this.xMouseDown);
		var o = this.adjustBackNetworkObjectY(this.yMouseDown);
		if (m) {
			var a = this.isArray(m) ? m[0].toString() : m.toString();
			if (a && a.match(/-legend-/)) {
				if (a.match(/-legend-Nodes/)) {
					this.moveLegend = "Nodes";
					this.moveLegendX = this.data.legend.pos.nodes.x - p;
					this.moveLegendY = this.data.legend.pos.nodes.y - o
				} else {
					if (a.match(/-legend-Edges/)) {
						this.moveLegend = "Edges";
						this.moveLegendX = this.data.legend.pos.edges.x - p;
						this.moveLegendY = this.data.legend.pos.edges.y - o
					} else {
						if (a.match(/-legend-Decorations/)) {
							this.moveLegend = "Decorations";
							this.moveLegendX = this.data.legend.pos.decorations.x - p;
							this.moveLegendY = this.data.legend.pos.decorations.y - o
						} else {
							this.moveLegend = a.split(/-legend-/)[1];
							d = parseInt(this.moveLegend.replace("Text", ""));
							this.moveLegendX = this.data.legend.text[d].x - p;
							this.moveLegendY = this.data.legend.text[d].y - o
						}
					}
				}
			} else {
				if (a && a.match(/-lab$/)) {
					if (h) {
						l = true
					}
					d = a.split("-")[0]
				} else {
					if (a && a.match(/-dec$/)) {
						if (h) {
							d = a.split("-")[0];
							g = true
						} else {
							this.resetDrag(n);
							this.resetFlags(n)
						}
					} else {
						if (a && a.match(/-elbow$/)) {
							b.style.cursor = "move";
							this.moveEdge = true;
							this.moveEdgeIndex = m[0][0] - this.data.nodes.length;
							this.moveEdgeElbow = m[0][1]
						} else {
							if (a && a.match(/-resize/)) {
								d = a.split("-")[0];
								this.resizeNode = a.split("-resize")[1]
							} else {
								d = m
							}
						}
					}
				}
				if (this.moveEdge) {
					var c = this.data.edges[this.moveEdgeIndex].elbows[this.moveEdgeElbow];
					this.moveEdgeX = c[0] - p;
					this.moveEdgeY = c[1] - o
				} else {
					if (!isNaN(d) && d < this.data.nodes.length) {
						b.style.cursor = "move";
						this.moveNode = true;
						this.moveNodeIndex = d;
						if (l) {
							this.moveNodeLab = true
						} else {
							if (g) {
								this.moveNodeDec = true
							}
						}
						var f = this.data.nodes[this.moveNodeIndex];
						this.moveNodeW = f.width ? f.width : f.size ? (this.nodeSize * f.size) : this.nodeSize;
						this.moveNodeH = f.height ? f.height : f.size ? (this.nodeSize * f.size) : this.nodeSize;
						if (this.moveNodeLab) {
							this.moveNodeX = f.labelX != null ? f.labelX - p : f.labelXi - p;
							this.moveNodeY = f.labelY != null ? f.labelY - o : f.labelYi - o
						} else {
							if (this.moveNodeDec) {
								this.moveNodeX = f.decorationsX != null ? f.decorationsX - p : f.decorationsXi - p;
								this.moveNodeY = f.decorationsY != null ? f.decorationsY - o : f.decorationsYi - o
							} else {
								if (this.is3DNetwork) {
									this.moveNodeX = f.x3d - p;
									this.moveNodeY = f.y3d - o
								} else {
									this.moveNodeX = f.x - p;
									this.moveNodeY = f.y - o
								}
							}
						}
					}
				}
			}
			if (this.networkStack.length < 1 || this.networkStack.length - 1 != this.networkStackIndex) {
				var k = this.cloneObject(this.networkStack);
				var q = this.networkStackIndex;
				this.clearNetworkStack();
				for (var j = 0; j < q; j++) {
					this.networkStack.push(this.cloneObject(k[j]))
				}
				this.addToNetworkStack();
				k = false
			}
		}
	};
	this.registerDragGenome = function(b) {
		var a = this.isEventIndices(b, true);
		if (a && isNaN(a[0][0])) {
			this.moveGenome = a[0][0]
		} else {
			this.moveGenome = false
		}
	};
	this.registerDragScatter = function(c) {
		var b = this.isEventIndices(c, true);
		var d = this.xMouseDown;
		var a = this.yMouseDown;
		if (b && b.match(/-legend-/)) {
			if (b.match(/-legend-sample/)) {
				ml = "legendSample";
				mx = this["legendSampleCurX"] - d;
				my = this["legendSampleCurY"] - a
			} else {
				if (b.match(/-legend-variable/)) {
					ml = "legendVariable";
					mx = this["legendVariableCurX"] - d;
					my = this["legendVariableCurY"] - a
				} else {
					if (b.match(/-legend-indicator-color/)) {
						ml = "legendColorIndicator";
						if (c.shiftKey || this.shiftKeyMobile) {
							this.resizeLegend = true
						} else {
							mx = this["legendColorIndicatorCurX"] - d;
							my = this["legendColorIndicatorCurY"] - a
						}
					} else {
						if (b.match(/-legend-color/)) {
							ml = "legendColor";
							mx = this["legendColorCurX"] - d;
							my = this["legendColorCurY"] - a
						} else {
							if (b.match(/-legend-size/)) {
								ml = "legendSize";
								mx = this["legendSizeCurX"] - d;
								my = this["legendSizeCurY"] - a
							} else {
								if (b.match(/-legend-shape/)) {
									ml = "legendShape";
									mx = this["legendShapeCurX"] - d;
									my = this["legendShapeCurY"] - a
								} else {
									if (b.match(/-legend-pattern/)) {
										ml = "legendPattern";
										mx = this["legendPatternCurX"] - d;
										my = this["legendPatternCurY"] - a
									} else {
										if (b.match(/-legend-oncoprint/)) {
											ml = "legendOncoprint";
											mx = this["legendOncoprintCurX"] - d;
											my = this["legendOncoprintCurY"] - a
										} else {
											if (b.match(/-legend-decoration/)) {
												ml = "legendDecoration";
												mx = this["legendDecorationCurX"] - d;
												my = this["legendDecorationCurY"] - a
											} else {
												ml = this.moveLegend;
												mx = this.moveLegendX;
												my = this.moveLegendY
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.moveLegend = ml;
			this.moveLegendX = mx;
			this.moveLegendY = my
		}
	};
	this.isLegend = function(a) {
		var b = this.isEventIndices(a);
		if (b && !this.isArray(b) && b.match(/legend/)) {
			this.registerDragScatter(a)
		}
	};
	this.isMarkerDrag = function(f, b, d) {
		var g = this.isEventIndices(f);
		if (g && !this.isArray(g) && g.toString().match(/^Marker/)) {
			var c = g.split(":");
			this.skipClick = false;
			this.draggingOn = true;
			this.xMouseDown = b;
			this.yMouseDown = d;
			var a = this.getMarker(c[1]);
			this.moveMarker = c[1];
			this.moveMarkerX = a.curX - b;
			this.moveMarkerY = a.curY - d
		}
	};
	this.registerSankey = function(j, d, k) {
		var b = this.isEventIndices(j, true);
		if (b && b[0] && b[0].toString().match(/^Sankey/)) {
			var a = b[0].split(":");
			var g = this.data.sankey.nodes[a[2]];
			this.skipClick = false;
			this.draggingOn = true;
			this.xMouseDown = d;
			this.yMouseDown = k;
			this.moveSankey = g;
			this.moveSankeyMin = g.y;
			this.moveSankeyX = g.x;
			this.moveSankeyY = k;
			var c = [];
			for (var h = 0; h < this.data.sankey.nodes.length; h++) {
				var f = this.data.sankey.nodes[h];
				if (f.breadth == this.moveSankey.breadth) {
					c.push({
						idx: h,
						id: f.id,
						y: f.y,
						dy: f.dy
					})
				}
			}
			this.moveSankeyOrder = c.sort(function(i, e) {
				return i.y - e.y
			})
		}
	};
	this.registerDrag = function(r) {
		if (!r) {
			r = window.event
		}
		if (this.isCanvasResize(r)) {
			this.resizingCanvasOn = true
		} else {
			if (this.isDOE) {
				return false
			} else {
				if (!r) {
					return false
				}
				if (!this.touches) {
					this.touches = []
				}
				var b = this.getTargetEvent(r);
				var h = r.shiftKey || this.shiftKeyMobile;
				var w = this.adjustedCoordinates(r);
				if (w) {
					CanvasXpress.current = b.id;
					var k = w.x;
					var x = w.y;
					var v = 0;
					for (var n = 0; n < this.layoutRows; n++) {
						for (var m = 0; m < this.layoutCols; m++) {
							var a = this.layoutComb ? v < this.data.l.weight.length : true;
							if (a) {
								var p = this.layoutComb ? this.layoutParams[v].graphType : this.graphType;
								var u = this.getBoundsXY(v);
								this.isMarkerDrag(r, k, x);
								if (this.moveMarker) {
									return false
								}
								if (p.match(/Pie|Venn|Stacked|Area|Circular|Treemap|TagCloud|ParallelCoordinates|Tree/)) {
									if (this.meta.system.isTouchScreen) {
										if (k >= u[0] && k <= u[1] && x >= u[2] && x <= u[3] || this.moveGenome) {
											this.skipClick = false;
											this.draggingOn = true;
											this.xMouseDown = k;
											this.yMouseDown = x;
											this.touches.push([k, x, new Date().getTime()]);
											return false
										}
									} else {
										if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
											this.isLegend(r)
										} else {
											return false
										}
									}
								} else {
									if (p == "Genome") {
										this.registerDragGenome(r)
									} else {
										if (p == "Sankey") {
											this.registerSankey(r, k, x);
											return false
										}
									}
								}
								if (k >= u[0] && k <= u[1] && x >= u[2] && x <= u[3] || this.moveGenome) {
									this.skipClick = false;
									this.draggingOn = true;
									this.xMouseDown = k;
									this.yMouseDown = x;
									this.touches.push([k, x, new Date().getTime()]);
									if (p == "Correlation") {
										return false
									}
									if (p.match(/Scatter/)) {
										this.registerDragScatter(r);
										if (this.moveLegend) {
											return false
										}
									}
									if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
										this.isLegend(r);
										if (this.moveLegend) {
											return false
										}
									}
									var s = this.$(this.target + "-cX-Drag");
									if (p == "Network") {
										this.registerDragNetwork(r)
									}
									if ((!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !h) || (!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && h)) {
										s.style.left = u[0] + "px"
									} else {
										s.style.left = this.xMouseDown + "px"
									}
									if ((!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !h) || (!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && h) || p == "Genome") {
										s.style.top = u[2] + "px"
									} else {
										s.style.top = this.yMouseDown + "px"
									}
									if (this.layoutValid) {
										this.layoutValidR = n;
										this.layoutValidC = m;
										this.layoutValidN = v
									}
									return false
								} else {
									if (k >= u[4] && k <= u[5] && x >= u[6] && x <= u[7]) {
										var f = this.isEventIndices(r);
										if (f) {
											this.skipClick = false;
											this.draggingOn = true;
											this.xMouseDown = k;
											this.yMouseDown = x;
											this.touches.push([k, x, new Date().getTime()]);
											if (p == "Correlation") {
												return false
											}
											if (p.match(/Scatter/)) {
												this.registerDragScatter(r);
												if (this.moveLegend) {
													return false
												}
											}
											if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
												this.isLegend(r);
												if (this.moveLegend) {
													return false
												}
											}
											var s = this.$(this.target + "-cX-Drag");
											if (f[0].match(/^varDendrogram|^smpDendrogram/)) {
												this.moveDendrogram = f[0].split(":")[0];
												b.style.cursor = "move";
												if (f[0].match(/^varDendrogram/) || (f[0].match(/^smpDendrogram/) && this.graphOrientation == "vertical")) {
													s.style.left = u[4] + "px";
													s.style.width = (u[5] - u[4]) + "px";
													s.style.height = "3px"
												} else {
													s.style.width = "3px";
													s.style.top = u[6] + "px";
													s.style.height = (u[7] - u[6]) + "px"
												}
											} else {
												if (f[0].match("SmpOverlay")) {
													this.moveSmpOverlay = f[0];
													b.style.cursor = "move";
													if (p.match(/Heatmap/) || this.graphOrientation == "horizontal") {
														s.style.width = "3px";
														s.style.top = u[6] + "px";
														s.style.height = (u[7] - u[6]) + "px"
													} else {
														s.style.left = u[4] + "px";
														s.style.width = (u[5] - u[4]) + "px";
														s.style.height = "3px"
													}
												} else {
													if (f[0].match("Smp")) {
														this.moveSmp = f[0];
														b.style.cursor = "move";
														if (p.match(/Heatmap/) || this.graphOrientation == "horizontal") {
															s.style.left = u[4] + "px";
															s.style.width = (u[5] - u[4]) + "px";
															s.style.height = "3px"
														} else {
															s.style.width = "3px";
															s.style.top = u[6] + "px";
															s.style.height = (u[7] - u[6]) + "px"
														}
													} else {
														if (f[0].match("VarOverlay")) {
															this.moveVarOverlay = f[0];
															b.style.cursor = "move";
															s.style.left = u[4] + "px";
															s.style.width = (u[5] - u[4]) + "px";
															s.style.height = "3px"
														} else {
															if (f[0].match("Var")) {
																this.moveVar = f[0];
																b.style.cursor = "move";
																s.style.width = "3px";
																s.style.top = u[6] + "px";
																s.style.height = (u[7] - u[6]) + "px"
															}
														}
													}
												}
											}
											return false
										}
									}
								}
							}
							v++
						}
					}
					return false
				}
			}
		}
	};
	this.updateDragCircular = function(f, d, j, g, i, a) {
		this.functionCaller = "updateDragCircular";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var k = (Math.atan2(i - this.cx, a - this.cy) * 180 / Math.PI) + this.circularRotate;
		var b = (Math.atan2(d - this.cx, j - this.cy) * 180 / Math.PI);
		var h = k - b;
		this.circularRotate = h;
		this.xMouseDown = d;
		this.yMouseDown = j;
		this.skipTransition = true;
		this.draw();
		this.skipClick = true
	};
	this.updateDragScatter3D = function(e, n, g, j, a) {
		this.functionCaller = "updateDragScatter3D";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var d = j;
		var i = a;
		var b = e;
		var h = n;
		var k = this.layoutComb ? this.layoutParams[g].x : this.x;
		var f = this.layoutComb ? this.layoutParams[g].y : this.y;
		var o = ((b - d) * this.rotationSensitivity) / k;
		var m = ((h - i) * this.rotationSensitivity) / f;
		this.xRotate -= o;
		this.yRotate += m;
		this.xMouseDown = e;
		this.yMouseDown = n;
		this.skipTransition = true;
		this.draw();
		this.skipClick = true
	};
	this.updateDragScatter = function(b, d) {
		this.functionCaller = "updateDragScatter";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		if (this.resizeLegend) {
			var c = b - this.xMouseDown;
			var a = d - this.yMouseDown;
			this.heatmapIndicatorWidth += parseInt(c / 10);
			this.heatmapIndicatorHeight += parseInt(a / 10);
			this.heatmapIndicatorWidth = Math.max(10, this.heatmapIndicatorWidth);
			this.heatmapIndicatorHeight = Math.max(10, this.heatmapIndicatorHeight)
		} else {
			var e = this.moveLegend;
			var c = this[e + "CurX"] - b - this.moveLegendX;
			var a = this[e + "CurY"] - d - this.moveLegendY;
			this[e + "CurX"] -= c;
			this[e + "CurY"] -= a;
			this[e + "X"] = this[e + "CurX"];
			this[e + "Y"] = this[e + "CurY"]
		}
		this.skipTransition = true;
		this.draw();
		this.skipClick = true
	};
	this.updateDragNetwork = function(N, F, u) {
		this.functionCaller = "updateDragNetwork";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var E, r, p, C, G, q, L, J, z, H, m, i, g, P, f, O, d, B, v;
		var D = {};
		var A = this.data;
		var b = this.moveNodeX;
		var a = this.moveNodeY;
		var c = this.moveNodeW;
		var s = this.moveNodeH;
		var I = N.shiftKey || this.shiftKeyMobile;
		var j = N.ctrlKey || this.ctrlKeyMobile;
		this.movingOn = true;
		var o = this.adjustBackNetworkObjectX(F);
		var n = this.adjustBackNetworkObjectY(u);
		var K = this.getTargetEvent(N);
		F = this.adjustNetworkMouseDownX(F);
		u = this.adjustNetworkMouseDownY(u);
		K.style.cursor = I ? "se-resize" : "move";
		if (this.moveNode || this.moveEdge || this.moveLegend) {
			if (this.moveLegend) {
				J = A.legend;
				if (this.moveLegend.match("Text")) {
					C = parseInt(this.moveLegend.replace("Text", ""));
					r = J.text[C].x - o - this.moveLegendX;
					p = J.text[C].y - n - this.moveLegendY;
					J.text[C].x -= r;
					J.text[C].y -= p
				} else {
					C = this.moveLegend.toLowerCase();
					r = J.pos[C].x - o - this.moveLegendX;
					p = J.pos[C].y - n - this.moveLegendY;
					J.pos[C].x -= r;
					J.pos[C].y -= p
				}
			} else {
				if (A.edges[this.moveEdgeIndex]) {
					z = A.edges[this.moveEdgeIndex].elbows[this.moveEdgeElbow];
					r = z[0] - o - this.moveEdgeX;
					p = z[1] - n - this.moveEdgeY;
					this.modifyXYEdgeElbow(this.moveEdgeIndex, this.moveEdgeElbow, r, p)
				} else {
					if (A.nodes[this.moveNodeIndex]) {
						E = A.nodes[this.moveNodeIndex];
						if (this.moveNodeLab) {
							r = E.labelX != null ? E.labelX - o - b : E.labelXi - o - b;
							p = E.labelY != null ? E.labelY - n - a : E.labelYi - n - a;
							this.modifyXYNodeLab(E.id, r, p)
						} else {
							if (this.moveNodeDec) {
								r = E.decorationsX != null ? E.decorationsX - o - b : E.decorationsXi - o - b;
								p = E.decorationsY != null ? E.decorationsY - n - a : E.decorationsYi - n - a;
								this.modifyXYNodeDec(E.id, r, p)
							} else {
								r = this.is3DNetwork ? E.x3d - o - b : E.x - o - b;
								p = this.is3DNetwork ? E.y3d - n - a : E.y - n - a;
								if (I && !N.ctrlKey && !this.ctrlKeyMobile) {
									q = (c - r) + F;
									L = (s - p) + u;
									this.modifyNodeSize(E.id, Math.abs(q), Math.abs(L));
									for (var C in this.selectNode) {
										if (C != E.id) {
											this.modifyNodeSize(C, q, L)
										}
									}
								} else {
									if (this.resizeNode) {
										m = E.rotate != null ? E.rotate : 0;
										switch (this.resizeNode) {
											case "ROT":
												m = 180 - (Math.atan2(o - E.x, n - E.y) * 180 / Math.PI);
												q = c;
												L = s;
												r = 0;
												p = 0;
												break;
											case "TL":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s - u;
												r += F / 2;
												p += u / 2;
												break;
											case "TR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s - u;
												r += F / 2;
												p += u / 2;
												break;
											case "BL":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s + u;
												r += F / 2;
												p += u / 2;
												break;
											case "BR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s + u;
												r += F / 2;
												p += u / 2;
												break;
											case "TM":
												q = I ? (c - r) + F : c;
												L = I ? (s - p) + u : s - u;
												r = 0;
												p += u / 2;
												break;
											case "BM":
												q = I ? (c - r) + F : c;
												L = I ? (s - p) + u : s + u;
												r = 0;
												p += u / 2;
												break;
											case "ML":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s;
												r += F / 2;
												p = 0;
												break;
											case "MR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s;
												r += F / 2;
												p = 0;
												break
										}
										P = this.getNodeWidth(E);
										f = this.getNodeHeight(E);
										O = Math.abs(q) / P;
										d = Math.abs(L) / f;
										B = (Math.abs(q) - P) / 2;
										v = (Math.abs(L) - f) / 2
									}
									H = this.findParentNodes(E.id);
									if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !I && !j) || (!this.moveParentsWithChildren && I && j)) && H) {
										E = A.nodes[A.nodeIndices[H[0]]]
									}
									this.modifyXYNode(E.id, r, p);
									if (E.community != null && this.networkConvexHulls[E.community]["nodes"] && j) {
										for (var G = 0; G < this.networkConvexHulls[E.community]["nodes"].length; G++) {
											if (this.networkConvexHulls[E.community]["nodes"][G] != this.moveNodeIndex) {
												var M = A.nodes[this.networkConvexHulls[E.community]["nodes"][G]];
												this.modifyXYNode(M.id, r, p)
											}
										}
									}
									if (m != null) {
										E.rotate = m
									}
									if (this.selectNode && (this.selectNode.hasOwnProperty(E.id) || j)) {
										if (j && !this.selectNode.hasOwnProperty(E.id)) {
											this.addRemoveToSelectedDataPoints([this.moveNodeIndex])
										}
										D[E.id] = true;
										H = this.findChildrenNodeIndices(E.id);
										if (H) {
											for (var G = 0; G < H.length; G++) {
												D[A.nodes[H[G]].id] = true
											}
										}
										for (var C in this.selectNode) {
											if (!D.hasOwnProperty(C)) {
												var M = A.nodes[A.nodeIndices[C]];
												H = this.findParentNodes(M.id);
												if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !I && !j) || (!this.moveParentsWithChildren && I && j)) && H) {
													M = A.nodes[A.nodeIndices[H[0]]]
												}
												if (this.resizeNode) {
													P = this.getNodeWidth(M);
													f = this.getNodeHeight(M);
													switch (this.resizeNode) {
														case "ROT":
															B = 0;
															v = 0;
															break;
														case "TL":
															break;
														case "TR":
															break;
														case "BL":
															break;
														case "BR":
															break;
														case "TM":
															break;
														case "BM":
															break;
														case "ML":
															break;
														case "MR":
															break
													}
													this.modifyXYNode(M.id, -B, -v)
												} else {
													this.modifyXYNode(M.id, r, p)
												}
												D[M.id] = true;
												H = this.findChildrenNodeIndices(M.id);
												if (m != null) {
													M.rotate = m
												}
												if (H) {
													for (var G = 0; G < H.length; G++) {
														D[A.nodes[H[G]].id] = true
													}
												}
											}
										}
									} else {
										this.resetSelectedNodes()
									}
									if (this.resizeNode) {
										this.modifyNodeSize(E.id, Math.abs(q), Math.abs(L));
										for (var C in this.selectNode) {
											if (C != E.id) {
												var M = A.nodes[A.nodeIndices[C]];
												this.modifyNodeSize(C, this.getNodeWidth(M) * O, this.getNodeHeight(M) * d)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			this.panningX = F;
			this.panningY = u
		}
		this.skipClick = r != null || p != null ? true : false;
		this.skipTransition = true;
		this.draw(false, false, false, true);
		if (this.is3DNetwork && E) {
			this.moveNodeIndex = A.nodeIndices[E.id]
		}
	};
	this.updateDragGenome = function(a, b) {
		this.functionCaller = "updateDragGenome";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		if (this.moveGenome) {
			this.movingOn = true;
			var c = this.$(this.target + "-cX-Drag");
			c.style.left = "0px";
			c.style.width = this.width + "px";
			c.style.top = b + "px";
			c.style.height = "3px"
		} else {
			var c = (a - this.xMouseDown) / this.xAxisUnit;
			if (this.setMinX == null) {
				this.setMinX = this.xAxisMin
			}
			if (this.setMaxX == null) {
				this.setMaxX = this.xAxisMax
			}
			this.setMinX -= c;
			this.setMaxX -= c;
			this.skipTransition = true;
			this.draw();
			this.xMouseDown = a
		}
	};
	this.updateDragMarker = function(c, e) {
		this.functionCaller = "updateDragMarker";
		if (this.isTransition()) {
			return
		}
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var a = this.getMarker(this.moveMarker);
		var d = a.curX - c;
		var b = a.curY - e;
		a.curX -= d;
		a.curY -= b;
		this.moveMarkerX = a.curX;
		this.moveMarkerY = a.curY;
		a.x = Math.max(0.01, Math.min(a.curX * a.x / (a.b[0] + (a.x * a.b[2])), 1));
		a.y = Math.max(0.01, Math.min(a.curY * a.y / (a.b[1] + (a.y * a.b[3])), 1));
		this.skipTransition = true;
		this.draw();
		this.skipClick = true
	};
	this.updateDragSankey = function(b, c) {
		var a = Math.max(-this.moveSankey.y, Math.min(this.y - (this.moveSankey.y + this.moveSankey.dy), c - this.moveSankeyY));
		this.moveSankey.y += a;
		this.moveSankeyY = c;
		this.resortSankey()
	};
	this.resortSankey = function(e) {
		this.functionCaller = "resortSankey";
		if (this.isTransition()) {
			return
		}
		var d = [];
		var c = this.moveSankeyMin;
		var b = 0;
		for (var a = 0; a < this.data.sankey.nodes.length; a++) {
			var f = this.data.sankey.nodes[a];
			if (f.breadth == this.moveSankey.breadth) {
				d.push({
					idx: a,
					id: f.id,
					y: f.y,
					dy: f.dy
				});
				c = Math.min(c, f.y);
				b += f.dy + this.margin
			}
		}
		if (c + b - this.margin > this.y) {
			c = this.y - (b - this.margin)
		}
		d.sort(function(h, g) {
			return h.y - g.y
		});
		if (!this.isSameObject(d, this.moveSankeyOrder) || e) {
			for (var a = 0; a < d.length; a++) {
				var f = this.data.sankey.nodes[d[a].idx];
				if (f.id != this.moveSankey.id || e) {
					f.y = c
				}
				c += f.dy + this.margin
			}
		}
		this.data.sankey.object.relayout();
		this.draw()
	};
	this.updateDrag = function(x) {
		if (this.draggingOn) {
			if (!x) {
				x = window.event
			}
			if (this.resetOn) {
				this.resetOn = false;
				this.stopEvent(x);
				return
			}
			var u = x.shiftKey || this.shiftKeyMobile;
			var f = x.ctrlKey || this.ctrlKeyMobile;
			var p = x.altKey || this.altKeyMobile;
			var A = this.adjustedCoordinates(x);
			if (A) {
				this.touchEvent = "drag";
				var r = A.x;
				var n = A.y;
				var v = this.layoutValidR;
				var s = this.layoutValidC;
				var z = this.layoutValidN || 0;
				var h = this.layoutComb ? this.layoutParams[z] : this;
				var w = h.graphType;
				if (this.meta.system.isTouchScreen && this.wheelKeyMobile) {
					if (n < this.yMouseDown || r > this.xMouseDown) {
						this.handleWheelEvent(x, 1, A)
					} else {
						this.handleWheelEvent(x, -1, A)
					}
					return false
				} else {
					if (this.moveMarker) {
						this.updateDragMarker(r, n);
						return false
					} else {
						if (w.match(/Pie|Venn|Stacked|Area|Treemap|TagCloud|ParallelCoordinates|Tree/)) {
							if (this.meta.system.isTouchScreen) {
								this.movingOn = true;
								this.resetOn = false
							}
							if (!w.match(/Network|Genome|Venn|Correlation|Scatter/) && this.moveLegend) {
								this.updateDragScatter(r, n);
								this.movingOn = true;
								this.resetOn = false
							} else {
								return false
							}
						}
					}
				}
				if (w == "Sankey") {
					this.updateDragSankey(r, n)
				} else {
					if (w.match(/Scatter/) && this.moveLegend) {
						this.updateDragScatter(r, n)
					} else {
						if (!w.match(/Network|Genome|Venn|Correlation|Scatter/) && this.moveLegend) {
							this.updateDragScatter(r, n)
						} else {
							if ((w == "Scatter3D" && !u) || this.is3DPlot) {
								this.updateDragScatter3D(r, n, z, this.xMouseDown, this.yMouseDown)
							} else {
								if (w == "Circular") {
									if (this.moveLegend) {
										this.updateDragScatter(r, n);
										this.movingOn = true;
										this.resetOn = false
									} else {
										this.updateDragCircular(x, r, n, z, this.xMouseDown, this.yMouseDown)
									}
								} else {
									if (w == "Network" && ((this.moveNode || this.moveLegend) || (!f && !u && !p))) {
										this.updateDragNetwork(x, r, n)
									} else {
										if (w == "Genome" && (this.moveGenome || (!u))) {
											this.updateDragGenome(r, n)
										} else {
											if (w == "Map") {} else {
												if (this.moveDendrogram) {
													var o = this.getBoundsXY(z);
													var y = this.$(this.target + "-cX-Drag");
													this.skipClick = true;
													if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
														if (this.moveDendrogram == "varDendrogram" || (this.moveDendrogram == "smpDendrogram" && this.graphOrientation == "vertical")) {
															y.style.top = n + "px"
														} else {
															y.style.left = r + "px"
														}
													}
												} else {
													if (this.moveVarOverlay || this.moveSmpOverlay) {
														var o = this.getBoundsXY(z);
														var y = this.$(this.target + "-cX-Drag");
														this.skipClick = true;
														if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
															if (this.moveSmpOverlay) {
																if (w.match(/Heatmap/) || this.graphOrientation == "horizontal") {
																	y.style.left = r + "px"
																} else {
																	y.style.top = n + "px"
																}
															} else {
																y.style.top = n + "px"
															}
														}
													} else {
														if (this.moveVar || this.moveSmp) {
															var o = this.getBoundsXY(z);
															var y = this.$(this.target + "-cX-Drag");
															this.skipClick = true;
															if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
																if (this.moveSmp) {
																	if (w.match(/Heatmap/) || this.graphOrientation == "horizontal") {
																		y.style.top = n + "px"
																	} else {
																		y.style.left = r + "px"
																	}
																} else {
																	y.style.left = r + "px"
																}
															}
														} else {
															if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
																return
															}
															var q;
															if (h.varIndicesStart > 0 || h.smpIndicesStart > 0) {
																q = true
															} else {
																if (h.varIndicesStart == 0 && h.startingVarIndices && h.startingVarIndices) {
																	if (h.varIndicesStart + h.varIndices.length < h.startingVarIndices.length) {
																		q = true
																	} else {
																		q = false
																	}
																} else {
																	if (h.smpIndicesStart == 0 && h.startingSmpIndices && h.startingSmpIndices) {
																		if (h.smpIndicesStart + (h.isGroupedData ? h.grpIndices.length : h.smpIndices.length) < h.startingSmpIndices.length) {
																			q = true
																		} else {
																			q = false
																		}
																	} else {
																		q = false
																	}
																}
															}
															if (w.match(/Heatmap|Bar|Line|Dotplot|Boxplot|Correlation/) && q) {
																this.panningOn = true;
																var m = Math.abs(this.xMouseDown - r);
																var k = Math.abs(this.yMouseDown - n);
																var y = false;
																if (m > k) {
																	if (m > this.x / 20) {
																		y = this.xMouseDown > r ? 39 : 37;
																		this.xMouseDown = r;
																		this.yMouseDown = n
																	}
																} else {
																	if (k > this.y / 20) {
																		y = this.yMouseDown > n ? 40 : 38;
																		this.xMouseDown = r;
																		this.yMouseDown = n
																	}
																}
																if (y) {
																	this.handlePanning(x, y)
																}
																this.movingOn = true;
																this.resetOn = false;
																return false
															}
															if (w.match(/Correlation/)) {
																return false
															}
															var o = this.getBoundsXY(z);
															var a = w.match(/Scatter|Heatmap|Network|Genome|Circular/);
															var b = this.graphOrientation == "vertical";
															var y = this.$(this.target + "-cX-Drag");
															this.skipClick = true;
															if ((!a && b && !u) || (!a && !b && u)) {
																y.style.width = (o[1] - o[0]) + "px"
															} else {
																if (r > this.xMouseDown) {
																	if (r > o[1]) {
																		y.style.width = (o[1] - this.xMouseDown) + "px"
																	} else {
																		y.style.width = (r - this.xMouseDown) + "px"
																	}
																} else {
																	if (r < o[0]) {
																		y.style.left = o[0] + "px";
																		y.style.width = (this.xMouseDown - o[0]) + "px"
																	} else {
																		y.style.left = r + "px";
																		y.style.width = (this.xMouseDown - r) + "px"
																	}
																}
															}
															if ((!a && !b && !u) || (!a && b && u) || w == "Genome") {
																y.style.height = (o[3] - o[2]) + "px"
															} else {
																if (n > this.yMouseDown) {
																	if (n > o[3]) {
																		y.style.height = (o[3] - this.yMouseDown) + "px"
																	} else {
																		y.style.height = (n - this.yMouseDown) + "px"
																	}
																} else {
																	if (n < o[2]) {
																		y.style.top = o[2] + "px";
																		y.style.height = (this.yMouseDown - o[2]) + "px"
																	} else {
																		y.style.top = n + "px";
																		y.style.height = (this.yMouseDown - n) + "px"
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.movingOn = true;
			this.resetOn = false
		}
	};
	this.endDrag = function(z) {
		this.functionCaller = "endDrag";
		if (this.draggingOn) {
			if (this.isTransition()) {
				return
			}
			var b = this.layoutComb ? this.layoutParams[this.layoutValidN || 0].graphType : this.graphType;
			if (b.match(/Venn|Stacked|Area|Treemap|TagCloud|ParallelCoordinates|Tree/)) {
				return false
			}
			if (!z) {
				z = window.event
			}
			var j = this.$(this.target);
			if (j) {
				j.style.cursor = "default";
				var w = this.getTargetEvent(z);
				if (w && w.style) {
					w.style.cursor = "default"
				}
			}
			this.panningGlobalX += this.panningX;
			this.panningGlobalY += this.panningY;
			this.panningX = 0;
			this.panningY = 0;
			if (this.moveMarker) {
				this.resetDrag()
			} else {
				if (this.moveSankey) {
					this.resortSankey(true);
					this.resetDrag()
				} else {
					if ((b == "Scatter3D" && !z.shiftKey && !this.shiftKeyMobile) || this.is3DPlot) {
						this.resetDrag(z)
					} else {
						if (b == "Network" && (this.moveNode || this.moveEdge || this.moveLegend)) {
							if (j) {
								if (this.isSelectNodes && this.movingOn) {
									this.resetSelectedNodes();
									this.draw()
								}
								if (this.userEvents.enddragnode && this.movingOn) {
									var m;
									if (this.moveLegend) {
										m = {
											legend: this.moveLegend
										}
									} else {
										var p = this.moveNodeIndex;
										var k = this.findChildrenNodeIndices(this.data.nodes[p].id);
										if (k) {
											k.push(p)
										} else {
											k = [p]
										}
										m = this.extractDataObject(k)
									}
									this.resetDrag(z);
									this.userEvents.enddragnode.call(this, m)
								} else {
									this.resetDrag(z)
								}
								this.addToNetworkStack()
							}
						} else {
							if (b == "Genome" && (this.moveGenome || (!z.shiftKey && !this.shiftKeyMobile))) {
								if (this.movingOn && this.moveGenome) {
									var B = this.adjustedCoordinates(z);
									var C = this.subtracksInfo;
									var D = [];
									if (B) {
										var n = B.y;
										if (n != this.yMouseDown) {
											var A = this.moveGenome.replace("track-", "").split(":");
											var a = parseInt(A[0]);
											var u = A.length > 1 ? parseInt(A[1]) : null;
											for (var v = 0; v < C.length; v++) {
												if (C[v]) {
													var q = C[v].start;
													var h = C[v].track;
													var g = C[v].index;
													if (q > n) {
														if (a != h && a != h - 1) {
															if (h > a) {
																h--
															}
															var o = this.data.tracks.splice(a, 1)[0];
															this.data.tracks.splice(h, 0, o);
															this.draw()
														} else {
															if (u != null) {
																if (a == h - 1) {
																	g = C[v - 1].index;
																	g++
																}
																u = C[u].index;
																if (u != g) {
																	if (g > u) {
																		g--
																	}
																	var o = this.data.tracks[a].data.splice(u, 1)[0];
																	this.data.tracks[a].data.splice(g, 0, o);
																	this.draw()
																}
															}
														}
														break
													}
												}
											}
										}
									}
								}
								this.resetDrag(z)
							} else {
								if (b.match(/Scatter/) && this.moveLegend) {
									this.resetDrag(z)
								} else {
									if (this.moveLegend) {
										this.resetDrag(z)
									} else {
										if (this.movingOn && !this.panningOn) {
											var B = this.adjustedCoordinates(z);
											if (B) {
												var r = B.x;
												var n = B.y;
												if (r != this.xMouseDown || n != this.yMouseDown) {
													var A = this.$(this.target + "-cX-Drag");
													var y = parseInt(A.style.left);
													var f = parseInt(A.style.top);
													var x = y + parseInt(A.style.width);
													var c = f + parseInt(A.style.height);
													this.handleDragEvent(z, y, f, x, c);
													this.resetDrag(z)
												}
											}
										} else {
											this.resetDrag(z)
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			this.resetDrag(z)
		}
	};
	this.validateMinMax = function(c, a, d, b) {
		if (!isNaN(c) && !isNaN(a)) {
			if (c > a || d > c || b < a) {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.handleDragEventNetwork = function(k, c, q, a, m) {
		this.functionCaller = "handleDragEventNetwork";
		if (this.isTransition()) {
			return
		}
		var f = {};
		var j = [];
		var u = [];
		var r = [];
		var l = [];
		var p = {};
		for (var g = 0; g < this.meta.render.objects.length; g++) {
			var b = this.meta.render.objects[g];
			if (b.idx != null && this.isObjectInsideArea(b.area, c, q, a, m)) {
				if (b.idx[0] < this.data.nodes.length) {
					f[b.idx[0]] = 1
				}
			}
		}
		for (var g = 0; g < this.data.nodes.length; g++) {
			if (!f[g]) {
				j.push(this.data.nodes[g].id)
			} else {
				u.push(this.data.nodes[g].id);
				r.push(g)
			}
		}
		if (j.length < this.data.nodes.length) {
			if (k.shiftKey || this.shiftKeyMobile) {
				this.addRemoveToSelectedDataPoints(u, false, true);
				this.isSelectNodes = u.length;
				this.draw();
				this.draggingOn = false;
				this.showInfoSpan(k, "While mouse-over nodes:<br>1. Press Shift and drag mouse to resize nodes<br>2. Drag mouse to move nodes")
			} else {
				this.resetZoomPan();
				this.hideUnhideNodes(j, true);
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				this.draw(false, false, false, true)
			}
			if (this.showDataTableOnSelect) {
				if (this.networkShowDataTable == "edges") {
					for (var g = 0; g < u.length; g++) {
						p[u[g]] = 1
					}
					for (var g = 0; g < this.data.edges.length; g++) {
						if (p[this.data.edges[g].id1] || p[this.data.edges[g].id2]) {
							l.push(this.data.nodes.length + g)
						}
					}
					this.updateDataTable(this.extractDataObject(l))
				} else {
					this.updateDataTable(this.extractDataObject(r))
				}
			}
		}
	};
	this.handleDragEventHeatmap = function(k, m, f, p, b, n) {
		this.functionCaller = "handleDragEventHeatmap";
		if (this.isTransition()) {
			return
		}
		var q = [];
		var u = [];
		this.resetAxesResizer();
		var r = this.layoutComb ? this.layoutParams[m] : this;
		var h = this.cloneObject(r.varIndices);
		var l = this.isGroupedData ? this.cloneObject(r.grpIndices) : this.cloneObject(r.smpIndices);
		this.setOriginalIndices(m, h, l);
		r.varIndicesStart = r.varIndicesStart < 0 ? 0 : r.varIndicesStart;
		r.smpIndicesStart = r.smpIndicesStart < 0 ? 0 : r.smpIndicesStart;
		r.varIndices = [];
		if (r.isGroupedData) {
			r.grpIndices = []
		} else {
			r.smpIndices = []
		}
		for (var j = 0; j < this.meta.render.objects.length; j++) {
			var a = this.meta.render.objects[j];
			var g = a.area;
			if (a.idx && ((f < g[1] || f < g[3]) && b > g[1] && (p < g[2] || p < g[4]) && n > g[2])) {
				if (!q[a.idx[0]]) {
					r.varIndices.push(a.idx[0]);
					q[a.idx[0]] = 1
				}
				if (!u[a.idx[1]]) {
					if (r.isGroupedData) {
						r.grpIndices.push(a.idx[1])
					} else {
						r.smpIndices.push(a.idx[1])
					}
					u[a.idx[1]] = 1
				}
			}
		}
		if (r.varIndices.length > 0 && r.smpIndices.length > 0) {
			for (var j = 0; j < h.length; j++) {
				if (h[j] == r.varIndices[0]) {
					r.varIndicesStart += j
				}
			}
			for (var j = 0; j < l.length; j++) {
				if (r.isGroupedData) {
					if (l[j] == r.grpIndices[0]) {
						r.smpIndicesStart += j
					}
				} else {
					if (l[j] == r.smpIndices[0]) {
						r.smpIndicesStart += j
					}
				}
			}
			this.draw();
			if (this.showDataTableOnSelect) {
				var d = this.extractDataObject(this.smpIndices, this.varIndices);
				this.updateDataTable(d)
			}
			this.skipClick = false
		} else {
			r.varIndices = h;
			if (r.isGroupedData) {
				r.grpIndices = l
			} else {
				r.smpIndices = l
			}
		}
	};
	this.handleDragEventCorrelation = function(f, b, d, a, c) {
		return this.handleDragEventHeatmap(f, 0, b, d, a, c)
	};
	this.isTransformedAxis = function(c, b, a) {
		if (this[c + "Transform"]) {
			if ((this[c + "Transform"] == "log2" && !a) || (this[c + "Transform"] == "exp2" && a)) {
				this["setMin" + b] = Math.pow(2, this["setMin" + b]);
				this["setMax" + b] = Math.pow(2, this["setMax" + b])
			} else {
				if ((this[c + "Transform"] == "log10" && !a) || (this[c + "Transform"] == "exp10" && a)) {
					this["setMin" + b] = Math.pow(10, this["setMin" + b]);
					this["setMax" + b] = Math.pow(10, this["setMax" + b])
				} else {
					if ((this[c + "Transform"] == "exp2" && !a) || (this[c + "Transform"] == "log2" && a)) {
						this["setMin" + b] = Math.log(this["setMin" + b]) / Math.LN2;
						this["setMax" + b] = Math.log(this["setMax" + b]) / Math.LN2
					} else {
						if ((this[c + "Transform"] == "exp10" && !a) || (this[c + "Transform"] == "log10" && a)) {
							this["setMin" + b] = Math.log(this["setMin" + b]) / Math.LN10;
							this["setMax" + b] = Math.log(this["setMax" + b]) / Math.LN10
						}
					}
				}
			}
		}
	};
	this.isTransformedRange = function(b, a) {
		if (this[b + "Transform"]) {
			if (this[b + "Transform"] == "log2") {} else {
				if (this[b + "Transform"] == "log10") {
					return Math.log(a) / Math.LN10
				} else {
					if (this[b + "Transform"] == "exp2") {} else {
						if (this[b + "Transform"] == "exp10") {}
					}
				}
			}
		} else {
			return a
		}
	};
	this.handleDragEventScatter = function(x, y, w, k, u, h) {
		this.functionCaller = "handleDragEventScatter";
		if (this.isTransition()) {
			return
		}
		this.selectDataPoint = [];
		this.selectDataPointObject = false;
		this.selectDataPointEvent = x;
		var a = {
			v: {},
			s: {}
		};
		var m = 0;
		var n = false;
		if (x.shiftKey || this.shiftKeyMobile) {
			for (var t = 0; t < this.meta.render.objects.length; t++) {
				var p = this.meta.render.objects[t];
				if (p.idx && this.isObjectInsideArea(p.area, w, k, u, h)) {
					if (!n) {
						n = this.extractDataObject(p.idx)
					} else {
						var l = this.extractDataObject(p.idx);
						n.y.data.push(l.y.data[0]);
						n.y.vars.push(l.y.vars[0])
					}
					this.addRemoveToSelectedDataPoints(p.idx, true);
					a.v[p.idx.shift()] = 1;
					for (var r = 0; r < p.idx.length; r++) {
						a.s[p.idx[r]] = 1
					}
					m++
				}
			}
			if (m > 0) {
				this.isSelectDataPoints = m;
				this.selectDataPointObject = n;
				this.handleUserSelectEvent();
				this.broadcastDraw();
				if (this.showDataTableOnSelect) {
					var q = [];
					var v = [];
					for (t in a.v) {
						q.push(parseInt(t))
					}
					for (t in a.s) {
						v.push(parseInt(t))
					}
					q.sort(function(e, c) {
						return (e - c)
					});
					v.sort(function(e, c) {
						return (e - c)
					});
					var n = this.extractDataObject(v, q);
					this.updateDataTable(n)
				}
			}
		} else {
			var n = this.layoutComb ? this.layoutParams[y] : this;
			var g = n.xAxisMin + ((w - (this.marginLeft + n.offsetX + n.left)) / n.xAxisUnit);
			var f = n.xAxisMin + ((u - (this.marginLeft + n.offsetX + n.left)) / n.xAxisUnit);
			var b = n.yAxisMax - ((k - (this.marginTop + n.offsetY + n.top)) / n.yAxisUnit);
			var d = n.yAxisMax - ((h - (this.marginTop + n.offsetY + n.top)) / n.yAxisUnit);
			if (this.validateMinMax(g, f, n.xAxisMin, n.xAxisMax) && this.validateMinMax(d, b, n.yAxisMin, n.yAxisMax)) {
				n = this.layoutComb && this.layoutAdjust ? this.layoutParams[y] : this;
				n.setMinX = g;
				n.setMaxX = f;
				n.setMaxY = b;
				n.setMinY = d;
				this.isTransformedAxis("xAxis", "X");
				this.isTransformedAxis("yAxis", "Y");
				this.draw()
			}
		}
	};
	this.handleDragEventGenome = function(f, h, d, j, a, i) {
		this.functionCaller = "handleDragEventGenome";
		if (this.isTransition()) {
			return
		}
		var g, k;
		var b = this.layoutComb ? this.layoutParams[h] : this;
		var g = b.xAxisMin + ((d - (this.marginLeft + b.offsetX + b.left)) / b.xAxisUnit);
		var k = b.xAxisMin + ((a - (this.marginLeft + b.offsetX + b.left)) / b.xAxisUnit);
		if (this.validateMinMax(g, k, this.xAxisMin, this.xAxisMax)) {
			this.setMinX = g;
			this.setMaxX = k;
			this.draw()
		}
	};
	this.handleDragEventOneDimension = function(L, N, j, a, h, P, l) {
		this.functionCaller = "handleDragEventOneDimension";
		if (this.isTransition()) {
			return
		}
		var z = this.graphType;
		if (this.moveDendrogram) {
			var b = this.layoutComb ? this.layoutParams[N] : this;
			var v;
			if (this.moveDendrogram == "varDendrogram") {
				v = a > this.marginTop + b.offsetY + b.top + b.y ? "bottom" : "top";
				if (this.varDendrogramPosition != v) {
					this.varDendrogramPosition = v;
					this.draw()
				}
			} else {
				if (z == "Heatmap" || this.graphOrientation == "horizontal") {
					v = j > this.marginLeft + b.offsetX + b.left + b.x ? "right" : "left"
				} else {
					v = a > this.marginTop + b.offsetY + b.top + b.y ? "bottom" : "top"
				}
				if (this.smpDendrogramPosition != v) {
					this.smpDendrogramPosition = v;
					this.draw()
				}
			}
			this.skipClick = false
		} else {
			if (this.moveVarOverlay) {
				var b = this.layoutComb ? this.layoutParams[N] : this;
				var x = this.moveVarOverlay.split("-")[1];
				var u = this.varOverlays[x];
				var v = a < this.marginTop + b.offsetY + b.top ? "top" : "bottom";
				this.varOverlays.splice(x, 1);
				var M = this.varOverlays.length;
				for (var G = 0; G < this.varOverlays.length; G++) {
					var F = this.varOverlays[G];
					if (this.varOverlayInfo[F] > a) {
						M = G;
						break
					}
				}
				this.varOverlays.splice(M, 0, u);
				this.varOverlayProperties[u]["position"] = v;
				this.draw();
				this.skipClick = false
			} else {
				if (this.moveVar) {
					var x = this.moveVar.split("-")[1];
					if (this.showVarDendrogram && this.varDendrogram) {
						alert("Ooops. Cannot change order when showing the dendrogram");
						return false
					}
					var K = this.layoutComb ? this.layoutParams[N].varIndices : this.varIndices;
					var J = this.layoutComb ? this.layoutParams[N].varInfo : this.varInfo;
					var M;
					var d = [];
					if (this.moveVar.match(/VarOvr/)) {
						var q = this.moveVar.split("-")[2];
						var g = this.data.z[this.varOverlays[q]];
						for (var G = 0; G < K.length; G++) {
							if (K[G] == x) {
								M = G;
								break
							}
						}
						if (M > 0) {
							while (M > 0 && g[K[M - 1]] == g[K[M]]) {
								M--
							}
						}
						d = [M];
						while (g[K[M + 1]] == g[K[M]]) {
							M++;
							d.push(M)
						}
					} else {
						for (var G = 0; G < K.length; G++) {
							if (K[G] == x) {
								M = G;
								break
							}
						}
						d = [M]
					}
					d = K.splice(d[0], d.length);
					J.splice(d[0], d.length);
					for (var G = 0; G < K.length; G++) {
						if (J[G] > j) {
							M = G;
							break
						}
					}
					for (var G = 0; G < d.length; G++) {
						K.splice(M + G, 0, d[G])
					}
					this.draw();
					this.skipClick = false
				} else {
					if (this.moveSmpOverlay) {
						var p, v;
						var b = this.layoutComb ? this.layoutParams[N] : this;
						var x = this.moveSmpOverlay.split("-")[1];
						var u = this.smpOverlays[x];
						if (z.match(/Heatmap/) || this.graphOrientation == "horizontal") {
							p = j;
							v = p > this.marginLeft + b.offsetX + b.left + b.x ? "right" : "left"
						} else {
							p = a;
							v = p < this.marginTop + b.offsetY + b.top ? "top" : "bottom"
						}
						this.smpOverlays.splice(x, 1);
						var M = this.smpOverlays.length;
						for (var G = 0; G < this.smpOverlays.length; G++) {
							var F = this.smpOverlays[G];
							if (this.smpOverlayInfo[F] > p) {
								M = G;
								break
							}
						}
						this.smpOverlays.splice(M, 0, u);
						this.smpOverlayProperties[u]["position"] = v;
						this.draw();
						this.skipClick = false
					} else {
						if (this.moveSmp) {
							var x = this.moveSmp.split("-")[1];
							var I;
							var f = this.layoutComb ? this.layoutParams[N].smpInfo : this.smpInfo;
							if (this.layoutComb) {
								this.layoutParams[N].dragged = true
							}
							if (this.isGroupedData) {
								I = this.layoutComb ? this.layoutParams[N].grpIndices : this.grpIndices
							} else {
								I = this.layoutComb ? this.layoutParams[N].smpIndices : this.smpIndices;
								if (this.showSmpDendrogram && this.smpDendrogram) {
									alert("Ooops. Cannot change order when showing the dendrogram");
									return false
								}
							}
							var M;
							var d = [];
							if (this.moveSmp.match(/SmpOvr/)) {
								var q = this.moveSmp.split("-")[2];
								var g = this.isGroupedData ? this.data.w.factors[this.smpOverlays[q]] : this.data.x[this.smpOverlays[q]];
								for (var G = 0; G < I.length; G++) {
									if (I[G] == x) {
										M = G;
										break
									}
								}
								if (M > 0) {
									while (M > 0 && g[I[M - 1]] == g[I[M]]) {
										M--
									}
								}
								d = [M];
								while (g[I[M + 1]] == g[I[M]]) {
									M++;
									d.push(M)
								}
							} else {
								for (var G = 0; G < I.length; G++) {
									if (I[G] == x) {
										M = G;
										break
									}
								}
								d = [M]
							}
							d = I.splice(d[0], d.length);
							f.splice(d[0], d.length);
							var p = z.match(/Heatmap/) || this.graphOrientation == "horizontal" ? a : j;
							for (var G = 0; G < I.length; G++) {
								if (f[G] > p) {
									M = G;
									break
								}
							}
							for (var G = 0; G < d.length; G++) {
								I.splice(M + G, 0, d[G])
							}
							this.draw();
							this.skipClick = false
						} else {
							if (L.shiftKey || this.shiftKeyMobile || l) {
								var E = {};
								var k = [];
								var I;
								var K = this.layoutComb ? this.layoutParams[N].varIndices : this.varIndices;
								var H = this.isGroupedData ? this.grpIndices : this.smpIndices;
								var w = false;
								if (this.isGroupedData) {
									I = this.layoutComb ? this.layoutParams[N].grpIndices : this.grpIndices
								} else {
									I = this.layoutComb ? this.layoutParams[N].smpIndices : this.smpIndices
								}
								this.setOriginalIndices(N, K, I);
								for (var G = 0; G < this.meta.render.objects.length; G++) {
									var A = this.meta.render.objects[G];
									if (A.idx && this.isObjectInsideArea(A.area, j, a, h, P)) {
										E[A.idx[1]] = true
									}
								}
								for (var G = 0; G < H.length; G++) {
									if (E.hasOwnProperty(H[G])) {
										k.push(H[G]);
										if (!w) {
											this.smpIndicesStart = G;
											w = true
										}
									}
								}
								this.setSamplesVisible(k, true);
								this.draw();
								if (this.showDataTableOnSelect) {
									var F = this.extractDataObject(k, this.varIndices);
									this.updateDataTable(F)
								}
							} else {
								var F = this.layoutComb ? this.layoutParams[N] : this;
								var D = z == "Candlestick" && N > 0 && this.showVolume;
								var y = this.layoutComb && this.layoutCurrent != N;
								var O = D && y ? F.xAxis2Min : F.xAxisMin;
								var r = D && y ? F.xAxis2Max : F.xAxisMax;
								var C = this.marginLeft + F.offsetX + F.left;
								var n = C + F.x;
								var B = this.marginTop + F.offsetY + F.top;
								var m = B + F.y;
								if (this.graphOrientation == "vertical") {
									O = D ? O + (Math.max(m - P, 0) / F.xAxis2Unit) : O + (Math.max(m - P, 0) / F.xAxisUnit);
									r = D ? r - (Math.max(a - B, 0) / F.xAxis2Unit) : r - (Math.max(a - B, 0) / F.xAxisUnit)
								} else {
									O = D ? O + (Math.max(j - C, 0) / F.xAxis2Unit) : O + (Math.max(j - C, 0) / F.xAxisUnit);
									r = D ? r - (Math.max(n - h, 0) / F.xAxis2Unit) : r - (Math.max(n - h, 0) / F.xAxisUnit)
								}
								if (this.validateMinMax(O, r, this.xAxisMin, this.xAxisMax)) {
									F = this.layoutComb && this.layoutAdjust ? this.layoutParams[N] : this;
									if (D) {
										F.setMinX2 = O;
										F.setMaxX2 = r
									} else {
										F.setMinX = O;
										F.setMaxX = r
									}
									this.draw()
								}
							}
						}
					}
				}
			}
		}
	};
	this.handleDragEvent = function(h, b, f, a, d) {
		var i = this.layoutComb ? this.layoutValidN : 0;
		var g = this.layoutComb ? this.layoutParams[i].graphType : this.graphType;
		if (g == "Correlation") {
			this.handleDragEventCorrelation(h, b, f, a, d)
		} else {
			if (g == "Network") {
				this.handleDragEventNetwork(h, b, f, a, d)
			} else {
				if (g == "Heatmap" && !this.moveDendrogram && !this.moveVar && !this.moveSmp && !this.moveVarOverlay && !this.moveSmpOverlay) {
					this.handleDragEventHeatmap(h, i, b, f, a, d)
				} else {
					if (g.match(/Scatter/)) {
						this.handleDragEventScatter(h, i, b, f, a, d)
					} else {
						if (g == "Genome") {
							this.handleDragEventGenome(h, i, b, f, a, d)
						} else {
							this.handleDragEventOneDimension(h, i, b, f, a, d)
						}
					}
				}
			}
		}
	};
	this.resetDrag = function(a) {
		var b = this.$(this.target + "-cX-Drag");
		if (b) {
			b.style.left = "0px";
			b.style.top = "0px";
			b.style.width = "0px";
			b.style.height = "0px"
		}
	};
	this.initializeDraggingEvents = function() {
		if (!this.disableEvents) {
			this.addDragDiv()
		}
	};
	this.initializeDraggingEvents()
};
CanvasXpress.prototype.initKeyEvents = function() {
	this.getKeyCode = function(a) {
		if (a) {
			if ((a.charCode) && (a.keyCode == 0)) {
				return a.charCode
			} else {
				return a.keyCode
			}
		}
	};
	this.registerKey = function(g) {
		if (!g) {
			g = window.event
		}
		var b = this.getTargetEvent(g);
		var d = g.shiftKey || this.shiftKeyMobile;
		var f = g.ctrlKey || this.ctrlKeyMobile;
		var a = g.altKey || this.altKeyMobile;
		var h = this.getKeyCode(g);
		if (this.eventKeys || (f && a && h == 107)) {
			if (h == 13) {
				return
			} else {
				if (h == 27) {
					if (this.animationOn) {
						this.animationOn = false;
						return false
					}
					if (f) {
						this.resetFilters()
					}
					this.masterReset(g)
				} else {
					if (h == 16 && this.helpKeyEvents) {
						if (f && a) {
							this.showCtrlShiftAltShorts()
						} else {
							if (f) {
								this.showCtrlShiftShorts()
							} else {
								if (a) {
									this.showShiftAltShorts()
								} else {
									this.showShiftShorts()
								}
							}
						}
					} else {
						if (h == 17 && this.helpKeyEvents) {
							if (d && a) {
								this.showCtrlShiftAltShorts()
							} else {
								if (d) {
									this.showCtrlShiftShorts()
								} else {
									if (a) {
										this.showCtrlAltShorts()
									} else {
										this.showCtrlShorts()
									}
								}
							}
						} else {
							if ((h == 18 || h == 224) && this.helpKeyEvents) {
								if (f && d) {
									this.showCtrlShiftAltShorts()
								} else {
									if (f) {
										this.showCtrlAltShorts()
									} else {
										if (d) {
											this.showShiftAltShorts()
										} else {
											this.showAltShorts()
										}
									}
								}
							} else {
								if (f && d) {
									if (h >= 33 && h <= 40) {
										this.arrowMove(h, true)
									} else {
										if (h == 80 && !this.keyOn) {
											this.keyOn = true;
											this.print()
										} else {
											if (h == 88 && !this.keyOn) {
												this.keyOn = true;
												this.clearNetworkStack()
											} else {
												if (h == 90 && this.graphType == "Network" && !this.keyOn) {
													this.keyOn = true;
													this.alignDistributeSelectedNodes(g, h)
												}
											}
										}
									}
									document.defaultAction = true
								} else {
									if (f && a) {
										if (h == 80 && !this.keyOn) {
											this.keyOn = true;
											this.print()
										} else {
											if (h == 82) {
												this.reproduce()
											}
										}
										document.defaultAction = true
									} else {
										if (d && a) {
											if (h >= 50 && h < 90 && !this.keyOn) {
												this.keyOn = true;
												this.setGraphType(h)
											}
											document.defaultAction = true
										} else {
											if (f) {
												if (h >= 33 && h <= 40) {
													if (h == 36 && this.isSelectDataPoints && this.graphType == "Scatter3D") {
														this.showHideSelectedDataPoint(g, h)
													} else {
														if (h == 36 && this.isSelectNodes && this.graphType == "Network") {
															this.showHideSelectedDataPoint(g, h)
														} else {
															this.arrowMove(h)
														}
													}
												} else {
													if ((h == 45 || h == 46) && !this.keyOn) {
														this.keyOn = true;
														this.showHideSelectedDataPoint(g, h)
													} else {
														if ((h >= 48 && h < 58) && !this.keyOn) {
															this.keyOn = true
														} else {
															if (h >= 65 && h <= 90) {
																if (h == 80 && !this.keyOn) {
																	this.keyOn = true;
																	this.print()
																}
																if (this.graphType == "Network" && !this.keyOn && !/input|textarea|select/i.test(b.tagName)) {
																	this.keyOn = true;
																	this.alignDistributeSelectedNodes(g, h)
																}
															}
														}
													}
												}
												document.defaultAction = true
											} else {
												if (h == 107 || h == 109 || h == 61 || h == 187 || h == 189) {
													if (this.eventPlusMinusKeys && !/input|textarea|select/i.test(b.tagName)) {
														if (h == 109 || h == 189) {
															this.handleWheelEvent(g, -1)
														} else {
															this.handleWheelEvent(g, 1)
														}
													}
												} else {
													if (d && h >= 33 && h <= 40) {
														if (this.eventArrowKeys && !/input|textarea|select/i.test(b.tagName)) {
															this.handlePanning(g, h)
														} else {
															document.defaultAction = true
														}
													} else {
														if (h >= 36 && h <= 40) {
															if (this.eventArrowKeys && !/input|textarea|select/i.test(b.tagName)) {
																this.handlePanning(g, h)
															}
														} else {
															if (d) {
																document.defaultAction = true
															} else {
																if (a) {
																	document.defaultAction = true
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.handlePanning = function(d, g) {
		this.functionCaller = "handlePanning";
		if (this.isTransition()) {
			return
		}
		if (this.graphType == "Correlation" || this.graphType == "Heatmap" || this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
			this.cancelEvent(d);
			this.resetAxesResizer(d);
			if (this.layoutComb && !this.layoutAdjust && this.graphType != "Correlation" && this.graphType != "Heatmap") {
				return false
			}
			this.setIndicesAfterPannEvent(d, g)
		} else {
			if (this.graphType == "Network") {
				this.cancelEvent(d);
				var a = Math.abs(this.x * this.panningStep);
				var f = Math.abs(this.y * this.panningStep);
				if (g == 33) {
					this.panningY -= f * 5
				} else {
					if (g == 34) {
						this.panningY += f * 5
					} else {
						if (g == 35) {
							this.panningX = a * 20;
							this.panningY = f * 20
						} else {
							if (g == 36) {
								this.panningX = 0;
								this.panningY = 0
							} else {
								if (g == 37) {
									this.panningX -= a
								} else {
									if (g == 38) {
										this.panningY -= f
									} else {
										if (g == 39) {
											this.panningX += a
										} else {
											if (g == 40) {
												this.panningY += f
											}
										}
									}
								}
							}
						}
					}
				}
				this.draw(false, false, false, true)
			} else {
				if (this.graphType == "Genome") {
					var b = this.genomeResolution == "high" ? 1 : this.xAxisRange * this.panningStep;
					if (this.setMinX == null) {
						this.setMinX = this.xAxisMin
					}
					if (this.setMaxX == null) {
						this.setMaxX = this.xAxisMax
					}
					this.cancelEvent(d);
					if (g == 37 || g == 38) {
						this.setMinX -= b;
						this.setMaxX -= b
					} else {
						if (g == 39 || g == 40) {
							this.setMinX += b;
							this.setMaxX += b
						} else {
							if (g == 33) {
								this.setMinX += this.xAxisRange * 0.95;
								this.setMaxX += this.xAxisRange * 0.95
							} else {
								if (g == 34) {
									this.setMinX -= this.xAxisRange * 0.95;
									this.setMaxX -= this.xAxisRange * 0.95
								} else {
									if (g == 35) {
										this.setMaxX = null
									} else {
										if (g == 36) {
											this.setMinX = null
										}
									}
								}
							}
						}
					}
					this.draw()
				}
			}
		}
		return false
	};
	this.showCtrlShiftAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl + Shift + Alt</th></tr>";
		a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlShiftShorts = function() {
		var b = this.rotationStep;
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift + Ctrl</th></tr>";
		if (this.graphType == "Network") {
			if (this.is3DNetwork) {
				a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg; continuously</td></tr>"
			} else {
				a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (b * 3) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (b * 3) + "&deg; continuously</td></tr>"
			}
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
				if (this.type2D == "XYZ") {
					if (this.xAxis.length > 1) {
						a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes continuously (1x)</td></tr>";
						a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes continuously (2x)</td></tr>"
					}
				} else {
					if (this.type2D == "XY") {
						if (this.zAxis.length > 1) {
							a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis continuously (1x)</td></tr>";
							a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis continuously (2x)</td></tr>"
						}
					} else {
						if (this.type2D == "X") {
							if (this.yAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes continuously (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes continuously (2x)</td></tr>"
							}
						} else {
							if (this.xAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes continuously (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes continuously (2x)</td></tr>"
							}
						}
					}
				}
			} else {
				if (this.graphType == "Scatter3D") {
					a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Rotate continuously</td></tr>";
					a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Rotate continuously</td></tr>"
				}
			}
		}
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl + Alt</th></tr>";
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showShiftAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift + Alt</th></tr>";
		a += "<tr><td class=k>2</td><td class=d>Scatter2D</td></tr>";
		a += "<tr><td class=k>3</td><td class=d>Scatter3D</td></tr>";
		a += "<tr><td class=k>4</td><td class=d>ScatterBubble2D</td></tr>";
		a += "<tr><td class=k>A</td><td class=d>Area</td></tr>";
		a += "<tr><td class=k>B</td><td class=d>Bar</td></tr>";
		a += "<tr><td class=k>C</td><td class=d>BarLine</td></tr>";
		a += "<tr><td class=k>D</td><td class=d>Dotplot</td></tr>";
		a += "<tr><td class=k>E</td><td class=d>DotLine</td></tr>";
		a += "<tr><td class=k>F</td><td class=d>AreaLine</td></tr>";
		a += "<tr><td class=k>G</td><td class=d>Genome</td></tr>";
		a += "<tr><td class=k>H</td><td class=d>Heatmap</td></tr>";
		a += "<tr><td class=k>I</td><td class=d>Boxplot</td></tr>";
		a += "<tr><td class=k>L</td><td class=d>Line</td></tr>";
		a += "<tr><td class=k>M</td><td class=d>Candlestick</td></tr>";
		a += "<tr><td class=k>N</td><td class=d>Network</td></tr>";
		a += "<tr><td class=k>P</td><td class=d>Pie</td></tr>";
		a += "<tr><td class=k>R</td><td class=d>Circular</td></tr>";
		a += "<tr><td class=k>S</td><td class=d>Stacked</td></tr>";
		a += "<tr><td class=k>T</td><td class=d>StackedPercent</td></tr>";
		a += "<tr><td class=k>U</td><td class=d>StackedLine</td></tr>";
		a += "<tr><td class=k>W</td><td class=d>StackedPercentLine</td></tr>";
		a += "<tr><td class=k>V</td><td class=d>Venn</td></tr>";
		a += "<tr><td class=k>X</td><td class=d>Correlation</td></tr>";
		a += "<tr><td class=k>Y</td><td class=d>Treemap</td></tr>";
		a += "<tr><td class=k>Z</td><td class=d>TagCloud</td></tr>";
		a += "<tr><td class=k>J</td><td class=d>ParallelCoordinates</td></tr>";
		a += "<tr><td class=k>K</td><td class=d>Sankey</td></tr>";
		a += "<tr><td class=k>Q</td><td class=d>Tree</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlShorts = function() {
		var b = this.rotationStep;
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl</th></tr>";
		if (this.graphType == "Network") {
			if (this.is3DNetwork) {
				a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg;</td></tr>"
			} else {
				a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (b * 3) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (b * 3) + "&deg;</td></tr>"
			}
			a += "<tr><td class=k>click</td><td class=d>Select/Unselect node</td></tr>";
			if (this.isSelectNodes) {
				a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
				a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
				a += "<tr><td class=k>Home</td><td class=d>Show connected nodes to slected nodes</td></tr>";
				a += "<tr><td class=k>t</td><td class=d>Align top</td></tr>";
				a += "<tr><td class=k>r</td><td class=d>Align right</td></tr>";
				a += "<tr><td class=k>b</td><td class=d>Align bottom</td></tr>";
				a += "<tr><td class=k>l</td><td class=d>Align left</td></tr>";
				a += "<tr><td class=k>v</td><td class=d>Distribute verticaly</td></tr>";
				a += "<tr><td class=k>h</td><td class=d>Distribute Horizontaly</td></tr>";
				a += "<tr><td class=k>z</td><td class=d>Undo</td></tr>";
				a += "<tr><td class=k>y</td><td class=d>Redo</td></tr>"
			}
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
				if (this.type2D == "XYZ") {
					if (this.xAxis.length > 1) {
						a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes (1x)</td></tr>";
						a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes (2x)</td></tr>"
					}
				} else {
					if (this.type2D == "XY") {
						if (this.zAxis.length > 1) {
							a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis (1x)</td></tr>";
							a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis (2x)</td></tr>"
						}
					} else {
						if (this.type2D == "X") {
							if (this.yAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes (2x)</td></tr>"
							}
						} else {
							if (this.xAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes (2x)</td></tr>"
							}
						}
					}
				}
				if (this.isSelectDataPoints) {
					a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
					a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>"
				}
			} else {
				if (this.graphType == "Scatter3D") {
					a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg;</td></tr>";
					a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg;</td></tr>";
					a += "<tr><td class=k>click</td><td class=d>Select/Unselect data points</td></tr>";
					if (this.isSelectDataPoints) {
						a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
						a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
						a += "<tr><td class=k>Home</td><td class=d>Zoom to selected nodes</td></tr>"
					}
				} else {
					if (this.isSegregable()) {}
				}
			}
		}
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showShiftShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift</th></tr>";
		if (this.isSegregable()) {
			a += "<tr><td class=k>Click and Drag</td><td class=d>Select Samples</td></tr>"
		} else {
			a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>"
		}
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Alt</th></tr>";
		a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.arrowMove = function(k, b) {
		this.functionCaller = "arrowMove";
		if (this.isTransition()) {
			return
		}
		var f = this.graphType;
		if (this.is3DPlot) {
			f = "Scatter3D"
		}
		var e = this.rotationStep;
		switch (f) {
			case "Network":
				if (this.is3DNetwork) {
					if (k == 33) {
						this.xRotate += (e * 3);
						this.yRotate -= (e * 3)
					} else {
						if (k == 34) {
							this.xRotate -= (e * 3);
							this.yRotate += (e * 3)
						} else {
							if (k == 37) {
								this.xRotate += e
							} else {
								if (k == 38) {
									this.yRotate -= e
								} else {
									if (k == 39) {
										this.xRotate -= e
									} else {
										if (k == 40) {
											this.yRotate += e
										}
									}
								}
							}
						}
					}
				} else {
					if (k == 33) {
						this.network2DRotate -= (e * 3)
					} else {
						if (k == 34) {
							this.network2DRotate += (e * 3)
						} else {
							if (k == 37 || k == 38) {
								this.network2DRotate -= e
							} else {
								if (k == 39 || k == 40) {
									this.network2DRotate += e
								}
							}
						}
					}
				}
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
				var h;
				var j;
				if (this.type2D == "XYZ") {
					h = ["xAxisCurrent", "yAxisCurrent", "zAxisCurrent"];
					j = ["xAxis", "yAxis", "zAxis"]
				} else {
					if (this.type2D == "XY") {
						h = ["zAxisCurrent"];
						j = ["zAxis"]
					} else {
						if (this.type2D == "X") {
							h = ["yAxisCurrent", "zAxisCurrent"];
							j = ["yAxis", "zAxis"]
						} else {
							h = ["xAxisCurrent", "zAxisCurrent"];
							j = ["xAxis", "zAxis"]
						}
					}
				}
				if (k == 33) {
					for (var d = 0; d < h.length; d++) {
						this[h[d]] += 2
					}
				} else {
					if (k == 34) {
						for (var d = 0; d < h.length; d++) {
							this[h[d]] -= 2
						}
					} else {
						if (k == 35) {
							for (var d = 0; d < h.length; d++) {
								this[h[d]] = this[j[d]].length - 1
							}
						} else {
							if (k == 36) {
								for (var d = 0; d < h.length; d++) {
									this[h[d]] = 0
								}
							} else {
								if (k == 37 || k == 40) {
									for (var d = 0; d < h.length; d++) {
										this[h[d]]--
									}
								} else {
									if (k == 38 || k == 39) {
										for (var d = 0; d < h.length; d++) {
											this[h[d]]++
										}
									}
								}
							}
						}
					}
				}
				this.xAxisCurrent = this.xAxisCurrent < 0 ? this.xAxis.length - 1 : this.xAxisCurrent > this.xAxis.length - 1 ? 0 : this.xAxisCurrent;
				this.yAxisCurrent = this.yAxisCurrent < 0 ? this.xAxis.length - 1 : this.yAxisCurrent > this.yAxis.length - 1 ? 0 : this.yAxisCurrent;
				this.zAxisCurrent = this.zAxisCurrent < 0 ? this.xAxis.length - 1 : this.zAxisCurrent > this.zAxis.length - 1 ? 0 : this.zAxisCurrent;
				break;
			case "Scatter3D":
				if (k == 33) {
					this.xRotate += (e * 3);
					this.yRotate -= (e * 3)
				} else {
					if (k == 34) {
						this.xRotate -= (e * 3);
						this.yRotate += (e * 3)
					} else {
						if (k == 35) {
							this.xRotate = 0;
							this.yRotate = 0;
							this.zRotate = 45
						} else {
							if (k == 36) {
								this.xRotate = 45;
								this.yRotate = 0;
								this.zRotate = 0
							} else {
								if (k == 37) {
									this.xRotate += e
								} else {
									if (k == 38) {
										this.yRotate -= e
									} else {
										if (k == 39) {
											this.xRotate -= e
										} else {
											if (k == 40) {
												this.yRotate += e
											}
										}
									}
								}
							}
						}
					}
				}
				break
		}
		if (b && !this.animationOn) {
			this.animationOn = true;
			this.animate(k)
		} else {
			this.draw(false, false, false, true)
		}
	};
	this.animate = function(d) {
		var a = this;
		var b = function() {
			this.update = function() {
				if (!a.animationOn) {
					clearInterval(c)
				}
				a.arrowMove(d);
				var f = a.graphType;
				if (a.is3DPlot) {
					f = "Scatter3D"
				}
				var e = this.rotationStep;
				switch (f) {
					case "Network":
						if (this.is3DNetwork) {
							if (d == 33) {
								this.xRotate += (e * 3);
								this.yRotate -= (e * 3)
							} else {
								if (d == 34) {
									this.xRotate -= (e * 3);
									this.yRotate += (e * 3)
								} else {
									if (d == 37) {
										this.xRotate -= e
									} else {
										if (d == 38) {
											this.yRotate -= e
										} else {
											if (d == 39) {
												this.xRotate += e
											} else {
												if (d == 40) {
													this.yRotate += e
												}
											}
										}
									}
								}
							}
						} else {
							if (d == 33) {
								this.network2DRotate += (e * 3)
							} else {
								if (d == 34) {
									this.network2DRotate -= (e * 3)
								} else {
									if (d == 37 || d == 38) {
										this.network2DRotate -= e
									} else {
										if (d == 39 || d == 40) {
											this.network2DRotate += e
										}
									}
								}
							}
						}
						break;
					case "Scatter2D":
					case "ScatterBubble2D":
						if (d != 37) {
							if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
								if (a.xAxisCurrent >= a.xAxis.length - 1) {
									a.xAxisCurrent = a.xAxis.length - 1;
									a.yAxisCurrent = a.yAxis.length - 1;
									a.zAxisCurrent = a.zAxis.length - 1;
									d = 37
								}
							} else {
								if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
									if (a.zAxisCurrent >= a.zAxis.length - 1) {
										a.zAxisCurrent = a.zAxis.length - 1;
										d = 37
									}
								} else {
									if (a.xAxisIndices.length > a.yAxisIndices.length) {
										if (a.yAxisCurrent >= a.yAxis.length - 1) {
											a.yAxisCurrent = a.yAxis.length - 1
										}
										if (a.zAxisCurrent >= a.zAxis.length - 1) {
											a.zAxisCurrent = a.zAxis.length - 1
										}
										if (a.yAxisCurrent >= a.yAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
											d = 37
										}
									} else {
										if (a.xAxisCurrent >= a.xAxis.length - 1) {
											a.xAxisCurrent = a.xAxis.length - 1
										}
										if (a.zAxisCurrent >= a.zAxis.length - 1) {
											a.zAxisCurrent = a.zAxis.length - 1
										}
										if (a.xAxisCurrent >= a.xAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
											d = 37
										}
									}
								}
							}
						} else {
							if (d != 39) {
								if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
									if (a.xAxisCurrent <= 0) {
										a.xAxisCurrent = 0;
										a.yAxisCurrent = 0;
										a.zAxisCurrent = 0;
										d = 39
									}
								} else {
									if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
										if (a.zAxisCurrent <= 0) {
											a.zAxisCurrent = 0;
											d = 39
										}
									} else {
										if (a.xAxisIndices.length > a.yAxisIndices.length) {
											if (a.yAxisCurrent <= 0) {
												a.yAxisCurrent = 0
											}
											if (a.zAxisCurrent <= 0) {
												a.zAxisCurrent = 0
											}
											if (a.yAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
												d = 39
											}
										} else {
											if (a.xAxisCurrent <= 0) {
												a.xAxisCurrent = 0
											}
											if (a.zAxisCurrent <= 0) {
												a.zAxisCurrent = 0
											}
											if (a.xAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
												d = 39
											}
										}
									}
								}
							}
						}
						break;
					case "Scatter3D":
						if (a.xRotate <= 0 && (d == 39 || d < 37)) {
							a.xRotate = 0;
							a.yRotate = 0;
							d = 40
						} else {
							if (a.xRotate >= 90 && (d == 37 || d < 37)) {
								a.xRotate = 90;
								a.yRotate = 90;
								d = 38
							} else {
								if (a.yRotate <= 0 && (d == 38 || d < 37)) {
									a.yRotate = 0;
									a.xRotate = 90;
									d = 39
								} else {
									if (a.yRotate >= 90 && (d == 40 || d < 37)) {
										a.yRotate = 90;
										a.xRotate = 0;
										d = 37
									}
								}
							}
						}
						break
				}
			};
			var c = this.setInterval(this.update, a.animationTime)
		};
		this.removeMenus();
		b.call()
	};
	this.setGraphType = function(b) {
		this.functionCaller = "setGraphType";
		if (this.isTransition()) {
			return
		}
		var a;
		if (b == 66) {
			a = "Bar"
		} else {
			if (b == 76) {
				a = "Line"
			} else {
				if (b == 65) {
					a = "Area"
				} else {
					if (b == 70) {
						a = "AreaLine"
					} else {
						if (b == 67) {
							a = "BarLine"
						} else {
							if (b == 73) {
								a = "Boxplot"
							} else {
								if (b == 68) {
									a = "Dotplot"
								} else {
									if (b == 69) {
										a = "DotLine"
									} else {
										if (b == 72) {
											a = "Heatmap"
										} else {
											if (b == 83) {
												a = "Stacked"
											} else {
												if (b == 85) {
													a = "StackedLine"
												} else {
													if (b == 84) {
														a = "StackedPercent"
													} else {
														if (b == 87) {
															a = "StackedPercentLine"
														} else {
															if (b == 50) {
																a = "Scatter2D"
															} else {
																if (b == 52) {
																	a = "ScatterBubble2D"
																} else {
																	if (b == 51) {
																		a = "Scatter3D"
																	} else {
																		if (b == 88) {
																			a = "Correlation"
																		} else {
																			if (b == 86) {
																				a = "Venn"
																			} else {
																				if (b == 80) {
																					a = "Pie"
																				} else {
																					if (b == 78) {
																						a = "Network"
																					} else {
																						if (b == 71) {
																							a = "Genome"
																						} else {
																							if (b == 77) {
																								a = "Candlestick"
																							} else {
																								if (b == 82) {
																									a = "Circular"
																								} else {
																									if (b == 89) {
																										a = "Treemap"
																									} else {
																										if (b == 90) {
																											a = "TagCloud"
																										} else {
																											if (b == 74) {
																												a = "ParallelCoordinates"
																											} else {
																												if (b == 75) {
																													a = "Sankey"
																												} else {
																													if (b == 79) {
																														a = "Tree"
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (a && this.isValidGraphType(a)) {
			this.graphType = a;
			this.draw()
		} else {
			alert("Dude! You cannot plot this data in a " + a + " graph")
		}
	};
	this.reset = function(a) {
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		switch (this.graphType) {
			case "Area":
			case "AreaLine":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Heatmap":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Candlestick":
			case "Circular":
			case "Treemap":
			case "TagCloud":
			case "ParallelCoordinates":
			case "Sankey":
			case "Tree":
				this.setAllVariablesVisible(false, a);
				this.setAllSamplesVisible(false, a);
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible(false, a);
				this.setAllSamplesVisible(false, a);
				break;
			case "Network":
				this.resetSelectedNodes();
				this.setAllNodesVisible();
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				break;
			case "Genome":
				this.setAllFeaturesVisible(a);
				break
		}
		if (this.startingVarIndices && this.startingVarIndices.length == this.varIndices.length) {
			this.varIndices = this.startingVarIndices
		}
		if (this.startingSmpIndices && this.startingSmpIndices.length == this.smpIndices.length) {
			this.smpIndices = this.startingSmpIndices
		}
	};
	this.redraw = function(b) {
		this.functionCaller = "redraw";
		if (this.isTransition()) {
			return
		}
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		switch (this.graphType) {
			case "Area":
			case "AreaLine":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Circular":
			case "Treemap":
			case "TagCloud":
			case "ParallelCoordinates":
			case "Sankey":
			case "Tree":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				break;
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Genome":
			case "Candlestick":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.resetRange();
				this.xRotate = 45;
				this.yRotate = 0;
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.resetRange();
				break;
			case "Scatter3D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.xRotate = 45;
				this.yRotate = 0;
				break;
			case "Heatmap":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				break;
			case "Network":
				this.resetSelectedNodes();
				this.setAllNodesVisible();
				this.network2DRotate = 0;
				if (this.randomData) {
					this.layoutDone = true
				}
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				break;
			case "Map":
				if (this.meta.leaflet) {
					var a = this.meta.leaflet.map;
					a.setView(a.options.center, a.options.zoom)
				}
				break
		}
		this.setInitialConfig();
		this.draw();
		return true
	};
	this.resetZoomPan = function() {
		this.zoom = 1;
		this.panningX = 0;
		this.panningY = 0;
		this.panningGlobalX = 0;
		this.panningGlobalY = 0;
		this.padX = this.x / 2;
		this.padY = this.y / 2;
		this.padZ = this.y / 2
	};
	this.resetSelectedObjects = function() {
		this.functionCaller = "resetSelectedObjects";
		if (this.isTransition()) {
			return
		}
		if (this.isSelectDataPoints || this.isSelectNodes) {
			this.resetSelectedDataPoints();
			this.resetSelectedNodes();
			this.draw()
		}
	};
	this.resetRange = function() {
		var a = this.layoutComb && this.layoutAdjust && this.layoutValidN != null ? this.layoutParams[this.layoutValidN] : this;
		a.setMinX = null;
		a.setMaxX = null;
		a.setMinX2 = null;
		a.setMaxX2 = null;
		a.setMinY = null;
		a.setMaxY = null
	};
	this.masterReset = function(f) {
		if (this.isDOE) {
			this.resetDOE()
		} else {
			var c = f && (f.shiftKey || this.shiftKeyMobile || f.ctrlKey || this.ctrlKeyMobile || f.altKey || this.altKeyMobile || f.metaKey);
			var a = this.broadcast && c ? CanvasXpress.instances : [this];
			for (var b = 0; b < a.length; b++) {
				var d = a[b];
				d.resetTooltipDivs();
				d.resetDrag(f);
				d.resetSelectedDataPoints();
				d.resetSelectedNodes();
				if (d.dataTableLastState && d.dataTableLastState != "docked") {
					d.hideUnhideDataTable(true)
				}
				d.resetConfigurator();
				d.resetAxesResizer(f);
				d.resetFlags(f);
				d.resetZoomPan();
				if (this.isOncoprint) {
					d.sortIndices("onc", "desc");
					d.zoomOncoprintVariables(50)
				} else {
					d.redraw(f)
				}
			}
		}
	}
};
CanvasXpress.prototype.initSelectEvents = function() {
	this.showHideSelectedDataPoint = function(k, m, g) {
		this.functionCaller = "showHideSelectedDataPoint";
		if (this.isTransition()) {
			return
		}
		if (k) {
			this.stopEvent(k)
		}
		var p = this.layoutComb ? this.layoutValidN : 0;
		var s = this.layoutComb ? this.layoutParams[p].graphType : this.graphType;
		var r = [];
		if (m == 45 || m == 46) {
			if (s == "Network") {
				var a = [];
				var l = m == 45 ? false : true;
				for (var d in this.selectNode) {
					a.push(d)
				}
				if (a.length > 0) {
					this.hideUnhideNodes(a, l)
				}
			} else {
				if (s.match(/Scatter/)) {
					if (m == 45) {
						this.selectDataPoint = this.hideDataPoint;
						this.hideDataPoint = []
					} else {
						if (m == 46) {
							this.hideDataPoint = this.selectDataPoint;
							this.selectDataPoint = []
						}
					}
					if (s == "Scatter3D") {
						var o = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
						for (var h = 0; h < this.data.y.vars.length; h++) {
							if (this.isVisibleSelectedDataPoint(h, o)) {
								r.push(h)
							}
						}
						this.varIndices = r
					}
				}
			}
			if (!g) {
				this.draw()
			}
		} else {
			if (m == 36 || m == 1000) {
				if (s == "Network") {
					var b = {};
					var j = [];
					var a = this.data.nodes;
					var f = this.data.edges;
					for (var h = 0; h < f.length; h++) {
						if (m == 1000) {
							if (this.selectNode.hasOwnProperty(f[h].id1) && this.selectNode.hasOwnProperty(f[h].id2)) {
								b[f[h].id1] = true;
								b[f[h].id2] = true
							}
						} else {
							if (this.selectNode.hasOwnProperty(f[h].id1) || this.selectNode.hasOwnProperty(f[h].id2)) {
								b[f[h].id1] = true;
								b[f[h].id2] = true
							}
						}
					}
					for (var h = 0; h < a.length; h++) {
						if (!b.hasOwnProperty(a[h].id) || a[h].hide) {
							j.push(a[h].id)
						}
					}
					this.resetSelectedNodes();
					if (j.length > 0) {
						this.hideUnhideNodes(j, true);
						if (!g) {
							this.draw()
						}
					}
				} else {
					if (s == "Scatter3D") {
						if (this.isSelectDataPoints) {
							for (var h in this.selectDataPoint) {
								var q = parseInt(h);
								if (!isNaN(q)) {
									r.push(this.varIndices[q])
								}
							}
							this.isSelectDataPoints = 0;
							this.selectDataPoint = [];
							this.varIndices = r;
							if (!g) {
								this.draw()
							}
						}
					}
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsHistogram = function(e) {
		var g = this[e.h.a].cntx[e.h.d];
		var a = g[0];
		var f = g[1];
		var b = this[e.h.a].hist[e.h.b][e.h.c - 1];
		for (var d = 0; d < b.length; d++) {
			this.addRemoveToSelectedDataPoints([b[d], a, f], true)
		}
		this.broadcastDraw()
	};
	this.broadcastDraw = function() {
		this.functionCaller = "broadcastDraw";
		if (this.isTransition()) {
			return
		}
		var a = this.broadcast ? CanvasXpress.instances : [this];
		for (var b = 0; b < a.length; b++) {
			a[b].draw()
		}
	};
	this.addRemoveToSelectedDataPoints = function(a, f, l) {
		this.functionCaller = "addRemoveToSelectedDataPoints";
		if (this.isTransition()) {
			return
		}
		var k = this.layoutComb ? this.layoutValidN : 0;
		if (k !== null && k !== false) {
			var m = this.broadcast ? CanvasXpress.instances : [this];
			var p = this.layoutComb ? this.layoutParams[k].graphType : this.graphType;
			var j = this.addRemoveToSelectedDataPointsToNames(p, a, l);
			for (var g = 0; g < m.length; g++) {
				var e = m[g];
				var d = e.layoutComb ? e.layoutParams[0].graphType : e.graphType;
				if (d == "Network") {
					this.addRemoveToSelectedDataPointsNodes(e, j[0]);
					var o = true
				} else {
					if (d == "Circular") {} else {
						if (d == "Venn") {} else {
							if (d == "Genome") {} else {
								if (d == "Correlation") {} else {
									if (p == "Scatter2D" && this.isHistogram) {
										var b = e.getVariableIndices(j[0], true);
										var h = e.getSampleIndices(j[1], false, true);
										var n = h && h.length > 0 ? h.join(":") : "";
										var o = b && b.length > 0 ? true : false;
										if (o) {
											this.addRemoveToSelectedDataPointsData(e, b, n)
										}
									} else {
										var b = e.getVariableIndices(j[0]);
										var h = e.getSampleIndices(j[1]);
										var n = h && h.length > 0 ? h.join(":") : "";
										var o = b && b.length > 0 ? true : false;
										if (o) {
											this.addRemoveToSelectedDataPointsData(e, b, n)
										}
									}
								}
							}
						}
					}
				}
				if (!f && o) {
					e.draw()
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsToNames = function(q, a, o) {
		var t = this.data.y;
		if (q == "Network") {
			var l = this.data.nodes;
			if (o) {
				return [a, []]
			} else {
				var b = parseInt(a.join(", "));
				if (b < l.length) {
					return [
						[l[b].id],
						[]
					]
				}
			}
		} else {
			if (q == "Pie") {
				var u, n, c;
				if (a.length > 2) {
					u = 1;
					n = a.length;
					c = a[0]
				} else {
					u = 0;
					n = 1;
					c = a[1]
				}
				var f = [];
				var h = [];
				if (this.dataStndBy) {
					var m = this.dataStndBy.y;
					for (var g = u; g < n; g++) {
						f.push(m.vars[a[g]])
					}
					for (var g = 0; g < c.length; g++) {
						h.push(m.smps[c[g]])
					}
				} else {
					for (var g = u; g < n; g++) {
						f.push(t.vars[a[g]])
					}
					for (var g = 0; g < c.length; g++) {
						h.push(t.smps[c[g]])
					}
				}
				return [f, h]
			} else {
				if (q == "Circular") {} else {
					if (q == "Venn") {} else {
						if (q == "Genome") {} else {
							if (q == "Correlation") {} else {
								if (q == "Scatter2D" && this.isHistogram) {
									var m = this.dataStndBy.y;
									var p = a[1] - 1;
									var r = t.histogram[a[0]][p];
									var f = [];
									for (var d = 0; d < r.length; d++) {
										f.push(m.vars[r[d]])
									}
									return [f, [m.smps[p]]]
								} else {
									var h = [];
									if (q.match(/Scatter/)) {
										if (q == "Scatter3D") {
											h.push(t.smps[a[1]]);
											h.push(t.smps[a[2]]);
											h.push(t.smps[a[3]])
										} else {
											h.push(t.smps[a[1]]);
											h.push(t.smps[a[2]])
										}
									} else {
										h.push(t.smps[a[1]])
									}
									return [
										[t.vars[a[0]]], h
									]
								}
							}
						}
					}
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsNodes = function(c, b) {
		for (var a = 0; a < b.length; a++) {
			var d = b[a];
			if (!c.selectNode) {
				c.selectNode = {};
				c.isSelectNodes = 0
			}
			if (c.selectNode.hasOwnProperty(d)) {
				c.isSelectNodes--;
				delete(c.selectNode[d])
			} else {
				c.isSelectNodes++;
				c.selectNode[d] = true
			}
		}
	};
	this.addRemoveToSelectedDataPointsData = function(c, d, b) {
		for (var a = 0; a < d.length; a++) {
			if (this.broadcastType == "var") {
				if (c.selectDataPoint[d[a]]) {
					delete(c.selectDataPoint[d[a]]);
					c.isSelectDataPoints--
				} else {
					c.selectDataPoint[d[a]] = true;
					c.isSelectDataPoints++
				}
			} else {
				if (b) {
					if (!c.selectDataPoint[d[a]]) {
						c.selectDataPoint[d[a]] = {}
					}
					if (c.selectDataPoint[d[a]].hasOwnProperty(b)) {
						c.isSelectDataPoints--;
						delete(c.selectDataPoint[d[a]][b])
					} else {
						c.isSelectDataPoints++;
						c.selectDataPoint[d[a]][b] = true
					}
				}
			}
		}
	};
	this.handleUserSelectEvent = function() {
		var c = this.userEvents;
		var d = this.selectDataPointObject;
		var b = this.selectDataPointEvent;
		var a = this.selectDataPoint;
		if (c.select) {
			if (typeof(c.select) == "object" && c.select.handler && c.select.scope) {
				c.select.handler.apply(c.select.scope, [d, b, this, a])
			} else {
				if (typeof(c.select) == "object" && c.select.handler) {
					c.select.handler(d, b, this, a)
				} else {
					c.select(d, b, this, a)
				}
			}
		}
	};
	this.resetSelectedDataPoints = function() {
		if (this.isSelectDataPoints) {
			this.selectDataPoint = [];
			this.selectDataPointObject = false;
			this.selectDataPointEvent = false;
			this.hideDataPoint = [];
			this.isSelectDataPoints = 0
		}
	};
	this.resetSelectedNodes = function() {
		if (this.isSelectNodes) {
			this.selectNode = {};
			this.isSelectNodes = 0
		}
	}
};
CanvasXpress.prototype.initDendrogramEvents = function() {
	this.zoomDendrogram = function(a) {
		this.functionCaller = "zoomDendrogram";
		if (this.isTransition()) {
			return
		}
		if (!a || !a.t || !a.t.objectType) {
			return false
		}
		var g = function(l) {
			if (l.children) {
				for (var k = 0; k < l.children.length; k++) {
					g(l.children[k])
				}
			} else {
				e.push(l.idx)
			}
			return e
		};
		var d = function(l) {
			if (!b) {
				if (l.nodeId != null && l.nodeId == a.t.nodeId) {
					b = true;
					f = l
				}
				if (l.children) {
					for (var k = 0; k < l.children.length; k++) {
						d(l.children[k])
					}
				}
			}
		};
		var e = [];
		var f = {};
		var b = false;
		var j = this[a.t.objectType];
		d(j);
		this.setOriginalIndices();
		var h = this.layoutComb ? this.layoutParams[a.t.c || 0] : this;
		if (a.t.objectType == "varDendrogram") {
			h.varIndices = g(f);
			for (var c = 0; c < h.startingVarIndices.length; c++) {
				if (h.startingVarIndices[c] == h.varIndices[0]) {
					h.varIndicesStart = c;
					break
				}
			}
		} else {
			h.smpIndices = g(f);
			for (var c = 0; c < h.startingSmpIndices.length; c++) {
				if (h.startingSmpIndices[c] == h.smpIndices[0]) {
					h.smpIndicesStart = c;
					break
				}
			}
		}
		this.draw()
	};
	this.modifyDendrogram = function(g) {
		this.functionCaller = "modifyDendrogram";
		if (this.isTransition()) {
			return
		}
		if (!g || !g.t || !g.t.objectType) {
			return false
		}
		var c = function(k) {
			if (k.children) {
				for (var j = 0; j < k.children.length; j++) {
					c(k.children[j])
				}
			} else {
				b.push(k.idx)
			}
			return b
		};
		var e = function(k) {
			if (!d) {
				if (k.nodeId != null && k.nodeId == g.t.nodeId) {
					k.children.reverse();
					d = true
				}
				if (k.children) {
					for (var j = 0; j < k.children.length; j++) {
						e(k.children[j])
					}
				}
			}
		};
		var b = [];
		var d = false;
		var a = this[g.t.objectType];
		var h = g.t.objectType.replace("Dendrogram", "s");
		this.setOriginalIndices();
		e(a);
		this[h + "Newick"] = this.writeNewick(a);
		var f = this.layoutComb ? this.layoutParams[g.t.c || 0] : this;
		if (g.t.objectType == "varDendrogram") {
			f.startingVarIndices = c(a)
		} else {
			f.startingSmpIndices = c(a)
		}
		this.draw()
	}
};
CanvasXpress.prototype.initCanvasEvents = function() {
	this.moveCanvas = function(b, a) {
		var d = this.remoteService ? this.$(this.remoteParentId + "-canvasXpressRemoteWindow") : this.$("container-" + this.target);
		if (d) {
			d.style.left = a;
			d.style.top = b
		}
	};
	this.contextmenuCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (b) {
				if (a.Ext && a.Ext.contextmenu) {
					return
				} else {
					a.cancelEvent(b);
					a.handleMouseEvents(b, "contextmenu", a.isEventIndices(b))
				}
			}
			return false
		}
	}(this);
	this.mousedownCanvas = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			if (c && c.which ? c.which != 3 : c.button != 2) {
				if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
					a.touchEvent = "hold";
					var b = function() {
						clearTimeout(b);
						if (a.meta.system.isTouchScreen && a.touches && a.touches.length == 1 && a.touchEvent == "hold") {
							a.masterReset(c)
						}
					};
					setTimeout(b, 1000);
					if (a.meta.system.isTouchScreen && c.type == "touchstart") {
						if (c.preventDefault) {
							c.preventDefault()
						} else {
							c.returnValue = false
						}
						if (a.wheelKeyMobile || a.mouseKeyMobile) {
							a.registerDrag(c)
						}
					} else {
						a.registerDrag(c)
					}
				}
			}
			return false
		}
	}(this);
	this.clickCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.isIE) {
				b = a.copyEvent(b)
			}
			a.resetMenus();
			a.resetLinks();
			a.closeHelp();
			a.clickBuffer = function() {
				if (!a.doubleClick) {
					if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
						if (!a.skipClick && (a.lastCanvasEvent != "drag")) {
							if (a.isHelp(b)) {
								a.stopEvent(b);
								a.showInfoSpan(b, 'Modify "helpKeyEvents"<br>&nbsp;&nbsp;&nbsp;to show or hide help<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on key events"')
							} else {
								if (a.isAxis(b)) {
									a.stopEvent(b)
								} else {
									if (a.axesResizerShow && !a.resizerType) {
										a.stopEvent(b);
										a.resetAxesResizer(b)
									} else {
										if (a.mobileApp) {
											a.stopEvent(b);
											a.addConfigurator(b)
										} else {
											var c = a.isEventIndices(b);
											if (c) {
												a.handleMouseEvents(b, "click", c)
											} else {
												if (!b.ctrlKey && !this.ctrlKeyMobile) {
													a.resetSelectedObjects()
												}
											}
										}
									}
								}
							}
						}
					} else {
						a.resetConfigurator()
					}
					a.lastCanvasEvent = "click"
				}
			};
			setTimeout(a.clickBuffer, 250);
			setTimeout(function() {
				a.doubleClick = false
			}, 500)
		}
	}(this);
	this.dblclickCanvas = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			a.doubleClick = true;
			if (a.clickBuffer) {
				clearTimeout(a.clickBuffer);
				a.clickBuffer = null
			}
			if (!a.skipClick) {
				var b = a.isEventIndices(c);
				if (b) {
					a.handleMouseEvents(c, "dblclick", b)
				} else {
					a.cancelEvent(c);
					a.addConfigurator(c)
				}
				a.lastCanvasEvent = "dblclick"
			}
			return false
		}
	}(this);
	this.wheelCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.lastWheel) {
				if (new Date().getTime() - a.lastWheel < 20) {
					a.cancelEvent(b);
					return false
				}
			}
			a.lastWheel = new Date().getTime();
			var c = 0;
			if (!b) {
				b = window.event
			}
			if (b.wheelDelta) {
				c = b.wheelDelta / 120;
				if (window.opera) {
					c = -c
				}
			} else {
				if (b.detail) {
					c = -b.detail / 3
				}
			}
			if (c) {
				a.handleWheelEvent(b, c)
			}
		}
	}(this);
	this.dropCanvas = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			a.cancelEvent(j);
			var h = j.dataTransfer;
			var g = j.dataTransfer.getData("text/html");
			if (h && h.files.length > 0) {
				a.loadFile(h)
			} else {
				if (g.match(/img.+src=.+png/)) {
					var k = a.$cX("div");
					k.innerHTML = g;
					var c = k.firstChild.src;
					var b = function() {
						return function(e) {
							var d = new FileReader();
							d.onloadend = function() {
								var f = a.parseDataFromPNG(this.result);
								f.uploadFile = true;
								a.remoteServiceType = "file";
								a.updateRemoteData(f)
							};
							d.readAsArrayBuffer(e)
						}
					}(a);
					a.ajaxRequest(c, false, b, "blob")
				}
			}
			this.className = "CanvasXpress"
		}
	}(this);
	this.dragEnterCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			this.className = "CanvasXpressUpload";
			return false
		}
	}(this);
	this.dragOverCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			this.className = "CanvasXpressUpload";
			return false
		}
	}(this);
	this.dragLeaveCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpress";
			return false
		}
	}(this);
	this.addRemoveCanvasListeners = function(a) {
		var b = this.meta.canvas.ctx2.canvas;
		this[a](b, "contextmenu", this.contextmenuCanvas, false);
		this[a](b, "mousedown", this.mousedownCanvas, false);
		this[a](b, "touchstart", this.mousedownCanvas, false);
		this[a](b, "click", this.clickCanvas, false);
		this[a](b, "dblclick", this.dblclickCanvas, false);
		this[a](b, "mousewheel", this.wheelCanvas, false);
		this[a](b, "drop", this.dropCanvas, false);
		this[a](b, "dragenter", this.dragEnterCanvas, false);
		this[a](b, "dragover", this.dragOverCanvas, false);
		this[a](b, "dragleave", this.dragLeaveCanvas, false)
	};
	this.isVersion = function(b) {
		if (this.showVersion) {
			var a = this.adjustedCoordinates(b);
			return a && a.x >= 0 && a.x <= 10 && a.y >= 0 && a.y <= 10 ? true : false
		}
	};
	this.isHelp = function(b) {
		var a = this.adjustedCoordinates(b);
		return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
	};
	this.handleWheelEvent = function(i, j, m) {
		this.functionCaller = "handleWheelEvent";
		if (this.isTransition()) {
			return
		}
		this.skipTransition = true;
		var b = this.getTargetEvent(i);
		if (/CanvasXpress/.test(b.className)) {
			CanvasXpress.current = b.id
		}
		if (this.graphType == "Correlation" || this.graphType == "Heatmap" || (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/) && !this.is3DPlot)) {
			this.cancelEvent(i);
			this.resetAxesResizer(i);
			if (this.layoutComb && !this.layoutAdjust && this.graphType != "Correlation" && this.graphType != "Heatmap") {
				return false
			}
			this.setIndicesAfterWheelEvent(i, j)
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D" || this.graphType == "Genome") {
				this.cancelEvent(i);
				if (this.graphType == "Genome" && this.xAxisUnit > 100 && j > 0) {
					return
				}
				this.setRangesAfterWheelEvent(i, j)
			} else {
				if (this.graphType == "Scatter3D" || this.is3DPlot) {
					this.cancelEvent(i);
					if (!m) {
						m = this.adjustedCoordinates(i);
						i.ac = {
							x: m.x,
							y: m.y
						}
					}
					if (m) {
						m.x -= (this.marginLeft + this.left);
						m.y -= (this.marginTop + this.top);
						var g = (Math.min(Math.max(m.x, 0), this.x) / this.x) - 0.5;
						var f = (Math.min(Math.max(m.y, 0), this.y) / this.y) - 0.5
					}
					if (j > 0) {
						if (this.zoom >= 4) {
							return
						}
						this.zoom *= 1.1;
						this.padX -= g * this.padX / 4;
						this.padY -= f * this.padY / 4
					} else {
						if (this.zoom <= 0.5) {
							return
						}
						this.zoom *= 0.9;
						this.padX += g * this.padX / 4;
						this.padY += f * this.padY / 4
					}
					this.draw()
				} else {
					if (this.graphType == "Network") {
						this.cancelEvent(i);
						if (!m) {
							m = this.adjustedCoordinates(i);
							i.ac = {
								x: m.x,
								y: m.y
							}
						}
						if (m) {
							if (i.type == "keydown") {
								m.x = this.width / 2;
								m.y = this.height / 2
							}
							var c = this.scaleFactor * this.zoomStep;
							var l = (this.widthBounds / 2) - (m.x / this.scaleFactor);
							var h = (this.heightBounds / 2) - (m.y / this.scaleFactor);
							this.scaleFactor = j > 0 ? this.scaleFactor + c : this.scaleFactor - c;
							this.widthBounds = this.x / this.scaleFactor;
							this.heightBounds = this.y / this.scaleFactor;
							var a = (this.widthBounds / 2) - (m.x / this.scaleFactor);
							var k = (this.heightBounds / 2) - (m.y / this.scaleFactor);
							this.panningX = l - a;
							this.panningY = h - k;
							if (!this.networkFreeze) {
								c = this.zoom * this.zoomStep;
								this.zoom = j > 0 ? this.zoom + c : this.zoom - c
							}
							this.draw(false, false, false, true);
							this.panningGlobalX += this.panningX;
							this.panningGlobalY += this.panningY
						}
					}
				}
			}
		}
		return false
	};
	this.getTreeNode = function(d) {
		if (d != null) {
			d = d.toString().replace("Tree-Node:", "");
			var a = this.data.tree.plot.descendants();
			for (var b = 0; b < a.length; b++) {
				var c = a[b];
				if (c.id == d) {
					return c
				}
			}
		}
		return false
	};
	this.handleTreeClick = function(b) {
		this.functionCaller = "handleTreeClick";
		if (b) {
			var a = false;
			var c = this.getTreeNode(b.id);
			if (c) {
				a = true;
				this.data.tree.click = c;
				if (c.children) {
					c._children = c.children;
					c.children = null
				} else {
					c.children = c._children;
					c._children = null
				}
			}
			if (a) {
				this.draw()
			}
		}
	};
	this.handleChordMouseOver = function(b) {
		if (b) {
			var a = this.circularChord;
			this.highlightCanvas(this.getKeys(this.circularChord.segments[b.id].ribbons))
		}
	};
	this.getEventAreaData = function(a) {
		return this.extractDataObject(this.isEventIndices(a))
	};
	this.handleMouseEvents = function(g, k, c) {
		this.functionCaller = "handleMouseEvents";
		if (this.isTransition()) {
			return
		}
		if (this.layoutComb) {
			this.setActiveLayout(g);
			if (!this.layoutValidN == null) {
				return false
			}
		}
		var a = c ? this.extractDataObject(c) : false;
		var h = false;
		var l = true;
		var b = g.shiftKey || this.shiftKeyMobile;
		var j = g.ctrlKey || this.ctrlKeyMobile;
		var f = g.altKey || this.altKeyMobile;
		if (a && a.objectType == "Tree") {
			this.skipTransition = false
		} else {}
		if (k == "click") {
			if (this.isDOE && c) {
				if (a && this.showDOEData && a.w) {
					if (a.y) {
						this.dataStndBy.l.doe = [c[2]]
					} else {
						this.dataStndBy.l.doe = a.w.grps[0]
					}
				} else {
					if (a && a.y.pie) {
						this.dataStndBy.l.doe = a.y.pie[0]
					} else {
						if (a && a.y.treemap) {
							this.dataStndBy.l.doe = a.y.treemap[0]
						} else {
							if (a && a.y.histogram) {
								this.dataStndBy.l.doe = a.y.histogram[0]
							} else {
								if (this.showDOEData) {
									this.dataStndBy.l.doe = [c[1]]
								}
							}
						}
					}
				}
				h = true
			} else {
				if (j) {
					if (f) {
						alert(this.prettyJSON(a))
					} else {
						this.addRemoveToSelectedDataPoints(this.isEventIndices(g));
						this.handleUserSelectEvent();
						this.draw()
					}
				} else {
					if (b) {
						if (this.graphType == "Network" && this.networkLayoutType == "radial") {
							this.reRootRadialNetwork(this.isEventIndices(g))
						}
					} else {
						if (f) {} else {
							if (c != null && this.isSelectDataPoints && !this.isHistogram && this.selectDataPoint.hasOwnProperty(c[0])) {} else {
								if (c != null && this.isSelectDataPoints && this.isHistogram && this.selectDataPoint.hasOwnProperty(this.data.y.histogram[c[0]][0])) {} else {
									if (c && isNaN(c[0]) && c[0].match(/Histogram/)) {
										this.resetSelectedDataPoints();
										l = false
									} else {
										if (this.isOneDimensionalGraph()) {
											l = false
										} else {
											this.resetSelectedObjects()
										}
									}
								}
							}
							if (l) {
								this.addRemoveToSelectedDataPoints(this.isEvent(g))
							}
						}
					}
				}
			}
		}
		if (this.userEvents[k]) {
			if (typeof(this.userEvents[k]) == "object" && this.userEvents[k].handler && this.userEvents[k].scope) {
				this.userEvents[k].handler.apply(this.userEvents[k].scope, [a, g, this, c])
			} else {
				if (typeof(this.userEvents[k]) == "object" && this.userEvents[k].handler) {
					this.userEvents[k].handler(a, g, this, c)
				} else {
					this.userEvents[k](a, g, this, c)
				}
			}
		}
		if (h) {
			this.draw()
		}
		return a && a.objectType == "Chord"
	};
	this.formatCoords = function(j, k) {
		var f = [];
		if (this.graphType != "Network") {
			for (var e = 0; e < k.length; e++) {
				if (e % 2) {
					f.push(sprintf("%.0f", (k[e] + this.translateY) * this.scaleY))
				} else {
					if (this.layoutValid && j == "circle" && e == 2) {
						f.push(sprintf("%.0f", k[e] * ((this.scaleX + this.scaleY) / 2)))
					} else {
						f.push(sprintf("%.0f", (k[e] + this.translateX) * this.scaleX))
					}
				}
			}
		} else {
			for (var e = 0; e < k.length; e++) {
				f.push(sprintf("%.0f", parseInt(k[e])))
			}
		}
		if (j == "rect") {
			var b = Math.min(f[0], f[2]);
			var d = Math.min(f[1], f[3]);
			var a = Math.max(f[0], f[2]);
			var g = Math.max(f[1], f[3]);
			f = [b, d, a, g]
		}
		return f.join(",")
	};
	this.drawArea = function(b) {
		var d = this.meta.canvas.ctx2;
		d.strokeStyle = "red";
		d.lineWidth = 2;
		var g = [];
		var k = this.meta.render.objects;
		if (b) {
			g.push(b)
		} else {
			for (var h = 0; h < k.length; h++) {
				if (k[h].idx) {
					g.push(h)
				}
			}
		}
		for (var h = 0; h < g.length; h++) {
			var e = this.cloneObject(k[g[h]]);
			if (e.idx) {
				var c = e.area;
				switch (c[0]) {
					case "rect":
						d.beginPath();
						d.moveTo(c[1], c[2]);
						d.lineTo(c[3], c[2]);
						d.lineTo(c[3], c[4]);
						d.lineTo(c[1], c[4]);
						d.closePath();
						d.stroke();
						break;
					case "circle":
						d.beginPath();
						d.arc(c[1], c[2], c[3], 0, Math.PI * 2, true);
						d.closePath();
						d.stroke();
						break;
					case "poly":
						d.beginPath();
						d.moveTo(c[1], c[2]);
						for (var f = 3; f < c.length; f += 2) {
							d.lineTo(c[f], c[f + 1])
						}
						d.closePath();
						d.stroke();
						break
				}
			}
		}
	};
	this.adjustNetworkObjects = function(b) {
		if (b) {
			if (b[0] == "circle") {
				b[1] = this.adjustNetworkObjectX(b[1]);
				b[2] = this.adjustNetworkObjectY(b[2]);
				b[3] = b[3] * this.scaleFactor
			} else {
				for (var a = 1; a < b.length; a++) {
					if (a % 2) {
						b[a] = this.adjustNetworkObjectX(b[a])
					} else {
						b[a] = this.adjustNetworkObjectY(b[a])
					}
				}
			}
		} else {
			return false
		}
		return b
	};
	this.adjustNetworkObjectFont = function(b) {
		var c = this.getFontPt(b);
		var a = Math.floor(c * this.scaleFactor);
		return b.replace(c, a)
	};
	this.adjustNetworkObjectX = function(a) {
		return (this.offsetX + a) * this.scaleFactor
	};
	this.adjustNetworkObjectY = function(a) {
		return (this.offsetY + a) * this.scaleFactor
	};
	this.adjustBackNetworkObjectX = function(a) {
		return (a / this.scaleFactor) - this.offsetX
	};
	this.adjustBackNetworkObjectY = function(a) {
		return (a / this.scaleFactor) - this.offsetY
	};
	this.adjustNetworkMouseDownX = function(a) {
		return (a - this.xMouseDown) / this.scaleFactor
	};
	this.adjustNetworkMouseDownY = function(a) {
		return (a - this.yMouseDown) / this.scaleFactor
	};
	this.clearHighlightCanvas = function() {
		this.meta.canvas.ctx2.canvas.width = this.width;
		this.meta.canvas.ctx2.canvas.height = this.height
	};
	this.highlightCanvas = function(j) {
		this.clearHighlightCanvas();
		this.isHighlightCanvas = true;
		var h = this.meta.render.objects;
		var u = function(f) {
			for (var c = f; c >= 0; c--) {
				if (h[c].func == "setClipArea") {
					return h[c].params[0]
				}
			}
			return false
		};
		if (j) {
			var x = {
				polygon: true,
				path: true,
				spline: true,
				confidence: true,
				violin: true
			};
			var v = {
				Legends: true,
				Titles: true
			};
			var r = [];
			for (var e = 0; e < j.length; e++) {
				r = r.concat(this.meta.render.groups[h[j[e]].group])
			}
			r = r.sort();
			var a = {};
			var n = false;
			var q = this.outlineWidth;
			if (this.higlightGreyOut) {
				var m = "rgba(255,255,255," + this.higlightGreyOutTransparency + ")";
				this.drawShape("rectangle", this.width / 2, this.height / 2, this.width, this.height, m, m)
			}
			for (var e = 0; e < r.length; e++) {
				if (!a[r[e]]) {
					a[r[e]] = true;
					var d = this.meta.render.objects[r[e]];
					var l = d.func;
					var b = this.cloneObject(d.params);
					var k = this.graphType;
					this.outlineWidth = q;
					if (l && b) {
						switch (l) {
							case "drawLine":
								if (k == "Network" && !this.preScaleNetwork) {
									b[1] = this.adjustNetworkObjectX(b[1]);
									b[2] = this.adjustNetworkObjectY(b[2]);
									b[3] = this.adjustNetworkObjectX(b[3]);
									b[4] = this.adjustNetworkObjectY(b[4]);
									b[8] = b[8] * this.scaleFactor;
									b[9] = b[9] * this.scaleFactor
								}
								if (b[0] == "error") {
									this.outlineWidth = 3
								} else {
									b[6] = b[6] ? parseFloat(b[6]) + 2 : 3
								}
								if (k != "Network" && !n) {
									this.setClipArea(b[11] ? b[11] : u(r[e]));
									n++
								}
								break;
							case "drawShape":
								if (k == "Network" && !this.preScaleNetwork) {
									b[1] = this.adjustNetworkObjectX(b[1]);
									b[2] = this.adjustNetworkObjectY(b[2]);
									b[3] = (b[3] + 4) * this.scaleFactor;
									b[4] = (b[4] + 4) * this.scaleFactor
								} else {
									if (x.hasOwnProperty(b[0])) {
										b[9] = 2
									} else {
										if (b[0] == "arch") {
											b[4] = parseFloat(b[4]) + 1
										} else {
											b[3] = parseFloat(b[3]) + 4;
											b[4] = parseFloat(b[4]) + 4
										}
									}
								}
								if (b[0] == "sphere" && this.isColorTransparent(b[5])) {
									b[5] = this.removeColorTransparency(b[5], true);
									b[6] = this.foreground;
									b[9] = 2
								} else {
									if (b[0] == "bezier" && b[8] && this.isArray(b[8])) {
										b[5] = this.getLinearGradient(0, 0, b[3], 0, b[8][0], b[8][1]);
										b[6] = this.foreground
									} else {
										b[5] = this.addColorTransparency(b[5], 0.7);
										b[6] = this.foreground
									}
								}
								if (k != "Network" && !n) {
									this.setClipArea(b[11] ? b[11] : u(r[e]));
									n++
								}
								break;
							case "drawArcText":
							case "drawText":
								if (k == "Network" && !this.preScaleNetwork) {
									b[1] = this.adjustNetworkObjectX(b[1]);
									b[2] = this.adjustNetworkObjectY(b[2]);
									b[3] = this.adjustNetworkObjectFont(b[3])
								} else {
									b[1] -= 1;
									b[2] -= 1
								}
								break;
							default:
								this.isHighlightCanvas = false;
								this.outlineWidth = q;
								return
						}
						this[l].apply(this, b);
						this.outlineWidth = q
					}
				}
			}
			if (n) {
				this.resetClipArea()
			}
		}
		this.isHighlightCanvas = false
	};
	this.flash = function(b, p, m, f, k, a) {
		var j = this.$cX("div", {
			id: this.target + "canvasXpressFlash" + new Date().getTime()
		}, {
			left: (b - (m / 2)) + "px",
			top: (p - (f / 2)) + "px",
			width: m + "px",
			height: f + "px",
			borderRadius: "999px",
			WebkitBorderRadius: "999px",
			MozBorderRadius: "999px",
			opacity: 0.6,
			filter: "alpha(opacity = 60)",
			position: "absolute",
			zIndex: 100000,
			display: "block",
			backgroundColor: k ? k : this.resizerBackgroundColor
		});
		this.meta.canvas.ctx.canvas.parentNode.appendChild(j);
		if (!a) {
			a = 3
		}
		var g = this;
		var e = 1;
		var o = function() {
			this.update = function() {
				if (e % 2) {
					j.style.display = "none"
				} else {
					j.style.display = "block"
				}
				if (e >= (a * 2)) {
					g.meta.canvas.ctx.canvas.parentNode.removeChild(j);
					clearInterval(c)
				}
				e++
			};
			var c = this.setInterval(this.update, 300)
		};
		o.call()
	};
	this.initializeCanvasEvents = function() {
		if (!this.disableEvents) {
			this.addRemoveCanvasListeners("addEvtListener")
		}
	};
	this.getFunctionCallerName = function(a) {
		var b = a.toString().match(/.functionCaller *= *['"]?(.+?)['"]/);
		return b && b[1] ? b[1] : false
	};
	this.getFunctionCallerType = function(a) {
		switch (a) {
			case "draw1DWireFrame":
			case "draw1DXLayout":
			case "draw2DLayout":
			case "set2DLayout":
			case "set2DWireFrameX":
			case "draw3DLayout":
			case "set3DXLayout":
			case "drawCircularDataAxis":
			case "drawLayoutCompartments":
				return "Axes";
			case "set2DWireFrameY":
			case "set3DYLayout":
				return "Axes2";
			case "set3DZLayout":
				return "Axes3";
			case "draw3DAxisTitle":
				return "AxesTitle";
			case "draw1DLabels":
			case "draw1DYLayoutHeatmap":
			case "draw1DYLayoutNoHeatmap":
			case "drawCircularSampleLabels":
			case "drawCorrelationLayout":
			case "drawDOELabelsLayout":
			case "drawNetworkNodeLabel":
			case "drawVennLayout":
			case "drawSelectedBackgroundLabel":
				return "Labels";
			case "drawLabelsTitlesLayout":
			case "draw1DYLayoutSampleTitle":
				return "LabelsTitle";
			case "drawAreaPlot":
			case "drawBarPlot":
			case "drawBoxPlot":
			case "drawCandlestickPlot":
			case "drawCircularDataPoints":
			case "drawCorrelationDataPoints":
			case "drawDotPlot":
			case "drawHeatmap":
			case "draw1DHeatmapDataPoints":
			case "drawLinePlot":
			case "drawNetworkNodes":
			case "drawNetworkEdges":
			case "drawPie":
			case "drawSankey":
			case "drawStackedPlot":
			case "drawTree":
			case "drawTreemap":
			case "drawVennBubble":
			case "drawVennDataPoints":
			case "drawVennLayoutBubbles":
			case "draw2DHistograms":
			case "draw2DDataPointsTrail":
			case "draw2DDataPointsNotrail":
			case "draw3DBar":
			case "draw3DDataPoints":
			case "drawErrorLine":
			case "drawMedianLine":
			case "drawSelectedBackground":
				return "Data";
			case "draw1DOverlays":
			case "draw1DOverlaysDataPoints":
			case "drawCircularOverlays":
				return "Overlays";
			case "drawDendrogram":
				return "Dendrograms";
			case "drawColorIndicator":
			case "drawCircularLegend":
			case "drawCircularRingLegend":
			case "drawVariableLegend":
			case "drawSampleLegend":
			case "drawPropertyLegend":
			case "drawDecorationLegend":
			case "drawLegendBackgroundBox":
			case "drawHeatmapIndicatorHistogram":
			case "drawNetworkProgressBar":
			case "drawOncoprintLegend":
			case "drawVennLegend":
			case "drawStockIndicatorsLegend":
			case "drawLayoutCompartmentsBox":
				return "Legends";
			case "drawCitation":
				return "Citations";
			case "drawCircularConnections":
				return "Connections";
			case "drawViolin":
			case "drawDecorationData":
			case "draw1DContour":
			case "drawMarkers":
				return "Decorations";
			case "drawTitle":
				return "Titles";
			case "drawPlotWindow":
			case "resizeCanvas":
				return "Size";
			case "draw1DHeatmapDataPoints":
				return "None";
			default:
				return a
		}
	};
	this.addToRender = function(k, p, o, r, b, j) {
		var g = this.meta.render;
		var m = k.shift();
		var f = m.replace("draw", "get") + "Area";
		var a = this[f] && this.isFunction(this[f]) ? this[f].apply(this, k) : false;
		var d = m.match(/^draw/) ? m.replace("draw", "").substring(0, 1) : "O";
		var q = g.objects.length;
		r = r != null ? r.toString() : q;
		if (!g.groups.hasOwnProperty(r)) {
			g.groups[r] = []
		}
		var c = this.getFunctionCallerType(this.functionCaller);
		if (!g.types.hasOwnProperty(c)) {
			g.types[c] = {
				all: [],
				drawShape: [],
				drawLine: [],
				drawText: [],
				drawArcText: [],
				other: []
			}
		}
		if (!this.isInArray(c, g.order)) {
			g.order.push(c)
		}
		var h = g.types[c].hasOwnProperty(m) ? g.types[c][m].length : g.types[c].other.length;
		var l = p && this.isArray(p) ? p.join(":") : p ? p : c + ":" + d + ":" + this.padNumber(h);
		g.objects.push({
			func: m,
			params: k,
			idx: p,
			id: l,
			modifier: o,
			group: r,
			area: a,
			layout: (this.layoutComb ? this.layoutCurrent : false),
			clr: this.functionCaller,
			type: c,
			ignore: b,
			baseline: j
		});
		g.groups[r].push(q);
		g.types[c].all.push(q);
		switch (m) {
			case "drawShape":
				g.types[c].drawShape.push(q);
				break;
			case "drawLine":
				g.types[c].drawLine.push(q);
				break;
			case "drawText":
				g.types[c].drawText.push(q);
				break;
			case "drawArcText":
				g.types[c].drawText.push(q);
				break;
			default:
				g.types[c].other.push(q);
				break
		}
		if (r != q && m == "drawLine") {
			p = g.objects[r].idx;
			l = p.join(":") + ":" + g.groups[r].length;
			g.objects[q].id = l;
			if (this.showBoxplotOriginalData || this.showViolinBoxplot) {
				p = false
			}
		}
		g.origin[q] = [];
		if (c == "Data" && p && !this.graphType.match(/Scatter|Treemap/)) {
			if (this.isGroupedData) {
				if ((this.isDotplotGraph() && p[p.length - 1] != "box") || this.graphType == "Stacked") {
					l = p[0] + ":" + p[p.length - 1];
					g.map[l] = q;
					g.origin[q].push(this.getTransitionOrigin(l))
				} else {
					if (p.length == 2 && r == q) {
						var n = this.data.w.grps[p[1]];
						for (var e = 0; e < n.length; e++) {
							l = p[0] + ":" + n[e];
							g.map[l] = q;
							g.origin[q].push(this.getTransitionOrigin(l))
						}
					} else {
						if (p.length == 3 && p[2] == "box") {
							var n = this.data.w.grps[p[1]];
							for (var e = 0; e < n.length; e++) {
								l = p[0] + ":" + n[e] + ":box";
								g.map[l] = q;
								g.origin[q].push(this.getTransitionOrigin(l))
							}
						} else {
							g.map[l] = q;
							g.origin[q].push(this.getTransitionOrigin(l))
						}
					}
				}
			} else {
				g.map[l] = q;
				g.origin[q].push(this.getTransitionOrigin(l))
			}
		} else {
			g.map[l] = q;
			g.origin[q].push(this.getTransitionOrigin(l))
		}
		if (this.debug || this.graphType == "Video") {
			this[m].apply(this, k)
		}
		return q
	};
	this.getTransitionOrigin = function(b) {
		var a = this.meta.render;
		if (a.transition && a.transition.map.hasOwnProperty(b)) {
			return a.transition.map[b]
		} else {
			return false
		}
	};
	this.setTransitionObject = function(c, j) {
		var h = c.func;
		var d = this.meta.render;
		var k = this.meta.render.transition;
		var e = function() {
			return j ? d.objects[c.group] : k.objects[c.group];
			var a = j ? d.objects[c.group].id : k.objects[c.group].id;
			return j ? k.objects[k.map[a]] : d.objects[d.map[a]]
		};
		switch (h) {
			case "drawShape":
				var l = c.params[0];
				switch (l) {
					case "box":
					case "rect":
					case "rectangle":
						if (c.baseline != null) {
							if (this.isArray(c.baseline) && c.baseline.length == 4) {
								c.params[1] = c.baseline[0];
								c.params[2] = c.baseline[1];
								c.params[3] = c.baseline[2];
								c.params[4] = c.baseline[3]
							} else {
								if (this.isArray(c.baseline)) {
									c.params[1] = c.baseline[0];
									c.params[2] = c.baseline[1];
									c.params[3] = 0;
									c.params[4] = 0
								} else {
									if (this.graphOrientation == "vertical") {
										c.params[2] = c.baseline;
										c.params[4] = 0
									} else {
										c.params[1] = c.baseline;
										c.params[3] = 0
									}
								}
							}
						} else {
							if (this.graphOrientation == "vertical") {
								c.params[2] += c.params[4] / 2;
								c.params[4] = 0
							} else {
								c.params[1] -= c.params[3] / 2;
								c.params[3] = 0
							}
						}
						break;
					case "spline":
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								c.params[1] = this.replaceArray(c.params[1], c.baseline[0]);
								c.params[2] = this.replaceArray(c.params[2], c.baseline[1])
							} else {
								if (this.graphOrientation == "vertical") {
									c.params[2] = this.replaceArray(c.params[2], c.baseline)
								} else {
									c.params[1] = this.replaceArray(c.params[1], c.baseline)
								}
							}
						}
						break;
					case "violin":
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								c.params[1][0] = c.baseline[0];
								c.params[1][1] = c.baseline[0];
								c.params[2][0] = c.baseline[1];
								c.params[2][1] = c.baseline[1]
							}
						}
						break;
					case "confidence":
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								for (var g = 0; g < c.params[1].length; g++) {
									c.params[1][g][0] = c.params[1][g][1] = c.baseline[g][0];
									c.params[2][g][0] = c.params[2][g][1] = c.baseline[g][1]
								}
							} else {
								if (this.graphOrientation == "vertical") {
									for (var g = 0; g < c.params[2].length; g++) {
										c.params[2][g][0] = c.params[2][g][1] = c.baseline
									}
								} else {
									for (var g = 0; g < c.params[1].length; g++) {
										c.params[1][g][0] = c.params[1][g][1] = c.baseline
									}
								}
							}
						}
						break;
					case "polygon":
						for (var g = 1; g < c.params[1].length; g++) {
							c.params[1][g] = c.params[1][0];
							c.params[2][g] = c.params[2][0]
						}
						break;
					case "arc2":
						c.params[3] = 0;
						c.params[4] = 0;
						c.params[12] = 0;
						c.params[13] = 0;
						break;
					case "pie":
						c.params[12] = 0;
						c.params[13] = 0;
						break;
					case "arch":
						c.params[1][0] = c.params[1][2] = c.params[1][3] = c.params[1][5] = c.params[1][1];
						c.params[2][0] = c.params[2][2] = c.params[2][3] = c.params[2][5] = c.params[2][1];
						c.params[3][0] = c.params[3][1] = c.params[3][2] = c.params[3][3] = 0;
						c.params[4] = 0;
						break;
					default:
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								c.params[1] = c.baseline[0];
								c.params[2] = c.baseline[1];
								c.params[3] = c.baseline[2] || 0;
								c.params[4] = c.baseline[3] || 0
							} else {
								if (this.graphOrientation == "vertical") {
									c.params[2] = c.baseline;
									c.params[3] = 0;
									c.params[4] = 0
								} else {
									c.params[1] = c.baseline;
									c.params[3] = 0;
									c.params[4] = 0
								}
							}
						} else {
							c.params[3] = 0;
							c.params[4] = 0
						}
						if (l == "ellipse2") {
							c.params[8] = c.params[8] > 0 ? Math.PI / 2 : -Math.PI / 2
						}
						break
				}
				break;
			case "drawLine":
				var l = c.params[0];
				switch (l) {
					case "error":
						var b = e();
						if (b) {
							if (c.params[6] > 0) {
								c.params[1] = c.params[3] = b.baseline || b.params[1]
							} else {
								c.params[2] = c.params[4] = b.baseline || b.params[2]
							}
							c.params[6] = 0
						}
						break;
					case "median":
						var b = e();
						if (b) {
							if (this.graphOrientation == "vertical") {
								c.params[1] = c.params[3] = (c.params[1] + c.params[3]) / 2;
								c.params[2] = c.params[4] = b.baseline || b.params[2]
							} else {
								c.params[2] = c.params[4] = (c.params[2] + c.params[4]) / 2;
								c.params[1] = c.params[3] = b.baseline || b.params[1]
							}
						}
						break;
					case "spline":
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								for (var g = 0; g < c.params[1].length; g++) {
									c.params[1][g] = c.baseline[0];
									c.params[2][g] = c.baseline[1]
								}
							} else {
								if (this.graphOrientation == "vertical") {
									for (var g = 0; g < c.params[2].length; g++) {
										c.params[2][g] = c.baseline
									}
								} else {
									for (var g = 0; g < c.params[1].length; g++) {
										c.params[1][g] = c.baseline
									}
								}
							}
						} else {
							if (this.graphOrientation == "vertical") {
								for (var g = 1; g < c.params[1].length; g++) {
									c.params[1][g] = c.params[1][0]
								}
							} else {
								for (var g = 1; g < c.params[2].length; g++) {
									c.params[2][g] = c.params[2][0]
								}
							}
						}
						break;
					default:
						if (c.baseline != null) {
							if (this.isArray(c.baseline)) {
								if (c.baseline.length == 4) {
									c.params[1] = c.baseline[0];
									c.params[2] = c.baseline[1];
									c.params[3] = c.baseline[2];
									c.params[4] = c.baseline[3]
								} else {
									c.params[1] = c.baseline[0];
									c.params[2] = c.baseline[1];
									c.params[3] = c.baseline[0];
									c.params[4] = c.baseline[1]
								}
							} else {
								if (this.graphOrientation == "vertical") {
									c.params[2] = c.baseline;
									c.params[4] = c.baseline
								} else {
									c.params[1] = c.baseline;
									c.params[3] = c.baseline
								}
							}
						} else {
							if (this.graphOrientation == "vertical") {
								c.params[3] = c.params[1];
								c.params[4] = c.params[2]
							} else {
								c.params[3] = c.params[1];
								c.params[4] = c.params[2]
							}
						}
						break
				}
				break;
			case "drawText":
				if (c.baseline != null) {
					if (this.isArray(c.baseline)) {
						c.params[1] = c.baseline[0];
						c.params[2] = c.baseline[1];
						if (c.baseline[2]) {
							c.params[3] = c.baseline[2]
						}
						if (c.baseline[3]) {
							c.params[7] = c.baseline[3]
						}
					} else {
						if (this.graphOrientation == "vertical") {
							c.params[2] = c.baseline
						} else {
							c.params[1] = c.baseline
						}
					}
				} else {
					c.params[4] = "rgba(0,0,0,0)"
				}
				break;
			case "drawArcText":
				c.params[3] = 0;
				c.params[4] = 0;
				c.params[5] = 0;
				break;
			default:
		}
		return c
	};
	this.initTransitionObject = function() {
		var a = this.meta.render;
		if (a.transition) {
			this.resetRender(true)
		} else {
			this.resetRender(true);
			for (var b = 0; b < a.transition.objects.length; b++) {
				this.setTransitionObject(a.transition.objects[b])
			}
		}
	};
	this.mapTransitionObject = function() {
		var f = this;
		var a = this.meta.render;
		var b = {};
		var g = {};
		var d = false;
		var e = function() {
			var n = {};
			var k;
			var o = f.data.tree.click;
			var s = o._children ? a.transition.objects : a.objects;
			var l = "Tree-Node:" + o.id;
			var m = o._children ? a.objects[a.map["Tree-Node:" + o.id]] : a.transition.objects[a.transition.map["Tree-Node:" + o.id]];
			if (o._children) {
				o.children = o._children;
				k = o.descendants();
				o._children = o.children;
				o.children = null
			} else {
				k = o.descendants()
			}
			for (var p = 0; p < k.length; p++) {
				n[k[p].id.toString()] = true
			}
			for (var p = 0; p < s.length; p++) {
				for (var q in n) {
					var j = new RegExp(":" + q + "$");
					if (s[p].id.match(j)) {
						switch (s[p].func) {
							case "drawLine":
								s[p].baseline = [m.params[1], m.params[2], m.params[1], m.params[2]];
								break;
							default:
								s[p].baseline = [m.params[1], m.params[2]];
								break
						}
					}
				}
			}
			f.data.tree.click = false
		};
		var h = function(s) {
			var y = a.transition.types.hasOwnProperty(s) ? a.transition.types[s].all : [];
			var p = a.types.hasOwnProperty(s) ? a.types[s].all : [];
			var r = a.transition.objects;
			var x = a.objects;
			var G = a.origin;
			var C = {};
			var l = [];
			if (s == "Data" && ((f.data.y && f.data.y.histogram) || (f.meta.vals.histogram))) {
				var D = f.data.y && f.data.y.histogram ? f.data.y.histogram : f.meta.vals.histogram;
				for (var B = 0; B < D.length; B++) {
					for (var A = 0; A < D[B].length; A++) {
						for (var z = 0; z < D[B][A].length; z++) {
							var w = D[B][A][z] + ":0:" + A + ":false";
							var v = D[B][A][z] + ":0:" + (A + 1) + ":false";
							if (f.meta.vals.histogram) {
								var n = a.map[w];
								var m = a.map[v];
								var w = B + ":" + (A + 1);
								var F = a.transition.map[w];
								if (F != null && n != null) {
									l.push([F, n])
								} else {
									if (F != null && m != null) {
										l.push([F, m])
									}
								}
							} else {
								var F = a.transition.map[w];
								var E = a.transition.map[v];
								var o = B + ":" + (A + 1);
								var n = a.map[o];
								if (F != null && n != null) {
									l.push([F, n])
								} else {
									if (E != null && n != null) {
										l.push([E, n])
									}
								}
							}
						}
					}
				}
			} else {
				for (var B = 0; B < p.length; B++) {
					var u = x[p[B]];
					if (!u.ignore) {
						for (var A = 0; A < G[p[B]].length; A++) {
							var q = G[p[B]][A];
							if (q) {
								l.push([q, p[B]])
							} else {
								l.push([f.setTransitionObject(f.cloneObject(u), true), p[B]])
							}
							C[q] = true
						}
					}
				}
				if (!d) {
					for (var B = 0; B < y.length; B++) {
						var q = r[y[B]];
						if (!q.ignore) {
							if (!C[y[B]]) {
								l.push([y[B], f.setTransitionObject(f.cloneObject(q))])
							}
						}
					}
				}
			}
			return l
		};
		if (!a.transition) {
			this.initTransitionObject();
			d = true
		}
		if (this.graphType == "Tree" && this.data.tree.click) {
			e()
		}
		for (var c in a.types) {
			g[c] = h(c);
			b[c] = true
		}
		for (var c in a.transition.types) {
			if (!b.hasOwnProperty(c)) {
				g[c] = h(c)
			}
		}
		return g
	};
	this.resetRender = function(c, b) {
		var a = this.meta.render;
		if (a.objects.length > 0 && !this.skipTransition) {
			delete(a.transition);
			a.transition = this.cloneObject(a, b)
		}
		if (!c) {
			a.objects = [];
			a.groups = {};
			a.types = {};
			a.order = [];
			a.map = {};
			a.origin = []
		}
	};
	this.render = function(b, d) {
		if (!this.debug && this.graphType != "Video") {
			var c = this.meta.render.objects;
			if (c.length > 0) {
				if (!b) {
					b = 0
				}
				if (!d) {
					d = c.length
				}
				for (var a = b; a < d; a++) {
					var f = c[a];
					this[f.func].apply(this, f.params)
				}
			}
		}
	};
	this.initializeCanvasEvents()
};
CanvasXpress.prototype.initCleanupEvents = function() {
	this.destroy = function(a) {
		if (a) {
			if (typeof(a) == "object" && a.target) {
				a = a.target
			}
			if (CanvasXpress.instances.length == 1 && CanvasXpress.instances[0].target == a) {
				return this.destroy()
			} else {
				this.removeInstance(a)
			}
		} else {
			this.removeInstance(this.target);
			CanvasXpress.cacheImages = {};
			CanvasXpress.cacheText = {};
			CanvasXpress.stack = {};
			CanvasXpress.current = false
		}
	};
	this.monitorInstances = function() {
		var a = this;
		setTimeout(function() {
			var d = [];
			for (var b = 0; b < CanvasXpress.instances.length; b++) {
				var e = a.$(CanvasXpress.instances[b].target);
				if (!e) {
					d.push(CanvasXpress.instances[b].target)
				}
			}
			for (var b = 0; b < d.length; b++) {
				a.destroy(d[b])
			}
		}, 1000)
	};
	this.removeInstance = function(f, b) {
		var e = CanvasXpress.instances;
		CanvasXpress.instances = [];
		for (var d = 0; d < e.length; d++) {
			if (e[d].target != f) {
				CanvasXpress.instances.push(e[d])
			} else {
				var h = e[d];
				if (h.isR) {
					var g = h.$("container-" + h.target).parentNode;
					var c = h.$cX("canvas", {
						id: h.target,
						width: h.meta.canvas.ctx.canvas.originalWidth,
						height: h.meta.canvas.ctx.canvas.originalHeight
					});
					h.resetTooltipDivs();
					h.cleanEvtListeners(b);
					h.removeTarget("container-" + h.target);
					h.removeTarget(h.target + "-cX-Info");
					delete CanvasXpress.stack[h.target];
					g.appendChild(c)
				} else {
					h.resetTooltipDivs();
					h.cleanEvtListeners(b);
					h.removeTarget("container-" + h.target);
					h.removeTarget(h.target + "-cX-Info");
					delete CanvasXpress.stack[h.target]
				}
			}
		}
	};
	this.cleanEvtListeners = function(b) {
		this.addRemoveLinkListeners("removeEvtListener");
		this.addRemoveToolbarListeners("removeEvtListener");
		this.addRemoveTouchToolbarListeners("removeEvtListener");
		this.addRemoveCodeListeners("removeEvtListener");
		this.addRemoveBinListeners("removeEvtListener");
		this.addRemoveDataExplorerListeners("removeEvtListener");
		this.addRemoveItemListeners("removeEvtListener");
		this.addRemoveConfiguratorListeners("removeEvtListener");
		this.addRemoveDataTableListeners("removeEvtListener");
		this.removeGenericDataFilterListenersOrReset();
		this.addRemoveDataFilterListeners("removeEvtListener");
		this.addRemoveCanvasListeners("removeEvtListener");
		this.addRemoveMotionListeners("removeEvtListener");
		this.addRemoveAxesResizerListeners("removeEvtListener");
		this.addRemoveNavigationListeners("removeEvtListener");
		this.removeEvtListener(document, "mousemove", this.mousemoveDoc, false);
		this.removeEvtListener(document, "touchmove", this.mousemoveDoc, false);
		this.removeEvtListener(document, "mouseup", this.mouseupDoc, false);
		this.removeEvtListener(document, "touchend", this.mouseupDoc, false);
		this.removeEvtListener(document, "keydown", this.keydownDoc, false);
		this.removeEvtListener(document, "keyup", this.keyupDoc, false);
		this.removeEvtListener(window, "resize", this.resizeWindow, false)
	}
};
CanvasXpress.prototype.initEvents = function() {
	this.cloneEvent = function(g) {
		var f = ["ac", "altKey", "bubbles", "button", "buttons", "cancelBubble", "cancelable", "charCode", "code", "clientX", "clientY", "ctrlKey", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "eventPhase", "isTrusted", "isTrusted", "keyCode", "keyIdentifier", "location", "layerX", "layerY", "metaKey", "movementX", "movementY", "offsetX", "offsetY", "pageX", "pageY", "repeat", "returnValue", "screenX", "screenY", "shiftKey", "timeStamp", "type", "wheelDelta", "wheelDeltaX", "wheelDeltaY", "which", "x", "y"];
		var d = ["clientX", "clientY", "force", "identifier", "pageX", "pageY", "radiusX", "radiusY", "rotationAngle", "screenX", "screenY"];
		var a = {
			srcElement: g.srcElement ? g.srcElement.id : g.target.id,
			target: g.target.id
		};
		for (var c = 0; c < f.length; c++) {
			a[f[c]] = g[f[c]]
		}
		if (!a.ac) {
			a.ac = this.adjustedCoordinates(a)
		}
		a.xMouseDown = this.xMouseDown;
		a.yMouseDown = this.yMouseDown;
		if (g.touches) {
			a.touches = [];
			for (var c = 0; c < g.touches.length; c++) {
				a.touches[c] = {
					target: g.touches[c].target.id
				};
				for (var b = 0; b < d.length; b++) {
					a.touches[c][d[b]] = g.touches[c][d[b]]
				}
				if (!a.touches[c].ac) {
					a.touches[c].ac = this.adjustedCoordinates(g.touches[c], g.touches[c].target)
				}
			}
		}
		return a
	};
	this.cleanEventInArguments = function(b) {
		for (var c = 0; c < b.length; c++) {
			if (b[c] instanceof Event) {
				b[c] = this.cloneEvent(b[c])
			}
		}
		return b
	};
	this.regularCoordinates = function(i, g) {
		var k = {};
		if (i && i.ac) {
			k.x = i.ac.x;
			k.y = i.ac.y
		} else {
			if (i.pageX == null && g.clientX != null) {
				var h = i.target.ownerDocument || document;
				var j = h.documentElement;
				var a = h.body;
				k.x = g.clientX + (j && j.scrollLeft || a && a.scrollLeft || 0) - (j && j.clientLeft || a && a.clientLeft || 0);
				k.y = g.clientY + (j && j.scrollTop || a && a.scrollTop || 0) - (j && j.clientTop || a && a.clientTop || 0)
			} else {
				k.x = i.pageX;
				k.y = i.pageY
			}
		}
		return k
	};
	this.relativeCoordinates = function(a) {
		var b = {
			x: 0,
			y: 0
		};
		if (a && a.ac) {
			b.x = a.ac.x;
			b.y = a.ac.y
		} else {
			while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
				b.x += a.offsetLeft;
				b.y += a.offsetTop;
				a = a.offsetParent
			}
		}
		return b
	};
	this.absoluteCoordinates = function(a) {
		var b = {
			x: 0,
			y: 0
		};
		if (a && a.ac) {
			b.x = a.ac.x;
			b.y = a.ac.y
		} else {
			while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
				b.x += a.offsetLeft - a.scrollLeft;
				b.y += a.offsetTop - a.scrollTop;
				a = a.offsetParent
			}
		}
		return b
	};
	this.adjustedCoordinates = function(g, b) {
		if (!g) {
			g = window.event
		}
		if (!b) {
			b = this.$(this.target)
		}
		if (b) {
			var h = {};
			var a = b.parentNode.getClientRects();
			var d = g && g.changedTouches ? g.changedTouches[0] : false;
			if (g && g.ac) {
				h.x = g.ac.x;
				h.y = g.ac.y
			} else {
				if (a && a[0]) {
					var f = a[0].left;
					var k = a[0].top;
					var j = g && g.clientX ? g.clientX : d ? d.clientX : g && g[0] ? g[0] : f;
					var i = g && g.clientY ? g.clientY : d ? d.clientY : g && g[1] ? g[1] : k;
					h.x = document.body.scrollLeft > Math.abs(f) + j && j > document.body.scrollLeft - f ? Math.abs(f) + j : j - f;
					h.y = document.body.scrollTop > Math.abs(k) + i && i > document.body.scrollTop - k ? Math.abs(k) + i : (i - k)
				} else {
					h.x = 0;
					h.y = 0
				}
			}
			return h
		}
	};
	this.isObjectInsideArea = function(g, d, f, b, e) {
		var a, h;
		switch (g[0]) {
			case "rect":
				a = (g[1] + g[3]) / 2;
				h = (g[2] + g[4]) / 2;
				break;
			case "circle":
				a = g[1];
				h = g[2];
				break;
			case "poly":
				var c = this.centroidArea(g);
				a = c[0];
				h = c[1];
				break
		}
		return this.isPointInsideArea(a, h, ["rect", d, f, b, e])
	};
	this.isPointInsideArea = function(m, l, k) {
		if (k) {
			switch (k[0]) {
				case "rect":
					if (k[1] > k[3]) {
						k[5] = k[1];
						k[1] = k[3];
						k[3] = k[5]
					}
					if (k[2] > k[4]) {
						k[5] = k[2];
						k[2] = k[4];
						k[4] = k[5]
					}
					if (m >= k[1] && m <= k[3] && l >= k[2] && l <= k[4]) {
						return true
					} else {
						return false
					}
				case "circle":
					var f = k[3] / 2;
					if (m >= k[1] - f && m <= k[1] + f && l >= k[2] - f && l <= k[2] + f) {
						return true
					} else {
						return false
					}
				case "poly":
					var d = [];
					var a = [];
					var g = false;
					for (var e = 1; e < k.length; e++) {
						if (e % 2) {
							d.push(k[e])
						} else {
							a.push(k[e])
						}
					}
					if (a[0] < a[1]) {
						a = a.reverse();
						d = d.reverse()
					}
					for (var e = 0, b = d.length - 1; e < d.length; b = e++) {
						if (((a[e] <= l && l < a[b]) || (a[b] <= l && l < a[e])) && (m < (d[b] - d[e]) * (l - a[e]) / (a[b] - a[e]) + d[e])) {
							g = !g
						}
					}
					return g
			}
		} else {
			return false
		}
	};
	this.isEvent = function(h, a) {
		var f = this.adjustedCoordinates(h);
		if (f) {
			var b = this.getTargetEvent(h);
			if ((b && b.id && b.id.match(this.target)) || (this.isMap && b.className.match(/leaflet/))) {
				var g = this.meta.render.objects;
				var c = [];
				for (var d = g.length - 1; d >= 0; d--) {
					var j = g[d];
					if (j.idx) {
						if (this.isPointInsideArea(f.x, f.y, j.area)) {
							if (a) {
								c.push(d)
							} else {
								return [d]
							}
						}
					}
				}
				if (a && c.length > 0) {
					return c
				}
			}
		}
		return false
	};
	this.isEventIndices = function(g, d, c) {
		var b = [];
		var a = c ? c : this.isEvent(g, d);
		if (a) {
			if (a.length == 1) {
				var h = this.meta.render.objects[a[0]];
				return h.modifier ? h.idx + h.modifier : h.idx
			} else {
				for (var f = 0; f < a.length; f++) {
					var h = this.meta.render.objects[a[f]];
					b.push(h.idx)
				}
				return b
			}
		}
		return false
	};
	this.getBoundsXY = function(e) {
		var d = this.layoutComb ? this.layoutParams[e] : this;
		var a = this.graphType == "Network" ? 0 : this.marginLeft + d.offsetX;
		var b = this.graphType == "Network" ? 0 : this.marginTop + d.offsetY;
		return [a + d.left, a + d.left + d.x, b + d.top, b + d.top + d.y, a, a + d.left + d.x + d.right, b, b + d.top + d.y + d.bottom]
	};
	this.getUngroupedDataObject = function(a) {
		if (this.isGroupedData && a.w) {
			this.isGroupedData = false;
			a = this.extractDataObject(a.w.grps[0], this.getVariableIndices(a.w.vars));
			this.isGroupedData = true
		}
		return a
	};
	this.extractDataObject = function(q, b) {
		var r = this;
		var x = this.layoutParams;
		var h = this.layoutValidN;
		var u = this.data;
		var N = this.layoutComb && h !== false ? x[h].graphType : this.graphType;
		var T = [];
		var R = [];
		var Q = [];
		var F = function(d) {
			var k = {};
			for (var j in u.x) {
				k[j] = [];
				for (var g = 0; g < d.length; g++) {
					k[j].push(u.x[j][d[g]])
				}
			}
			return k
		};
		var D = function(d) {
			var k = {};
			for (var j in u.z) {
				k[j] = [];
				for (var g = 0; g < d.length; g++) {
					k[j].push(u.z[j][d[g]])
				}
			}
			return k
		};
		var O = function(d) {
			var j = [];
			if (r.isDOE) {
				for (var g = 0; g < d.length; g++) {
					j.push(x[h].data.y.vars[d[g]])
				}
			} else {
				for (var g = 0; g < d.length; g++) {
					j.push(u.y.vars[d[g]])
				}
			}
			return j
		};
		var w = function(j, n) {
			var d = n ? n : u.y.smps;
			var p = [];
			if (r.isDOE) {
				p.push(x[h].data.y.smps[j[0]])
			} else {
				for (var k = 0; k < j.length; k++) {
					p.push(d[j[k]])
				}
			}
			return p
		};
		var m = function(g, d) {
			var k = [];
			for (var j = 0; j < g.length; j++) {
				k.push(d.grps[g[j]])
			}
			return k
		};
		var f = function(g, d, s) {
			var p = [];
			if (r.isDOE) {
				for (var n = 0; n < g.length; n++) {
					p[n] = [];
					p[n].push(x[h].data.y.data[g[n]][d[0]])
				}
			} else {
				if (!s) {
					s = "data"
				}
				if (d) {
					for (var n = 0; n < g.length; n++) {
						p[n] = [];
						if (r.isTransformedData) {
							for (var k = 0; k < d.length; k++) {
								p[n].push(r.bestFormatNumber(u.y.trans[g[n]][d[k]]))
							}
						} else {
							for (var k = 0; k < d.length; k++) {
								p[n].push(u.y[s][g[n]][d[k]])
							}
						}
					}
				} else {
					if (r.isTransformedData) {
						for (var n = 0; n < g.length; n++) {
							p.push(r.bestFormatNumber(u.y.trans[g[n]]))
						}
					} else {
						for (var n = 0; n < g.length; n++) {
							p.push(u.y[s][g[n]])
						}
					}
				}
			}
			return p
		};
		switch (N) {
			case "Area":
			case "AreaLine":
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Pie":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
			case "Treemap":
			case "TagCloud":
			case "ParallelCoordinates":
			case "Sankey":
			case "Tree":
			case "Map":
				if (!q || q.length == 0 || q[0] == null) {
					return
				} else {
					if (isNaN(q[0])) {
						if (q[0] && q[0].match(/Confidence/)) {
							var P = q[0].split(":");
							var G = {
								display: P[0],
								objectType: "Confidence"
							};
							return G
						} else {
							if (q[0] && q[0].match(/Line/)) {
								var P = q[0].split(":");
								var G = {
									display: P[1],
									objectType: "Line"
								};
								return G
							} else {
								if (q[0] && q[0].match(/Sankey/)) {
									var P = q[0].split(":");
									var G = {
										display: P[1],
										objectType: "Sankey"
									};
									return G
								} else {
									if (q[0] && q[0].match(/Tree/)) {
										var G = {};
										var l = this.getTreeNode(q[0]);
										if (l) {
											G = {
												id: l.id,
												display: l.data.tooltip,
												objectType: "Tree"
											}
										}
										return G
									} else {
										if (q[0] && q[0].match(/Marker/)) {
											var P = q[0].split(":");
											var G = {
												id: P[1],
												display: P[2],
												objectType: "Marker"
											};
											return G
										} else {
											if (q[0] && q[0].match(/Violin/)) {
												var P = q[0].split(":");
												var G = {
													display: P[1],
													objectType: "Violin"
												};
												return G
											} else {
												if (q[0] && q[0].match(/Sunburst/)) {
													var P = q[0].split(":");
													var G = {
														display: P[1],
														objectType: "Sunburst"
													};
													return G
												} else {
													if (q[0] && q[0].match(/Bubble/)) {
														var P = q[0].split(":");
														var G = {
															display: P[1],
															objectType: "Bubble"
														};
														return G
													} else {
														if (q[0] && q[0].match(/Connect/)) {
															var P = q[0].split(":");
															var G = {
																display: P[1],
																objectType: "Connect"
															};
															return G
														} else {
															if (q[0] && q[0].match(/Chord/)) {
																var P = q[0].split(":");
																var G = {
																	id: P[1],
																	display: P[2],
																	objectType: "Chord"
																};
																return G
															} else {
																if (q[0] && q[0].match(/Outlier/)) {
																	var P = q[0].split(":");
																	var G = {
																		display: P[1],
																		objectType: "Outlier"
																	};
																	return G
																} else {
																	if (q[0] && q[0].match(/Histogram/)) {
																		var E = q[0].split("-");
																		var G = {
																			h: {
																				a: E[0],
																				b: E[1],
																				c: E[2],
																				d: E[3]
																			}
																		};
																		G.objectType = "Histogram";
																		return G
																	} else {
																		if (q[0] && q[0].match(/Dendrogram/)) {
																			var G = {
																				t: {}
																			};
																			var E = q[0].split("-");
																			if (E.length > 1) {
																				G.t.nodeId = parseInt(E.shift());
																				G.t.height = Number(E.shift());
																				G.t.objectType = E.shift();
																				G.t.name = E[0] ? E.join("-") : false
																			} else {
																				G.t.tooltip = "<i>Drag to move</i>"
																			}
																			return G
																		} else {
																			if (q[0] && q[0].match(/,error/)) {
																				var E = q[0].split(",");
																				T = [parseInt(E[0])];
																				R = [parseInt(E[1])]
																			} else {
																				if (q[0] && q[0].match(/Var/)) {
																					var E = q[0].split("-");
																					var M = parseInt(E[1]);
																					var S = [M];
																					S = S.concat(this.smpIndices);
																					var G = this.extractDataObject(S);
																					if (q[0].match(/VarOvr/)) {
																						G.display = this.varOverlays[E[2]] + " : " + u.z[this.varOverlays[E[2]]][M];
																						G.objectType = "VarOverlay"
																					} else {
																						if (q[0].match(/VarOverlay/)) {
																							G.display = this.varOverlays[E[1]];
																							G.objectType = "VarOverlay"
																						} else {
																							G.display = u.y.vars[M];
																							G.objectType = "Var"
																						}
																					}
																					return G
																				} else {
																					if (q[0] && q[0].match(/Smp/)) {
																						var E = q[0].split("-");
																						var M = parseInt(E[1]);
																						var G = this.extractDataObject([M], this.varIndices);
																						if (q[0].match(/SmpOvrSgr/)) {
																							G.display = this.smpOverlays[E[1]] + " : " + E[2];
																							G.objectType = "SmpOverlaySgr"
																						} else {
																							if (q[0].match(/SmpOvr/)) {
																								G.display = this.isGroupedData ? this.smpOverlays[E[2]] + " : " + u.w.factors[this.smpOverlays[E[2]]][M] : this.smpOverlays[E[2]] + " : " + u.x[this.smpOverlays[E[2]]][M];
																								G.objectType = "SmpOverlay"
																							} else {
																								if (q[0].match(/SmpOverlay/)) {
																									G.display = this.smpOverlays[E[1]];
																									G.objectType = "SmpOverlay"
																								} else {
																									G.display = this.isGroupedData ? u.w.smps[M] : u.y.smps[M];
																									G.objectType = "Smp"
																								}
																							}
																						}
																						return G
																					} else {
																						if (q[0] && q[0].match(/Cat/)) {
																							var G = {};
																							var E = q[0].split("-");
																							G.display = E[1];
																							G.objectType = "Cat";
																							return G
																						} else {
																							if (q[0] && q[0].match(/Onc/)) {
																								var G = {};
																								var E = q[0].split("-");
																								G.display = E[1];
																								G.objectType = "Onc";
																								return G
																							} else {
																								return
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						if (N == "Pie" && q.length > 2) {
							R = [q[0]];
							for (var M = 1; M < q.length; M++) {
								T.push(q[M])
							}
						} else {
							if (b) {
								T = b;
								R = q
							} else {
								T = [q[0]];
								R = [];
								for (var M = 1; M < q.length; M++) {
									if (q[M] !== false) {
										R.push(q[M])
									}
								}
							}
						}
						if (N.match(/Scatter/)) {
							if (this.colorBy && this.getSampleIndices(this.colorBy) > -1) {
								R.push(this.getSampleIndices(this.colorBy))
							}
							if (this.shapeBy && this.getSampleIndices(this.shapeBy) > -1) {
								R.push(this.getSampleIndices(this.shapeBy))
							}
							if (this.sizeBy && this.getSampleIndices(this.sizeBy) > -1) {
								R.push(this.getSampleIndices(this.sizeBy))
							}
						}
					}
				}
				if ((this.isGroupedData && u.w && N != "Treemap" && !this.treemapBy.length > 0) || (this.isDOE && this.showDOEData && h == 0 && u.w) || (this.layoutValid && u.l.group && N != "Treemap")) {
					var G = {
						x: {},
						w: {},
						z: D(T)
					};
					if (N.match(/Boxplot|Dotplot|DotLine/) && R[1] != null) {
						G.y = {
							data: u.y.data[T[0]][R[1]],
							vars: u.y.vars[T[0]],
							smps: u.y.smps[R[1]]
						};
						R.pop()
					}
					var e = this.layoutValid && u.l.group && x[h].w ? x[h].w : u.w;
					for (var E in e) {
						if (E == "smps") {
							G.w[E] = w(R, e.smps)
						} else {
							if (E == "grps") {
								G.w[E] = m(R, e)
							} else {
								if (E == "vars") {
									G.w[E] = O(T)
								} else {
									if (e[E].length > T[0] && e[E][T[0]].length > R[0]) {
										G.w[E] = [];
										G.w[E].push(e[E][T[0]][R[0]])
									}
								}
							}
						}
					}
					for (var E in u.x) {
						var y = [];
						for (var M = 0; M < G.w.grps[0].length; M++) {
							y.push(u.x[E][G.w.grps[0][M]])
						}
						G.x[E] = y
					}
				} else {
					var G = {
						x: F(R),
						y: {
							vars: O(T),
							smps: w(R)
						},
						z: D(T)
					};
					if (this.isHistogram && !this.isDOE) {
						G.y.histogram = u.y.histogram[T]
					}
					if (this.isDOE) {
						if (x[h].data.y.pie) {
							G.y.pie = [];
							for (var M = 0; M < T.length; M++) {
								G.y.pie.push(x[h].data.y.pie[T[M]])
							}
						} else {
							if (x[h].data.y.treemap) {
								G.y.treemap = [];
								for (var M = 0; M < T.length; M++) {
									G.y.treemap.push(x[h].data.y.treemap[T[M]])
								}
							} else {
								if (x[h].data.y.histogram) {
									G.y.histogram = x[h].data.y.histogram[T]
								}
							}
						}
					}
					if (N == "Candlestick") {
						for (var E in u.y) {
							if (E && E != "vars" && E != "smps" && E != "desc") {
								G.y[E] = [];
								for (var M = 0; M < T.length; M++) {
									G.y[E][M] = [];
									for (var L = 0; L < R.length; L++) {
										G.y[E][M].push(u.y[E][T[M]][R[L]])
									}
								}
							}
						}
					} else {
						G.y.data = f(T, R);
						if (this.isMultidimensionalData) {
							var I = ["outline", "shape", "size"];
							for (var M = 0; M < I.length; M++) {
								var J = I[M] + "ByData";
								if (u.y[this[J]]) {
									G.y[this[J]] = f(T, R, this[J])
								}
							}
						} else {
							if (N == "Sankey") {
								G.links = this.data.sankey.links[R]
							}
						}
					}
				}
				return G;
			case "Correlation":
				var P;
				if (!q || (isNaN(q[0]) && !q[0].match(/^\d/))) {
					return
				} else {
					P = this.isGroupedData ? u.w.cor : u.y.cor
				}
				if (this.correlationAxis == "samples") {
					var G = {
						x: {},
						y: {}
					};
					for (var E in u.x) {
						var y = [];
						for (var M = 0; M < q.length; M++) {
							y.push(u.x[E][q[M]])
						}
						G.x[E] = y
					}
					G.y.smps = [u.y.smps[q[0]], u.y.smps[q[1]]]
				} else {
					var G = {
						y: {},
						z: {}
					};
					for (var E in u.y) {
						var c = [];
						for (var M = 0; M < q.length; M++) {
							c.push(u.y[E][q[M]])
						}
						G.z[E] = c
					}
					G.y.vars = [u.y.vars[q[0]], u.y.vars[q[1]]]
				}
				G.y.data = P[q[0]][q[1]];
				return G;
			case "Venn":
				var G = {
					venn: {
						data: {}
					}
				};
				G.venn.data[this.vennCompartments[q[0]]] = u.venn.data[this.vennCompartments[q[0]]];
				return G;
			case "Network":
				var G = {};
				if (!q || q.length == 0) {
					return
				}
				if (isNaN(q[0])) {
					q[0] = q[0].toString();
					if (q[0].match(/legend/)) {
						if (q[0].match(/Nodes/)) {
							G = {
								nodeLegend: u.legend.nodes
							}
						} else {
							if (q[0].match(/Edges/)) {
								G = {
									edgeLegend: u.legend.edges
								}
							} else {
								if (q[0].match(/Decorations/)) {
									G = {
										decorationLegend: u.legend.decorations
									}
								} else {
									if (q[0].match(/-legend-indicator-color/)) {
										G = {
											indicatorLegend: "ColorIndicator"
										}
									} else {
										var A = parseInt(q[0].replace("-1-legend-Text", ""));
										G = {
											textLegend: u.legend.text[A]
										}
									}
								}
							}
						}
					} else {
						if (q[0].match(/-dec/)) {
							var M = q[0].split("-");
							var H = u.nodes[M[0]];
							var P = this.decorations[M[1]];
							var z = H[P] ? H[P] : H.decorations && H.decorations[P] ? H.decorations[P] : false;
							var K = M[3] ? M[2] : false;
							if (K) {
								if (z) {
									if (z[K] != null) {
										G.display = P + " : " + K + " : " + z[K]
									} else {
										G.display = P + " : " + K + " : NA"
									}
								} else {
									G.display = P + " : NA"
								}
							} else {
								G.display = P + " : " + z
							}
						} else {
							if (q[0].match(/-elbow/)) {
								G = {
									edges: [u.edges[parseInt(q[0].split("-")) - u.nodes.length]]
								}
							}
						}
					}
				} else {
					for (var M = 0; M < q.length; M++) {
						if (q[M] >= u.nodes.length) {
							if (!G.edges) {
								G.edges = []
							}
							G.edges.push(u.edges[q[M] - u.nodes.length])
						} else {
							if (!G.nodes) {
								G.nodes = []
							}
							G.nodes.push(u.nodes[q[M]])
						}
					}
				}
				return G;
			case "Genome":
				var N;
				var G = [];
				G[0] = {
					data: []
				};
				var A = 0;
				var B = isNaN(q[0]) && q[0].match(":") ? q[0].match(/:(\d+)/)[1] : false;
				for (var M = 0; M < u.tracks.length; M++) {
					var H = u.tracks[M].data.length;
					A += H;
					if (isNaN(q[0])) {
						if (q[0] == "track-" + M) {
							return {
								name: u.tracks[M].name
							}
						} else {
							if (q[0] == "track-" + M + ":" + B) {
								var C = parseInt(B) - (A - H);
								for (var E in u.tracks[M]) {
									if (E == "data") {
										G[0][E].push(u.tracks[M][E][C])
									} else {
										G[0][E] = u.tracks[M][E]
									}
								}
								return G
							}
						}
						continue
					}
					if (q[q.length - 1] < A) {
						for (var L = 0; L < q.length; L++) {
							var C = q[L] - (A - H);
							for (var E in u.tracks[M]) {
								if (E == "data") {
									G[0][E].push(u.tracks[M][E][C])
								} else {
									G[0][E] = u.tracks[M][E]
								}
							}
						}
						return G
					}
				}
		}
	};
	this.getSummaryDataObject = function(b) {
		if (b) {
			switch (this.graphType) {
				case "Bar":
				case "Line":
				case "Area":
				case "AreaLine":
				case "BarLine":
				case "Boxplot":
				case "Dotplot":
				case "DotLine":
				case "Heatmap":
				case "Stacked":
				case "StackedLine":
				case "StackedPercent":
				case "StackedPercentLine":
				case "Scatter2D":
				case "ScatterBubble2D":
				case "Scatter3D":
				case "Circular":
				case "Treemap":
				case "TagCloud":
				case "ParallelCoordinates":
				case "Map":
					var i = "";
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {
						if ((this.isGroupedData && b.w) || (this.showDOEData && this.configStndBy && this.configStndBy.groupingFactors && b.w)) {
							i = "<b>" + b.w.vars[0] + "</b><br>";
							if (this.summaryType == "mean") {
								i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.mean[0]);
								if (b.w.stdev && b.w.stdev[0] != null) {
									i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
								}
								if (b.w.n && b.w.n[0] != null) {
									i += " (" + b.w.n + ")"
								}
								i += "<br>"
							} else {
								if (this.summaryType == "median" || this.summaryType == "iqr" || (this.showDOEData && this.graphType == "Boxplot")) {
									i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.median[0]);
									if (b.w.stdev && b.w.stdev[0] != null) {
										i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
									}
									if (b.w.n && b.w.n[0] != null) {
										i += " (" + b.w.n + ")"
									}
									i += "<br>"
								} else {
									if (this.summaryType == "sum") {
										i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.sum[0]);
										if (b.w.stdev && b.w.stdev[0] != null) {
											i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
										}
										if (b.w.n && b.w.n[0] != null) {
											i += " (" + b.w.n + ")"
										}
										i += "<br>"
									}
								}
							}
							if (this.graphType.match(/Boxplot|Dotplot|DotLine/) && b.y && b.y.smps) {
								i += "<b>" + b.y.smps + "</b>: " + this.bestFormatNumber(b.y.data) + "<br>"
							}
						} else {
							if (b.y) {
								i = "<b>" + b.y.vars[0] + "</b><br>";
								for (var d = 0; d < b.y.smps.length; d++) {
									if (this.isMultidimensionalData) {
										var l = [b.y.data[0][d]];
										var g = ["outline", "shape", "size"];
										for (var c = 0; c < g.length; c++) {
											var m = g[c] + "ByData";
											if (b.y[this[m]] && b.y[this[m]][0][d]) {
												l.push(b.y[this[m]][0][d])
											}
										}
										i += "<b>" + b.y.smps[d] + "</b>: " + l.join(", ") + "<br>"
									} else {
										i += "<b>" + b.y.smps[d] + "</b>: " + b.y.data[0][d] + "<br>"
									}
								}
							} else {
								if (b.h) {
									i = "<b>" + this[b.h.a].vars[b.h.b] + "</b><br>n: " + this[b.h.a].data[b.h.b][b.h.c] + "<br>"
								} else {
									if (b.t) {
										if (b.t.tooltip) {
											i = b.t.tooltip
										} else {
											if (b.t.name) {
												i = "<b>" + b.t.name + "</b><br><i>Click to flip<br>Dbl-click to focus</i>"
											} else {
												i = "<i>Click to flip<br>Dbl-click to focus</i>"
											}
										}
									}
								}
							}
						}
					}
					return i;
				case "Sankey":
					if (b.links) {
						var i = "<b>" + b.links.source.name + " &#8702; " + b.links.target.name + "</b><br>";
						i += "<b>" + b.y.vars[0] + "</b>: " + b.y.data[0][0] + "<br>"
					} else {
						if (b.display) {
							return "<b>" + b.display + "</b><br>"
						}
					}
					return i;
				case "Tree":
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {}
					return i;
				case "Pie":
					var n = "<b>" + b.y.smps[0] + "</b><br>";
					for (var d = 0; d < b.y.vars.length; d++) {
						var a = sprintf("%." + this.pieSegmentPrecision + "f", (b.y.data[d] / this.varPie.tot) * 100);
						n += "<b>" + b.y.vars[d] + "</b>: " + b.y.data[d] + " (" + a + "%)<br>"
					}
					return n;
				case "Candlestick":
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {
						return dateFormat(b.y.smps[0], this.timeFormat) + ", " + b.y.close[0]
					}
				case "Correlation":
					var n;
					if (this.correlationAxis == "samples") {
						n = b.y.smps[0] + " vs " + b.y.smps[1]
					} else {
						n = b.y.vars[0] + " vs " + b.y.vars[1]
					}
					return n;
				case "Venn":
					for (var e in b.venn.data) {
						return e + " = " + b.venn.data[e]
					}
				case "Network":
					var n;
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {
						if (b && b.nodes) {
							if (b.nodes[0]) {
								n = b.nodes[0].hideTooltip ? "" : b.nodes[0].tooltip || b.nodes[0].name || b.nodes[0].label || b.nodes[0].id
							}
						} else {
							if (b && b.edges) {
								var h = this.nodes[b.edges[0].id1];
								var f = this.nodes[b.edges[0].id2];
								n = (h.label || h.id) + " - " + (f.label || f.id);
								n = b.edges[0].hideTooltip ? "" : b.edges[0].tooltip || b.edges[0].name || b.edges[0].label || n
							}
						}
					}
					return n;
				case "Genome":
					return b.name || b[0].data[0].id
			}
		} else {
			return ""
		}
	};
	this.setUserEvents = function() {
		var d = {};
		var c = this.events;
		if (this.disableEvents) {
			this.userEvents = {};
			return
		}
		var b = this;
		if (c && c.enddragnode) {
			d.enddragnode = c.enddragnode
		}
		if (c && c.stackchange) {
			d.stackchange = c.stackchange
		}
		if (c && c.select) {
			d.select = c.select
		}
		if (c && c.enddraw) {
			d.enddraw = c.enddraw
		}
		if (c && c.remoteupdate) {
			d.remoteupdate = c.remoteupdate
		}
		if (c && c.mouseout) {
			d.mouseout = c.mouseout
		} else {
			d.mouseout = function(j, h, g, f) {
				g.resetInfoSpan(h)
			}
		}
		if (c && c.mouseup) {
			d.mouseup = c.mouseup
		}
		if (c && c.contextmenu) {
			d.contextmenu = c.contextmenu
		} else {
			d.contextmenu = function(j, h, g, f) {
				if (g.graphType == "Network") {
					if (j && j.nodes && j.nodes.length == 1) {
						if (g.selectNode && !g.selectNode[j.nodes[0].id]) {
							g.resetSelectedObjects();
							g.addRemoveToSelectedDataPoints(f);
							g.handleUserSelectEvent()
						}
					}
				}
				g.addMenu(h)
			}
		}
		if (c && c.click) {
			d.click = c.click
		} else {
			d.click = function(j, h, g, f) {
				if (j && j.h) {
					g.addRemoveToSelectedDataPointsHistogram(j)
				} else {
					if (j && j.t) {
						g.modifyDendrogram(j)
					} else {
						if (j && j.objectType) {
							if (j.objectType == "Onc") {
								g.filterOncoprint(j.display)
							} else {
								if (j.objectType == "Tree") {
									g.handleTreeClick(j)
								} else {
									alert("Click on " + j.display)
								}
							}
						} else {
							if (j && j.nodes && j.nodes.length == 1 && j.nodes[0].links) {
								g.showLinkDiv(h, j.nodes[0].links, j.nodes[0].label != null ? j.nodes[0].label : j.nodes[0].name ? j.nodes[0].name : j.nodes[0].id)
							} else {
								if (j && j.edges && j.edges.length == 1 && j.edges[0].links) {
									g.showLinkDiv(h, j.edges[0].links, j.edges[0].label != null ? j.edges[0].label : j.edges[0].name ? j.edges[0].name : j.edges[0].id1 + "-" + j.edges[0].id2)
								} else {}
							}
						}
					}
				}
				return false
			}
		}
		if (c && c.dblclick) {
			d.dblclick = c.dblclick
		} else {
			d.dblclick = function(j, h, g, f) {
				if (j && j.t) {
					g.zoomDendrogram(j)
				} else {
					if (j && j.objectType) {
						alert("Double Click on " + j.display)
					} else {
						if (g.graphType == "Network" || g.graphType == "Genome") {
							g.addConfigurator(h, f)
						} else {
							if (j) {
								g.showTooltipDiv(h, g.arrayToHTML(g.getDataClassAsArray(g.getUngroupedDataObject(j))), false, false, false, false, j)
							}
						}
					}
				}
				return false
			}
		}
		var e = ["mouseover", "mousemove"];
		for (var a = 0; a < e.length; a++) {
			if (c && c[e[a]]) {
				d[e[a]] = c[e[a]]
			} else {
				d[e[a]] = function(k, i, g, h) {
					var j = g.getSummaryDataObject(k);
					if (j && j != "") {
						g.showInfoSpan(i, j);
						if (k.objectType == "Chord") {
							g.handleChordMouseOver(k)
						}
						if (h && h[0].toString().match("elbow")) {
							var f = g.getTargetEvent(i);
							f.style.cursor = "move"
						}
					}
				}
			}
		}
		this.userEvents = d
	};
	this.resetFlags = function(a) {
		this.resetOn = true;
		this.animationOn = false;
		this.skipTransition = false;
		this.draggingOn = false;
		this.movingOn = false;
		this.panningOn = false;
		this.changingColorOn = false;
		this.changingColorItemOn = false;
		this.changingSliderItemOn = false;
		this.keyOn = false;
		this.xMouseDown = false;
		this.yMouseDown = false;
		this.touches = false;
		this.toucheEvent = false;
		this.moveNode = false;
		this.moveNodeIndex = false;
		this.moveNodeLab = false;
		this.moveNodeDec = false;
		this.moveNodeX = false;
		this.moveNodeY = false;
		this.moveNodeW = false;
		this.moveNodeH = false;
		this.moveEdge = false;
		this.moveEdgeIndex = false;
		this.moveEdgeElbow = false;
		this.moveEdgeX = false;
		this.moveEdgeY = false;
		this.resizeNode = false;
		this.resizeLegend = false;
		this.moveLegend = false;
		this.moveLegendX = false;
		this.moveLegendY = false;
		this.moveMarker = false;
		this.moveMarkerX = false;
		this.moveMarkerY = false;
		this.moveSankey = false;
		this.moveSankeyX = false;
		this.moveSankeyY = false;
		this.moveGenome = false;
		this.moveDendrogram = false;
		this.moveVar = false;
		this.moveSmp = false;
		this.moveVarOverlay = false;
		this.moveSmpOverlay = false;
		if (a) {
			this.stopEvent(a)
		}
		document.defaultAction = true;
		document.body.style.cursor = "default"
	};
	this.mousemoveDoc = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var b = g.target || g.srcElement;
			if (b.className == "CanvasXpress" && !CanvasXpress.resizing) {
				CanvasXpress.current = b.id
			}
			if ((CanvasXpress.current && CanvasXpress.current == a.target2) || CanvasXpress.resizing || (b.id && b.id.match(/-cX-API-Example/)) || (a.isMap && b.className.match(/leaflet|CanvasXpressDataFilter/))) {
				if (a.lastMousemove) {
					if (new Date().getTime() - a.lastMousemove < 20) {
						return
					}
				}
				a.lastMousemove = new Date().getTime();
				a.isToolbar(g);
				if (a.isVersion(g)) {
					var h = a.$(a.target);
					h.style.cursor = "help";
					a.showInfoSpan([g.clientX, g.clientY + 30], "CanvasXpress<br>ver : " + a.meta.factory.version + "<br>date : " + a.meta.factory.buildDate)
				} else {
					if (a.filteringNumericOn) {
						a.preventSelection();
						a.updateNumericFilter(g)
					} else {
						if (a.filteringStringOn) {
							a.preventSelection();
							a.updateStringFilter(g)
						} else {
							if (a.draggingTargetOn) {
								a.preventSelection();
								a.updateMousemove(g)
							} else {
								if (a.resizingDataTableOn) {
									a.preventSelection();
									a.updateDataTableResizerDiv(g)
								} else {
									if (a.motionOn) {
										a.preventSelection();
										a.updateMotion(g)
									} else {
										if (a.axesResizingOn) {
											a.preventSelection();
											a.mousemoveAxesResize(g)
										} else {
											if (a.resizingDataTableColumnOn) {
												a.preventSelection();
												a.mousemoveDataTableHeader(g)
											} else {
												if (a.changingColorOn) {
													a.preventSelection();
													a.updateColorValue(g)
												} else {
													if (a.changingColorItemOn) {
														a.preventSelection();
														a.updateColorItemValue(false, g)
													} else {
														if (a.changingSliderItemOn) {
															a.preventSelection();
															a.updateSliderItemValue(g)
														} else {
															if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
																if (a.draggingOn) {
																	a.preventSelection();
																	a.cancelEvent(g);
																	a.updateDrag(g);
																	a.lastCanvasEvent = "drag"
																} else {
																	if (a.resizingCanvasOn && a.resizeCanvasCursorShow) {
																		a.preventSelection();
																		a.cancelEvent(g);
																		a.updateCanvasResizer(g);
																		a.lastCanvasEvent = "resize"
																	} else {
																		if (a.mobileApp) {} else {
																			a.updateCanvasResizerCursor(g)
																		}
																	}
																}
																var f = a.isEvent(g);
																if (f) {
																	if (b.className == "CanvasXpress" || (this.isMap && b.className.match(/leaflet/))) {
																		if (a.varIndicesStart > 0 || a.smpIndicesStart > 0) {
																			b.style.cursor = "move"
																		}
																		var d = a.handleMouseEvents(g, "mousemove", a.isEventIndices(g, false, f));
																		if (!d) {
																			a.highlightCanvas(f)
																		}
																	}
																} else {
																	a.resetInfoSpan(g, true);
																	a.clearHighlightCanvas()
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			} else {
				a.cancelEvent(g)
			}
			return false
		}
	}(this);
	this.registerMousemove = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = d.target || d.srcElement;
			if (a.hasClass(this, "CanvasXpressMenu")) {
				if (a.draggableTarget) {
					return
				}
				var c = this;
				while (a.hasClass(c.previousSibling, "CanvasXpressMenu")) {
					c = c.previousSibling
				}
				a.draggableTarget = c;
				a.activeTarget = a.draggableTarget;
				a.activeTarget.style.zIndex = 10001;
				a.xMouseDown = d.clientX;
				a.yMouseDown = d.clientY;
				a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
				a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
				a.draggingTargetOn = true
			} else {
				if ((d.button == 1 && window.event != null || d.button == 0) && a.hasClass(b, "draggable") && b.className.match("CanvasXpressDataExplorer") && b.tagName.toUpperCase() == "SPAN") {
					return
				} else {
					if ((d.button == 1 && window.event != null || d.button == 0) && a.hasClass(b, "draggable")) {
						if (a.activeTarget) {
							a.activeTarget.style.zIndex = 10000
						}
						a.draggableTarget = b.parentNode && a.hasClass(b.parentNode, "draggable-container") ? b.parentNode : b;
						a.activeTarget = a.draggableTarget;
						a.activeTarget.style.zIndex = 10001;
						a.xMouseDown = d.clientX;
						a.yMouseDown = d.clientY;
						a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
						a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
						a.draggingTargetOn = true;
						a.removeMenus()
					} else {
						if (b.id == a.target + "-cX-ToolbarMove") {
							a.draggableTarget = a.remoteService ? a.$(a.remoteParentId + "-canvasXpressRemoteWindow") : a.$("container-" + a.target);
							a.activeTarget = a.draggableTarget;
							a.activeTarget.style.zIndex = 10001;
							a.xMouseDown = d.clientX;
							a.yMouseDown = d.clientY;
							a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
							a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
							a.draggingTargetOn = true;
							a.removeMenus()
						}
					}
				}
			}
		}
	}(this);
	this.updateMousemove = function(h) {
		if (!h) {
			h = window.event
		}
		if (this.draggableTarget && this.draggableTarget.style) {
			var g = parseInt(this.draggableTarget.style.left);
			var f = parseInt(this.draggableTarget.style.top);
			var a = this.draggableXoffset + h.clientX - this.xMouseDown;
			var i = this.draggableYoffset + h.clientY - this.yMouseDown;
			this.draggableTarget.style.left = a + "px";
			this.draggableTarget.style.top = i + "px";
			this.draggableLastX = a;
			this.draggableLastY = i;
			if (this.draggableTarget.id == this.target + "-cX-DataTable" && this.dataTableLastState == "docked") {
				this.moveDataTableDiv("release")
			} else {
				if (this.hasClass(this.draggableTarget, "CanvasXpressMenu")) {
					var c = a - g;
					var b = i - f;
					var d = this.draggableTarget.nextSibling;
					while (d && this.hasClass(d, "CanvasXpressMenu")) {
						d.style.left = (parseInt(d.style.left) + c) + "px";
						d.style.top = (parseInt(d.style.top) + b) + "px";
						d = d.nextSibling
					}
				}
			}
		}
	};
	this.endMousemove = function(a) {
		if (this.draggableTarget != null) {
			this.moveDataTableDiv();
			document.onselectstart = null;
			var b = this.remoteService ? this.remoteParentId + "-canvasXpressRemoteWindow" : "container-" + this.target;
			if (this.draggableTarget.id == b) {
				CanvasXpress.stack[this.target].afterRender.push(["moveCanvas", [this.draggableTarget.style.left, this.draggableTarget.style.top]]);
				this.draggableTarget.style.zIndex = "unset"
			}
			this.yMouseDown = null;
			this.draggableXoffset = null;
			this.draggableYoffset = null;
			this.draggableTarget.ondragstart = null;
			this.draggableTarget = false;
			this.draggingTargetOn = false
		}
	};
	this.mouseupDoc = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var d = f.target || f.srcElement;
			var c = d.className;
			var b = c && c.match(/canvasxpress|-cx-/i) ? true : false;
			if ((CanvasXpress.current && CanvasXpress.current == a.target2 && b) || d.id.match(/-cX-API-Example/) || (a.isMap && d.className.match(/leaflet|CanvasXpressDataFilter/)) || a.resizingCanvasOn || a.draggingOn || a.draggingTargetOn) {
				if (a.draggingTargetOn) {
					a.endMousemove(f)
				} else {
					if (a.motionOn) {
						a.endMotion(f)
					} else {
						if (a.resizingDataTableOn) {
							a.endDataTableResizerDiv(f)
						} else {
							if (a.resizingDataTableColumnOn) {
								a.endDataTableColumnResize(f)
							} else {
								if (a.changingColorOn) {
									a.endColorChange(f)
								} else {
									if (a.changingColorItemOn) {
										a.endColorItemChange(f)
									} else {
										if (a.changingSliderItemOn) {
											a.endSliderItemChange(f)
										} else {
											if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
												a.stopEvent(f);
												a.endDrag(f);
												a.endCanvasResizer(f);
												a.endAxesResizer(f);
												a.endNumericFilter(f);
												a.endStringFilter(f);
												a.resetFlags(f)
											}
										}
									}
								}
							}
						}
					}
				}
				if (a.userEvents[f.type]) {
					a.handleMouseEvents(f, f.type)
				}
			}
		}
	}(this);
	this.touchendDoc = function(a) {
		return function(g) {
			if (CanvasXpress.current && CanvasXpress.current == a.target2) {
				if (!a.touchEvent || !a.mobileApp || !a.touches) {
					return a.mouseupDoc(g)
				}
				var f = a.layoutComb ? a.layoutParams[a.layoutValidN].graphType : a.graphType;
				var d = a;
				var b = function() {
					clearTimeout(b);
					if (d.touches.length > 1) {
						var k = d.touches[0];
						var j = d.touches[1];
						var q = Math.abs(j[0] - k[0]);
						var p = Math.abs(j[1] - k[1]);
						if (q < 20 && p < 20) {
							d.touchEvent = "dbltap"
						} else {
							d.touchEvent = "pinch"
						}
					} else {
						if (d.touchEvent != "drag") {
							if (d.touchEvent == "dbltap" || d.touchEvent == "pinch") {
								return false
							}
							d.touchEvent = "tap"
						}
					}
					if (d.touchEvent == "pinch" && d.touchesEnd.length > 1) {
						if (d.graphType.match(/Network|Genome|Heatmap|Bar|Line|Dotplot|Boxplot|Area|Stacked|Scatter3D|Circular/)) {
							var n = d.euclidianDistance([d.touches[0][0], d.touches[1][0]], [d.touches[0][1], d.touches[1][1]]);
							var e = d.euclidianDistance([d.touchesEnd[0][0], d.touchesEnd[1][0]], [d.touchesEnd[0][1], d.touchesEnd[1][1]]);
							var o = (d.touchesEnd[0][0] + d.touchesEnd[1][0]) / 2;
							var m = (d.touchesEnd[0][1] + d.touchesEnd[1][1]) / 2;
							var l = d.zoomStep;
							d.zoomStep *= 3;
							d.resetFlags(g);
							d.handleWheelEvent(g, e - n, {
								x: o,
								y: m
							});
							d.zoomStep = l
						}
						d.touchesEnd = false;
						return false
					} else {
						if (d.touchEvent == "dbltap") {
							d.stopEvent(g);
							d.addConfigurator(g, false, 3, 3);
							d.resetFlags(g);
							return false
						} else {
							if (d.touchEvent == "tap") {
								var h = d.isEventIndices(g);
								if (h) {
									d.handleMouseEvents(g, "click", h)
								} else {
									d.resetSelectedObjects()
								}
								d.resetFlags(g);
								return false
							}
						}
					}
					d.stopEvent(g);
					d.endDrag(g);
					d.endCanvasResizer(g);
					d.endAxesResizer(g);
					d.resetFlags(g)
				};
				var c = a.adjustedCoordinates(g);
				if (c) {
					if (!a.touchesEnd) {
						a.touchesEnd = []
					}
					a.touchesEnd.push([c.x, c.y, new Date().getTime()]);
					setTimeout(b, 250)
				}
			}
		}
	}(this);
	this.keydownDoc = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (CanvasXpress.current && CanvasXpress.current == a.target2) {
				if (!a.configuringOn && !b.id.match(/cX-DataFilter.+ContentSearch/) && !b.id.match(/cX-DataFilterInput/) && b.className != "CanvasXpressListItemScrollSearch") {
					a.registerKey(c)
				}
			} else {
				if (b.className.match(/CanvasXpressMap/)) {
					CanvasXpress.$(b._cX).registerKey(c)
				}
			}
		}
	}(this);
	this.keyupDoc = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (CanvasXpress.current && CanvasXpress.current == a.target2) {
				a.keyOn = false;
				if (b.id.match(/cX-DataFilter.+ContentSearch/)) {
					a.updateSearchFilters(b.id)
				} else {
					if (b.id.match(/cX-DataFilterInput/)) {
						a.updateSelectStringFilter(b.id)
					} else {
						if (b.className == "CanvasXpressListItemScrollSearch") {
							a.filterScrollSearch(b.id)
						} else {
							if (a.configuringOn) {
								a.selectConfig(c)
							} else {
								if (a.remoteService) {
									a.selectDataSet(c)
								}
							}
						}
					}
				}
			} else {
				if (b.className.match(/CanvasXpressMap/)) {}
			}
		}
	}(this);
	this.resizeWindow = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.resizeImage) {
				a.resizeImage(true)
			}
			a.resizeCanvasDimension();
			return false
		}
	}(this);
	this.resizeCanvasDimension = function() {
		if (this.targetParentNodeResponsive) {
			var b = this;
			var a = function() {
				var g = b.$(b.target);
				var f = b.$(b.targetParentNode);
				var d = f.clientWidth - 27;
				var e = parseInt(d * b.targetParentNodeAspectRatio[1] / b.targetParentNodeAspectRatio[0]);
				b.setDimensions(d, e)
			};
			clearTimeout(a);
			setTimeout(a, 250)
		}
	};
	this.initDocEvents = function() {
		this.addEvtListener(document, "mousemove", this.mousemoveDoc, false);
		this.addEvtListener(document, "touchmove", this.mousemoveDoc, false);
		this.addEvtListener(document, "mouseup", this.mouseupDoc, false);
		this.addEvtListener(document, "touchend", this.touchendDoc, false);
		this.addEvtListener(document, "keydown", this.keydownDoc, false);
		this.addEvtListener(document, "keyup", this.keyupDoc, false);
		this.addEvtListener(window, "resize", this.resizeWindow, false)
	};
	this.initializeEvents = function() {
		this.setUserEvents();
		this.initDraggingEvents();
		this.initCanvasResizerEvents();
		this.initMotionEvents();
		this.initAxisResizerEvents();
		this.initKeyEvents();
		this.initSelectEvents();
		this.initDendrogramEvents();
		this.initCanvasEvents();
		this.initDocEvents();
		this.initCleanupEvents()
	};
	this.initializeEvents()
};
CanvasXpress.prototype.initAnimation = function() {
	this.saveSnapshot = function() {
		var a = this.cloneVisualData(this.data);
		if (a) {
			this.snapshots.push(a)
		}
	};
	this.playSnapshot = function(b, d, c) {
		if (this.snapshots.length < 1) {
			return
		}
		this.stopSnapshotPlay();
		var a = this;
		this.snapshotPlay = {
			idx: 0,
			time: b,
			task: setTimeout(function() {
				a.nextSnapshot(c)
			}, 0),
			callback: d,
			oldData: this.data
		};
		this.snapshotPaused = false
	};
	this.nextSnapshot = function(c) {
		if (this.snapshotPlay.idx >= this.snapshots.length) {
			if (this.snapshotPlay.callback) {
				this.snapshotPlay.callback.call(this, c)
			} else {
				this.snapshotPlay.idx = 0
			}
		}
		if (this.snapshotPlay) {
			var b = this.snapshotPlay.time || this.snapshots[this.snapshotPlay.idx].time || 50;
			this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
			var a = this;
			this.snapshotPlay.task = setTimeout(function() {
				a.nextSnapshot(c)
			}, b);
			this.snapshotPaused = false
		}
	};
	this.stopSnapshotPlay = function(a) {
		if (!this.snapshotPlay) {
			return
		}
		clearTimeout(this.snapshotPlay.task);
		this.loadData(this.snapshotPlay.oldData, a);
		delete(this.snapshotPlay);
		this.snapshotPaused = false
	};
	this.clearSnapshot = function() {
		this.stopSnapshotPlay(true);
		this.snapshots = [];
		this.snapshotPaused = false
	};
	this.duplicateSnapshot = function() {
		if (this.snapshots.length < 1) {
			return
		}
		var a = (this.snapshotPlay ? this.snapshotPlay.idx : this.snapshots.length) - 1;
		var b = this.cloneVisualData(this.snapshots[a]);
		if (this.snapshotPlay) {
			this.snapshots.splice(a + 1, 0, b);
			this.snapshotPlay.idx++
		} else {
			this.snapshots.push(b)
		}
	};
	this.makeSnapshotPlay = function() {
		if (!this.snapshotPlay) {
			this.snapshotPlay = {
				idx: this.snapshots.length,
				oldData: this.data
			}
		} else {
			this.pauseSnapshot()
		}
	};
	this.moveSnapshot = function(c) {
		if (this.snapshots.length < 1) {
			return
		}
		this.makeSnapshotPlay();
		var b = this.snapshotPlay.idx - 1,
			a = b + c;
		if (a >= 0 && a <= this.snapshots.length) {
			this.snapshots.splice(a, 0, (this.snapshots.splice(b, 1))[0])
		}
		this.snapshotPlay.idx = a + 1
	};
	this.prevSnapshotOnce = function() {
		if (this.snapshots.length < 2) {
			return
		}
		this.makeSnapshotPlay();
		this.snapshotPlay.idx -= 2;
		if (this.snapshotPlay.idx < 0) {
			this.snapshotPlay.idx = 0
		}
		this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
		this.snapshotPaused = true
	};
	this.nextSnapshotOnce = function() {
		if (!this.snapshotPlay) {
			return
		}
		if (this.snapshotPlay.idx < this.snapshots.length) {
			this.loadData(this.snapshots[this.snapshotPlay.idx++], true)
		}
		this.snapshotPaused = true
	};
	this.hasNextSnapshot = function() {
		return this.snapshots.length > 1 && this.snapshotPlay && this.snapshotPaused && this.snapshotPlay.idx < this.snapshots.length
	};
	this.hasPrevSnapshot = function() {
		return this.snapshots.length > 1 && (!this.snapshotPlay || (this.snapshotPlay.idx > 1 && this.snapshotPaused))
	};
	this.updateSnapshot = function() {
		if (this.snapshotPlay) {
			this.snapshots[this.snapshotPlay.idx - 1] = this.cloneVisualData(this.data)
		}
	};
	this.pauseSnapshot = function() {
		if (!this.snapshotPlay) {
			return
		}
		if (this.snapshotPlay.task) {
			clearTimeout(this.snapshotPlay.task)
		}
		this.snapshotPaused = true
	};
	this.setSnapshotTime = function(a) {
		if (a > 0) {
			this.snapshots[this.snapshotPlay.idx - 1].time = a
		}
	};
	this.getSnapshotTime = function() {
		return this.snapshots[this.snapshotPlay.idx - 1].time || 50
	};
	this.assembleObj = function(b, k, m) {
		var e = [];
		if (!k[m]) {
			return b[m]
		}
		if (!k[m].indices) {
			k[m].indices = {}
		}
		for (var h = 0; h < b[m].length; h++) {
			var f = b[m][h],
				a = f.id || f.id1 + "-" + f.id2;
			if (!k[m].deleted[a]) {
				var l = k[m].changed[a];
				if (l) {
					for (var g in l) {
						f[g] = l[g]
					}
				}
				var p = k[m].indices[a] != null ? k[m].indices[a] : m == "nodes" ? b.nodeIndices[a] : b.edgeIndices[a];
				e[p] = f;
				k[m].indices[a] = p
			}
		}
		for (var a in k[m].added) {
			e[k[m].indices[a]] = k[m].added[a]
		}
		return e
	};
	this.assembleData = function(b, c) {
		var a = {};
		a.nodes = this.assembleObj(b, c, "nodes");
		a.nodeIndices = c.nodes && c.nodes.indices ? c.nodes.indices : b.nodeIndices;
		a.edges = this.assembleObj(b, c, "edges");
		a.legend = c.legend || b.legend;
		return a
	};
	this.loadData = function(d, e) {
		this.functionCaller = "loadData";
		if (this.isTransition()) {
			return
		}
		this.data = d;
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Circular":
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
				return false;
				break;
			case "Network":
				if (this.data.type == "changedData") {
					this.data = this.assembleData(this.cloneObject(this.snapshotsBase), this.cloneObject(this.data))
				}
				this.edges = this.data.edges;
				var b = {};
				for (var c = 0; c < this.data.nodes.length; c++) {
					var a = this.data.nodes[c];
					b[a.id] = a
				}
				this.nodes = b;
				break
		}
		if (e) {
			this.draw(false, false, true)
		}
	};
	this.changedNodeData = function(c, g) {
		var i = {
			deleted: {},
			changed: {},
			added: {}
		};
		for (var b in c.nodeIndices) {
			var j = g.nodeIndices[b];
			if (j == null) {
				i.deleted[b] = 1
			} else {
				var h = c.nodes[c.nodeIndices[b]],
					e = g.nodes[j],
					k = {
						id: b
					},
					f = false;
				for (var a in e) {
					if (!this.isSameObject(e[a], h[a])) {
						k[a] = e[a];
						f = true
					}
				}
				if (f) {
					i.changed[b] = k
				}
			}
		}
		for (var b in g.nodeIndices) {
			if (c.nodeIndices[b] == null) {
				i.added[b] = g.nodes[g.nodeIndices[b]]
			}
		}
		i.indices = this.changedIndices(c.nodeIndices, g.nodeIndices);
		return i
	};
	this.getEdgeIndices = function(f) {
		var b = {};
		if (f.edges.length) {
			for (var a = 0; a < f.edges.length; a++) {
				var c = f.edges[a];
				b[c.id1 + "-" + c.id2] = a
			}
		}
		return b
	};
	this.changedEdgeData = function(f, g) {
		var c = {
			deleted: {},
			changed: {},
			added: {}
		};
		if (!f.edgeIndices) {
			f.edgeIndices = this.getEdgeIndices(f)
		}
		var e = this.getEdgeIndices(g);
		for (var h in f.edgeIndices) {
			var a = e[h];
			if (a == null) {
				c.deleted[h] = 1
			} else {
				var b = g.edges[a];
				if (!this.isSameObject(f.edges[f.edgeIndices[h]], b)) {
					c.changed[h] = b
				}
			}
		}
		for (var h in e) {
			if (f.edgeIndices[h] == null) {
				c.added[h] = g.edges[e[h]]
			}
		}
		c.indices = this.changedIndices(f.edgeIndices, e);
		return c
	};
	this.changedIndices = function(b, c) {
		var a = {};
		for (var e in c) {
			if (b[e] == null || b[e] != c[e]) {
				a[e] = c[e]
			}
		}
		return a
	};
	this.getSnapshotChanged = function(b) {
		var a = this.snapshotsBase;
		return {
			type: "changedData",
			nodes: this.changedNodeData(a, b),
			edges: this.changedEdgeData(a, b),
			legend: this.isSameObject(a.legend, b.legend) ? null : b.legend
		}
	};
	this.cloneVisualData = function(f) {
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Circular":
				return this.cloneObject(f);
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
				return false;
				break;
			case "Network":
				if (this.snapshotCopyChangeOnly) {
					if (this.snapshots.length) {
						return f.type == "changedData" ? this.cloneObject(f) : this.getSnapshotChanged(f)
					} else {
						this.snapshotsBase = this.cloneObject(f);
						return {
							type: "changedData"
						}
					}
				}
				if (!this.snapshotNoCopyData) {
					return this.cloneObject(f)
				}
				var c = {
					nodes: [],
					edges: []
				};
				if (f.nodes && f.nodes.length) {
					for (var b = 0; b < f.nodes.length; b++) {
						var g = {};
						var e = f.nodes[b];
						var h = ["outline", "width", "height", "pattern", "rotate", "color", "shape", "size", "x", "y", "id", "hideLabel", "hideChildren", "hideParent", "label", "labelX", "labelY", "labelSize", "name", "hide", "anchor", "parentNode", "imagePath"];
						for (var a = 0; a < h.length; a++) {
							g[h[a]] = e[h[a]]
						}
						c.nodes.push(g)
					}
				}
				if (f.edges && f.edges.length) {
					for (var b = 0; b < f.edges.length; b++) {
						var g = {};
						var e = f.edges[b];
						var h = ["color", "width", "type", "id1", "id2", "anchor"];
						for (var a = 0; a < h.length; a++) {
							g[h[a]] = e[h[a]]
						}
						c.edges.push(g)
					}
				}
				return c;
				break
		}
	};
	this.isValidAnimation = function() {
		switch (this.graphType) {
			case "Scatter2D":
			case "ScatterBubble2D":
				return true;
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
			case "Network":
			case "Circular":
				return false
		}
	};
	this.createAnimation = function(e) {
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
				this.isAnimation = true;
				var f = this.cloneVisualData(this.data);
				if (e.match(/grow|spring|random/) && this.data.y.data) {
					var d = this.animationCycles;
					for (var c = 0; c < d; c++) {
						for (var b = 0; b < this.data.y.data.length; b++) {
							for (var a = 0; a < this.data.y.data[b].length; a++) {
								if (!isNaN(this.data.y.data[b][a])) {
									var g = this.data.y.data[b][a];
									if (e == "grow") {
										this.data.y.data[b][a] = g / d * c
									} else {
										if (e == "spring") {
											this.data.y.data[b][a] = g / (d - 1.5) * (c + 1)
										} else {
											this.data.y.data[b][a] = g / d * Math.floor(this.random() * c)
										}
									}
								}
							}
						}
						this.saveSnapshot();
						this.data = this.cloneVisualData(f)
					}
				}
				this.data = f;
				this.saveSnapshot();
				this.playSnapshot(this.animationTime, this.stopAnimation);
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
			case "Network":
			case "Circular":
				return;
				break
		}
	};
	this.stopAnimation = function() {
		this.stopSnapshotPlay();
		this.snapshots = [];
		this.isAnimation = false
	};
	this.setSnapshotsData = function(a) {
		this.snapshots = a.ss || a;
		this.snapshotsBase = a.base
	};
	this.getSnapshotsData = function() {
		return {
			base: this.snapshotsBase,
			ss: this.snapshots
		}
	};
	this.createDemoNetworkAnimation = function(h) {
		var p = [],
			e = {},
			q = [];
		for (var u = 0; u < h; u++) {
			var n = u + 1;
			p.push({
				size: 0.5,
				x: Math.floor(this.random() * h * 5),
				y: Math.floor(this.random() * h * 5),
				outline: "rgb(255,255,255)",
				color: "rgb(255,0,0)",
				id: n,
				label: n,
				hideLabel: true,
				labelSize: 0.7,
				name: "Node " + n,
				pattern: "closed",
				shape: "star"
			});
			e[n] = u
		}
		var d = {
			nodes: p,
			nodeIndices: e,
			edges: [],
			edgeIndices: {}
		};
		q.push({
			type: "changedData"
		});
		var s = 10;
		var b = 5;
		var o = 255 / b;
		var a = 0.5 / b;
		var k = 5;
		for (var t = 0; t < s; t++) {
			var m = Math.floor(this.random() * p.length);
			for (var u = 0; u < b; u++) {
				var g = Math.floor(255 - (u + 1) * o);
				var l = Math.floor((u + 1) * o),
					v = [g, l, l];
				var f = {};
				f[p[m].id] = {
					size: 0.5 + a * (u + 1),
					color: "rgb(" + v.join(",") + ")"
				};
				q.push({
					type: "changedData",
					nodes: {
						deleted: {},
						added: {},
						changed: f
					},
					time: 5
				})
			}
		}
		this.setSnapshotsData({
			base: d,
			ss: q
		})
	};
	this.createDemoNetworkAnimation1 = function() {
		var b = [];
		var l = {};
		var o = [];
		var n = 10;
		var m = 200;
		var a = "ball";
		var f = {
			width: n,
			x: 100,
			y: 0,
			color: "rgb(0,255,0)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "sphere"
		};
		a = "plank";
		var g = {
			width: 200,
			height: 5,
			x: 100,
			y: m,
			color: "rgb(255,255,0)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "rectangle"
		};
		a = "ref";
		var d = {
			width: 10,
			x: 80,
			y: 0,
			color: "rgb(0,0,255)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "sphere"
		};
		var c = {
			nodes: [f, g, d],
			nodeIndices: {
				ball: 0,
				plank: 1,
				ref: 2
			},
			edges: [],
			edgeIndices: {}
		};
		o.push({
			type: "changedData"
		});
		for (var k = 1, h = 0; h < m - n / 2; h += n / 2, k += 0.1) {
			var e = k * k;
			o.push({
				type: "changedData",
				nodes: {
					deleted: {},
					added: {},
					changed: {
						ball: {
							y: h,
							time: 25 * n > h ? 50 - h * 2 / n : 5
						}
					}
				},
				time: 100 / e
			})
		}
		this.setSnapshotsData({
			base: c,
			ss: o
		})
	};
	this.moveMenu = function(e, c) {
		var b = parseInt(e.style.left);
		var a = b - c;
		var d = (a - b) / 5;
		this.updateMoveMenu(e, b, a, d)
	};
	this.updateMoveMenu = function(e, b, a, d) {
		var c = this;
		b = this.stepResizeMove(b, a, d);
		e.style.left = Math.round(b) + "px";
		if (b == a) {
			return
		}
		setTimeout(function() {
			c.updateMoveMenu(e, b, a, d)
		}, 40)
	};
	this.fade = function(e, a, f, d) {
		if (e) {
			if (this.showFadeResizeMoveAnimation) {
				if (!a) {
					a = 1000
				}
				if (e.fadeState == null) {
					if (e.style.opacity == null || e.style.opacity == "" || e.style.opacity == "1") {
						e.fadeState = 2
					} else {
						e.fadeState = -2
					}
				}
				if (e.fadeState == 1 || e.fadeState == -1) {
					e.fadeState = e.fadeState == 1 ? -1 : 1;
					e.fadeleft = a - e.fadeleft
				} else {
					var b = this;
					e.fadeState = e.fadeState == 2 ? -1 : 1;
					e.fadeleft = a;
					setTimeout(function() {
						b.animateFade(new Date().getTime(), e, f, d)
					}, 33)
				}
			} else {
				e.style.opacity = 0;
				e.style.filter = "alpha(opacity = 0)";
				if (f != null) {
					f()
				}
			}
		}
	};
	this.animateFade = function(a, h, j, d) {
		var b = this;
		var g = new Date().getTime();
		var f = g - a;
		if (h.fadeleft <= f) {
			h.style.opacity = h.fadeState == 1 ? "1" : "0";
			h.style.filter = "alpha(opacity = " + (h.fadeState == 1 ? "100" : "0") + ")";
			h.fadeState = h.fadeState == 1 ? 2 : -2;
			if (j != null) {
				j()
			}
			if (d) {
				setTimeout(function() {
					b.resetFade(h);
					for (var c = 0; c < d.length; c++) {
						delete(h.style[d[c]])
					}
				}, 500)
			}
			return
		}
		h.fadeleft -= f;
		var i = h.fadeleft / 1000;
		if (h.fadeState == 1) {
			i = 1 - i
		}
		h.style.opacity = i;
		h.style.filter = "alpha(opacity = " + (i * 100) + ")";
		setTimeout(function() {
			b.animateFade(g, h, j)
		}, 33)
	};
	this.resetFade = function(a) {
		if (a) {
			a.style.opacity = 1;
			a.style.filter = "alpha(opacity = 100)";
			if (!this.meta.system.isIE) {
				delete(a.fadeState);
				delete(a.fadeleft)
			}
		}
	};
	this.resizeMove = function(d, b, m, k, e, q, l) {
		if (d) {
			if (this.showFadeResizeMoveAnimation) {
				if (!q) {
					q = 500
				}
				var p = parseInt(d.style.left) || 0;
				var i = parseInt(d.style.top) || 0;
				var g = parseInt(d.style.width) || d.clientWidth || 0;
				var a = parseInt(d.style.height) || d.clientHeight || 0;
				var j = 1;
				if (q > 0) {
					j = q / 40
				}
				var n = b - p;
				if (n != 0) {
					n /= j
				}
				var h = m - i;
				if (h != 0) {
					h /= j
				}
				var f = k - g;
				if (f != 0) {
					f /= j
				}
				var r = e - a;
				if (r != 0) {
					r /= j
				}
				this.updateResizeMove(d, p, b, n, i, m, h, g, k, f, a, e, r, l)
			} else {
				d.style.left = Math.round(b) + "px";
				d.style.top = Math.round(m) + "px";
				d.style.width = Math.round(k) + "px";
				d.style.height = Math.round(e) + "px";
				if (l != null) {
					l()
				}
			}
		}
	};
	this.updateResizeMove = function(d, n, b, m, i, l, h, g, j, f, a, e, q, k) {
		if (d) {
			var p = this;
			n = this.stepResizeMove(n, b, m);
			i = this.stepResizeMove(i, l, h);
			g = this.stepResizeMove(g, j, f);
			a = this.stepResizeMove(a, e, q);
			d.style.left = Math.round(n) + "px";
			d.style.top = Math.round(i) + "px";
			d.style.width = Math.round(g) + "px";
			d.style.height = Math.round(a) + "px";
			if (n == b && i == l && a == e && g == j) {
				if (k != null) {
					k()
				}
				return
			}
			setTimeout(function() {
				p.updateResizeMove(d, n, b, m, i, l, h, g, j, f, a, e, q, k)
			}, 40)
		}
	};
	this.stepResizeMove = function(d, b, a) {
		if (a == 0 || d == b) {
			return b
		}
		d += a;
		if ((a > 0 && d >= b) || (a < 0 && d <= b)) {
			return b
		}
		return d
	};
	this.transitionAccordion = function(i, x, f, r) {
		var k = this;
		var w = new Date().getTime();
		var m = w - i;
		var v = function(d) {
			var c = 0;
			for (var a = 0; a < d.childNodes.length; a++) {
				c += d.childNodes[a].clientHeight
			}
			return c
		};
		if (x <= m) {
			if (f) {
				f.style.height = this.dataFilterHeight + "px"
			}
			if (r) {
				r.style.height = "0px";
				r.style.display = "none"
			}
			if (f) {
				var s = (f.clientWidth || parseInt(f.style.width)) - this.dataFilterWidth < 18;
				var p = (f.clientHeight || parseInt(f.style.height)) < this.meta.canvas.ctx.canvas.height;
				var b = f.lastChild.clientHeight;
				var j = v(f.lastChild);
				if (j && j > 0) {
					if (j >= b || j > this.dataFilterHeight) {
						if (s) {
							this.resizeDataFilterForScroller(true)
						}
					} else {
						if (p && this.dataFilterScroller) {
							this.resizeDataFilterForScroller()
						}
					}
				} else {
					if (p && this.dataFilterScroller) {
						this.resizeDataFilterForScroller()
					}
				}
			} else {
				if (this.dataFilterScroller) {
					this.resizeDataFilterForScroller()
				}
			}
			return
		}
		x -= m;
		var g = Math.round((x / 250) * this.dataFilterHeight);
		if (f) {
			if (f.style.display != "block") {
				f.style.display = "block"
			}
			f.style.height = (this.dataFilterHeight - g) + "px"
		}
		if (r) {
			r.style.height = g + "px"
		}
		setTimeout(function() {
			k.transitionAccordion(w, x, f, r)
		}, 33)
	};
	this.initTransitions = function() {
		if (!CanvasXpress.transitions) {
			CanvasXpress.transitions = {}
		}
		CanvasXpress.transitions[this.target] = []
	};
	this.isTransition = function(c) {
		if (this.isTransitionOn) {
			var g = arguments.callee.caller;
			var e = this.getFunctionCallerName(g);
			if (g && e) {
				var b = this.cleanEventInArguments(Array.from(g.arguments));
				CanvasXpress.transitions[this.target].push([e, b])
			}
			return true
		} else {
			return false
		}
	};
	this.hideCanvas = function() {
		if (this.showTransition) {
			this.meta.canvas.ctx4.drawImage(this.meta.canvas.ctx.canvas, 0, 0);
			this.meta.canvas.ctx4.canvas.style.visibility = "visible"
		}
		this.meta.canvas.ctx.canvas.style.visibility = "hidden";
		this.meta.canvas.ctx2.canvas.style.visibility = "hidden"
	};
	this.showCanvas = function(b, a) {
		if (this.showTransition && !this.skipTransition && !b) {
			this.transition()
		} else {
			this.meta.canvas.ctx.canvas.style.visibility = "visible";
			this.meta.canvas.ctx2.canvas.style.visibility = "visible";
			this.meta.canvas.ctx3.canvas.style.visibility = "hidden";
			this.meta.canvas.ctx4.canvas.style.visibility = "hidden"
		}
	};
	this.clearTransitionCanvas = function(a) {
		if (this.transitionIter % 2 || a) {
			this.meta.canvas.ctx3.canvas.width = this.width;
			this.meta.canvas.ctx3.canvas.height = this.height;
			if (a) {
				this.meta.canvas.ctx3.canvas.style.visibility = "hidden"
			}
		}
		if (!this.transitionIter % 2 || a) {
			this.meta.canvas.ctx4.canvas.width = this.width;
			this.meta.canvas.ctx4.canvas.height = this.height;
			if (a) {
				this.meta.canvas.ctx4.canvas.style.visibility = "hidden"
			}
		}
	};
	this.switchTransitionCanvas = function() {
		if (this.transitionIter % 2) {
			this.meta.canvas.ctx3.canvas.style.visibility = "visible";
			this.meta.canvas.ctx4.canvas.style.visibility = "hidden";
			this.meta.canvas.ctx4.canvas.width = this.width;
			this.meta.canvas.ctx4.canvas.height = this.height
		} else {
			this.meta.canvas.ctx3.canvas.style.visibility = "hidden";
			this.meta.canvas.ctx4.canvas.style.visibility = "visible";
			this.meta.canvas.ctx3.canvas.width = this.width;
			this.meta.canvas.ctx3.canvas.height = this.height
		}
	};
	this.getTransitionSteps = function() {
		var c = [];
		var a = 1 / (this.transitionStep - 1);
		for (var b = 0; b < this.transitionStep; b++) {
			c.push(this.easeVal(a * b))
		}
		return c
	};
	this.getTransitionObjectsSteps = function(g, a, f) {
		var d = this.getTransitionSteps();
		var b = Math.ceil(g / this.getTransitionStaggeringSteps(f));
		var e = [];
		for (var c = 0; c < g; c++) {
			e.push(Math.max(0, d[Math.min(d.length - 1, Math.max(0, a - Math.floor(c / b)))]))
		}
		return e
	};
	this.getTransitionStaggeringSteps = function(a) {
		if (this.graphType == "Tree" || this.graphType.match(/Scatter/) || this.graphType == "Sankey" || this.graphType == "Circular" || this.graphType == "Correlation" || this.graphType == "Venn" || (this.decorations && this.decorations.kaplanMeier) || this.connectBy || (this.graphType.match(/Bar/) && this.barType == "lollipop" && !this.isGroupedData)) {
			return 1
		} else {
			if (a) {
				if (a == "Data") {
					return this.transitionStaggering
				} else {
					return 1
				}
			} else {
				return this.transitionStaggering
			}
		}
	};
	this.transition = function() {
		var d = this;
		var f = new Date().getTime();
		var b = 1 / this.transitionStep;
		var c = parseInt(this.transitionTime / this.transitionStep);
		var a = this.transitionStep + this.getTransitionStaggeringSteps();
		var e = this.mapTransitionObject();
		this.transitionIter = 0;
		this.isTransitionCanvas = true;
		this.isTransitionOn = true;
		var g = function() {
			this.update = function() {
				var k = d.easeVal(b * d.transitionIter);
				if (d.transitionIter >= a) {
					d.showCanvas(true);
					d.clearTransitionCanvas(true);
					d.isTransitionCanvas = false;
					d.isTransitionOn = false;
					clearInterval(h);
					if (CanvasXpress.transitions[d.target].length > 0) {
						var m = CanvasXpress.transitions[d.target].shift();
						if (m[2]) {
							for (var n in m[2]) {
								d[n] = m[2][n]
							}
						}
						d[m[0]].apply(d, m[1])
					}
					return
				}
				var l = d.meta.render.order;
				for (var j = 0; j < l.length; j++) {
					if (e[l[j]]) {
						d.disableGradientTransparencyShadow();
						if (l[j] == "Data" && !d.layoutValid && d.graphType != "Correlation") {
							d.setClipArea()
						}
						if (l[j] == "Data" && d.graphType == "Venn") {
							d.rectangleClear(0, 0, d.width, d.height);
							d.setGlobalCompositionOperation("lighter")
						}
						if ((l[j] == "Legends" || l[j] == "Labels") && d.graphType != "Circular") {
							d.transitionPropertyDataTransparency(d.transitionIter, l[j])
						} else {
							if (l[j] == "Size") {
								d.transitionPropertyDataNoInterpolate(l[j])
							} else {
								d.transitionPropertyData(d.transitionIter, e[l[j]], l[j])
							}
						}
						if (l[j] == "Data" && d.graphType == "Venn") {
							d.setGlobalCompositionOperation("source-over")
						}
						if (l[j] == "Data" && !d.layoutValid && d.graphType != "Correlation") {
							d.resetClipArea()
						}
						d.enableGradientTransparencyShadow()
					}
				}
				d.switchTransitionCanvas();
				d.transitionIter++
			};
			var h = this.setInterval(this.update, c)
		};
		g.call()
	};
	this.transitionPropertyData = function(H, P, k) {
		var E = this.meta.render.transition.objects;
		var g = this.meta.render.objects;
		var a = this.getTransitionObjectsSteps(P.length, H, k);
		for (var I = 0; I < P.length; I++) {
			var v = a[I];
			var j = P[I][0];
			var A = P[I][1];
			var l = this.isObject(j) ? j : E[j];
			var F = this.isObject(A) ? A : g[A];
			var m = l.func;
			var G = F.func;
			var z = l.params;
			var N = F.params;
			switch (m) {
				case "drawShape":
					if (z[0] == "arch") {
						var C = this.interpolateChord(z, N, v);
						var o = C[0];
						var n = C[1];
						var u = C[2];
						var J = C[3];
						var O = this.interpolateColor(z[5], N[5], v);
						this.drawShape(N[0], o, n, u, J, O, N[6], N[7], N[8], N[9], N[10], N[11], N[12], N[13], N[14], N[15])
					} else {
						var o = this.interpolateNumber(z[1], N[1], v);
						var n = this.interpolateNumber(z[2], N[2], v);
						var u = this.interpolateNumber(z[3], N[3], v);
						var J = this.interpolateNumber(z[4], N[4], v);
						var O = this.interpolateColor(z[5], N[5], v);
						var D = z[0] == "pie" || z[0].match(/arc/) ? this.interpolateNumber(z[12], N[12], v) : false;
						var C = z[0] == "pie" || z[0].match(/arc/) ? this.interpolateNumber(z[13], N[13], v) : false;
						var B = z[0] == "ellipse2" ? this.interpolateNumber(z[8], N[8], v) : false;
						this.drawShape(N[0], o, n, u, J, O, N[6], N[7], B, N[9], N[10], N[11], D, C, N[14], N[15])
					}
					break;
				case "drawLine":
					var M = this.interpolateNumber(z[1], N[1], v);
					var d = this.interpolateNumber(z[2], N[2], v);
					var K = this.interpolateNumber(z[3], N[3], v);
					var b = this.interpolateNumber(z[4], N[4], v);
					var u = z[0] == "error" ? this.interpolateNumber(z[6], N[6], v) : N[6];
					var O = this.interpolateColor(z[5], N[5], v);
					this.drawLine(N[0], M, d, K, b, O, u, N[7], N[8], N[9], N[10], N[11], N[12]);
					break;
				case "drawText":
					var o = this.interpolateNumber(z[1], N[1], v);
					var n = this.interpolateNumber(z[2], N[2], v);
					var L = this.interpolateTextFont(z[3], N[3], v);
					var O = this.interpolateColor(z[4], N[4], v);
					var B = this.interpolateNumber(z[7] || 0, N[7] || 0, v);
					this.drawText(N[0], o, n, L, O, N[5], N[6], B, N[8], N[9], N[10], N[11]);
					break;
				case "drawArcText":
					var B = this.interpolateNumber(z[3], N[3], v);
					var D = this.interpolateNumber(z[4], N[4], v);
					var C = this.interpolateNumber(z[5], N[5], v);
					var L = this.interpolateTextFont(z[6], N[6], v);
					var O = this.interpolateColor(z[7], N[7], v);
					this.drawArcText(N[0], N[1], N[2], B, D, C, L, O, N[8], N[9], N[10], N[11]);
					break;
				default:
					break
			}
		}
	};
	this.transitionPropertyDataNoInterpolate = function(g) {
		var b = this.meta.render.types[g].all;
		for (var c = 0; c < b.length; c++) {
			var a = this.meta.render.objects[b[c]];
			var d = a.func;
			var f = a.params;
			switch (d) {
				case "drawShape":
					this.drawShape(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]);
					break;
				case "drawLine":
					this.drawLine(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12]);
					break;
				case "drawText":
					this.drawText(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11]);
					break;
				case "drawArcText":
					this.drawArcText(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11]);
					break
			}
		}
	};
	this.transitionPropertyDataTransparency = function(j, b) {
		var d = this.meta.render.types[b].all;
		var h = this.getTransitionObjectsSteps(d.length, j);
		for (var f = 0; f < d.length; f++) {
			var a = this.meta.render.objects[d[f]];
			var c = a.func;
			var g = a.params;
			var k = h[f];
			switch (c) {
				case "drawShape":
					this.drawShape(g[0], g[1], g[2], g[3], g[4], this.addColorTransparency(g[5], k), this.addColorTransparency(g[6], k), g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]);
					break;
				case "drawLine":
					this.drawLine(g[0], g[1], g[2], g[3], g[4], this.addColorTransparency(g[5], k), g[6], g[7], g[8], g[9], g[10], g[11], g[12]);
					break;
				case "drawText":
					this.drawText(g[0], g[1], g[2], g[3], this.addColorTransparency(g[4], k), g[5], g[6], g[7], g[8], g[9], g[10], g[11]);
					break;
				case "drawArcText":
					this.drawArcText(g[0], g[1], g[2], g[3], g[4], g[5], g[6], this.addColorTransparency(g[7], k), g[8], g[9], g[10], g[11]);
					break
			}
		}
	};
	this.easeVal = function(a) {
		switch (this.transitionFunction) {
			case "linear":
				return a;
			case "easeInQuad":
				return a * a;
			case "easeOutQuad":
				return a * (2 - a);
			case "easeInOutQuad":
				return a < 0.5 ? 2 * a * a : -1 + (4 - 2 * a) * a;
			case "easeInCubic":
				return a * a * a;
			case "easeOutCubic":
				return (--a) * a * a + 1;
			case "easeInOutCubic":
				return a < 0.5 ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1;
			case "easeInQuart":
				return a * a * a * a;
			case "easeOutQuart":
				return 1 - (--a) * a * a * a;
			case "easeInOutQuart":
				return a < 0.5 ? 8 * a * a * a * a : 1 - 8 * (--a) * a * a * a;
			case "easeInQuint":
				return a * a * a * a * a;
			case "easeOutQuint":
				return 1 + (--a) * a * a * a * a;
			case "easeInOutQuint":
				return a < 0.5 ? 16 * a * a * a * a * a : 1 + 16 * (--a) * a * a * a * a;
			default:
				return a
		}
	};
	this.interpolateNumber = function(n, m, q) {
		var l = [];
		var p = this.isArray(n);
		var o = this.isArray(m);
		if (p && o) {
			for (var h = 0; h < n.length; h++) {
				var k = [];
				var g = this.isArray(n[h]);
				var e = this.isArray(m[h]);
				if (g && e) {
					for (var f = 0; f < n[h].length; f++) {
						k.push(n[h][f] + q * (m[h][f] - n[h][f]))
					}
					l.push(k)
				} else {
					if (g) {
						for (var f = 0; f < n[h].length; f++) {
							k.push(n[h][f] + q * (m[h] - n[h][f]))
						}
						l.push(k)
					} else {
						if (e) {
							for (var f = 0; f < m[h].length; f++) {
								k.push(n[h] + q * (m[h][f] - n[h]))
							}
							l.push(k)
						} else {
							l.push(n[h] + q * (m[h] - n[h]))
						}
					}
				}
			}
			return l
		} else {
			if (p) {
				for (var h = 0; h < n.length; h++) {
					l.push(n[h] + q * (m - n[h]))
				}
				return l
			} else {
				if (o) {
					for (var h = 0; h < m.length; h++) {
						l.push(n + q * (m[h] - n))
					}
					return l
				} else {
					return n + q * (m - n)
				}
			}
		}
	};
	this.interpolateChord = function(q, i, o) {
		var n = this.interpolateNumber(q[3], i[3], o);
		var g = this.interpolateNumber(q[4], i[4], o);
		var f = this.interpolateNumber(q[1][1], i[1][1], o);
		var d = this.interpolateNumber(q[2][1], i[2][1], o);
		var c = f + (g * Math.cos(n[0]));
		var m = d + (g * Math.sin(n[0]));
		var b = f + (g * Math.cos(n[3]));
		var l = d + (g * Math.sin(n[3]));
		var a = f + (g * Math.cos(n[2]));
		var k = d + (g * Math.sin(n[2]));
		var p = f + (g * Math.cos(n[1]));
		var j = d + (g * Math.sin(n[1]));
		return [
			[c, f, b, a, f, p],
			[m, d, l, k, d, j], n, g
		]
	};
	this.interpolateColor = function(e, d, f) {
		e = this.colorAsArray(e);
		d = this.colorAsArray(d);
		var g = [];
		g[0] = parseInt(this.interpolateNumber(e[0], d[0], f));
		g[1] = parseInt(this.interpolateNumber(e[1], d[1], f));
		g[2] = parseInt(this.interpolateNumber(e[2], d[2], f));
		if (e.length == 4 && d.length == 4) {
			g[3] = parseInt(this.interpolateNumber(e[3], d[3], f) * 10) / 10
		} else {
			g[3] = parseInt(this.interpolateNumber(e[3] != null ? e[3] : 1, d[3] != null ? d[3] : 1, f) * 10) / 10
		}
		return (g.length == 4 ? "rgba(" : "rgb(") + g.join(",") + ")"
	};
	this.interpolateTextFont = function(d, c, f) {
		var g = this.getFontPt(d);
		var e = this.getFontPt(c);
		var h = Math.floor(this.interpolateNumber(g, e, f));
		return d.replace(g, h)
	}
};
CanvasXpress.prototype.initExample = function() {
	this.dataSetGeneric = {
		z: {
			Annt1: ["Desc:1", "Desc:2", "Desc:3", "Desc:4"],
			Annt2: ["Desc:A", "Desc:B", "Desc:A", "Desc:B"],
			Annt3: ["Desc:X", "Desc:X", "Desc:Y", "Desc:Y"]
		},
		x: {
			Factor1: ["Lev:1", "Lev:2", "Lev:3", "Lev:1", "Lev:2", "Lev:3"],
			Factor2: ["Lev:A", "Lev:B", "Lev:A", "Lev:B", "Lev:A", "Lev:B"],
			Factor3: ["Lev:X", "Lev:X", "Lev:Y", "Lev:Y", "Lev:Z", "Lev:Z"]
		},
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],
			data: [
				[5, 10, 25, 40, 45, 50],
				[95, 80, 75, 70, 55, 40],
				[25, 30, 45, 60, 65, 70],
				[55, 40, 35, 30, 15, 1]
			]
		},
		a: {
			xAxis: ["Variable1", "Variable2"],
			xAxis2: ["Variable3", "Variable4"]
		},
		t: {
			vars: "(((Variable1,Variable3),Variable4),Variable2)",
			smps: "(((((Sample1,Sample2),Sample3),Sample4),Sample5),Sample6)"
		}
	};
	this.dataSetCircular = {
		z: {
			Ring: ["1", "2", "2", "3"]
		},
		x: {
			Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
			Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
		},
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
			data: [
				[5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
				[95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
				[25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
				[55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
			]
		},
		c: [
			["rgb(51,125,255)", "Sample1", "Sample10"],
			["rgb(125,255,51)", "Sample8", "Sample11"],
			["rgb(255,51,125)", "Sample12", "Sample4"],
			["rgb(125,255,51)", "Sample9", "Sample2"],
			["rgb(51,125,255)", "Sample3", "Sample6"]
		]
	};
	this.dataSetCircular2 = {
		z: {
			Ring: ["-1", "1", "2", "2", "3"]
		},
		x: {
			Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
			Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
		},
		y: {
			vars: ["Number", "Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
			data: [
				[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5],
				[5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
				[95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
				[25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
				[55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
			]
		},
		c: [
			["rgb(51,125,255)", "Seg1", 1, "Seg2", 5, 1, 1],
			["rgb(125,255,51)", "Seg2", 3, "Seg3", 1, 1, 2],
			["rgb(255,51,125)", "Seg3", 2, "Seg1", 4, 2, 1],
			["rgb(125,255,51)", "Seg2", 4, "Seg1", 2, 1, 1],
			["rgb(51,125,255)", "Seg1", 3, "Seg3", 4, 1, 1]
		]
	};
	this.dataSetBoxplot = {
		x: {
			Factor1: ["Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2"]
		},
		y: {
			vars: ["Variable1", "Variable2"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			data: [
				[5, 8, 10, 6, 8, 20, 25, 27, 30, 27, 6, 29],
				[49, 18, 14, 16, 18, 15, 65, 67, 60, 72, 76, 9]
			]
		}
	};
	this.dataSetMultidimensionalHeatmap = {
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10"],
			data: [
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
				[10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
				[10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
			],
			data2: [
				[1, 1, 2, 2, 3, 3, 4, 4, 5, 5],
				[6, 6, 7, 7, 8, 8, 9, 9, 10, 10],
				[10, 10, 9, 9, 8, 8, 7, 7, 6, 6],
				[5, 5, 4, 4, 3, 3, 2, 2, 1, 1],
				[3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
			],
			data3: [
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
				["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
				["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"]
			],
			data4: [
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
				["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
				["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"]
			]
		},
		x: {
			Factor: ["Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2"]
		},
		z: {
			Annt: ["Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2"]
		}
	};
	this.dataSet3DScatter = {
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5", "Variable6", "Variable7", "Variable8", "Variable9", "Variable10", "Variable11", "Variable12", "Variable13", "Variable14", "Variable15", "Variable16", "Variable17", "Variable18", "Variable19", "Variable20", "Variable21", "Variable22", "Variable23", "Variable24", "Variable25", "Variable26", "Variable27", "Variable28", "Variable29", "Variable30", "Variable31", "Variable32", "Variable33", "Variable34", "Variable35", "Variable36", "Variable37", "Variable38", "Variable39", "Variable40", "Variable41", "Variable42", "Variable43", "Variable44", "Variable45", "Variable46", "Variable47", "Variable48", "Variable49", "Variable50", "Variable51", "Variable52", "Variable53", "Variable54", "Variable55", "Variable56", "Variable57", "Variable58", "Variable59", "Variable60", "Variable61", "Variable62", "Variable63", "Variable64", "Variable65", "Variable66", "Variable67", "Variable68", "Variable69", "Variable70", "Variable71", "Variable72", "Variable73", "Variable74", "Variable75", "Variable76", "Variable77", "Variable78", "Variable79", "Variable80", "Variable81"],
			smps: ["Sample1", "Sample2", "Sample3"],
			data: [
				[-5, 5, 5],
				[-5, 15, 15],
				[-5, 25, 25],
				[-5, 35, 35],
				[-5, 45, 45],
				[-5, 35, 55],
				[-5, 25, 65],
				[-5, 15, 75],
				[-5, 5, 85],
				[-15, 15, 5],
				[-15, 25, 15],
				[-15, 35, 25],
				[-15, 45, 35],
				[-15, 55, 45],
				[-15, 45, 55],
				[-15, 35, 65],
				[-15, 25, 75],
				[-15, 15, 85],
				[-25, 25, 5],
				[-25, 35, 15],
				[-25, 45, 25],
				[-25, 55, 35],
				[-25, 65, 45],
				[-25, 55, 55],
				[-25, 45, 65],
				[-25, 35, 75],
				[-25, 25, 85],
				[-35, 35, 5],
				[-35, 45, 15],
				[-35, 55, 25],
				[-35, 65, 35],
				[-35, 75, 45],
				[-35, 65, 55],
				[-35, 55, 65],
				[-35, 45, 75],
				[-35, 35, 85],
				[-45, 45, 5],
				[-45, 55, 15],
				[-45, 65, 25],
				[-45, 75, 35],
				[-45, 85, 45],
				[-45, 75, 55],
				[-45, 65, 65],
				[-45, 55, 75],
				[-45, 45, 85],
				[-55, 35, 5],
				[-55, 45, 15],
				[-55, 55, 25],
				[-55, 65, 35],
				[-55, 75, 45],
				[-55, 65, 55],
				[-55, 55, 65],
				[-55, 45, 75],
				[-55, 35, 85],
				[-65, 25, 5],
				[-65, 35, 15],
				[-65, 45, 25],
				[-65, 55, 35],
				[-65, 65, 45],
				[-65, 55, 55],
				[-65, 45, 65],
				[-65, 35, 75],
				[-65, 25, 85],
				[-75, 15, 5],
				[-75, 25, 15],
				[-75, 35, 25],
				[-75, 45, 35],
				[-75, 55, 45],
				[-75, 45, 55],
				[-75, 35, 65],
				[-75, 25, 75],
				[-75, 15, 85],
				[-85, 5, 5],
				[-85, 15, 15],
				[-85, 25, 25],
				[-85, 35, 35],
				[-85, 45, 45],
				[-85, 35, 55],
				[-85, 25, 65],
				[-85, 15, 75],
				[-85, 5, 85]
			]
		}
	};
	this.dataSetFunction = {
		fx: "sin(2y) * cos(3x) / sec(xy)"
	};
	this.dataSetNonLinearFit = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			nlfit: [{
				param: [164, 313, 0.031, -1.5, 0.0000012, 1.9],
				label: "Custom Fit",
				type: "cst"
			}, {
				param: [164, 313, 0.031, 1.5, 0.0000012, 1.9],
				label: "Regular Fit",
				type: "reg"
			}]
		}
	};
	this.dataSetDecorationLine = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			line: [{
				x: 0.4,
				y: 200,
				color: "rgb(255,125,51)",
				type: "dashedLine"
			}, {
				x: 0.15,
				color: "rgb(51,255,125)",
				type: "line"
			}]
		}
	};
	this.dataSetDecorationLines = {
		y: {
			vars: ["Concentration"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			data: [
				[0.0009, 0.0018, 0.0037, 0.0073, 0.0146, 0.0293, 0.0586, 0.117, 0.234, 0.469, 0.938, 1.88]
			]
		},
		d: {
			lines: [{
				value: 0.25,
				label: "Background",
				color: "rgb(255,125,51)",
				type: "dashedLine"
			}]
		}
	};
	this.dataSetDecorationArea = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			area: [{
				x: 1.42,
				y: 322,
				label: "Area",
				width: 1.2,
				height: 30,
				color: "rgb(255,125,51,0.5)",
				ouline: "rgb(255,125,51,0.5)",
				pattern: "closed",
				rotate: 0.1,
				type: "oval"
			}]
		}
	};
	this.dataSetKaplanMeier = {
		y: {
			vars: ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15", "p16", "p17", "p18", "p19", "p20"],
			smps: ["Time", "Censored-1", "Censored-2"],
			data: [
				[1, 0, 1],
				[2, 0, 1],
				[3, 0, 1],
				[3, 0, 1],
				[1, 1, 1],
				[2, 1, 1],
				[2, 1, 2],
				[3, 1, 1],
				[3, 1, 1],
				[4, 0, 0],
				[5, 0, 0],
				[6, 0, 0],
				[6, 0, 0],
				[7, 1, 0],
				[8, 0, 1],
				[9, 0, 0],
				[9, 0],
				[9, 0],
				[10, 1],
				[11, 1]
			]
		},
		z: {
			grp: ["A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B"],
			cls: ["A", "A", "A", "A", "A", "A", "A", "A", "A", "B", "B", "B", "B", "B", "B", "B", "B", "B", "B", "B"]
		}
	};
	this.dataSetDashDot = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 50
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 50
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 100
		}],
		edges: [{
			id1: "Id1",
			id2: "Id2",
			color: "rgb(0,255,0)",
			type: "line"
		}, {
			id1: "Id3",
			id2: "Id4",
			color: "rgb(0,255,0)",
			type: "dashedLine"
		}, {
			id1: "Id5",
			id2: "Id6",
			color: "rgb(0,255,0)",
			type: "dottedLine"
		}]
	};
	this.dataSetLines = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 0
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 0
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 100
		}, {
			id: "Id7",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 100
		}, {
			id: "Id8",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 100
		}, {
			id: "Id9",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 200
		}, {
			id: "Id10",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 200
		}, {
			id: "Id11",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 200
		}, {
			id: "Id12",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 200
		}, {
			id: "Id13",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 300
		}, {
			id: "Id14",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 300
		}, {
			id: "Id15",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 300
		}, {
			id: "Id16",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 300
		}, {
			id: "Id17",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 400
		}, {
			id: "Id18",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 400
		}, {
			id: "Id19",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 400
		}, {
			id: "Id20",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 400
		}, {
			id: "Id21",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 500
		}, {
			id: "Id22",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 500
		}, {
			id: "Id23",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 500
		}, {
			id: "Id24",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 500
		}, {
			id: "Id25",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 600
		}, {
			id: "Id26",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 600
		}, {
			id: "Id27",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 600
		}, {
			id: "Id28",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 600
		}, {
			id: "Id29",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 700
		}, {
			id: "Id30",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 700
		}, {
			id: "Id31",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 700
		}, {
			id: "Id32",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 700
		}, {
			id: "Id33",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 800
		}, {
			id: "Id34",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 800
		}, {
			id: "Id35",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 800
		}, {
			id: "Id36",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 800
		}, {
			id: "Id37",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 900
		}, {
			id: "Id39",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 900
		}, {
			id: "Id40",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1000
		}, {
			id: "Id41",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1100
		}, {
			id: "Id42",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1000
		}, {
			id: "Id43",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1100
		}, {
			id: "Id44",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1000
		}, {
			id: "Id45",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1100
		}, {
			id: "Id46",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1200
		}, {
			id: "Id47",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1300
		}, {
			id: "Id48",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1200
		}, {
			id: "Id49",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1300
		}, {
			id: "Id50",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1200
		}, {
			id: "Id51",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1300
		}, {
			id: "Id52",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1400
		}, {
			id: "Id54",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1400
		}, {
			id: "Id56",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1400
		}, {
			id: "Id57",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1400
		}],
		edges: [{
			id1: "Id1",
			id2: "Id2",
			color: "rgb(0,255,0)",
			type: "line"
		}, {
			id1: "Id2",
			id2: "Id3",
			color: "rgb(0,255,0)",
			type: "dashedLine"
		}, {
			id1: "Id3",
			id2: "Id4",
			color: "rgb(0,255,0)",
			type: "dottedLine"
		}, {
			id1: "Id5",
			id2: "Id6",
			color: "rgb(0,255,0)",
			type: "arrowHeadLine"
		}, {
			id1: "Id6",
			id2: "Id7",
			color: "rgb(0,255,0)",
			type: "arrowLine"
		}, {
			id1: "Id7",
			id2: "Id8",
			color: "rgb(0,255,0)",
			type: "arrowTailLine"
		}, {
			id1: "Id9",
			id2: "Id10",
			color: "rgb(0,255,0)",
			type: "arrowHeadDashedLine"
		}, {
			id1: "Id10",
			id2: "Id11",
			color: "rgb(0,255,0)",
			type: "arrowDashedLine"
		}, {
			id1: "Id11",
			id2: "Id12",
			color: "rgb(0,255,0)",
			type: "arrowTailDashedLine"
		}, {
			id1: "Id13",
			id2: "Id14",
			color: "rgb(0,255,0)",
			type: "arrowHeadDottedLine"
		}, {
			id1: "Id14",
			id2: "Id15",
			color: "rgb(0,255,0)",
			type: "arrowDottedLine"
		}, {
			id1: "Id15",
			id2: "Id16",
			color: "rgb(0,255,0)",
			type: "arrowTailDottedLine"
		}, {
			id1: "Id17",
			id2: "Id18",
			color: "rgb(0,255,0)",
			type: "squareHeadLine"
		}, {
			id1: "Id18",
			id2: "Id19",
			color: "rgb(0,255,0)",
			type: "squareLine"
		}, {
			id1: "Id19",
			id2: "Id20",
			color: "rgb(0,255,0)",
			type: "squareTailLine"
		}, {
			id1: "Id21",
			id2: "Id22",
			color: "rgb(0,255,0)",
			type: "squareHeadDashedLine"
		}, {
			id1: "Id22",
			id2: "Id23",
			color: "rgb(0,255,0)",
			type: "squareDashedLine"
		}, {
			id1: "Id23",
			id2: "Id24",
			color: "rgb(0,255,0)",
			type: "squareTailDashedLine"
		}, {
			id1: "Id25",
			id2: "Id26",
			color: "rgb(0,255,0)",
			type: "squareHeadDottedLine"
		}, {
			id1: "Id26",
			id2: "Id27",
			color: "rgb(0,255,0)",
			type: "squareDottedLine"
		}, {
			id1: "Id27",
			id2: "Id28",
			color: "rgb(0,255,0)",
			type: "squareTailDottedLine"
		}, {
			id1: "Id29",
			id2: "Id30",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailLine"
		}, {
			id1: "Id30",
			id2: "Id31",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailDashedLine"
		}, {
			id1: "Id31",
			id2: "Id32",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailDottedLine"
		}, {
			id1: "Id33",
			id2: "Id34",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailLine"
		}, {
			id1: "Id34",
			id2: "Id35",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailDashedLine"
		}, {
			id1: "Id35",
			id2: "Id36",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailDottedLine"
		}, {
			id1: "Id37",
			id2: "Id42",
			color: "rgb(0,255,0)",
			type: "bezierLine"
		}, {
			id1: "Id44",
			id2: "Id39",
			color: "rgb(0,255,0)",
			type: "bezierYLine"
		}, {
			id1: "Id40",
			id2: "Id41",
			color: "rgb(0,255,0)",
			type: "arrowBezierLine"
		}, {
			id1: "Id42",
			id2: "Id43",
			color: "rgb(0,255,0)",
			type: "arrowTailBezierLine"
		}, {
			id1: "Id44",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "arrowHeadBezierLine"
		}, {
			id1: "Id46",
			id2: "Id47",
			color: "rgb(0,255,0)",
			type: "squareBezierLine"
		}, {
			id1: "Id48",
			id2: "Id49",
			color: "rgb(0,255,0)",
			type: "squareTailBezierLine"
		}, {
			id1: "Id50",
			id2: "Id51",
			color: "rgb(0,255,0)",
			type: "squareHeadBezierLine"
		}, {
			id1: "Id49",
			id2: "Id57",
			color: "rgb(0,255,0)",
			type: "arrowBezierYLine"
		}, {
			id1: "Id47",
			id2: "Id56",
			color: "rgb(0,255,0)",
			type: "arrowTailBezierYLine"
		}, {
			id1: "Id35",
			id2: "Id42",
			color: "rgb(0,255,0)",
			type: "arrowHeadBezierYLine"
		}, {
			id1: "Id46",
			id2: "Id41",
			color: "rgb(0,255,0)",
			type: "squareBezierYLine"
		}, {
			id1: "Id48",
			id2: "Id43",
			color: "rgb(0,255,0)",
			type: "squareTailBezierYLine"
		}, {
			id1: "Id50",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "squareHeadBezierYLine"
		}, {
			id1: "Id9",
			id2: "Id1",
			color: "rgb(0,255,0)",
			type: "curvedLine"
		}, {
			id1: "Id13",
			id2: "Id5",
			color: "rgb(0,255,0)",
			type: "squareCurvedLine"
		}, {
			id1: "Id25",
			id2: "Id17",
			color: "rgb(0,255,0)",
			type: "squareHeadCurvedLine"
		}, {
			id1: "Id29",
			id2: "Id21",
			color: "rgb(0,255,0)",
			type: "squareTailCurvedLine"
		}, {
			id1: "Id40",
			id2: "Id33",
			color: "rgb(0,255,0)",
			type: "arrowCurvedLine"
		}, {
			id1: "Id52",
			id2: "Id46",
			color: "rgb(0,255,0)",
			type: "arrowHeadCurvedLine"
		}, {
			id1: "Id4",
			id2: "Id12",
			color: "rgb(0,255,0)",
			type: "arrowTailCurvedLine"
		}, {
			id1: "Id8",
			id2: "Id16",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailCurvedLine"
		}, {
			id1: "Id20",
			id2: "Id28",
			color: "rgb(0,255,0)",
			type: "squareTailArrowHeadCurvedLine"
		}, {
			id1: "Id24",
			id2: "Id32",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailCurvedLine"
		}, {
			id1: "Id39",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "arrowTailSquareHeadCurvedLine"
		}]
	};
	this.dataSetShapes = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "square",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "triangle",
			size: 1,
			x: 400,
			y: 0
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "star",
			size: 1,
			x: 600,
			y: 0
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "rhombus",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "octagon",
			size: 1,
			x: 200,
			y: 100
		}, {
			id: "Id7",
			color: "rgb(255,0,0)",
			shape: "oval",
			size: 1,
			x: 400,
			y: 100
		}, {
			id: "Id8",
			color: "rgb(255,0,0)",
			shape: "plus",
			size: 1,
			x: 600,
			y: 100
		}, {
			id: "Id9",
			color: "rgb(255,0,0)",
			shape: "minus",
			size: 1,
			x: 0,
			y: 200
		}, {
			id: "Id10",
			color: "rgb(255,0,0)",
			shape: "pacman",
			size: 1,
			x: 200,
			y: 200
		}, {
			id: "Id11",
			color: "rgb(255,0,0)",
			shape: "pacman2",
			size: 1,
			x: 400,
			y: 200
		}, {
			id: "Id12",
			color: "rgb(255,0,0)",
			shape: "mdavid",
			size: 1,
			x: 600,
			y: 200
		}, {
			id: "Id13",
			color: "rgb(255,0,0)",
			shape: "rect2",
			size: 1,
			x: 0,
			y: 300
		}, {
			id: "Id14",
			color: "rgb(255,0,0)",
			shape: "rect3",
			size: 1,
			x: 200,
			y: 300
		}, {
			id: "Id15",
			color: "rgb(255,0,0)",
			shape: "arc",
			size: 1,
			x: 400,
			y: 300
		}, {
			id: "Id16",
			color: "rgb(255,0,0)",
			shape: "rectangle",
			size: 1,
			x: 600,
			y: 300
		}, {
			id: "Id17",
			color: "rgb(255,0,0)",
			shape: "image",
			imagePath: "https://www.canvasxpress.org/images/cx.png",
			size: 1,
			x: 0,
			y: 400
		}, {
			id: "Id18",
			color: "rgb(255,0,0)",
			shape: "pie0",
			size: 1,
			x: 200,
			y: 400
		}, {
			id: "Id19",
			color: "rgb(255,0,0)",
			shape: "pie1",
			size: 1,
			x: 400,
			y: 400
		}, {
			id: "Id20",
			color: "rgb(255,0,0)",
			shape: "pie2",
			size: 1,
			x: 600,
			y: 400
		}, {
			id: "Id21",
			color: "rgb(255,0,0)",
			shape: "pie3",
			size: 1,
			x: 0,
			y: 500
		}, {
			id: "Id22",
			color: "rgb(255,0,0)",
			shape: "pie4",
			size: 1,
			x: 200,
			y: 500
		}, {
			id: "Id23",
			color: "rgb(255,0,0)",
			shape: "pie5",
			size: 1,
			x: 400,
			y: 500
		}, {
			id: "Id24",
			color: "rgb(255,0,0)",
			shape: "pie6",
			size: 1,
			x: 600,
			y: 500
		}, {
			id: "Id25",
			color: "rgb(255,0,0)",
			shape: "pie7",
			size: 1,
			x: 0,
			y: 600
		}, {
			id: "Id26",
			color: "rgb(255,0,0)",
			shape: "pie8",
			size: 1,
			x: 200,
			y: 600
		}, {
			id: "Id27",
			color: "rgb(255,0,0)",
			shape: "pie9",
			size: 1,
			x: 400,
			y: 600
		}, {
			id: "Id28",
			color: "rgb(255,0,0)",
			shape: "circle",
			size: 1,
			x: 600,
			y: 600
		}, {
			id: "Id29",
			color: "rgb(255,0,0)",
			shape: "box",
			size: 1,
			x: 0,
			y: 700
		}, {
			id: "Id30",
			color: "rgb(255,0,0)",
			shape: "rect",
			size: 1,
			x: 200,
			y: 700
		}, {
			id: "Id31",
			color: "rgb(255,0,0)",
			shape: "rect2",
			size: 1,
			x: 400,
			y: 700
		}, {
			id: "Id32",
			color: "rgb(255,0,0)",
			shape: "rect3",
			size: 1,
			x: 600,
			y: 700
		}, {
			id: "Id33",
			color: "rgb(255,0,0)",
			shape: "roundrect",
			size: 1,
			x: 0,
			y: 800
		}, {
			id: "Id34",
			color: "rgb(255,0,0)",
			shape: "triangle2",
			size: 1,
			x: 200,
			y: 800
		}, {
			id: "Id35",
			color: "rgb(255,0,0)",
			shape: "equilateral",
			size: 1,
			x: 400,
			y: 800
		}, {
			id: "Id36",
			color: "rgb(255,0,0)",
			shape: "equilateral2",
			size: 1,
			x: 600,
			y: 800
		}, {
			id: "Id37",
			color: "rgb(255,0,0)",
			shape: "hexagon",
			size: 1,
			x: 0,
			y: 900
		}, {
			id: "Id38",
			color: "rgb(255,0,0)",
			shape: "oval2",
			size: 1,
			x: 200,
			y: 900
		}, {
			id: "Id39",
			color: "rgb(255,0,0)",
			shape: "oval3",
			size: 1,
			x: 400,
			y: 900
		}, {
			id: "Id40",
			color: "rgb(255,0,0)",
			shape: "ellipse",
			size: 1,
			x: 600,
			y: 900
		}, {
			id: "Id41",
			color: "rgb(255,0,0)",
			shape: "ellipse2",
			size: 1,
			x: 0,
			y: 1000
		}, {
			id: "Id42",
			color: "rgb(255,0,0)",
			shape: "ellipse3",
			size: 1,
			x: 200,
			y: 1000
		}],
		edges: []
	};
	this.dataSetNetworkDecorations = {
		nodes: [{
			id: "Gene1",
			exp1: 1,
			exp2: 2,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 4,
				cl3: 3
			},
			exp5: {
				cl1: 12,
				cl2: 1,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 160
		}, {
			id: "Gene2",
			exp1: 2,
			exp2: 4,
			exp3: 1,
			exp4: {
				cl1: 7,
				cl2: 1,
				cl3: 8
			},
			exp5: {
				cl1: 1,
				cl2: 11,
				cl3: 8
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 340
		}, {
			id: "Gene3",
			exp1: 1,
			exp2: 5,
			exp3: 1,
			exp4: {
				cl1: 12,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 3,
				cl2: 7,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 160
		}, {
			id: "Gene4",
			exp1: 4,
			exp2: 2,
			exp3: 1,
			exp4: {
				cl1: 1,
				cl2: 14,
				cl3: 7
			},
			exp5: {
				cl1: 2,
				cl2: 1,
				cl3: 15
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 340
		}, {
			id: "Gene5",
			exp1: 1,
			exp2: 3,
			exp3: 2,
			exp4: {
				cl1: 4,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 6,
				cl2: 7,
				cl3: 2
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 255,
			y: 100
		}, {
			id: "Gene6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 255,
			y: 400
		}, {
			id: "Gene7",
			exp1: 3,
			exp2: 3,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 14,
				cl3: 1
			},
			exp5: {
				cl1: 9,
				cl2: 3,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 50,
			y: 250
		}, {
			id: "Gene8",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 450,
			y: 250
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene4",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene5",
			id2: "Gene6",
			color: "rgb(51,12,255)",
			width: "3",
			type: "arrowHeadLine"
		}, {
			id1: "Gene3",
			id2: "Gene8",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}, {
			id1: "Gene7",
			id2: "Gene1",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}]
	};
	this.dataSetNetworkRadial = {
		nodes: [{
			id: "Gene1",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene2",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene3",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene4",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene5",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene6",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene7",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene8",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "SNP1",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP2",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP3",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP4",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP5",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP6",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP7",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP8",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "PH1",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH1a",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH1"
		}, {
			id: "PH1b",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH1"
		}, {
			id: "PH2",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH2a",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2"
		}, {
			id: "PH2b",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2"
		}, {
			id: "PH2ba",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2b"
		}, {
			id: "PH3",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH4",
			color: "rgb(0,255,255)",
			shape: "star"
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP1",
			id2: "PH1",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "Gene2",
			id2: "Gene7",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene2",
			id2: "Gene8",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP4",
			id2: "PH4",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH1",
			id2: "PH1a",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "PH1",
			id2: "PH1b",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "Gene4",
			id2: "SNP3",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene6",
			id2: "SNP4",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "PH2",
			id2: "PH2a",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH2",
			id2: "PH2b",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "Gene6",
			id2: "SNP5",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene7",
			id2: "SNP6",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP6",
			id2: "SNP7",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene4",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene5",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP7",
			id2: "Gene6",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP6",
			id2: "SNP8",
			color: "rgb(153,12,255)",
			type: "line"
		}, {
			id1: "Gene3",
			id2: "SNP1",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene3",
			id2: "SNP2",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP2",
			id2: "PH2",
			color: "rgb(153,12,255)",
			type: "line"
		}, {
			id1: "SNP3",
			id2: "PH3",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH2b",
			id2: "PH2ba",
			color: "rgb(102,12,152)",
			type: "line"
		}]
	};
	this.dataSetNetworkBasic = {
		nodes: [{
			id: "Cell",
			shape: "image",
			eventless: true,
			width: 525,
			height: 400,
			imagePath: "https://www.canvasxpress.org/images/cell.png",
			x: 250,
			y: 250,
			hideLabel: true
		}, {
			id: "Gene1",
			exp1: 1,
			exp2: 2,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 4,
				cl3: 3
			},
			exp5: {
				cl1: 12,
				cl2: 1,
				cl3: 5
			},
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "https://www.canvasxpress.org/images/prot.png",
			x: 155,
			y: 160
		}, {
			id: "Gene2",
			exp1: 2,
			exp2: 4,
			exp3: 1,
			exp4: {
				cl1: 7,
				cl2: 1,
				cl3: 8
			},
			exp5: {
				cl1: 1,
				cl2: 11,
				cl3: 8
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 340
		}, {
			id: "Gene3",
			exp1: 1,
			exp2: 5,
			exp3: 1,
			exp4: {
				cl1: 12,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 3,
				cl2: 7,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 160
		}, {
			id: "Gene4",
			label: "Receptor\nGene4",
			exp1: 4,
			exp2: 2,
			exp3: 1,
			exp4: {
				cl1: 1,
				cl2: 14,
				cl3: 7
			},
			exp5: {
				cl1: 2,
				cl2: 1,
				cl3: 15
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 340
		}, {
			id: "Gene5",
			exp1: 1,
			exp2: 3,
			exp3: 2,
			exp4: {
				cl1: 4,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 6,
				cl2: 7,
				cl3: 2
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			width: 20,
			height: 20,
			x: 255,
			y: 100
		}, {
			id: "Met",
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "https://www.canvasxpress.org/images/met.png",
			x: 255,
			y: 400,
			hideLabel: true
		}, {
			id: "Gene7",
			exp1: 3,
			exp2: 3,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 14,
				cl3: 1
			},
			exp5: {
				cl1: 9,
				cl2: 3,
				cl3: 5
			},
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "https://www.canvasxpress.org/images/prot7.png",
			x: 50,
			y: 250
		}, {
			id: "DNA",
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "https://www.canvasxpress.org/images/dna1.png",
			x: 450,
			y: 250,
			hideLabel: true
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene4",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene5",
			id2: "Met",
			color: "rgb(51,12,255)",
			width: "3",
			type: "arrowHeadLine"
		}, {
			id1: "Gene3",
			id2: "DNA",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}, {
			id1: "Gene7",
			id2: "Gene1",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}],
		legend: {
			nodes: [{
				shape: "sphere",
				color: "rgb(255,0,0)",
				text: "Gene",
				id: "nodesLegendId0"
			}],
			edges: [{
				type: "arrowHeadLine",
				text: "Activate",
				id: "edgesLegendId0"
			}],
			text: [{
				text: "Cool Pathway",
				x: 150,
				y: 460,
				id: "textLegendId0"
			}],
			pos: {
				nodes: {
					x: -5,
					y: -5
				},
				edges: {
					x: 360,
					y: -5
				},
				decorations: {
					x: 20,
					y: 80
				}
			}
		}
	};
	this.dataSetVenn = {
		venn: {
			data: {
				A: 340,
				B: 562,
				C: 620,
				D: 592,
				AB: 639,
				AC: 456,
				AD: 257,
				BC: 915,
				BD: 354,
				CD: 143,
				ABC: 552,
				ABD: 578,
				ACD: 298,
				BCD: 613,
				ABCD: 148
			},
			legend: {
				A: "List 1",
				B: "List 2",
				C: "List 3",
				D: "List 4"
			}
		}
	};
	this.dataSetMarket = {
		market: [{
			symbol: "BMY",
			data: [
				[20100824, 26.26, 26.37, 25.95, 26.02, 11625900, 26.02],
				[20100823, 26.48, 26.76, 26.38, 26.48, 12146600, 26.48],
				[20100820, 26.31, 26.54, 26.08, 26.44, 18140100, 26.44],
				[20100819, 26.2, 26.29, 25.81, 26.06, 8218000, 26.06],
				[20100818, 26.53, 26.57, 26.23, 26.28, 12235800, 26.28],
				[20100817, 26.4, 26.79, 26.26, 26.59, 12325700, 26.59],
				[20100816, 26.24, 26.34, 26.04, 26.28, 10377700, 26.28],
				[20100813, 26.24, 26.46, 26.1, 26.32, 5760100, 26.32],
				[20100812, 26.01, 26.39, 26, 26.33, 7350500, 26.33],
				[20100811, 26.32, 26.5, 26.15, 26.25, 8808100, 26.25],
				[20100810, 26.32, 26.78, 26.3, 26.66, 7009500, 26.66],
				[20100809, 26.37, 26.54, 26.3, 26.51, 6825300, 26.51],
				[20100806, 26.29, 26.45, 26.05, 26.37, 8774900, 26.37],
				[20100805, 25.83, 26.38, 25.8, 26.38, 12264600, 26.38],
				[20100804, 25.7, 26.13, 25.61, 26.03, 10233700, 26.03],
				[20100803, 25.65, 25.85, 25.58, 25.68, 6842900, 25.68],
				[20100802, 25.33, 25.61, 25.29, 25.53, 9770900, 25.53],
				[20100730, 24.98, 25.13, 24.78, 24.92, 11435700, 24.92],
				[20100729, 25.37, 25.5, 24.85, 25.08, 9463800, 25.08],
				[20100728, 25.25, 25.36, 25.02, 25.12, 8072400, 25.12],
				[20100727, 25.09, 25.35, 24.84, 25.32, 14152600, 25.32],
				[20100726, 24.57, 25.03, 24.57, 24.97, 8817400, 24.97],
				[20100723, 24.94, 24.95, 24.26, 24.65, 13043700, 24.65],
				[20100722, 24.96, 25.22, 24.75, 24.93, 10385300, 24.93],
				[20100721, 24.92, 25.11, 24.59, 24.75, 9830000, 24.75],
				[20100720, 24.65, 25.09, 24.46, 25.02, 10655500, 25.02],
				[20100719, 25.27, 25.27, 24.78, 24.84, 11804800, 24.84],
				[20100716, 25.44, 25.47, 25.1, 25.17, 13136300, 25.17]
			]
		}]
	};
	this.dataSetGenomeAdvanced = {
		tracks: [{
			name: "Affymetrix Probes",
			type: "box",
			connect: true,
			data: [{
				id: "123456_at",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[10, 20],
					[30, 40],
					[50, 60],
					[70, 80],
					[90, 100],
					[110, 120]
				],
				sequences: ["GTTTTACGTAC", "TACGTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC"],
				index: 0,
				counter: 0,
				start: 10,
				end: 120,
				measureText: 56
			}, {
				id: "345678_at",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[100, 110],
					[120, 130],
					[140, 150],
					[160, 170],
					[180, 190]
				],
				index: 2,
				counter: 2,
				start: 100,
				end: 190,
				measureText: 56
			}],
			startY: 50,
			endY: 82,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Sanger Sequencing (Multiple sequeneces)",
			highlight: [{
				offset: 80,
				width: 1,
				color: "rgb(120,120,180)"
			}, {
				offset: 185,
				width: 1,
				color: "rgb(180,20,180)"
			}],
			subtype: "DNA",
			type: "sequence",
			data: [{
				id: "Reference Sequence",
				fill: "rgb(51,255,255)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 1,
				sequence: "AAAACCCGGGTTTTACGTACGTACGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTAAACC",
				translate: [-3, -2, -1, 1, 2, 3],
				index: 0,
				counter: 3,
				measureText: 108
			}, {
				id: "R1-0000-1234",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 1,
				gaps: [
					[18, 1],
					[22, 1]
				],
				sequence: "AAAACCCGGGTTTTACGTCGTAGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAA",
				coordinate: 50,
				trace: {
					A: [57, 127, 237, 371, 486, 531, 486, 371, 237, 127, 57, 54, 117, 217, 339, 442, 484, 442, 339, 217, 117, 54, 10, 24, 60, 130, 240, 375, 490, 535, 490, 375, 240, 130, 60, 24, 10, 56, 121, 222, 346, 452, 494, 452, 346, 222, 121, 56, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 4, 5, 7, 14, 27, 47, 72, 93, 101, 93, 72, 47, 27, 14, 7, 5, 4, 5, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 5, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 1, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 1, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 4, 5, 7, 14, 27, 47, 72, 94, 102, 94, 72, 47, 27, 14, 7, 5, 4, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 12, 24, 43, 67, 87, 95, 87, 67, 43, 24, 12, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 4, 6, 13, 26, 47, 72, 93, 102, 93, 72, 47, 26, 13, 6, 4, 4, 6, 13, 26, 46, 71, 92, 100, 92, 71, 46, 26, 13, 6, 4, 6, 8, 14, 27, 46, 69, 89, 97, 89, 69, 46, 27, 14, 8, 6, 4, 5, 8, 14, 28, 49, 76, 98, 107, 98, 76, 49, 28, 14, 8, 5, 4, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 11, 24, 43, 67, 88, 96, 88, 67, 43, 24, 11, 5, 22, 54, 118, 219, 342, 447, 489, 447, 342, 219, 118, 54, 22, 5, 12, 25, 46, 71, 93, 102, 93, 71, 46, 25, 12, 5, 5, 12, 24, 44, 68, 89, 97, 89, 68, 44, 24, 12, 5, 20, 54, 121, 226, 355, 465, 508, 465, 355, 226, 121, 54, 20, 3, 4, 6, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 6, 4, 3, 6, 8, 15, 27, 47, 71, 91, 99, 91, 71, 47, 27, 15, 8, 6, 1, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 1, 6, 11, 25, 60, 128, 237, 369, 482, 527, 482, 369, 237, 128, 60, 25, 11, 6, 2, 5, 12, 25, 47, 74, 97, 106, 97, 74, 47, 25, 12, 5, 2, 5, 8, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 5, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 6, 18, 48, 107, 201, 315, 412, 451, 412, 315, 201, 107, 48, 18, 6, 9, 16, 31, 53, 81, 105, 114, 105, 81, 53, 31, 16, 9, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 19, 51, 113, 212, 332, 434, 475, 434, 332, 212, 113, 51, 19, 8, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 8, 12, 26, 49, 76, 99, 109, 99, 76, 49, 26, 12, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 22, 54, 118, 218, 341, 445, 487, 445, 341, 218, 118, 54, 22, 21, 52, 112, 208, 324, 423, 462, 423, 324, 208, 112, 52, 21, 10, 23, 54, 115, 212, 330, 430, 471, 430, 330, 212, 115, 54, 23, 10, 2, 3, 5, 12, 25, 45, 69, 91, 99, 91, 69, 45, 25, 12, 5, 3, 2, 2, 3, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 3, 2, 8, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 8, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 7, 14, 28, 49, 75, 97, 105, 97, 75, 49, 28, 14, 7, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 16, 30, 53, 80, 103, 113, 103, 80, 53, 30, 16, 25, 61, 133, 246, 384, 501, 548, 501, 384, 246, 133, 61, 25, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 5, 6, 9, 15, 29, 50, 77, 99, 108, 99, 77, 50, 29, 15, 9, 6, 5, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 9, 23, 55, 120, 223, 348, 454, 497, 454, 348, 223, 120, 55, 23, 9, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 6, 3, 2, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 22, 55, 120, 223, 348, 455, 498, 455, 348, 223, 120, 55, 22, 22, 53, 115, 213, 332, 434, 474, 434, 332, 213, 115, 53, 22, 7, 20, 53, 118, 221, 346, 454, 496, 454, 346, 221, 118, 53, 20, 7, 2, 3, 5, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 5, 3, 2, 15, 28, 50, 75, 97, 106, 97, 75, 50, 28, 15, 1, 2, 5, 12, 25, 47, 74, 96, 105, 96, 74, 47, 25, 12, 5, 2, 1, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 12, 26, 47, 72, 94, 103, 94, 72, 47, 26, 12, 5, 8, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 8, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 7, 20, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 20, 7, 2, 3, 5, 12, 25, 46, 72, 94, 102, 94, 72, 46, 25, 12, 5, 3, 2, 2, 4, 11, 25, 46, 72, 94, 102, 94, 72, 46, 25, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 6, 3, 2, 10, 25, 61, 133, 247, 386, 504, 551, 504, 386, 247, 133, 61, 25, 10, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 2, 8, 22, 57, 127, 238, 372, 487, 532, 487, 372, 238, 127, 57, 22, 8, 60, 129, 237, 370, 483, 528, 483, 370, 237, 129, 60],
					C: [6, 13, 23, 34, 45, 49, 45, 34, 23, 13, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 4, 5, 9, 15, 26, 39, 49, 54, 49, 39, 26, 15, 9, 5, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 21, 51, 111, 206, 321, 419, 459, 419, 321, 206, 111, 51, 21, 11, 26, 62, 134, 248, 387, 505, 552, 505, 387, 248, 134, 62, 26, 11, 5, 10, 24, 58, 126, 233, 364, 475, 520, 475, 364, 233, 126, 58, 24, 10, 5, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 8, 21, 52, 113, 211, 329, 431, 471, 431, 329, 211, 113, 52, 21, 8, 3, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 3, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 9, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 9, 5, 6, 9, 16, 27, 41, 53, 57, 53, 41, 27, 16, 9, 6, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 4, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 4, 4, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 4, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 5, 7, 10, 17, 29, 43, 54, 59, 54, 43, 29, 17, 10, 7, 5, 5, 6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 24, 56, 121, 224, 348, 454, 497, 454, 348, 224, 121, 56, 24, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 5, 9, 15, 25, 38, 48, 53, 48, 38, 25, 15, 9, 5, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 5, 7, 10, 17, 29, 42, 54, 59, 54, 42, 29, 17, 10, 7, 5, 3, 7, 20, 52, 116, 217, 339, 443, 485, 443, 339, 217, 116, 52, 20, 7, 3, 3, 8, 22, 55, 123, 229, 358, 469, 513, 469, 358, 229, 123, 55, 22, 8, 3, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 10, 16, 26, 39, 49, 54, 49, 39, 26, 16, 10, 5, 8, 14, 24, 36, 46, 49, 46, 36, 24, 14, 8, 5, 22, 54, 119, 222, 346, 453, 495, 453, 346, 222, 119, 54, 22, 5, 5, 6, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 6, 5, 5, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 7, 20, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 20, 7, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 10, 16, 27, 39, 50, 55, 50, 39, 27, 16, 10, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 3, 8, 22, 56, 124, 232, 362, 474, 519, 474, 362, 232, 124, 56, 22, 8, 3, 56, 120, 221, 345, 450, 492, 450, 345, 221, 120, 56, 2, 7, 21, 55, 122, 229, 358, 469, 513, 469, 358, 229, 122, 55, 21, 7, 2, 5, 7, 10, 17, 27, 40, 51, 56, 51, 40, 27, 17, 10, 7, 5, 3, 7, 13, 23, 35, 45, 50, 45, 35, 23, 13, 7, 3, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 2, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 2, 4, 7, 14, 25, 39, 50, 55, 50, 39, 25, 14, 7, 4, 1, 1, 2, 6, 12, 22, 34, 44, 49, 44, 34, 22, 12, 6, 2, 1, 1, 2, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 3, 8, 23, 58, 129, 240, 376, 492, 539, 492, 376, 240, 129, 58, 23, 8, 3, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 2, 2, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 2, 2, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 2, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 2, 2, 2, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 2, 10, 16, 26, 38, 48, 52, 48, 38, 26, 16, 10],
					G: [4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 4, 4, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 4, 4, 22, 57, 127, 237, 370, 485, 530, 485, 370, 237, 127, 57, 22, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 2, 7, 21, 55, 123, 230, 361, 472, 517, 472, 361, 230, 123, 55, 21, 7, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5, 3, 3, 9, 22, 55, 120, 224, 349, 457, 499, 457, 349, 224, 120, 55, 22, 9, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 22, 54, 116, 215, 335, 438, 479, 438, 335, 215, 116, 54, 22, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 22, 57, 127, 237, 371, 485, 530, 485, 371, 237, 127, 57, 22, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 3, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 3, 11, 25, 59, 127, 234, 364, 476, 520, 476, 364, 234, 127, 59, 25, 11, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 1, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 11, 25, 61, 131, 243, 378, 494, 540, 494, 378, 243, 131, 61, 25, 11, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 2, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 2, 2, 2, 3, 4, 8, 13, 20, 25, 27, 25, 20, 13, 8, 4, 3, 2, 2, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 59, 130, 243, 381, 498, 545, 498, 381, 243, 130, 59, 54, 118, 218, 341, 446, 488, 446, 341, 218, 118, 54, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 3, 8, 23, 59, 131, 244, 382, 500, 547, 500, 382, 244, 131, 59, 23, 8, 3, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 1, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 11, 24, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 24, 11, 23, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 23, 26, 62, 133, 246, 384, 501, 548, 501, 384, 246, 133, 62, 26, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 2, 2, 4, 8, 13, 19, 25, 27, 25, 19, 13, 8, 4, 2, 2, 2, 7, 20, 54, 120, 224, 351, 460, 503, 460, 351, 224, 120, 54, 20, 7, 2, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 2, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 2, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 7, 11, 17, 24, 29, 32, 29, 24, 17, 11, 7],
					T: [3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 23, 59, 131, 244, 382, 501, 548, 501, 382, 244, 131, 59, 23, 5, 10, 24, 59, 129, 239, 373, 488, 534, 488, 373, 239, 129, 59, 24, 10, 5, 6, 19, 50, 112, 210, 329, 431, 472, 431, 329, 210, 112, 50, 19, 6, 54, 118, 219, 342, 447, 488, 447, 342, 219, 118, 54, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 10, 23, 54, 115, 213, 331, 433, 473, 433, 331, 213, 115, 54, 23, 10, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 21, 54, 119, 223, 348, 456, 498, 456, 348, 223, 119, 54, 21, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 2, 3, 4, 6, 8, 11, 12, 11, 8, 6, 4, 3, 2, 23, 58, 129, 242, 378, 495, 541, 495, 378, 242, 129, 58, 23, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 2, 6, 19, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 19, 6, 2, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 20, 53, 119, 222, 349, 456, 499, 456, 349, 222, 119, 53, 20, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 57, 126, 235, 367, 481, 526, 481, 367, 235, 126, 57, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 5, 5, 6, 7, 9, 11, 14, 15, 14, 11, 9, 7, 6, 5, 5, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 23, 55, 119, 221, 345, 451, 493, 451, 345, 221, 119, 55, 23, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 61, 133, 245, 381, 498, 545, 498, 381, 245, 133, 61, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 50, 111, 207, 325, 426, 466, 426, 325, 207, 111, 50, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 56, 119, 220, 342, 447, 489, 447, 342, 220, 119, 56, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 7, 21, 53, 117, 219, 343, 449, 491, 449, 343, 219, 117, 53, 21, 7, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 2, 6, 18, 48, 108, 202, 316, 414, 452, 414, 316, 202, 108, 48, 18, 6, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 8, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 11, 13, 14, 13, 11, 9, 7, 6, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 3, 7, 21, 53, 117, 219, 343, 448, 491, 448, 343, 219, 117, 53, 21, 7, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5],
					peak: [5, 16, 29, 42, 54, 68, 84, 99, 112, 127, 142, 157, 173, 186, 198, 212, 227, 242, 258, 273, 286, 299, 312, 325, 338, 353, 369, 385, 402, 418, 433, 447, 461, 475, 489, 502, 514, 527, 539, 550, 562, 575, 589, 605, 622, 637, 649, 660, 671, 683, 697, 710, 722, 735, 750, 764, 777, 792, 808, 822, 834, 847, 861, 877, 891, 905, 921, 935, 948, 962, 976, 991, 1007, 1023, 1039, 1055, 1071, 1084, 1097, 1113, 1129, 1142]
				},
				index: 1,
				counter: 4,
				measureText: 74
			}, {
				id: "R1-0000-3456",
				fill: "rgb(255,51,255)",
				outline: "rgb(0,0,0)",
				dir: "left",
				offsetLeft: "134",
				sequence: "AAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAAC",
				coordinate: 230,
				trace: {
					A: [6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 2, 6, 19, 50, 112, 210, 330, 432, 472, 432, 330, 210, 112, 50, 19, 6, 2, 5, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 5, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 2, 4, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 4, 2, 1, 2, 4, 11, 24, 46, 71, 93, 102, 93, 71, 46, 24, 11, 4, 2, 1, 3, 8, 21, 55, 122, 228, 357, 468, 512, 468, 357, 228, 122, 55, 21, 8, 3, 15, 28, 49, 75, 96, 105, 96, 75, 49, 28, 15, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 4, 6, 12, 24, 43, 65, 85, 93, 85, 65, 43, 24, 12, 6, 4, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 2, 4, 11, 24, 44, 68, 89, 98, 89, 68, 44, 24, 11, 4, 2, 24, 58, 125, 230, 358, 468, 512, 468, 358, 230, 125, 58, 24, 50, 109, 203, 317, 414, 453, 414, 317, 203, 109, 50, 8, 22, 54, 119, 220, 344, 450, 492, 450, 344, 220, 119, 54, 22, 8, 4, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 4, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 9, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 9, 3, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 1, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 1, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 4, 5, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 5, 4, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 5, 9, 22, 54, 116, 215, 336, 439, 480, 439, 336, 215, 116, 54, 22, 9, 5, 11, 24, 45, 70, 91, 99, 91, 70, 45, 24, 11, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 2, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 3, 2, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 11, 23, 43, 66, 86, 94, 86, 66, 43, 23, 11, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 1, 2, 5, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 5, 2, 1, 50, 113, 211, 331, 433, 474, 433, 331, 211, 113, 50, 2, 7, 20, 54, 120, 225, 352, 461, 505, 461, 352, 225, 120, 54, 20, 7, 2, 7, 21, 56, 125, 234, 366, 480, 525, 480, 366, 234, 125, 56, 21, 7, 9, 15, 29, 50, 76, 99, 108, 99, 76, 50, 29, 15, 9, 16, 30, 52, 79, 103, 112, 103, 79, 52, 30, 16, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 14, 28, 51, 78, 102, 111, 102, 78, 51, 28, 14, 7, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 5, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 4, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 4, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 7, 21, 56, 125, 235, 368, 482, 528, 482, 368, 235, 125, 56, 21, 7, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 2, 3, 5, 11, 23, 42, 66, 85, 93, 85, 66, 42, 23, 11, 5, 3, 2, 2, 4, 10, 22, 41, 65, 85, 93, 85, 65, 41, 22, 10, 4, 2, 4, 8, 22, 54, 118, 220, 343, 448, 490, 448, 343, 220, 118, 54, 22, 8, 4, 13, 26, 45, 69, 90, 98, 90, 69, 45, 26, 13, 4, 5, 8, 15, 30, 52, 80, 104, 113, 104, 80, 52, 30, 15, 8, 5, 4, 2, 3, 6, 13, 27, 49, 76, 99, 108, 99, 76, 49, 27, 13, 6, 3, 2, 9, 23, 55, 120, 222, 347, 453, 496, 453, 347, 222, 120, 55, 23, 9, 60, 131, 243, 380, 496, 543, 496, 380, 243, 131, 60, 11, 26, 61, 132, 244, 380, 496, 542, 496, 380, 244, 132, 61, 26, 11, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 5, 6, 9, 15, 29, 51, 77, 99, 108, 99, 77, 51, 29, 15, 9, 6, 5, 3, 5, 11, 23, 42, 66, 86, 94, 86, 66, 42, 23, 11, 5, 3, 4, 5, 7, 14, 26, 47, 71, 92, 100, 92, 71, 47, 26, 14, 7, 5, 4, 5, 8, 15, 29, 52, 79, 102, 112, 102, 79, 52, 29, 15, 8, 5, 5, 6, 9, 16, 30, 53, 80, 104, 113, 104, 80, 53, 30, 16, 9, 6, 5, 20, 50, 110, 204, 318, 416, 455, 416, 318, 204, 110, 50, 20, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 3, 4, 6, 13, 26, 46, 71, 93, 101, 93, 71, 46, 26, 13, 6, 4, 3, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 60, 132, 245, 383, 501, 548, 501, 383, 245, 132, 60, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 10, 23, 42, 66, 86, 95, 86, 66, 42, 23, 10, 4, 6, 12, 25, 44, 67, 87, 95, 87, 67, 44, 25, 12, 6, 4, 58, 129, 242, 380, 498, 544, 498, 380, 242, 129, 58, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 23, 57, 125, 232, 362, 474, 518, 474, 362, 232, 125, 57, 23, 4, 5, 8, 15, 29, 52, 80, 103, 112, 103, 80, 52, 29, 15, 8, 5, 4],
					C: [1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 1, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 1, 4, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 4, 60, 132, 246, 385, 504, 551, 504, 385, 246, 132, 60, 19, 50, 110, 206, 322, 421, 460, 421, 322, 206, 110, 50, 19, 7, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 7, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 1, 2, 5, 11, 21, 33, 43, 47, 43, 33, 21, 11, 5, 2, 1, 1, 2, 5, 11, 21, 33, 42, 46, 42, 33, 21, 11, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 1, 1, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 56, 120, 221, 344, 449, 491, 449, 344, 221, 120, 56, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 4, 1, 2, 6, 12, 22, 35, 45, 50, 45, 35, 22, 12, 6, 2, 1, 8, 21, 53, 116, 216, 337, 441, 482, 441, 337, 216, 116, 53, 21, 8, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 6, 10, 16, 26, 38, 48, 53, 48, 38, 26, 16, 10, 6, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 20, 53, 119, 224, 350, 459, 502, 459, 350, 224, 119, 53, 20, 19, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 19, 23, 55, 118, 218, 340, 444, 485, 444, 340, 218, 118, 55, 23, 3, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 4, 4, 5, 8, 14, 24, 36, 45, 49, 45, 36, 24, 14, 8, 5, 4, 4, 10, 17, 29, 43, 55, 59, 55, 43, 29, 17, 10, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 54, 121, 226, 354, 464, 508, 464, 354, 226, 121, 54, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 2, 2, 3, 7, 13, 23, 36, 47, 51, 47, 36, 23, 13, 7, 3, 2, 2, 4, 7, 14, 25, 39, 51, 55, 51, 39, 25, 14, 7, 4, 51, 113, 210, 329, 430, 471, 430, 329, 210, 113, 51, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 1, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 1, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 1, 1, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 55, 117, 216, 337, 440, 481, 440, 337, 216, 117, 55, 53, 115, 212, 331, 432, 472, 432, 331, 212, 115, 53, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 1, 2, 6, 12, 22, 35, 46, 50, 46, 35, 22, 12, 6, 2, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 4, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 6, 4, 4, 4, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 23, 57, 125, 233, 364, 476, 521, 476, 364, 233, 125, 57, 23, 2, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 2, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 3, 3, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 3, 3, 54, 116, 215, 335, 437, 478, 437, 335, 215, 116, 54, 4, 4, 6, 9, 16, 26, 39, 50, 55, 50, 39, 26, 16, 9, 6, 4, 4, 2, 2, 4, 7, 14, 24, 37, 49, 53, 49, 37, 24, 14, 7, 4, 2, 2, 4, 6, 9, 16, 26, 39, 51, 55, 51, 39, 26, 16, 9, 6, 4, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 7, 22, 57, 128, 239, 375, 491, 537, 491, 375, 239, 128, 57, 22, 7, 22, 58, 130, 244, 383, 501, 548, 501, 383, 244, 130, 58, 22, 22, 53, 113, 208, 324, 423, 463, 423, 324, 208, 113, 53, 22, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 5, 2, 4, 7, 14, 26, 40, 52, 56, 52, 40, 26, 14, 7, 4, 2, 4, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 4, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 5, 5, 6, 9, 16, 25, 37, 48, 52, 48, 37, 25, 16, 9, 6, 5, 5, 4, 7, 14, 24, 35, 46, 50, 46, 35, 24, 14, 7, 4, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 3, 3, 5, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 5, 3, 3, 6, 12, 22, 34, 43, 47, 43, 34, 22, 12, 6, 8, 14, 24, 37, 47, 52, 47, 37, 24, 14, 8, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 5, 11, 21, 33, 43, 46, 43, 33, 21, 11, 5, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 4, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 4, 5, 10, 23, 57, 123, 228, 355, 465, 508, 465, 355, 228, 123, 57, 23, 10, 5],
					G: [1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 1, 1, 1, 3, 6, 11, 17, 22, 25, 22, 17, 11, 6, 3, 1, 1, 1, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 1, 58, 129, 242, 379, 497, 543, 497, 379, 242, 129, 58, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 51, 114, 214, 335, 438, 480, 438, 335, 214, 114, 51, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 2, 6, 18, 49, 109, 204, 319, 418, 457, 418, 319, 204, 109, 49, 18, 6, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 20, 53, 118, 222, 348, 456, 498, 456, 348, 222, 118, 53, 20, 1, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 8, 13, 19, 24, 25, 24, 19, 13, 8, 5, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 6, 7, 11, 16, 23, 28, 31, 28, 23, 16, 11, 7, 6, 4, 9, 24, 59, 130, 242, 378, 494, 540, 494, 378, 242, 130, 59, 24, 9, 4, 2, 7, 22, 58, 130, 244, 382, 500, 547, 500, 382, 244, 130, 58, 22, 7, 2, 7, 20, 51, 113, 210, 329, 431, 471, 431, 329, 210, 113, 51, 20, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 4, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 4, 4, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 25, 61, 134, 248, 387, 506, 553, 506, 387, 248, 134, 61, 25, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 4, 7, 12, 18, 23, 26, 23, 18, 12, 7, 4, 24, 60, 132, 246, 384, 502, 549, 502, 384, 246, 132, 60, 24, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 7, 11, 17, 23, 29, 31, 29, 23, 17, 11, 7, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 21, 52, 114, 211, 330, 431, 471, 431, 330, 211, 114, 52, 21, 6, 18, 49, 109, 205, 321, 420, 459, 420, 321, 205, 109, 49, 18, 6, 7, 21, 55, 124, 232, 363, 476, 521, 476, 363, 232, 124, 55, 21, 7, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 3, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 5, 10, 24, 58, 126, 234, 365, 477, 521, 477, 365, 234, 126, 58, 24, 10, 5, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 4, 6, 9, 15, 21, 26, 28, 26, 21, 15, 9, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 5, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 5, 56, 124, 232, 364, 476, 521, 476, 364, 232, 124, 56, 6, 11, 25, 60, 129, 239, 372, 486, 531, 486, 372, 239, 129, 60, 25, 11, 6, 8, 22, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 22, 8, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 56, 126, 236, 370, 485, 530, 485, 370, 236, 126, 56, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 4, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 4, 4, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 4],
					T: [1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 6, 19, 51, 114, 213, 334, 438, 479, 438, 334, 213, 114, 51, 19, 6, 6, 19, 51, 115, 215, 336, 440, 482, 440, 336, 215, 115, 51, 19, 6, 2, 6, 19, 51, 115, 215, 337, 441, 482, 441, 337, 215, 115, 51, 19, 6, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 21, 54, 120, 224, 351, 459, 503, 459, 351, 224, 120, 54, 21, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 6, 19, 50, 111, 209, 327, 429, 469, 429, 327, 209, 111, 50, 19, 6, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 2, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 2, 5, 9, 22, 52, 113, 210, 327, 427, 467, 427, 327, 210, 113, 52, 22, 9, 5, 57, 123, 227, 354, 462, 505, 462, 354, 227, 123, 57, 58, 125, 230, 359, 469, 512, 469, 359, 230, 125, 58, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 2, 7, 21, 56, 125, 235, 368, 482, 527, 482, 368, 235, 125, 56, 21, 7, 2, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 9, 22, 53, 115, 214, 333, 435, 476, 435, 333, 214, 115, 53, 22, 9, 5, 10, 24, 59, 128, 238, 371, 485, 531, 485, 371, 238, 128, 59, 24, 10, 5, 56, 120, 221, 344, 450, 492, 450, 344, 221, 120, 56, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 7, 21, 55, 122, 229, 359, 470, 514, 470, 359, 229, 122, 55, 21, 7, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 8, 22, 56, 125, 232, 364, 476, 521, 476, 364, 232, 125, 56, 22, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 7, 10, 11, 10, 7, 5, 3, 2, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 5, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 9, 21, 52, 112, 207, 323, 422, 461, 422, 323, 207, 112, 52, 21, 9, 5, 9, 22, 54, 118, 218, 340, 445, 486, 445, 340, 218, 118, 54, 22, 9, 6, 10, 23, 53, 113, 209, 325, 425, 464, 425, 325, 209, 113, 53, 23, 10, 6, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 8, 21, 53, 116, 216, 338, 441, 483, 441, 338, 216, 116, 53, 21, 8, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 4, 4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 4],
					peak: [7, 23, 40, 54, 66, 80, 93, 105, 117, 130, 145, 161, 178, 192, 206, 221, 235, 250, 264, 278, 292, 304, 317, 331, 344, 357, 372, 389, 405, 421, 435, 446, 460, 474, 486, 501, 516, 528, 540, 555, 569, 583, 599, 613, 625, 636, 648, 662, 677, 692, 708, 722, 735, 749, 764, 780, 796, 810, 824, 841, 857, 870, 883, 898, 912, 925, 937, 951, 967, 983, 999, 1015, 1030, 1042, 1056, 1070, 1081, 1092, 1103, 1116, 1129, 1142, 1156, 1171]
				},
				index: 3,
				counter: 6,
				offset: 51,
				measureText: 74
			}, {
				id: "R1-0000-5678",
				fill: "rgb(51,255,255)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 126,
				gaps: [
					[5, 1],
					[58, 1]
				],
				sequence: "CCCGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAACCCGGGTTTAAACC",
				coordinate: 150,
				trace: {
					A: [14, 26, 46, 70, 91, 99, 91, 70, 46, 26, 14, 6, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 6, 4, 10, 23, 43, 67, 87, 95, 87, 67, 43, 23, 10, 4, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 13, 26, 48, 73, 95, 104, 95, 73, 48, 26, 13, 6, 9, 16, 30, 52, 78, 101, 111, 101, 78, 52, 30, 16, 9, 6, 13, 26, 46, 71, 92, 101, 92, 71, 46, 26, 13, 1, 2, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 1, 52, 115, 213, 332, 435, 475, 435, 332, 213, 115, 52, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 13, 27, 49, 77, 100, 109, 100, 77, 49, 27, 13, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 12, 25, 44, 68, 89, 97, 89, 68, 44, 25, 12, 4, 7, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 7, 4, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 7, 21, 53, 117, 218, 341, 446, 488, 446, 341, 218, 117, 53, 21, 7, 3, 9, 23, 58, 127, 237, 370, 483, 529, 483, 370, 237, 127, 58, 23, 9, 57, 123, 228, 355, 464, 508, 464, 355, 228, 123, 57, 3, 5, 12, 26, 47, 73, 95, 103, 95, 73, 47, 26, 12, 5, 3, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 10, 22, 41, 63, 83, 91, 83, 63, 41, 22, 10, 1, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 1, 4, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 4, 4, 6, 13, 25, 45, 70, 90, 99, 90, 70, 45, 25, 13, 6, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 3, 6, 12, 26, 48, 74, 97, 105, 97, 74, 48, 26, 12, 6, 3, 52, 116, 216, 338, 443, 484, 443, 338, 216, 116, 52, 5, 6, 8, 15, 29, 50, 76, 98, 107, 98, 76, 50, 29, 15, 8, 6, 5, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 2, 3, 6, 13, 27, 50, 77, 100, 109, 100, 77, 50, 27, 13, 6, 3, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 11, 24, 58, 124, 229, 357, 466, 509, 466, 357, 229, 124, 58, 24, 11, 21, 54, 119, 223, 349, 457, 500, 457, 349, 223, 119, 54, 21, 19, 49, 109, 202, 317, 414, 453, 414, 317, 202, 109, 49, 19, 2, 3, 6, 13, 27, 50, 78, 101, 110, 101, 78, 50, 27, 13, 6, 3, 2, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 6, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 6, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 4, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 4, 7, 13, 27, 48, 75, 97, 106, 97, 75, 48, 27, 13, 7, 3, 6, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 6, 3, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 5, 12, 25, 45, 70, 92, 100, 92, 70, 45, 25, 12, 5, 5, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 59, 129, 241, 376, 492, 538, 492, 376, 241, 129, 59, 1, 2, 4, 11, 24, 44, 69, 91, 99, 91, 69, 44, 24, 11, 4, 2, 1, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 5, 10, 24, 58, 126, 233, 363, 475, 519, 475, 363, 233, 126, 58, 24, 10, 5, 58, 129, 243, 380, 498, 545, 498, 380, 243, 129, 58, 12, 24, 45, 69, 90, 98, 90, 69, 45, 24, 12, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 2, 5, 12, 25, 47, 73, 96, 105, 96, 73, 47, 25, 12, 5, 2, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 15, 29, 51, 78, 102, 111, 102, 78, 51, 29, 15, 8, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 5, 8, 14, 27, 46, 70, 90, 98, 90, 70, 46, 27, 14, 8, 25, 60, 129, 239, 372, 486, 532, 486, 372, 239, 129, 60, 25, 9, 21, 51, 110, 204, 319, 416, 455, 416, 319, 204, 110, 51, 21, 9, 56, 119, 220, 343, 448, 489, 448, 343, 220, 119, 56, 3, 4, 7, 14, 28, 50, 78, 101, 110, 101, 78, 50, 28, 14, 7, 4, 3, 14, 28, 51, 79, 103, 112, 103, 79, 51, 28, 14],
					C: [53, 114, 212, 330, 431, 472, 431, 330, 212, 114, 53, 20, 52, 115, 215, 336, 440, 481, 440, 336, 215, 115, 52, 20, 19, 49, 110, 206, 323, 423, 463, 423, 323, 206, 110, 49, 19, 2, 6, 12, 23, 35, 46, 51, 46, 35, 23, 12, 6, 2, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 7, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 7, 5, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 1, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 9, 22, 52, 113, 209, 326, 426, 465, 426, 326, 209, 113, 52, 22, 9, 5, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 4, 7, 13, 23, 35, 44, 48, 44, 35, 23, 13, 7, 4, 6, 9, 16, 27, 40, 52, 56, 52, 40, 27, 16, 9, 6, 50, 110, 204, 319, 417, 455, 417, 319, 204, 110, 50, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 4, 8, 14, 24, 37, 48, 52, 48, 37, 24, 14, 8, 4, 3, 2, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 2, 3, 4, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 4, 3, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 19, 49, 110, 205, 322, 421, 461, 421, 322, 205, 110, 49, 19, 57, 127, 238, 373, 489, 535, 489, 373, 238, 127, 57, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 4, 4, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 4, 4, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 7, 13, 23, 36, 46, 50, 46, 36, 23, 13, 7, 6, 11, 26, 62, 134, 248, 387, 505, 553, 505, 387, 248, 134, 62, 26, 11, 6, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 4, 5, 9, 15, 26, 38, 49, 54, 49, 38, 26, 15, 9, 5, 4, 3, 8, 22, 58, 128, 239, 374, 489, 535, 489, 374, 239, 128, 58, 22, 8, 3, 2, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 3, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 3, 2, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 2, 5, 9, 21, 52, 111, 206, 321, 420, 459, 420, 321, 206, 111, 52, 21, 9, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 3, 5, 8, 15, 25, 38, 50, 54, 50, 38, 25, 15, 8, 5, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 2, 4, 7, 14, 24, 37, 48, 53, 48, 37, 24, 14, 7, 4, 2, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 22, 57, 128, 240, 376, 492, 538, 492, 376, 240, 128, 57, 22, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 5, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 5, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 2, 6, 20, 52, 116, 217, 341, 446, 488, 446, 341, 217, 116, 52, 20, 6, 2, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 4, 4, 5, 9, 15, 25, 38, 49, 53, 49, 38, 25, 15, 9, 5, 4, 4, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 54, 119, 221, 346, 453, 496, 453, 346, 221, 119, 54, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 7, 21, 55, 123, 230, 361, 473, 517, 473, 361, 230, 123, 55, 21, 7, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 5, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 6, 9, 15, 25, 37, 46, 50, 46, 37, 25, 15, 9, 6, 4, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 4, 10, 16, 27, 40, 50, 55, 50, 40, 27, 16, 10, 4, 9, 23, 58, 128, 238, 371, 485, 531, 485, 371, 238, 128, 58, 23, 9, 4, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58],
					G: [6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 20, 53, 119, 222, 349, 457, 499, 457, 349, 222, 119, 53, 20, 58, 126, 235, 367, 480, 525, 480, 367, 235, 126, 58, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 4, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 4, 51, 113, 211, 331, 433, 473, 433, 331, 211, 113, 51, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 9, 22, 56, 123, 228, 356, 466, 510, 466, 356, 228, 123, 56, 22, 9, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 7, 20, 53, 119, 223, 350, 459, 502, 459, 350, 223, 119, 53, 20, 7, 2, 5, 9, 21, 51, 111, 205, 319, 417, 456, 417, 319, 205, 111, 51, 21, 9, 5, 8, 21, 53, 116, 215, 336, 439, 480, 439, 336, 215, 116, 53, 21, 8, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 2, 2, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 5, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 5, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 2, 2, 2, 4, 7, 13, 19, 24, 27, 24, 19, 13, 7, 4, 2, 2, 2, 7, 19, 50, 110, 205, 321, 420, 459, 420, 321, 205, 110, 50, 19, 7, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 2, 1, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 1, 4, 4, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 4, 4, 10, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 10, 57, 127, 238, 373, 488, 534, 488, 373, 238, 127, 57, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 5, 8, 13, 19, 25, 27, 25, 19, 13, 8, 5, 3, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 4, 8, 13, 20, 25, 28, 25, 20, 13, 8, 4, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 21, 54, 119, 222, 347, 454, 496, 454, 347, 222, 119, 54, 21, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 5, 9, 15, 21, 27, 30, 27, 21, 15, 9, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 11, 24, 57, 123, 227, 354, 463, 506, 463, 354, 227, 123, 57, 24, 11, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 6, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 6, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 55, 120, 222, 346, 452, 494, 452, 346, 222, 120, 55, 23, 57, 123, 229, 357, 466, 510, 466, 357, 229, 123, 57, 23, 53, 118, 220, 344, 450, 492, 450, 344, 220, 118, 53, 3, 6, 12, 18, 24, 26, 24, 18, 12, 6, 3, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 3, 3, 3, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5],
					T: [5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 51, 112, 208, 324, 424, 463, 424, 324, 208, 112, 51, 2, 6, 19, 49, 109, 205, 321, 421, 460, 421, 321, 205, 109, 49, 19, 6, 2, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 22, 56, 122, 227, 355, 464, 508, 464, 355, 227, 122, 56, 22, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 8, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 8, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 48, 108, 202, 316, 414, 453, 414, 316, 202, 108, 48, 20, 52, 116, 218, 341, 446, 488, 446, 341, 218, 116, 52, 20, 7, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 7, 3, 4, 6, 9, 12, 12, 12, 9, 6, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 56, 126, 237, 371, 486, 531, 486, 371, 237, 126, 56, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 19, 49, 110, 205, 322, 422, 461, 422, 322, 205, 110, 49, 19, 6, 2, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 9, 22, 55, 120, 223, 348, 455, 497, 455, 348, 223, 120, 55, 22, 9, 23, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 23, 8, 22, 58, 128, 239, 374, 490, 536, 490, 374, 239, 128, 58, 22, 8, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 6, 10, 22, 52, 111, 205, 320, 417, 456, 417, 320, 205, 111, 52, 22, 10, 6, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 54, 117, 215, 335, 437, 478, 437, 335, 215, 117, 54, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 2, 3, 5, 8, 11, 11, 11, 8, 5, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 55, 123, 231, 363, 475, 520, 475, 363, 231, 123, 55, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 23, 54, 115, 213, 331, 432, 472, 432, 331, 213, 115, 54, 23, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4],
					peak: [5, 17, 30, 43, 55, 68, 81, 95, 109, 123, 137, 149, 162, 174, 187, 202, 218, 234, 247, 260, 274, 286, 300, 317, 333, 346, 358, 372, 385, 399, 414, 426, 439, 455, 471, 487, 503, 517, 530, 545, 562, 579, 595, 608, 620, 634, 648, 662, 675, 687, 700, 715, 729, 743, 759, 772, 786, 800, 811, 823, 837, 850, 862, 874, 885, 899, 914, 927, 941, 954, 968, 982]
				},
				index: 5,
				counter: 8,
				measureText: 74
			}],
			startY: 137,
			endY: 226,
			displayedFeatures: 6,
			totalFeatures: 6
		}, {
			name: "Copy Number Variation",
			type: "heatmap",
			autowidth: true,
			height: 20,
			data: [{
				id: "Cell Line-123",
				offset: 10,
				data: [7, 5, 5, 5, 6, 7, 9, 8, 8, 8, 8, 5, 7, 9, 15, 15, 16, 9, 9, 7, 8, 10, 9, 21, 22, 22, 24, 20, 24, 26, 24, 25, 24, 31, 29, 33, 33, 33, 33, 33, 20, 17, 19, 18, 18, 18, 27, 23, 31, 26, 31, 31, 31, 34, 32, 31, 30, 30, 30, 30, 30, 24, 24, 20, 21, 17, 17, 27, 29, 25, 31, 31, 31],
				index: 0,
				counter: 9,
				measureText: 67
			}],
			startY: 281,
			endY: 281,
			displayedFeatures: 1,
			totalFeatures: 1
		}, {
			name: "Tissue Distribution (Heart, Liver, Kidney)",
			type: "heatmap",
			height: 20,
			data: [{
				id: "123456_at",
				offset: 100,
				data: [25, 35, 46],
				index: 0,
				counter: 10,
				measureText: 56
			}, {
				id: "345678_at",
				offset: 181,
				data: [65, 46, 29],
				index: 2,
				counter: 12,
				measureText: 56
			}],
			startY: 336,
			endY: 386,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Another CNV",
			type: "line",
			autowidth: true,
			height: 20,
			fill: ["rgb(255,0,0)", "rgb(0,255,0)"],
			outline: ["rgb(255,0,0)", "rgb(0,255,0)"],
			data: [{
				id: "Cell Line-124",
				offset: 10,
				data: [30, 31, 31, 33, 29, 29, 30, 31, 32, 33, 33, 31, 31, 29, 30, 30, 27, 32, 31, 31, 28, 31, 31, 29, 31, 31, 31, 26, 25, 29, 26, 26, 21, 26, 21, 31, 31, 28, 28, 23, 25, 28, 28, 31, 33, 33, 32, 31, 31, 31, 24, 28, 28, 28, 31, 32, 32, 31, 31, 28, 24, 28, 24, 29, 31, 29, 31],
				index: 0,
				counter: 13,
				measureText: 67
			}],
			startY: 441,
			endY: 466,
			displayedFeatures: 2,
			totalFeatures: 2
		}, {
			type: "bar",
			height: 20,
			fill: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
			outline: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
			data: [{
				id: "123456_at",
				offset: 100,
				data: [25, 35, 46],
				index: 0,
				counter: 15,
				measureText: 56
			}, {
				id: "345678_at",
				offset: 181,
				data: [65, 46, 29],
				index: 2,
				counter: 17,
				measureText: 56
			}],
			startY: 501,
			endY: 551,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Clones",
			type: "box",
			data: [{
				id: "clone-1234567",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "left",
				data: [
					[121, 196]
				],
				index: 0,
				counter: 18,
				start: 121,
				end: 196,
				measureText: 77
			}, {
				id: "clone-2345678",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[371, 400]
				],
				landmarks: [{
					offset: 157,
					text: "Gap "
				}, {
					offset: 137,
					text: "Insertion "
				}],
				index: 1,
				counter: 19,
				start: 371,
				end: 400,
				measureText: 77
			}],
			startY: 606,
			endY: 619,
			displayedFeatures: 2,
			totalFeatures: 2
		}, {
			name: "SNP Location",
			type: "triangle",
			data: [{
				id: "SNP123",
				fill: "rgb(100,0,0)",
				outline: "rgb(0,0,0)",
				offset: 23,
				index: 0,
				counter: 20,
				measureText: 43
			}, {
				id: "SNP789",
				fill: "rgb(100,0,0)",
				outline: "rgb(0,0,0)",
				offset: 195,
				index: 6,
				counter: 26,
				measureText: 43
			}],
			startY: 674,
			endY: 782,
			displayedFeatures: 7,
			totalFeatures: 7
		}, {
			name: "SNP Sequences",
			type: "sequence",
			subtype: "DNA",
			data: [{
				id: "SNP123",
				offset: 19,
				sequence: "CACA[AT]GCACCTTGTA",
				index: 0,
				counter: 27,
				measureText: 43
			}, {
				id: "SNP234",
				offset: 41,
				sequence: "ATCG[TG]AATA",
				index: 1,
				counter: 28,
				measureText: 43
			}, {
				id: "SNP789",
				offset: 116,
				sequence: "GCCC[CT]AGGG",
				index: 2,
				counter: 29,
				measureText: 43
			}]
		}]
	};
	this.dataSetLesMiserables = {
		nodes: [{
			id: "Id0",
			name: "Myriel",
			group: 1
		}, {
			id: "Id1",
			name: "Napoleon",
			group: 1
		}, {
			id: "Id2",
			name: "Mlle. Baptistine",
			group: 1
		}, {
			id: "Id3",
			name: "Mme. Magloire",
			group: 1
		}, {
			id: "Id4",
			name: "Countess de Lo",
			group: 1
		}, {
			id: "Id5",
			name: "Geborand",
			group: 1
		}, {
			id: "Id6",
			name: "Champtercier",
			group: 1
		}, {
			id: "Id7",
			name: "Cravatte",
			group: 1
		}, {
			id: "Id8",
			name: "Count",
			group: 1
		}, {
			id: "Id9",
			name: "Old Man",
			group: 1
		}, {
			id: "Id10",
			name: "Labarre",
			group: 2
		}, {
			id: "Id11",
			name: "Valjean",
			group: 2
		}, {
			id: "Id12",
			name: "Marguerite",
			group: 3
		}, {
			id: "Id13",
			name: "Mme. de R",
			group: 2
		}, {
			id: "Id14",
			name: "Isabeau",
			group: 2
		}, {
			id: "Id15",
			name: "Gervais",
			group: 2
		}, {
			id: "Id16",
			name: "Tholomyes",
			group: 3
		}, {
			id: "Id17",
			name: "Listolier",
			group: 3
		}, {
			id: "Id18",
			name: "Fameuil",
			group: 3
		}, {
			id: "Id19",
			name: "Blacheville",
			group: 3
		}, {
			id: "Id20",
			name: "Favourite",
			group: 3
		}, {
			id: "Id21",
			name: "Dahlia",
			group: 3
		}, {
			id: "Id22",
			name: "Zephine",
			group: 3
		}, {
			id: "Id23",
			name: "Fantine",
			group: 3
		}, {
			id: "Id24",
			name: "Mme. Thenardier",
			group: 4
		}, {
			id: "Id25",
			name: "Thenardier",
			group: 4
		}, {
			id: "Id26",
			name: "Cosette",
			group: 5
		}, {
			id: "Id27",
			name: "Javert",
			group: 4
		}, {
			id: "Id28",
			name: "Fauchelevent",
			group: 0
		}, {
			id: "Id29",
			name: "Bamatabois",
			group: 2
		}, {
			id: "Id30",
			name: "Perpetue",
			group: 3
		}, {
			id: "Id31",
			name: "Simplice",
			group: 2
		}, {
			id: "Id32",
			name: "Scaufflaire",
			group: 2
		}, {
			id: "Id33",
			name: "Woman 1",
			group: 2
		}, {
			id: "Id34",
			name: "Judge",
			group: 2
		}, {
			id: "Id35",
			name: "Champmathieu",
			group: 2
		}, {
			id: "Id36",
			name: "Brevet",
			group: 2
		}, {
			id: "Id37",
			name: "Chenildieu",
			group: 2
		}, {
			id: "Id38",
			name: "Cochepaille",
			group: 2
		}, {
			id: "Id39",
			name: "Pontmercy",
			group: 4
		}, {
			id: "Id40",
			name: "Boulatruelle",
			group: 6
		}, {
			id: "Id41",
			name: "Eponine",
			group: 4
		}, {
			id: "Id42",
			name: "Anzelma",
			group: 4
		}, {
			id: "Id43",
			name: "Woman 2",
			group: 5
		}, {
			id: "Id44",
			name: "Mother Innocent",
			group: 0
		}, {
			id: "Id45",
			name: "Gribier",
			group: 0
		}, {
			id: "Id46",
			name: "Jondrette",
			group: 7
		}, {
			id: "Id47",
			name: "Mme. Burgon",
			group: 7
		}, {
			id: "Id48",
			name: "Gavroche",
			group: 8
		}, {
			id: "Id49",
			name: "Gillenormand",
			group: 5
		}, {
			id: "Id50",
			name: "Magnon",
			group: 5
		}, {
			id: "Id51",
			name: "Mlle. Gillenormand",
			group: 5
		}, {
			id: "Id52",
			name: "Mme. Pontmercy",
			group: 5
		}, {
			id: "Id53",
			name: "Mlle. Vaubois",
			group: 5
		}, {
			id: "Id54",
			name: "Lt. Gillenormand",
			group: 5
		}, {
			id: "Id55",
			name: "Marius",
			group: 8
		}, {
			id: "Id56",
			name: "Baroness T",
			group: 5
		}, {
			id: "Id57",
			name: "Mabeuf",
			group: 8
		}, {
			id: "Id58",
			name: "Enjolras",
			group: 8
		}, {
			id: "Id59",
			name: "Combeferre",
			group: 8
		}, {
			id: "Id60",
			name: "Prouvaire",
			group: 8
		}, {
			id: "Id61",
			name: "Feuilly",
			group: 8
		}, {
			id: "Id62",
			name: "Courfeyrac",
			group: 8
		}, {
			id: "Id63",
			name: "Bahorel",
			group: 8
		}, {
			id: "Id64",
			name: "Bossuet",
			group: 8
		}, {
			id: "Id65",
			name: "Joly",
			group: 8
		}, {
			id: "Id66",
			name: "Grantaire",
			group: 8
		}, {
			id: "Id67",
			name: "Mother Plutarch",
			group: 9
		}, {
			id: "Id68",
			name: "Gueulemer",
			group: 4
		}, {
			id: "Id69",
			name: "Babet",
			group: 4
		}, {
			id: "Id70",
			name: "Claquesous",
			group: 4
		}, {
			id: "Id71",
			name: "Montparnasse",
			group: 4
		}, {
			id: "Id72",
			name: "Toussaint",
			group: 5
		}, {
			id: "Id73",
			name: "Child 1",
			group: 10
		}, {
			id: "Id74",
			name: "Child 2",
			group: 10
		}, {
			id: "Id75",
			name: "Brujon",
			group: 4
		}, {
			id: "Id76",
			name: "Mme. Hucheloup",
			group: 8
		}],
		edges: [{
			id1: "Id1",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id2",
			id2: "Id0",
			value: 8
		}, {
			id1: "Id3",
			id2: "Id0",
			value: 10
		}, {
			id1: "Id3",
			id2: "Id2",
			value: 6
		}, {
			id1: "Id4",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id5",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id6",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id7",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id8",
			id2: "Id0",
			value: 2
		}, {
			id1: "Id9",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id11",
			id2: "Id10",
			value: 1
		}, {
			id1: "Id11",
			id2: "Id3",
			value: 3
		}, {
			id1: "Id11",
			id2: "Id2",
			value: 3
		}, {
			id1: "Id11",
			id2: "Id0",
			value: 5
		}, {
			id1: "Id12",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id13",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id14",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id15",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id17",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id18",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id18",
			id2: "Id17",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id17",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id18",
			value: 4
		}, {
			id1: "Id20",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id19",
			value: 4
		}, {
			id1: "Id21",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id20",
			value: 5
		}, {
			id1: "Id22",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id20",
			value: 4
		}, {
			id1: "Id22",
			id2: "Id21",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id20",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id21",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id22",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id12",
			value: 2
		}, {
			id1: "Id23",
			id2: "Id11",
			value: 9
		}, {
			id1: "Id24",
			id2: "Id23",
			value: 2
		}, {
			id1: "Id24",
			id2: "Id11",
			value: 7
		}, {
			id1: "Id25",
			id2: "Id24",
			value: 13
		}, {
			id1: "Id25",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id25",
			id2: "Id11",
			value: 12
		}, {
			id1: "Id26",
			id2: "Id24",
			value: 4
		}, {
			id1: "Id26",
			id2: "Id11",
			value: 31
		}, {
			id1: "Id26",
			id2: "Id16",
			value: 1
		}, {
			id1: "Id26",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id27",
			id2: "Id11",
			value: 17
		}, {
			id1: "Id27",
			id2: "Id23",
			value: 5
		}, {
			id1: "Id27",
			id2: "Id25",
			value: 5
		}, {
			id1: "Id27",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id27",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id28",
			id2: "Id11",
			value: 8
		}, {
			id1: "Id28",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id30",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id31",
			id2: "Id30",
			value: 2
		}, {
			id1: "Id31",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id31",
			id2: "Id23",
			value: 2
		}, {
			id1: "Id31",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id32",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id33",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id33",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id34",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id34",
			id2: "Id29",
			value: 2
		}, {
			id1: "Id35",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id35",
			id2: "Id34",
			value: 3
		}, {
			id1: "Id35",
			id2: "Id29",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id37",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id36",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id38",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id36",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id37",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id39",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id40",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id41",
			id2: "Id24",
			value: 2
		}, {
			id1: "Id41",
			id2: "Id25",
			value: 3
		}, {
			id1: "Id42",
			id2: "Id41",
			value: 2
		}, {
			id1: "Id42",
			id2: "Id25",
			value: 2
		}, {
			id1: "Id42",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id43",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id43",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id43",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id44",
			id2: "Id28",
			value: 3
		}, {
			id1: "Id44",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id45",
			id2: "Id28",
			value: 2
		}, {
			id1: "Id47",
			id2: "Id46",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id47",
			value: 2
		}, {
			id1: "Id48",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id49",
			id2: "Id26",
			value: 3
		}, {
			id1: "Id49",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id50",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id50",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id51",
			id2: "Id49",
			value: 9
		}, {
			id1: "Id51",
			id2: "Id26",
			value: 2
		}, {
			id1: "Id51",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id52",
			id2: "Id51",
			value: 1
		}, {
			id1: "Id52",
			id2: "Id39",
			value: 1
		}, {
			id1: "Id53",
			id2: "Id51",
			value: 1
		}, {
			id1: "Id54",
			id2: "Id51",
			value: 2
		}, {
			id1: "Id54",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id54",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id51",
			value: 6
		}, {
			id1: "Id55",
			id2: "Id49",
			value: 12
		}, {
			id1: "Id55",
			id2: "Id39",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id54",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id26",
			value: 21
		}, {
			id1: "Id55",
			id2: "Id11",
			value: 19
		}, {
			id1: "Id55",
			id2: "Id16",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id25",
			value: 2
		}, {
			id1: "Id55",
			id2: "Id41",
			value: 5
		}, {
			id1: "Id55",
			id2: "Id48",
			value: 4
		}, {
			id1: "Id56",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id56",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id58",
			id2: "Id55",
			value: 7
		}, {
			id1: "Id58",
			id2: "Id48",
			value: 7
		}, {
			id1: "Id58",
			id2: "Id27",
			value: 6
		}, {
			id1: "Id58",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id58",
			id2: "Id11",
			value: 4
		}, {
			id1: "Id59",
			id2: "Id58",
			value: 15
		}, {
			id1: "Id59",
			id2: "Id55",
			value: 5
		}, {
			id1: "Id59",
			id2: "Id48",
			value: 6
		}, {
			id1: "Id59",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id60",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id60",
			id2: "Id58",
			value: 4
		}, {
			id1: "Id60",
			id2: "Id59",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id58",
			value: 6
		}, {
			id1: "Id61",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id61",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id61",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id62",
			id2: "Id55",
			value: 9
		}, {
			id1: "Id62",
			id2: "Id58",
			value: 17
		}, {
			id1: "Id62",
			id2: "Id59",
			value: 13
		}, {
			id1: "Id62",
			id2: "Id48",
			value: 7
		}, {
			id1: "Id62",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id62",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id62",
			id2: "Id61",
			value: 6
		}, {
			id1: "Id62",
			id2: "Id60",
			value: 3
		}, {
			id1: "Id63",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id63",
			id2: "Id48",
			value: 5
		}, {
			id1: "Id63",
			id2: "Id62",
			value: 6
		}, {
			id1: "Id63",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id63",
			id2: "Id58",
			value: 4
		}, {
			id1: "Id63",
			id2: "Id61",
			value: 3
		}, {
			id1: "Id63",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id63",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id64",
			id2: "Id55",
			value: 5
		}, {
			id1: "Id64",
			id2: "Id62",
			value: 12
		}, {
			id1: "Id64",
			id2: "Id48",
			value: 5
		}, {
			id1: "Id64",
			id2: "Id63",
			value: 4
		}, {
			id1: "Id64",
			id2: "Id58",
			value: 10
		}, {
			id1: "Id64",
			id2: "Id61",
			value: 6
		}, {
			id1: "Id64",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id64",
			id2: "Id59",
			value: 9
		}, {
			id1: "Id64",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id64",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id65",
			id2: "Id63",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id64",
			value: 7
		}, {
			id1: "Id65",
			id2: "Id48",
			value: 3
		}, {
			id1: "Id65",
			id2: "Id62",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id58",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id61",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id65",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id65",
			id2: "Id55",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id64",
			value: 3
		}, {
			id1: "Id66",
			id2: "Id58",
			value: 3
		}, {
			id1: "Id66",
			id2: "Id59",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id62",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id65",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id63",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id61",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id60",
			value: 1
		}, {
			id1: "Id67",
			id2: "Id57",
			value: 3
		}, {
			id1: "Id68",
			id2: "Id25",
			value: 5
		}, {
			id1: "Id68",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id25",
			value: 6
		}, {
			id1: "Id69",
			id2: "Id68",
			value: 6
		}, {
			id1: "Id69",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id27",
			value: 2
		}, {
			id1: "Id69",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id25",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id69",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id68",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id58",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id69",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id68",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id70",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id72",
			id2: "Id26",
			value: 2
		}, {
			id1: "Id72",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id72",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id73",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id74",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id74",
			id2: "Id73",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id69",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id68",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id25",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id70",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id71",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id64",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id65",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id66",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id63",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id62",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id58",
			value: 1
		}],
		m: {
			Name: "Les Miserables",
			Description: "Coappearance network of characters in the novel Les Miserables",
			Reference: "D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993)."
		}
	};
	this.getDataSet = function(e) {
		if (e && this["dataSet" + e]) {
			return this["dataSet" + e]
		} else {
			if (e && e.match(/Random/)) {
				var c;
				var b = e.split(":");
				var a = {
					randomDataVariables: this.randomDataVariables,
					randomDataSamples: this.randomDataSamples,
					randomDataVariableAnnotations: this.randomDataVariableAnnotations,
					randomDataSampleAnnotations: this.randomDataSampleAnnotations,
					randomDataUniform: this.randomDataUniform,
					randomDataSymmetrical: this.randomDataSymmetrical,
					randomDataGraphTime: this.isGraphTime,
					randomMissingDataPercentage: this.randomMissingDataPercentage
				};
				if (b.length > 0) {
					if (b[1] != null) {
						this.randomDataVariables = Number(b[1])
					}
					if (b[2] != null) {
						this.randomDataSamples = Number(b[2])
					}
					if (b[3] != null) {
						this.randomDataVariableAnnotations = Number(b[3])
					}
					if (b[4] != null) {
						this.randomDataSampleAnnotations = Number(b[4])
					}
					if (b[5] != null && Number(b[5]) > 0) {
						this.randomDataUniform = true
					} else {
						this.randomDataUniform = false
					}
					if (b[6] != null && Number(b[6]) > 0) {
						this.randomDataSymmetrical = true
					} else {
						this.randomDataSymmetrical = false
					}
					if (b[7] != null && Number(b[7]) > 0) {
						this.isGraphTime = true
					} else {
						this.isGraphTime = false
					}
					if (b[8] != null) {
						this.randomMissingDataPercentage = Number(b[8])
					}
				}
				c = this.createRandomData(true);
				this.randomDataVariables = a.randomDataVariables;
				this.randomDataSamples = a.randomDataSamples;
				this.randomDataVariableAnnotations = a.randomDataVariableAnnotations;
				this.randomDataSampleAnnotations = a.randomDataSampleAnnotations;
				this.randomDataUniform = a.randomDataUniform;
				this.randomDataSymmetrical = a.randomDataSymmetrical;
				this.isGraphTime = a.randomDataGraphTime;
				this.randomMissingDataPercentage = a.randomMissingDataPercentage;
				return c
			} else {
				return this.dataSetExample
			}
		}
	};
	this.getGenericDataSet = function() {
		return {
			x: this.dataSetGeneric.x,
			y: this.dataSetGeneric.y,
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a,
			venn: this.dataSetVenn.venn,
			market: this.dataSetMarket.market,
			nodes: this.dataSetNetworkRadial.nodes,
			edges: this.dataSetNetworkRadial.edges,
			tracks: this.dataSetGenomeAdvanced.tracks
		}
	};
	this.initializeExample = function() {
		this.dataSetExample = {
			x: this.dataSetGeneric.x,
			y: this.dataSetGeneric.y,
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a,
			venn: this.dataSetVenn.venn,
			market: this.dataSetMarket.market,
			nodes: this.dataSetNetworkRadial.nodes,
			edges: this.dataSetNetworkRadial.edges,
			tracks: this.dataSetGenomeAdvanced.tracks
		};
		this.dataSetSummaryExample = {
			x: this.dataSetGeneric.x,
			y: {
				vars: this.dataSetGeneric.y["vars"],
				smps: this.dataSetGeneric.y["smps"],
				mean: this.dataSetGeneric.y["data"],
				stdev: [
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3]
				],
				n: [
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5]
				],
				desc: this.dataSetGeneric.y["desc"]
			},
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a
		}
	};
	this.initializeExample()
};
CanvasXpress.prototype.initData = function(a) {
	this.isValidPlotData = function(b) {
		var c = this.isGroupedData ? this.data.w : this.data.y;
		if (b == "cor" && c.cor) {
			return true
		} else {
			if (b == "venn" && this.data.venn) {
				return true
			} else {
				if (b == "network" && this.data.nodes) {
					return true
				} else {
					if (b == "genome" && this.data.tracks) {
						return true
					} else {
						if (b == "sum" && c.sum && c.sum[0].length > 0) {
							return true
						} else {
							if (b == "max" && c.max && c.max[0].length > 0) {
								return true
							} else {
								if (b == "min" && c.min && c.min[0].length > 0) {
									return true
								} else {
									if (b == "mean" && c.mean && c.mean[0].length > 0) {
										return true
									} else {
										if (b == "median" && c.median && c.median[0].length > 0) {
											return true
										} else {
											if (b == "iqr" && c.iqr1 && c.qtl1 && c.median && c.qtl3 && c.iqr3 && c.median[0].length > 0) {
												return true
											} else {
												if (b == "candle" && c.close && c.open && c.high && c.low && c.close[0].length > 0) {
													return true
												} else {
													if (b == "volume" && c.volume && c.volume[0].length > 0) {
														return true
													} else {
														if (b == "raw" && this.isRawData) {
															return true
														} else {
															if (b == "video" && this.data.video) {
																return true
															} else {
																return false
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.setRangeData = function(d, e, b, y, G) {
		var c = this.isGroupedData && !e ? this.data.w : this.data.y;
		var r = Number.POSITIVE_INFINITY;
		var v = Number.NEGATIVE_INFINITY;
		if (this.setMin != null && this.setMax != null) {
			this.minData = this.setMin;
			this.maxData = this.setMax;
			return
		}
		if (this.isGroupedData && !d) {
			d = this.graphType == "Boxplot" ? "iqr" : this.summaryType;
			if (this.graphType == "Boxplot" && !this.isBoxPlotCalc) {
				this.groupSamples(this.groupingFactors, false, false, false, true);
				c = this.data.w
			}
		}
		if (d == "genome") {
			for (var w = 0; w < this.data.tracks.length; w++) {
				for (var t = 0; t < this.data.tracks[w].data.length; t++) {
					if (this.data.tracks[w].type == "box") {
						for (var s = 0; s < this.data.tracks[w].data[t].data.length; s++) {
							p = this.data.tracks[w].data[t].data[s];
							v = Math.max(v, Math.max(p[0], p[1]));
							r = Math.min(r, Math.min(p[0], p[1]))
						}
					} else {
						if (this.data.tracks[w].type == "sequence") {
							p = this.data.tracks[w].data[t].offset;
							v = Math.max(v, p + this.data.tracks[w].data[t].sequence.length);
							r = Math.min(r, p)
						} else {
							if (this.data.tracks[w].type.match(/bar|heatmap|line|stacked/)) {
								p = this.data.tracks[w].data[t].offset;
								v = this.data.tracks[w].autowidth ? Math.max(v, p + this.data.tracks[w].data[t].data.length) : Math.max(v, p);
								r = Math.min(r, p)
							} else {
								p = this.data.tracks[w].data[t].offset;
								v = Math.max(v, p);
								r = Math.min(r, p)
							}
						}
					}
				}
			}
		} else {
			if (d == "circular") {
				if (this.circularType == "chord") {
					this.circularChord = this.chordifyData();
					r = 0;
					v = this.circularChord.total
				} else {
					var q = this.getVariableIndices(this.rAxis);
					if (q >= 0) {
						var g = this.range(this.data.y.data[q]);
						r = g[0];
						v = g[1]
					} else {
						r = 0;
						v = 1
					}
				}
			} else {
				if (d == "km" && !e) {
					r = 0;
					v = 1
				} else {
					if (d == "video") {
						r = 0;
						v = 1
					} else {
						if (d == "percentile" && !e && !y) {
							r = 0;
							v = 100
						} else {
							if ((d == "mean" || d == "median" || d == "sum" || d == "max" || d == "min") && (!e)) {
								if (y) {
									v = 0;
									r = 0;
									maxSt = 0;
									minSt = 0;
									var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
									var D = this.isTransformedData ? c.trans : c[this.summaryType];
									for (var w = 0; w < f.length; w++) {
										var o = f[w];
										var m = 0;
										var n = 0;
										for (var t = 0; t < this.varIndices.length; t++) {
											var x = this.varIndices[t];
											var F = D[x][o];
											if (!isNaN(F)) {
												minSt = Math.min(F, minSt);
												maxSt = Math.max(F, maxSt);
												if (F > 0) {
													m += F
												} else {
													if (F < 0) {
														n += F
													}
												}
											}
										}
										v = Math.max(m, v);
										r = Math.min(n, r)
									}
								} else {
									for (var w = 0; w < this.varIndices.length; w++) {
										var o = this.varIndices[w];
										var p;
										var l;
										if (this.isTransformedData) {
											p = c.trans[o];
											l = c.tstdev ? c.tstdev[o] : false
										} else {
											if (this.summaryType == "mean") {
												p = c.mean[o]
											} else {
												if (this.summaryType == "median") {
													p = c.median[o]
												} else {
													if (this.summaryType == "sum") {
														p = c.sum[o]
													} else {
														if (this.summaryType == "max") {
															p = c.max[o]
														} else {
															if (this.summaryType == "min") {
																p = c.min[o]
															}
														}
													}
												}
											}
											l = c.stdev ? c.stdev[o] : false
										}
										for (var t = 0; t < p.length; t++) {
											var C;
											var F = p[t];
											if (l) {
												C = l[t]
											} else {
												C = Number.NaN
											}
											if (!isNaN(F)) {
												if (!isNaN(C)) {
													if (b) {
														if (F > 0) {
															r = Math.min(F, r);
															v = Math.max(F + C, v)
														}
													} else {
														r = Math.min(F, r);
														v = Math.max(F + C, v)
													}
												} else {
													if (b) {
														if (F > 0) {
															r = Math.min(F, r);
															v = Math.max(F, v)
														}
													} else {
														r = Math.min(F, r);
														v = Math.max(F, v)
													}
												}
											}
										}
									}
								}
							} else {
								if ((d == "iqr" && !e && this.grpIndices) || (this.summaryType == "iqr" && !this.isRawData)) {
									for (var w = 0; w < this.varIndices.length; w++) {
										var o = this.varIndices[w];
										var B = this.grpIndices ? this.grpIndices : this.smpIndices;
										for (var t = 0; t < B.length; t++) {
											var x = B[t];
											var A = c.iqr1[o][x];
											var z = c.iqr3[o][x];
											var u = c.out[o][x];
											if (!isNaN(A) && !isNaN(z)) {
												if (b) {
													if (A > 0 && z > 0) {
														r = Math.min(A, r);
														v = Math.max(z, v)
													}
												} else {
													r = Math.min(A, r);
													v = Math.max(z, v)
												}
											}
											if (u) {
												for (var s = 0; s < u.length; s++) {
													if (!isNaN(u[s])) {
														if (b) {
															if (u[s] > 0) {
																r = Math.min(u[s], r);
																v = Math.max(u[s], v)
															}
														} else {
															r = Math.min(u[s], r);
															v = Math.max(u[s], v)
														}
													}
												}
											}
										}
									}
								} else {
									if (d == "candle") {
										if (this.isTransformedData) {
											alert("Transformation not allowed");
											this.isTransformedData = false
										}
										var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
										for (var w = 0; w < this.varIndices.length; w++) {
											var o = this.varIndices[w];
											for (var t = 0; t < f.length; t++) {
												var x = f[t];
												var h = c.high[o][x];
												var E = c.low[o][x];
												if (!isNaN(h) && !isNaN(E)) {
													r = Math.min(E, r);
													v = Math.max(h, v)
												}
											}
										}
									} else {
										if (d == "volume") {
											var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
											for (var w = 0; w < this.varIndices.length; w++) {
												var o = this.varIndices[w];
												for (var t = 0; t < f.length; t++) {
													var x = f[t];
													if (!isNaN(c.volume[o][x])) {
														r = Math.min(c.volume[o][x], r);
														v = Math.max(c.volume[o][x], v)
													}
												}
											}
										} else {
											if (d == "cor") {
												var f = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
												for (var w = 0; w < f.length; w++) {
													for (var t = 0; t < f.length; t++) {
														var F = this.isTransformedData ? c.trans[w][t] : c.cor[w][t];
														if (!isNaN(F)) {
															if (b) {
																if (F > 0) {
																	r = Math.min(F, r);
																	v = Math.max(F, v)
																}
															} else {
																r = Math.min(F, r);
																v = Math.max(F, v)
															}
														}
													}
												}
											} else {
												var D = this.isTransformedData ? c.trans : c.data;
												if (D.length > 0) {
													if (y) {
														v = 0;
														r = 0;
														maxSt = 0;
														minSt = 0;
														for (var w = 0; w < this.smpIndices.length; w++) {
															var m = 0;
															var n = 0;
															for (var t = 0; t < this.varIndices.length; t++) {
																var F = D[this.varIndices[t]][this.smpIndices[w]];
																if (!isNaN(F)) {
																	minSt = Math.min(F, minSt);
																	maxSt = Math.max(F, maxSt);
																	if (F > 0) {
																		m += F
																	} else {
																		if (F < 0) {
																			n += F
																		}
																	}
																}
															}
															v = Math.max(m, v);
															r = Math.min(n, r)
														}
													} else {
														for (var w = 0; w < this.varIndices.length; w++) {
															for (var t = 0; t < this.smpIndices.length; t++) {
																var F = D[this.varIndices[w]][this.smpIndices[t]];
																if (!isNaN(F)) {
																	if (b) {
																		if (F > 0) {
																			r = Math.min(F, r);
																			v = Math.max(F, v)
																		}
																	} else {
																		r = Math.min(F, r);
																		v = Math.max(F, v)
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		this.minData = this.setMin != null ? this.setMin : r == Number.POSITIVE_INFINITY || r == Number.NEGATIVE_INFINITY ? -1 : r;
		this.maxData = this.setMax != null ? this.setMax : v == Number.NEGATIVE_INFINITY || v == Number.POSITIVE_INFINITY ? 1 : v;
		if (y && d != "percentile") {
			this.minDataStacked = minSt;
			this.maxDataStacked = maxSt
		}
	};
	this.setRangeDataObject = function(f) {
		var e = Number.POSITIVE_INFINITY;
		var b = Number.NEGATIVE_INFINITY;
		for (var d = 0; d < this.varIndices.length; d++) {
			for (var c = 0; c < this.smpIndices.length; c++) {
				var g = f[this.varIndices[d]][this.smpIndices[c]];
				if (!isNaN(g)) {
					e = Math.min(g, e);
					b = Math.max(g, b)
				}
			}
		}
		e = e == Number.POSITIVE_INFINITY || e == Number.NEGATIVE_INFINITY ? -1 : e;
		b = b == Number.NEGATIVE_INFINITY || b == Number.POSITIVE_INFINITY ? 1 : b;
		return [e, b]
	};
	this.checkObject = function() {
		var d = this.data.y;
		if (this.isGroupedData) {
			this.data.w = {};
			d = this.data.w
		}
		var c = ["vars", "smps", "labs", "desc", "data", "mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "trans", "tstdev", "cor", "min", "max", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
		for (var b = 0; b < c.length; b++) {
			if (!d[c[b]]) {
				if (c[b] == "factors") {
					d[c[b]] = {}
				} else {
					d[c[b]] = []
				}
			}
		}
	};
	this.resetObject = function(b) {
		var d = ["mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "cor", "min", "max", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
		if (this.isGroupedData) {
			if (!this.isTransformedData) {
				d.push("trans");
				d.push("tstdev")
			}
			for (var c = 0; c < d.length; c++) {
				delete(this.data.y[d[c]])
			}
			delete(this.data.w)
		} else {
			if (!this.isTransformedData) {
				d.push("trans");
				d.push("tstdev")
			}
			if (this.isRawData) {
				for (var c = 0; c < d.length; c++) {
					delete(this.data.y[d[c]])
				}
			} else {}
		}
		if (b && this.isRawData) {
			this.checkObject()
		}
	};
	this.summarize = function(g, y) {
		var c = this.isGroupedData ? this.data.w : this.data.y;
		var h = this.isGroupedData ? false : true;
		if (!this.isGroupedData) {
			this.checkObject()
		}
		var d = ["trans", "tstdev", "mean", "median", "stdev", "qtl1", "qtl3", "iqr1", "iqr3", "out", "n", "min", "max", "sum"];
		var t = function(z, k) {
			if (!c[z][k]) {
				c[z][k] = []
			}
		};
		if (g == "cor") {
			this.isBoxPlotCalc = false;
			if (this.correlationAxis == "samples") {
				var m = this.isGroupedData ? this.grpIndices : this.smpIndices;
				for (var w = 0; w < m.length; w++) {
					var o = m[w];
					var n = this.getDataForSmpGrpAtIndex(o);
					if (!c.cor[o]) {
						c.cor[o] = []
					}
					for (var u = w; u < m.length; u++) {
						var x = m[u];
						if (!c.cor[x]) {
							c.cor[x] = []
						}
						var l = this.getDataForSmpGrpAtIndex(x);
						if (w == u) {
							if (this.isTransformedData) {
								c.trans[o][x] = 1
							}
							c.cor[o][x] = 1
						} else {
							c.cor[o][x] = this.correlation(n, l);
							c.cor[x][o] = c.cor[o][x];
							if (this.isTransformedData) {
								c.trans[o][x] = c.cor[o][x];
								c.trans[x][o] = c.cor[x][o]
							}
						}
					}
				}
			} else {
				for (var w = 0; w < this.varIndices.length; w++) {
					var o = this.varIndices[w];
					if (!c.cor[o]) {
						c.cor[o] = []
					}
					for (var u = w; u < this.varIndices.length; u++) {
						var x = this.varIndices[u];
						if (!c.cor[x]) {
							c.cor[x] = []
						}
						if (w == u) {
							c.cor[o][x] = 1;
							if (this.isTransformedData) {
								c.trans[o][x] = 1
							}
						} else {
							c.cor[o][x] = this.correlation(c.data[o], c.data[x], h);
							c.cor[x][o] = c.cor[o][x];
							if (this.isTransformedData) {
								c.trans[o][x] = c.cor[o][x];
								c.trans[x][o] = c.cor[x][o]
							}
						}
					}
				}
			}
		} else {
			this.isBoxPlotCalc = g == "iqr" ? true : false;
			for (var w = 0; w < this.varIndices.length; w++) {
				var b;
				var o = this.varIndices[w];
				for (var u = 0; u < d.length; u++) {
					t(d[u], o)
				}
				if (this.isGroupedData) {
					if (!y) {
						var q = this.isTransformedData ? this.data.y.trans : this.data.y.data;
						b = [];
						for (var u = 0; u < this.data.w.grps.length; u++) {
							b[u] = [];
							for (var s = 0; s < this.data.w.grps[u].length; s++) {
								var f = this.data.w.grps[u][s];
								b[u].push(q[o][f])
							}
						}
					} else {
						b = y[o]
					}
				} else {
					c.grps = [];
					b = [];
					for (var u = 0; u < this.smpIndices.length; u++) {
						var x = this.smpIndices[u];
						c.grps[u] = [];
						c.grps[u].push(x);
						b[u] = [this.isTransformedData ? c.trans[o][x] : c.data[o][x]]
					}
				}
				if (g == "iqr") {
					this.summaryType = "iqr";
					if (this.isRawData) {
						if (!this.isGroupedData) {
							for (var u = 0; u < this.smpIndices.length; u++) {
								var x = this.smpIndices[u];
								if (this.isTransformedData) {
									c.trans[o][u] = b[u][0]
								}
								c.mean[o][x] = b[u][0];
								c.median[o][x] = b[u][0];
								c.qtl1[o][x] = b[u][0];
								c.qtl3[o][x] = b[u][0];
								c.iqr1[o][x] = b[u][0];
								c.iqr3[o][x] = b[u][0];
								c.out[o][x] = [];
								c.n[o][x] = 1
							}
						} else {
							for (var u = 0; u < b.length; u++) {
								var p = this.quantiles(b[u], h);
								if (this.isTransformedData) {
									c.trans[o][u] = p[1]
								}
								c.mean[o][u] = p[0];
								c.median[o][u] = p[2];
								c.qtl1[o][u] = p[1];
								c.qtl3[o][u] = p[3];
								c.iqr1[o][u] = p[4];
								c.iqr3[o][u] = p[5];
								c.out[o][u] = p[6];
								c.n[o][u] = p[7]
							}
						}
					}
				} else {
					if (g == "median") {
						this.summaryType = "median";
						if (this.isRawData) {
							for (var u = 0; u < b.length; u++) {
								var p = this.median(b[u], h);
								if (this.isTransformedData) {
									c.trans[o][u] = p[1]
								}
								c.median[o][u] = p[0];
								c.n[o][u] = p[1]
							}
						}
					} else {
						if (g == "mean" || g == "raw") {
							this.summaryType = "mean";
							if (this.isRawData) {
								for (var u = 0; u < b.length; u++) {
									var p = this.sumarizeErrorData(b[u], h);
									if (this.isTransformedData) {
										c.trans[o][u] = p[0];
										c.tstdev[o][u] = p[1]
									}
									c.mean[o][u] = p[0];
									c.stdev[o][u] = p[1];
									c.n[o][u] = p[2]
								}
							}
						} else {
							if (g == "sum") {
								this.summaryType = "sum";
								if (this.isRawData) {
									for (var u = 0; u < b.length; u++) {
										var e = this.sum(b[u], h);
										if (this.isTransformedData) {
											c.trans[o][u] = e
										}
										c.sum[o][u] = e;
										c.n[o][u] = b[u].length
									}
								}
							} else {
								if (g == "max") {
									this.summaryType = "max";
									if (this.isRawData) {
										for (var u = 0; u < b.length; u++) {
											var v = this.max(b[u], h);
											if (this.isTransformedData) {
												c.trans[o][u] = v
											}
											c.max[o][u] = v;
											c.n[o][u] = b[u].length
										}
									}
								} else {
									if (g == "min") {
										this.summaryType = "min";
										if (this.isRawData) {
											for (var u = 0; u < b.length; u++) {
												var r = this.min(b[u], h);
												if (this.isTransformedData) {
													c.trans[o][u] = r
												}
												c.min[o][u] = r;
												c.n[o][u] = b[u].length
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.copySummarizedData = function() {
		var f = this.isGroupedData ? this.data.w : this.data.y;
		var e;
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			f.data[d] = [];
			f.trans[d] = [];
			if (this.summaryType == "mean") {
				for (var b = 0; b < f.mean[d].length; b++) {
					f.data[d][b] = f.mean[d][b]
				}
			} else {
				if (this.summaryType == "median" || this.summaryType == "iqr") {
					for (var b = 0; b < f.median[d].length; b++) {
						f.data[d][b] = f.median[d][b]
					}
				} else {
					if (this.summaryType == "candle") {
						for (var b = 0; b < f.close[d].length; b++) {
							f.data[d][b] = f.close[d][b]
						}
					} else {
						if (this.summaryType == "volume") {
							for (var b = 0; b < f.volume[d].length; b++) {
								f.data[d][b] = f.volume[d][b]
							}
						} else {
							if (this.summaryType == "sum") {
								for (var b = 0; b < f.sum[d].length; b++) {
									f.data[d][b] = f.sum[d][b]
								}
							} else {
								if (this.summaryType == "max") {
									for (var b = 0; b < f.max[d].length; b++) {
										f.data[d][b] = f.max[d][b]
									}
								} else {
									if (this.summaryType == "min") {
										for (var b = 0; b < f.min[d].length; b++) {
											f.data[d][b] = f.min[d][b]
										}
									}
								}
							}
						}
					}
				}
			}
			if (!e) {
				e = d
			}
		}
		return e
	};
	this.transformValue = function(c, d, b) {
		switch (c) {
			case "log2":
				return b ? Math.pow(2, d) : Math.log(d) / Math.LN2;
			case "log10":
				return b ? Math.pow(10, d) : Math.log(d) / Math.LN10;
			case "exp2":
				return b ? Math.log(d) / Math.LN2 : Math.pow(2, d);
			case "exp10":
				return b ? Math.log(d) / Math.LN10 : Math.pow(10, d);
			default:
				return d
		}
	};
	this.transform = function(e, d, b, c) {
		this.functionCaller = "transform";
		if (this.isTransition()) {
			return
		}
		var f = 0;
		if (!this.isGroupedData) {
			this.checkObject()
		}
		if (!this.isRawData || this.isGroupedData) {
			f = this.copySummarizedData()
		}
		this.transformType = e;
		this.transformAxis = d;
		this.xAxisMaxStrLength = false;
		this.xAxis2MaxStrLength = false;
		this.yAxisMaxStrLength = false;
		this.zAxisMaxStrLength = false;
		if (e == "reset" || e == "undo") {
			this.transformReset();
			this.transformType = false;
			this.isTransformedData = false;
			this.isLogData = false;
			if (this.tempIndices) {
				if (this.isGroupedData) {
					this.grpIndices = this.tempIndices
				} else {
					this.smpIndices = this.tempIndices
				}
				this.tempIndices = false
			}
		} else {
			if (e == "save") {
				this.transformSave();
				this.transformType = false;
				this.isTransformedData = false;
				this.isLogData = false
			} else {
				if (e == "log2" || e == "log10" || e == "exp2" || e == "exp10") {
					if (this.transformLogExpCeilFloor(e)) {
						this.isTransformedData = e
					} else {
						return
					}
				} else {
					if (e == "ceil") {
						if (this.transformCeilValue != null) {
							this.transformLogExpCeilFloor(e);
							this.isTransformedData = e
						} else {
							return
						}
					} else {
						if (e == "floor") {
							if (this.transformFloorValue != null) {
								this.transformLogExpCeilFloor(e);
								this.isTransformedData = e
							} else {
								return
							}
						} else {
							if (e == "ratio" || e == "ratio2" || e == "ratio10") {
								this.transformRatio(e, b);
								this.isTransformedData = e
							} else {
								this.transformRelative(e, d, f);
								this.isTransformedData = e
							}
						}
					}
				}
			}
		}
		delete(this.meta.def.colorBrew);
		if (this.graphType == "Boxplot") {
			this.summarizeBoxplot = true
		}
		if (!c) {
			this.draw()
		}
	};
	this.transformReset = function() {
		var e = this.data.y;
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			for (var b = 0; b < e.data[d].length; b++) {
				if (e.trans && e.trans[d] && !isNaN(e.data[d][b])) {
					e.trans[d][b] = e.data[d][b]
				}
			}
		}
		if (this.isGroupedData) {
			this.isTransformedData = false;
			this.groupSamples(this.groupingFactors, false, false, false, true)
		}
	};
	this.transformSave = function() {
		var b = this.isGroupedData ? this.groupingFactors : false;
		var f = this.data.y;
		this.ungroupSamples();
		for (var d = 0; d < this.varIndices.length; d++) {
			var e = this.varIndices[d];
			for (var c = 0; c < f.data[e].length; c++) {
				if (!isNaN(f.data[e][c])) {
					f.data[e][c] = f.trans[e][c]
				}
			}
		}
		if (b) {
			this.isTransformedData = false;
			this.groupSamples(b, false, false, false, true)
		}
	};
	this.transformLogExpCeilFloor = function(e) {
		var f = this.data.y;
		if (e.match(/log/)) {
			if (this.minData <= 0) {}
			e = e == "log2" ? "log2" : e == "log10" ? "log10" : this.transformBase == 2 ? "log2" : "log10"
		} else {
			if (e == "exp") {
				e = e == "exp2" ? "exp2" : e == "exp10" ? "exp10" : this.transformBase == 2 ? "exp2" : "exp10"
			}
		}
		if (!f.trans) {
			f.trans = []
		}
		if (!f.tstdev) {
			f.tstdev = []
		}
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			if (!f.trans[d]) {
				f.trans[d] = []
			}
			if (!f.tstdev[d]) {
				f.tstdev[d] = []
			}
			for (var b = 0; b < f.data[d].length; b++) {
				if (!isNaN(f.data[d][b])) {
					if (e == "log2") {
						this.isLogData = true;
						this.transformBase = 2;
						f.trans[d][b] = Math.log(f.data[d][b]) / Math.LN2
					} else {
						if (e == "log10") {
							this.isLogData = true;
							this.transformBase = 10;
							f.trans[d][b] = Math.log(f.data[d][b]) / Math.LN10
						} else {
							if (e == "exp2") {
								this.isLogData = false;
								this.transformBase = 2;
								f.trans[d][b] = Math.pow(2, f.data[d][b])
							} else {
								if (e == "exp10") {
									this.isLogData = false;
									this.transformBase = 10;
									f.trans[d][b] = Math.pow(10, f.data[d][b])
								} else {
									if (e == "ceil") {
										f.trans[d][b] = Math.min(this.transformCeilValue, f.data[d][b])
									} else {
										if (e == "floor") {
											f.trans[d][b] = Math.max(this.transformFloorValue, f.data[d][b])
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.isGroupedData) {
			this.isTransformedData = e;
			this.groupSamples(this.groupingFactors, false, false, true, true)
		}
		return true
	};
	this.transformRatio = function() {
		var k = [];
		var o = this.data;
		var b = this.isGroupedData && !this.graphType.match(/dotplot|boxplot/i) ? o.w : o.y;
		if (this.isGroupedData && this.ratioGroupReference && o.x.hasOwnProperty(this.ratioGroupReference)) {
			if (!this.ratioLevelReference) {
				for (var t = 0; t < o.x[this.ratioGroupReference].length; t++) {
					if (o.x[this.ratioGroupReference][t] != null) {
						this.ratioLevelReference = o.x[this.ratioGroupReference][t];
						break
					}
				}
			}
			if (this.groupingFactors.length == 1) {
				this.ratioReference = this.getSampleIndices(this.ratioLevelReference);
				if (this.ratioReference < 0) {
					this.ratioLevelReference = o.w.smps[0];
					this.ratioReference = 0
				}
				k = [this.ratioReference]
			} else {
				var g = [];
				for (var t = 0; t < this.groupingFactors.length; t++) {
					if (this.groupingFactors[t] != this.ratioGroupReference) {
						g.push(this.groupingFactors[t])
					}
				}
				var c = {};
				var v = [];
				var s = 0;
				for (var t = 0; t < this.smpIndices.length; t++) {
					var m = this.smpIndices[t];
					var n = [];
					var y;
					for (var r = 0; r < g.length; r++) {
						var u = g[r];
						y = o.x[u][m];
						if (!y) {
							y = "NA"
						}
						n.push(y)
					}
					y = n.join(" - ");
					if (!c.hasOwnProperty(y)) {
						o.w.smps.push(y);
						v[s] = y;
						c[y] = [];
						c[y].push(m);
						s++
					} else {
						c[y].push(m)
					}
				}
				k = this.getSamplesByAnnotationLevel(this.ratioGroupReference, this.ratioLevelReference);
				this.ratioReference = [];
				for (var t = 0; t < o.w.grps.length; t++) {
					var h = o.w.grps[t][0];
					var p = false;
					for (var q in c) {
						for (var r = 0; r < c[q].length; r++) {
							if (h == c[q][r]) {
								p = this.getObjectArray(c[q]);
								break
							}
						}
						if (p) {
							break
						}
					}
					for (var r = 0; r < k.length; r++) {
						if (p.hasOwnProperty(k[r])) {
							this.ratioReference.push(k[r]);
							break
						}
					}
				}
			}
		} else {
			if (this.ratioSampleReference) {
				var w = this.isGroupedData && this.graphType.match(/dotplot|boxplot/i);
				if (w) {
					this.isGroupedData = false;
					this.ratioReference = this.getSampleIndices(this.ratioSampleReference);
					this.isGroupedData = true
				} else {
					this.ratioReference = this.getSampleIndices(this.ratioSampleReference)
				}
			}
			if (this.ratioReference < 0) {
				this.ratioSampleReference = o.y.smps[0];
				this.ratioReference = 0
			}
			k = [this.ratioReference]
		}
		for (var t = 0; t < this.varIndices.length; t++) {
			var m = this.varIndices[t];
			if (!b.trans) {
				b.trans = []
			}
			if (!b.stdev) {
				b.stdev = []
			}
			if (!b.trans[m]) {
				b.trans[m] = []
			}
			if (!b.stdev[m]) {
				b.stdev[m] = []
			}
			for (var r = 0; r < b.data[m].length; r++) {
				var f;
				if (this.isGroupedData && this.ratioGroupReference && o.x.hasOwnProperty(this.ratioGroupReference)) {
					if (this.groupingFactors.length == 1) {
						f = o.w.mean[m][this.ratioReference]
					} else {
						f = o.w.mean[m][this.ratioReference[r]]
					}
				} else {
					f = b.data[m][this.ratioReference]
				}
				if (!isNaN(b.data[m][r]) && !isNaN(f) && f > 0) {
					var d = this.transformBase == 2 ? "ratio2" : "ratio10";
					var x = b.data[m][r] / f;
					var e = b.stdev[m][r];
					if (d == "ratio2") {
						b.trans[m][r] = Math.log(x) / Math.LN2;
						if (e && e > 0) {
							b.tstdev[m][r] = Math.log(e) / Math.LN2
						}
					} else {
						if (d == "ratio10") {
							b.trans[m][r] = Math.log(x) / Math.LN10;
							if (e && e > 0) {
								b.tstdev[m][r] = Math.log(e) / Math.LN10
							}
						}
					}
				}
			}
		}
	};
	this.transformRelative = function(q, n, m) {
		var c = this.isGroupedData && !this.graphType.match(/dotplot|boxplot/i) ? this.data.w : this.data.y;
		var k = this.isGroupedData ? false : true;
		var o;
		n = n ? n : this.transformAxis;
		if (n == "samples") {
			for (var g = 0; g < c.data[m].length; g++) {
				var b = [];
				for (var d = 0; d < this.varIndices.length; d++) {
					var h = this.varIndices[d];
					b.push(c.data[h][g])
				}
				if (q == "percentile") {
					o = this.range(b, k)
				} else {
					if (q == "zscore") {
						o = this.sumarizeErrorData(b, k)
					}
				}
				for (var d = 0; d < this.varIndices.length; d++) {
					var h = this.varIndices[d];
					if (!c.trans) {
						c.trans = []
					}
					if (!c.trans[h]) {
						c.trans[h] = []
					}
					if (!isNaN(c.data[h][g])) {
						if (q == "percentile") {
							c.trans[h][g] = this.percentile(o[0], o[1], c.data[h][g])
						} else {
							if (q == "zscore") {
								c.trans[h][g] = (c.data[h][g] - o[0]) / o[1]
							}
						}
					}
				}
			}
		} else {
			for (var g = 0; g < this.varIndices.length; g++) {
				var p = this.varIndices[g];
				if (!c.trans) {
					c.trans = []
				}
				if (!c.trans[p]) {
					c.trans[p] = []
				}
				var b = c.data[p];
				if (q == "percentile") {
					o = this.range(b, k)
				} else {
					if (q == "zscore") {
						o = this.sumarizeErrorData(b, k)
					}
				}
				for (var d = 0; d < b.length; d++) {
					if (!isNaN(c.data[p][d])) {
						if (q == "percentile") {
							c.trans[p][d] = this.percentile(o[0], o[1], c.data[p][d])
						} else {
							if (q == "zscore") {
								c.trans[p][d] = (c.data[p][d] - o[0]) / o[1]
							}
						}
					}
				}
			}
		}
	};
	this.groupSamples = function(I, v, F, b, o, f) {
		this.functionCaller = "groupSamples";
		if (this.isTransition()) {
			return
		}
		if (!this.isRawData) {
			return
		}
		var H = this.data;
		if (!this.isArray(I)) {
			I = [I]
		}
		if (!I || I.length < 1 || !H.x) {
			return this.ungroupSamples()
		}
		for (var D = 0; D < I.length; D++) {
			if (!I || !H.x[I[D]]) {
				return this.ungroupSamples()
			}
		}
		if (!this.isDOE && this.layoutComb && !H.l.group) {
			H.l.group = I;
			if (!o) {
				this.draw()
			}
			return
		}
		if (H.l && H.l.group) {
			H.l.group = I
		}
		if (this.isDOE && this.layoutComb && H.l.comp) {
			this.varIndices = [];
			for (var D = 0; D < H.l.comp.length; D++) {
				for (var B = 0; B < H.l.comp[D].length; B++) {
					this.varIndices.push(H.l.comp[D][B])
				}
			}
		}
		var e = {};
		var J = [];
		var C = 0;
		var l = this.getObjectArray(this.smpOverlays);
		var p = H.w && H.w.smps ? H.w.smps : false;
		if (!b) {
			this.resetIndices()
		}
		this.isGroupedData = true;
		this.groupingFactors = I;
		this.resetObject(true);
		this.hiddenGrps = [];
		for (var D = 0; D < this.smpIndices.length; D++) {
			var r = this.smpIndices[D];
			var w = [];
			var y = [];
			var L;
			var z;
			for (var B = 0; B < I.length; B++) {
				var E = I[B];
				L = H.x[E][r];
				if (!L) {
					L = "NA"
				}
				w.push(L);
				if (!l.hasOwnProperty(E)) {
					y.push(L)
				}
			}
			L = w.join(" - ");
			z = y.length > 0 ? y.join(" - ") : "";
			if (!e.hasOwnProperty(L)) {
				H.w.smps.push(L);
				H.w.labs.push(z);
				J[C] = L;
				e[L] = [];
				e[L].push(r);
				C++
			} else {
				e[L].push(r)
			}
		}
		if (J.length < 1) {
			H.w.smps = p;
			this.draw();
			return
		}
		for (var D = 0; D < J.length; D++) {
			var L = J[D];
			H.w.grps.push(e[L])
		}
		this.grpIndices = [];
		if (F) {
			for (var D = 0; D < F.length; D++) {
				this.grpIndices.push(F[D]);
				this.hiddenGrps.push(false)
			}
		} else {
			for (var D = 0; D < H.w.grps.length; D++) {
				this.grpIndices.push(D);
				this.hiddenGrps.push(false)
			}
		}
		for (var D = 0; D < this.varIndices.length; D++) {
			H.w.vars.push(H.y.vars[this.varIndices[D]])
		}
		var q = {};
		for (var L in H.x) {
			q[L] = this.isNumeric(H.x[L])
		}
		for (var D = 0; D < H.w.grps.length; D++) {
			for (var L in H.x) {
				if (!H.w.factors.hasOwnProperty(L)) {
					H.w.factors[L] = []
				}
				var n;
				if (q[L]) {
					n = [];
					for (var B = 0; B < H.w.grps[D].length; B++) {
						var K = H.x[L][H.w.grps[D][B]];
						if (!isNaN(K)) {
							n.push(K)
						}
					}
					H.w.factors[L].push(this.mean(n))
				} else {
					n = {};
					for (var B = 0; B < H.w.grps[D].length; B++) {
						var K = H.x[L][H.w.grps[D][B]];
						if (K != null && K != "") {
							n[H.x[L][H.w.grps[D][B]]] = true
						}
					}
					var c = this.getKeys(n);
					H.w.factors[L].push(c.join(" + "))
				}
			}
		}
		var q = [];
		if (v) {
			if (this.isArray(v)) {
				q = v
			} else {
				q.push(v)
			}
		} else {
			v = this.graphType == "Boxplot" ? "iqr" : this.graphType.match(/Stacked/i) ? "sum" : this.summaryType ? this.summaryType : "mean";
			q.push(v)
		}
		for (var u = 0; u < q.length; u++) {
			var G = [];
			var h = q[u];
			if (this.isTransformedData) {
				a = H.y.trans
			} else {
				if (this.isRawData) {
					a = H.y.data
				} else {
					if (this.summaryType == "median" || this.summaryType == "iqr") {
						a = H.y.median
					} else {
						if (this.summaryType == "mean") {
							a = H.y.mean
						} else {
							if (this.summaryType == "cor") {
								a = H.y.cor
							} else {
								if (this.summaryType == "sum") {
									a = H.y.sum
								} else {
									if (this.summaryType == "max") {
										a = H.y.max
									} else {
										if (this.summaryType == "min") {
											a = H.y.min
										} else {
											a = H.y[this.summaryType]
										}
									}
								}
							}
						}
					}
				}
			}
			for (var D = 0; D < this.varIndices.length; D++) {
				var r = this.varIndices[D];
				G[r] = [];
				for (var B = 0; B < H.w.grps.length; B++) {
					G[r][B] = [];
					for (var A = 0; A < H.w.grps[B].length; A++) {
						var g = H.w.grps[B][A];
						G[r][B].push(a[r][g])
					}
				}
			}
			this.summarize(h, G)
		}
		if (this.colorBy && this.isInArray(this.colorBy, this.groupingFactors)) {
			var x = this.groupingFactors.indexOf(this.colorBy);
			for (var D = 0; D < H.w.smps.length; D++) {
				var y = H.w.smps[D].split(" - ");
				var m = y.splice(x).join(" - ");
				H.w.smps[D] = y
			}
		}
		this.updateMetaData("w");
		this.setOriginalIndices(false, false, false, !this.layoutComb);
		if (!f) {
			this.xAxisValues = [];
			this.xAxis2Values = [];
			this.yAxisValues = [];
			this.zAxisValues = [];
			if (!this.layoutComb || !this.layoutAdjust) {
				if (typeof(this.setAxes) == "function") {
					this.setAxes()
				}
			}
		}
		if (!o) {
			this.draw()
		}
	};
	this.ungroupSamples = function(f, c, b) {
		this.functionCaller = "ungroupSamples";
		if (this.isTransition()) {
			return
		}
		if (!this.isGroupedData) {
			return
		}
		this.isGroupedData = false;
		var e = this.data;
		if (e.l) {
			delete(e.l.group)
		}
		if (e.w && !b) {
			delete(e.w)
		}
		this.groupingFactors = [];
		this.grpIndices = [];
		this.hiddenGrps = [];
		this.updateMetaData("w");
		if (!c) {
			this.setOriginalIndices(false, false, false, true)
		}
		if (!f) {
			this.draw()
		}
		return
	};
	this.regroupSamples = function() {
		this.isGroupedData = false;
		this.groupSamples(this.groupingFactors, false, false, false, true)
	};
	this.pivot = function(e, k) {
		this.functionCaller = "pivot";
		if (this.isTransition()) {
			return
		}
		var g = this.rebuildDataTableFilter();
		var f = {
			y: {
				data: [],
				vars: [],
				smps: []
			}
		};
		var h = e.shift();
		for (var d = 0; d < e.length; d++) {
			f.y.vars.push(e[d][0]);
			var b = [];
			for (var c = 1; c < h.length; c++) {
				b.push(e[d][c])
			}
			f.y.data.push(b)
		}
		h.shift();
		f.y.smps = h;
		this.initializeData(f);
		this.resetObject();
		if (!k) {
			this.draw()
		}
		this.rebuildDataTableFilter(g)
	};
	this.pivotXX = function(h, b, g) {
		var e = [];
		var f = this.data;
		for (var c = 0; c < f.y.smps.length; c++) {
			e.push([f.x[h][c], f.x[b][c], f.y.data[0][c]])
		}
		return this.pivot(this.pivotMatrix(e, 0, 1, 2), g)
	};
	this.pivotXY = function(k, b, h) {
		var f = [];
		var e;
		var g = this.data;
		if (g.x.hasOwnProperty(k)) {
			for (var c = 0; c < g.y.smps.length; c++) {
				f.push([g.x[k][c], g.y.data[0][c], g.y.data[1][c]])
			}
			if (g.y.vars[0] == b) {
				e = this.pivotMatrix(f, 0, 1, 2)
			} else {
				if (g.y.vars[1] == b) {
					e = this.pivotMatrix(f, 0, 2, 1)
				}
			}
		} else {
			if (g.x.hasOwnProperty(b)) {
				for (var c = 0; c < g.y.smps.length; c++) {
					f.push([g.x[b][c], g.y.data[0][c], g.y.data[1][c]])
				}
				if (g.y.vars[0] == k) {
					e = this.pivotMatrix(f, 1, 0, 2)
				} else {
					if (g.y.vars[1] == k) {
						e = this.pivotMatrix(f, 2, 0, 1)
					}
				}
			}
		}
		return this.pivot(e, h)
	};
	this.pivotYY = function(g, b, f) {
		var e;
		g = this.getVariableIndices(g);
		b = this.getVariableIndices(b);
		var d = [];
		for (var c = 0; c < this.data.y.vars.length; c++) {
			if (c != g && c != b) {
				e = c;
				break
			}
		}
		return this.pivot(this.pivotMatrix(this.transposeMatrix(this.data.y.data), g, b, e), f)
	};
	this.transpose = function(D, f) {
		this.functionCaller = "transpose";
		if (this.isTransition()) {
			return
		}
		var u = this.rebuildDataTableFilter();
		var B = this.data;
		var w = this.meta.data;
		if (D) {
			return this.transposeMatrix(D)
		} else {
			this.ungroupSamples(true);
			this.transform("reset", false, false, true);
			if (B.l) {
				delete(B.l)
			}
			if (B.d) {
				if (B.d.line) {
					delete(B.d.line)
				}
				if (B.d.marker) {
					for (var A = 0; A < B.d.marker.length; A++) {
						var t = B.d.marker[A].sample;
						var o = B.d.marker[A].variable;
						B.d.marker[A].variable = t;
						B.d.marker[A].sample = o
					}
				}
			}
			if (B.a) {
				delete(B.a)
			}
			if (B.t) {
				var o = B.t.vars;
				var t = B.t.smps;
				if (o) {
					B.t.smps = o
				}
				if (t) {
					B.t.vars = t
				}
			}
			var e = ["varOverlays", "varOverlayInfo", "varOverlayProperties", "varOverlaysStrLength", "varOverlaysThicknessBottom", "varOverlaysThicknessTop"];
			var g = ["smpOverlays", "smpOverlayInfo", "smpOverlayProperties", "smpOverlaysStrLength", "smpOverlaysThicknessBottom", "smpOverlaysThicknessTop"];
			for (var A = 0; A < e.length; A++) {
				if (this[e[A]] || this[g[A]]) {
					var n = this[e[A]];
					var q = this[g[A]];
					this[e[A]] = q;
					this[g[A]] = n
				}
			}
			var l = B.x;
			var k = B.z;
			if (l) {
				B.z = l
			} else {
				delete(B.z)
			}
			if (k) {
				B.x = k
			} else {
				delete(B.x)
			}
			var r = w.x;
			var c = w.z;
			w.x = c;
			w.z = r;
			var h = w.y.maxSmpChr;
			var b = w.y.maxSmpLen;
			var E = w.y.maxSmpStr;
			w.y.maxSmpChr = w.y.maxVarChr;
			w.y.maxSmpLen = w.y.maxVarLen;
			w.y.maxSmpStr = w.y.maxVarStr;
			w.y.maxVarChr = h;
			w.y.maxVarLen = b;
			w.y.maxVarStr = E;
			var t = B.y.smps;
			B.y.smps = B.y.vars;
			B.y.vars = t;
			var C = B.y.data;
			B.y.data = [];
			for (var A = 0; A < B.y.vars.length; A++) {
				B.y.data[A] = [];
				for (var y = 0; y < B.y.smps.length; y++) {
					B.y.data[A][y] = C[y][A]
				}
			}
			this.initializeData(this.data);
			this.resetObject();
			this.setOriginalIndices(false, false, false, true);
			if (!f) {
				this.draw()
			}
			this.rebuildDataTableFilter(u)
		}
	};
	this.chordifyData = function() {
		var q = {};
		var v = [];
		var M = [];
		var H = [];
		var y = [];
		for (var E = 0; E < this.varIndices.length; E++) {
			var m = this.varIndices[E];
			var K = this.data.y.vars[m];
			v.push(K);
			q[K] = {};
			for (var D = 0; D < this.smpIndices.length; D++) {
				var J = this.smpIndices[D];
				var I = this.data.y.smps[J];
				v.push(I);
				q[K][I] = this.data.y.data[m][J]
			}
		}
		v = this.unique(v);
		var A = v.length;
		var l = 0;
		for (var E = 0; E < A; E++) {
			M[E] = [];
			y.push(this.seq(0, A - 1, 1));
			var e = 0;
			for (var D = 0; D < A; D++) {
				M[E][D] = 0;
				if (q[v[E]] && q[v[E]][v[D]]) {
					M[E][D] = q[v[E]][v[D]]
				}
				e += M[E][D]
			}
			H.push(e);
			l += e
		}
		for (var E = 0; E < y.length; E++) {
			y[E].sort(function(d, c) {
				return M[E][c] - M[E][d]
			})
		}
		if (this.circularArc > 360) {
			this.circularArc = 360
		} else {
			if (this.circularArc < 90) {
				this.circularArc = 90
			}
		}
		var x = this.circularArc * (Math.PI * 2) / 360;
		var p = (x - this.radians(this.arcSegmentsSeparation) * (this.circularArc == 360 ? A : A - 1)) / l;
		var k = [];
		var h = [];
		var B = 0;
		for (var E = 0; E < A; E++) {
			var b = B;
			for (var D = 0; D < A; D++) {
				var G = y[E][D];
				var L = M[E][G];
				var C = B;
				var O = B += L * p;
				k[G * A + E] = {
					idx: E,
					sid: G,
					start: C,
					end: O,
					value: L,
					color: this.colors[G % this.colors.length]
				}
			}
			h[E] = {
				name: v[E],
				idx: E,
				start: b,
				end: B,
				value: H[E],
				color: this.colors[E % this.colors.length]
			};
			B += this.radians(this.arcSegmentsSeparation)
		}
		var N = [];
		for (var E = 0; E < A; E++) {
			for (var D = E; D < A; D++) {
				var f = k[D * A + E];
				var F = k[E * A + D];
				if (f.value || F.value) {
					N.push({
						source: f,
						target: F
					})
				}
			}
		}
		return {
			chords: N,
			segments: h,
			total: l,
			unit: p
		}
	};
	this.summarizeOncoprint = function() {
		if (this.isOncoprint && !this.isOncoprintSumarized) {
			var f = {};
			var g = [];
			var n = [];
			var c = [];
			var k = [];
			var l = this.data;
			for (var e = 0; e < l.y.vars.length; e++) {
				g[e] = 0
			}
			for (var e = 0; e < l.y.smps.length; e++) {
				n[e] = 0;
				c[e] = 0;
				k[e] = 0
			}
			for (var e = 0; e < l.y.vars.length; e++) {
				for (var d = 0; d < l.y.smps.length; d++) {
					var h, b;
					if (this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/)) {
						h = this.getDataAtPos(e, d, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue);
						b = this.getDataAtPos(e, d, false, false, false, false, true)
					} else {
						h = this.getDataAtPos(e, d, false, this.xAxisTransform, this.minData, this.maxData);
						b = this.getDataAtPos(e, d, false, false, false, false, true)
					}
					if (h >= this.oncoprintAmplification) {
						f[e] = true;
						g[e]++;
						c[d]++
					} else {
						if (h <= this.oncoprintDeletion) {
							f[e] = true;
							g[e]++;
							k[d]++
						}
					}
					if (b && ((isNaN(b) && !b.toString().match(/^no$|^-$|^neg$/i)) || b > 0)) {
						f[e] = true;
						g[e]++;
						n[d]++
					}
				}
			}
			if (!l.z) {
				l.z = {}
			}
			l.z.Altered = [];
			l.z.Alterations = [];
			for (var e = 0; e < l.y.vars.length; e++) {
				l.z.Alterations.push(g[e]);
				if (f[e]) {
					l.z.Altered[e] = "True"
				} else {
					l.z.Altered[e] = "False"
				}
			}
			if (!l.x) {
				l.x = {}
			}
			l.x.Amplified = [];
			l.x.Deleted = [];
			l.x.Altered = [];
			l.x.Mutated = [];
			for (var e = 0; e < l.y.smps.length; e++) {
				l.x.Amplified.push(c[e]);
				l.x.Deleted.push(k[e]);
				l.x.Altered.push(n[e]);
				l.x.Mutated.push(c[e] + k[e] + n[e])
			}
			this.smpOverlayProperties.Altered = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Amplified = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Deleted = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Mutated = {
				type: "Bar",
				position: "right",
				thickness: 30
			};
			this.smpOverlays.push("Amplified");
			this.smpOverlays.push("Deleted");
			this.smpOverlays.push("Altered");
			this.smpOverlays.push("Mutated");
			this.isOncoprintSumarized = true;
			this.sortIndices("onc", "desc");
			this.updateMetaData("x", "Amplified", false, true);
			this.updateMetaData("x", "Deleted", false, true);
			this.updateMetaData("x", "Altered", false, true);
			this.updateMetaData("x", "Mutated", false, true);
			this.updateMetaData("z", "Altered", false, true);
			this.updateMetaData("z", "Alterations", false, true)
		}
	};
	this.getDataAtPos = function(g, f, k, d, e, l, h) {
		var c = Number.NaN;
		var b = this.isGroupedData ? this.data.w : this.data.y;
		if (h) {
			c = this.data.y[this.isOncoprint][g][f]
		} else {
			if (this.isGroupedData || !this.isRawData) {
				if (this.isTransformedData) {
					if (!k) {
						c = b.trans[g][f]
					} else {
						if (k == "stdev") {
							c = b.tstdev[g][f]
						} else {
							if (b.hasOwnProperty(k)) {
								c = b[k][g][f]
							}
						}
					}
				} else {
					k = k ? k : this.summaryType;
					if (b.hasOwnProperty(k)) {
						c = b[k][g][f]
					} else {
						c = 0
					}
				}
			} else {
				if (k) {
					if (b[k] && b[k][g]) {
						c = b[k][g][f]
					} else {
						if (k == "sum" && !this.isGroupedData) {
							c = b.data[g][f]
						}
					}
				} else {
					if (this.isTransformedData) {
						c = b.trans[g][f]
					} else {
						c = b.data[g][f]
					}
				}
			}
		}
		if (d) {
			if (!isNaN(c)) {
				if (d == "log2") {
					c = Math.log(c) / Math.LN2
				} else {
					if (d == "log10") {
						c = Math.log(c) / Math.LN10
					} else {
						if (d == "exp2") {
							c = Math.pow(2, c)
						} else {
							if (d == "exp10") {
								c = Math.pow(10, c)
							} else {
								if (d == "percentile") {
									c = this.percentile(e, l, c)
								} else {
									if (d == "ceil") {
										c = Math.min(l, c)
									} else {
										if (d == "floor") {
											c = Math.max(e, c)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return c
	};
	this.getDataForSmpAtPosition = function(c) {
		var b = [];
		for (var d = 0; d < this.data.y.data.length; d++) {
			b.push(this.data.y.data[d][c])
		}
		return b
	};
	this.getDataForSmpGrpAtIndex = function(c, h, d) {
		var b = [];
		if (!h) {
			h = this.varIndices
		}
		if (this.isGroupedData || !this.isRawData) {
			var k = this.isGroupedData ? this.data.w : this.data.y;
			if (this.isTransformedData) {
				b.push(k.trans[0][c])
			} else {
				d = this.summaryType;
				if (k.hasOwnProperty(d)) {
					for (var e = 0; e < h.length; e++) {
						var f = h[e];
						b.push(k[d][f][c])
					}
				}
			}
		} else {
			var g = d ? this.data.y[d] : this.data.y.data;
			if (this.isTransformedData) {
				for (var e = 0; e < h.length; e++) {
					var f = h[e];
					b.push(this.data.y.trans[f][c])
				}
			} else {
				for (var e = 0; e < h.length; e++) {
					var f = h[e];
					b.push(g[f][c])
				}
			}
		}
		return b
	};
	this.getDataForVariableAtIndex = function(c) {
		var b = [];
		if (this.isTransformedData) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var e = this.smpIndices[d];
				b.push(this.data.y.trans[c][e])
			}
		} else {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var e = this.smpIndices[d];
				b.push(this.data.y.data[c][e])
			}
		}
		return b
	};
	this.getMetaDataForVariableAtIndex = function(b) {
		var d = {};
		if (this.data.z) {
			for (var c in this.data.z) {
				d[c] = this.data.z[c][b]
			}
		}
		d[name] = this.data.y.vars[b];
		return d
	};
	this.getMetaDataForSampleAtIndex = function(b) {
		if (this.isGroupedData) {
			return this.getMetaDataForGrpAtIndex(b)
		} else {
			return this.getMetaDataForSmpAtIndex(b)
		}
	};
	this.getMetaDataForSmpAtIndex = function(b) {
		var d = {};
		if (this.data.x) {
			for (var c in this.data.x) {
				d[c] = this.data.x[c][b]
			}
		}
		d[name] = this.data.y.vars[b];
		return d
	};
	this.getMetaDataForGrpAtIndex = function(b) {
		var e = [];
		for (var c = 0; c < this.data.w.grps[b].length; c++) {
			var d = this.data.w.grps[b][c];
			e.push(this.getMetaDataForSmpAtIndex[d])
		}
		return e
	};
	this.setOriginalIndices = function(g, b, d, f) {
		var e = this.layoutComb && this.layoutParams ? this.layoutParams[g || 0] : this;
		if (!b) {
			b = e.varIndices
		}
		if (!d) {
			d = this.isGroupedData ? e.grpIndices : e.smpIndices
		}
		if (f || !e.startingVarIndices || e.startingVarIndices.length == 0) {
			e.startingVarIndices = this.cloneObject(b)
		}
		if (f || !e.startingSmpIndices || e.startingSmpIndices.length == 0) {
			e.startingSmpIndices = this.cloneObject(d)
		}
	};
	this.getVocabulary = function(b) {
		return CanvasXpress.vocabulary.byId[b]
	};
	this.updateVocabulary = function(b) {
		for (var c = 0; c < b.length; c++) {
			if (!CanvasXpress.vocabulary.byStr.hasOwnProperty(b[c])) {
				CanvasXpress.vocabulary.byStr[b[c]] = CanvasXpress.vocabulary.n++;
				CanvasXpress.vocabulary.byId.push(b[c])
			}
		}
	};
	this.codeData = function() {
		return;
		if (this.data.x) {
			var b = this.meta.data.x;
			for (var e in this.data.x) {
				if (b[e].type == "String") {
					for (var d = 0; d < this.data.x[e].length; d++) {
						if (this.data.x[e][d]) {
							var c = CanvasXpress.vocabulary.byStr[this.data.x[e][d]];
							if (c != null) {
								this.data.x[e][d] = c
							}
						}
					}
				}
			}
		}
		if (this.data.z) {
			var b = this.meta.data.z;
			for (var e in this.data.z) {
				if (b[e].type == "String") {
					for (var d = 0; d < this.data.z[e].length; d++) {
						if (this.data.z[e][d]) {
							var c = CanvasXpress.vocabulary.byStr[this.data.z[e][d]];
							if (c != null) {
								this.data.z[e][d] = c
							}
						}
					}
				}
			}
		}
	};
	this.validatePropertyValues = function(e) {
		var m = ["color", "shape", "size", "pattern", "outline", "motion", "ellipse"];
		for (var f = 0; f < m.length; f++) {
			var c = this[m[f] + "By"];
			var h = this[c + "Data"];
			if (c) {
				if (this.isMultidimensionalData) {
					if (h && !this.data.y[h]) {
						this[m[f] + "By"] = false;
						this[c + "Data"] = false
					}
				} else {
					if (this.data.x && !this.data.x.hasOwnProperty(c) && this.data.z && !this.data.z.hasOwnProperty(c)) {
						if (c == "variable" || (this.graphType.match(/Boxplot|Dotplot/))) {
							continue
						} else {
							if (this.getSampleIndices(c) || this.getSampleIndices(c, true)) {
								continue
							} else {
								this[m[f] + "By"] = false
							}
						}
					}
				}
			}
		}
		if (this.treemapBy.length > 0) {
			var b = [];
			var k = [];
			for (var f = 0; f < this.treemapBy.length; f++) {
				if (this.treemapBy[f] == "sample") {
					k.push("sample")
				} else {
					if (!this.data.x || !this.data.x.hasOwnProperty(this.treemapBy[f])) {
						k.push("sample")
					} else {
						if (this.data.x && this.data.x.hasOwnProperty(this.treemapBy[f])) {
							b.push(this.treemapBy[f])
						}
					}
				}
			}
			if (k.length > 0) {}
			this.treemapBy = b
		}
		var g = this.graphType.match(/Boxplot|Dotplot|Scatter/) || this.graphType == "Tree";
		if (this.shapeBy && !this.isMultidimensionalData && !g) {
			this.shapeBy = false
		} else {
			if (this.shapeBy && this.groupingFactors.length > 1 && !g) {
				this.shapeBy = "variable"
			} else {
				if (this.shapeBy && this.groupingFactors.length == 1 && this.shapeBy != this.groupingFactors[0] && !g) {
					this.shapeBy = "variable"
				}
			}
		}
		if (this.sizeBy && !this.isMultidimensionalData && !g) {
			this.sizeBy = false
		} else {
			if (this.sizeBy && this.groupingFactors.length > 1 && !g) {
				this.sizeBy = "variable"
			} else {
				if (this.sizeBy && this.groupingFactors.length == 1 && this.sizeBy != this.groupingFactors[0] && !g) {
					this.sizeBy = "variable"
				}
			}
		}
		if (this.colorBy && this.graphType == "Heatmap" && !this.isMultidimensionalData) {
			this.colorBy = false
		} else {
			if (this.colorBy && this.groupingFactors.length > 1 && !this.graphType.match(/Boxplot|Dotplot|Scatter|Stacked|Treemap/)) {
				this.colorBy = "variable"
			} else {
				if (this.colorBy && this.groupingFactors.length == 1 && this.colorBy != this.groupingFactors[0] && !this.graphType.match(/Boxplot|Dotplot|Scatter|Stacked|Treemap/)) {
					this.colorBy = "variable"
				}
			}
		}
		if ((this.shapeBy || this.sizeBy || this.patternBy || this.outlineBy) && !this.colorBy && !this.isMultidimensionalData && !this.graphType == "Heatmap") {
			this.colorBy = "variable"
		} else {
			if (!this.shapeBy && !this.sizeBy && !this.patternBy && this.colorBy == "variable") {
				this.colorBy = false
			}
		}
		if (this.shapeBy == "variable" && !this.colorBy && !this.graphType.match(/Scatter/)) {
			this.colorBy = "variable"
		}
		if (this.sizeBy == "variable" && !this.colorBy && !this.graphType.match(/Scatter/)) {
			this.colorBy = "variable"
		}
		if (this.patternBy == "variable" && !this.colorBy && !this.graphType.match(/Scatter/)) {
			this.colorBy = "variable"
		}
		if (e) {
			this.setLegends()
		}
	};
	this.getPropertyValueBin = function(d, f, c, k, e) {
		var g = Math.min(Math.floor((Math.max(f, d.min) - d.min) / ((d.max - d.min) / d.vals.length)), d.vals.length - 1);
		return c ? g : parseInt(this[k[e]][g])
	};
	this.getPropertyValueSize = function(b, d, c) {
		var e = b.vals.length - 1;
		return parseFloat((((d - b.min) / (b.max - b.min)) * (this[c][e] - this[c][0]))) + parseInt(this[c][0])
	};
	this.getMetadataValueVocabulary = function(c, d, e) {
		if (d == "x" && this.data.x.hasOwnProperty(e)) {
			var b = this.meta.data.x[e];
			if (b.type == "String") {
				return CanvasXpress.vocabulary.byStr[this.data.x[e][c]]
			} else {
				return this.data.x[e][c]
			}
		} else {
			if (d == "z" && this.data.z.hasOwnProperty(e)) {
				var b = this.meta.data.z[e];
				if (b.type == "String") {
					return CanvasXpress.vocabulary.byStr[this.data.z[e][c]]
				} else {
					return this.data.z[e][c]
				}
			}
		}
	};
	this.getMetadataValue = function(c, d, e) {
		if (this.useVocabulary) {
			return this.getMetadataValueVocabulary(c, d, e)
		}
		if (d == "x" && this.data.x.hasOwnProperty(e)) {
			var b = this.meta.data.x[e];
			if (b.type == "String") {
				return this.data.x[e][c]
			} else {
				return this.data.x[e][c]
			}
		} else {
			if (d == "z" && this.data.z.hasOwnProperty(e)) {
				var b = this.meta.data.z[e];
				if (b.type == "String") {
					return this.data.z[e][c]
				} else {
					return this.data.z[e][c]
				}
			}
		}
	};
	this.getPropertyValueVocabulary = function(o, r, z) {
		var v = this;
		var k, f, B, n;
		var d = this[z];
		var x = this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData));
		var u = this.groupingFactors && this.groupingFactors.length == 1;
		var e = this.data;
		var y = this.meta.data;
		var s = {
			colorVarDendrogramBy: "colors",
			colorSmpDendrogramBy: "colors",
			colorBy: "colors",
			outlineBy: "colors",
			outlineByData: "colors",
			shapeBy: "shapes",
			shapeByData: "shapes",
			sizeBy: "sizes",
			sizeByData: "sizes",
			patternBy: "patterns",
			patternByData: "patterns"
		};
		var A = function() {
			var g = {};
			var p = 0;
			for (var m = 0; m < e.w.grps[r].length; m++) {
				var h = y.x[d].type;
				var c = h == "String" ? CanvasXpress.vocabulary.byStr[e.x[d][e.w.grps[r][m]]] : e.x[d][e.w.grps[r][m]];
				if (!g.hasOwnProperty(c)) {
					g[c] = true;
					p++
				}
				if (p > 1) {
					return false
				}
			}
			return true
		};
		var w = function() {
			if (!v.patternBy) {
				if (o > v.colors.length - 1) {
					return v[s[z]][Math.floor(o / v.colors.length)]
				} else {
					return v[s[z]][0]
				}
			} else {
				return v[s[z]][0]
			}
		};
		var b = z ? this[s[z]].length : false;
		if (o != null && r != null && d && e.y.hasOwnProperty(d)) {
			k = e.y[d][o][r];
			f = y[d];
			B = f.type
		} else {
			if (r != null && d && e.x && e.x.hasOwnProperty(d)) {
				f = y.x[d];
				if (x || !this.isGroupedData) {
					B = f.type;
					k = this.isGroupedData ? e.w.smps[r] : B == "String" ? CanvasXpress.vocabulary.byStr[e.x[d][r]] : e.x[d][r];
					if (f[z] && f[z].hasOwnProperty(k)) {
						return f[z][k]
					} else {
						if (z == "colorSmpDendrogramBy" && f.colorBy && f.colorBy.hasOwnProperty(k)) {
							return f.colorBy[k]
						}
					}
				} else {
					if (u && (this.groupingFactors[0] == d || A())) {
						B = f.type;
						k = B == "String" ? CanvasXpress.vocabulary.byStr[e.x[d][e.w.grps[r][0]]] : e.x[d][e.w.grps[r][0]];
						if (z.match(/color|patternBy/)) {
							if (f[z] && f[z].hasOwnProperty(k)) {
								return f[z][k]
							} else {
								if (f[s[z]]) {
									return f[s[z]][f.order[k] % b]
								} else {
									return this[s[z]][f.order[k] % b]
								}
							}
						} else {
							return f[s[z]] ? f[s[z]][0] : z.match(/color/) ? this[s[z]][0] : z == "patternBy" ? w() : this[s[z]][0]
						}
					} else {
						return o != null && z.match(/color/) ? this[s[z]][o % b] : z == "patternBy" ? w() : this[s[z]][0]
					}
				}
			} else {
				if (o != null && d && e.z && e.z.hasOwnProperty(d)) {
					f = y.z[d];
					B = f.type;
					k = B == "String" ? CanvasXpress.vocabulary.byStr[e.z[d][o]] : e.z[d][o];
					if (f[z] && f[z].hasOwnProperty(k)) {
						return f[z][k]
					} else {
						if (z == "colorVarDendrogramBy" && f.colorBy && f.colorBy.hasOwnProperty(k)) {
							return f.colorBy[k]
						}
					}
				} else {
					if (o != null && r != null && z && ((this.isGroupedData && y.w.smps.hasOwnProperty(z)) || (!this.isGroupedData && y.y.range.hasOwnProperty(z)))) {
						k = e.y.data[o][r];
						f = y.y.range[z];
						B = y.y.type
					} else {
						if (o != null && !this.isGroupedData && y.y.range.hasOwnProperty(d)) {
							f = y.y.range[d];
							B = f.type;
							k = r != null ? e.y.data[o][r] : e.y.data[o][this.getSampleIndices(d)];
							if (y.modified && y.modified.z && y.modified.z[d]) {
								return this[s[z]][k % b]
							} else {
								if (!f.colorBrew) {
									f.colorBrew = this.getColorBrew(false, f.min, f.max)
								}
							}
						} else {
							if (o != null) {
								if (d) {
									return this[s[z]][o % b]
								} else {
									return !d && z.match(/color/) ? this[s[z]][o % b] : z == "patternBy" ? w() : this[s[z]][0]
								}
							} else {
								return this[s[z]][0]
							}
						}
					}
				}
			}
		}
		if (B == "Numeric") {
			if (z.match(/color|outlineBy/)) {
				return !isNaN(k) ? this.getColorForValue(f.colorBrew, Number(k)) : this.missingDataColor
			} else {
				if (z.match(/shapeBy/)) {
					if (!isNaN(k)) {
						return "pie" + this.getPropertyValueBin(f, k, true, s, z)
					} else {
						return "sphere"
					}
				} else {
					if (z.match(/sizeBy/)) {
						if (!isNaN(k)) {
							return this.sizeByContinuous ? this.getPropertyValueSize(f, k, s[z]) : this.getPropertyValueBin(f, k, false, s, z)
						} else {
							return this[s[z]][0]
						}
					} else {
						if (z.match(/patternBy/)) {
							if (!isNaN(k)) {
								return this.getPropertyValueBin(f, k, false, s, z)
							} else {
								return "closed"
							}
						}
					}
				}
			}
		} else {
			if (B == "String") {
				if (f[s[z]]) {
					return z == "sizeBy" ? parseInt(f[s[z]][f.order[k] % b]) : f[s[z]][f.order[k] % b]
				} else {
					return z == "sizeBy" ? parseInt(this[s[z]][f.order[k] % b]) : this[s[z]][f.order[k] % b]
				}
			}
		}
	};
	this.getPropertyValue = function(o, r, z) {
		if (this.useVocabulary) {
			return this.getPropertyValueVocabulary(o, r, z)
		}
		var v = this;
		var k, f, B, n;
		var d = this[z];
		var x = this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData));
		var u = this.groupingFactors && this.groupingFactors.length == 1;
		var e = this.data;
		var y = this.meta.data;
		var s = {
			colorVarDendrogramBy: "colors",
			colorSmpDendrogramBy: "colors",
			colorBy: "colors",
			outlineBy: "colors",
			outlineByData: "colors",
			shapeBy: "shapes",
			shapeByData: "shapes",
			sizeBy: "sizes",
			sizeByData: "sizes",
			patternBy: "patterns",
			patternByData: "patterns"
		};
		var A = function() {
			var g = {};
			var p = 0;
			for (var m = 0; m < e.w.grps[r].length; m++) {
				var h = y.x[d].type;
				var c = e.x[d][e.w.grps[r][m]];
				if (!g.hasOwnProperty(c)) {
					g[c] = true;
					p++
				}
				if (p > 1) {
					return false
				}
			}
			return true
		};
		var w = function() {
			if (!v.patternBy) {
				if (o > v.colors.length - 1) {
					return v[s[z]][Math.floor(o / v.colors.length)]
				} else {
					return v[s[z]][0]
				}
			} else {
				return v[s[z]][0]
			}
		};
		var b = z ? this[s[z]].length : false;
		if (o != null && r != null && d && e.y.hasOwnProperty(d)) {
			k = e.y[d][o][r];
			f = y[d];
			B = f.type
		} else {
			if (r != null && d && e.x && e.x.hasOwnProperty(d)) {
				f = y.x[d];
				if (x || !this.isGroupedData) {
					B = f.type;
					k = this.isGroupedData ? e.w.smps[r] : e.x[d][r];
					if (f[z] && f[z].hasOwnProperty(k)) {
						return f[z][k]
					} else {
						if (z == "colorSmpDendrogramBy" && f.colorBy && f.colorBy.hasOwnProperty(k)) {
							return f.colorBy[k]
						}
					}
				} else {
					if (u && (this.groupingFactors[0] == d || A())) {
						B = f.type;
						k = e.x[d][e.w.grps[r][0]];
						if (z.match(/color|patternBy/)) {
							if (f[z] && f[z].hasOwnProperty(k)) {
								return f[z][k]
							} else {
								if (f[s[z]]) {
									return f[s[z]][f.order[k] % b]
								} else {
									return this[s[z]][f.order[k] % b]
								}
							}
						} else {
							return f[s[z]] ? f[s[z]][0] : z.match(/color/) ? this[s[z]][0] : z == "patternBy" ? w() : this[s[z]][0]
						}
					} else {
						return o != null && z.match(/color/) ? this[s[z]][o % b] : z == "patternBy" ? w() : this[s[z]][0]
					}
				}
			} else {
				if (o != null && d && e.z && e.z.hasOwnProperty(d)) {
					f = y.z[d];
					B = f.type;
					k = e.z[d][o];
					if (f[z] && f[z].hasOwnProperty(k)) {
						return f[z][k]
					} else {
						if (z == "colorVarDendrogramBy" && f.colorBy && f.colorBy.hasOwnProperty(k)) {
							return f.colorBy[k]
						}
					}
				} else {
					if (o != null && r != null && z && ((this.isGroupedData && y.w.smps.hasOwnProperty(z)) || (!this.isGroupedData && y.y.range.hasOwnProperty(z)))) {
						k = e.y.data[o][r];
						f = y.y.range[z];
						B = y.y.type
					} else {
						if (o != null && !this.isGroupedData && y.y.range.hasOwnProperty(d)) {
							f = y.y.range[d];
							B = f.type;
							k = r != null ? e.y.data[o][r] : e.y.data[o][this.getSampleIndices(d)];
							if (y.modified && y.modified.z && y.modified.z[d]) {
								return this[s[z]][k % b]
							} else {
								if (!f.colorBrew) {
									f.colorBrew = this.getColorBrew(false, f.min, f.max)
								}
							}
						} else {
							if (o != null) {
								if (d) {
									return this[s[z]][o % b]
								} else {
									return !d && z.match(/color/) ? this[s[z]][o % b] : z == "patternBy" ? w() : this[s[z]][0]
								}
							} else {
								return this[s[z]][0]
							}
						}
					}
				}
			}
		}
		if (B == "Numeric") {
			if (z.match(/color|outlineBy/)) {
				return !isNaN(k) ? this.getColorForValue(f.colorBrew, Number(k)) : this.missingDataColor
			} else {
				if (z.match(/shapeBy/)) {
					if (!isNaN(k)) {
						return "pie" + this.getPropertyValueBin(f, k, true, s, z)
					} else {
						return "sphere"
					}
				} else {
					if (z.match(/sizeBy/)) {
						if (!isNaN(k)) {
							return this.sizeByContinuous ? this.getPropertyValueSize(f, k, s[z]) : this.getPropertyValueBin(f, k, false, s, z)
						} else {
							return this[s[z]][0]
						}
					} else {
						if (z.match(/patternBy/)) {
							if (!isNaN(k)) {
								return this.getPropertyValueBin(f, k, false, s, z)
							} else {
								return "closed"
							}
						}
					}
				}
			}
		} else {
			if (B == "String") {
				if (f[s[z]]) {
					return z == "sizeBy" ? parseInt(f[s[z]][f.order[k] % b]) : f[s[z]][f.order[k] % b]
				} else {
					return z == "sizeBy" ? parseInt(this[s[z]][f.order[k] % b]) : this[s[z]][f.order[k] % b]
				}
			}
		}
	};
	this.resetMetaData = function() {
		delete(this.meta.data);
		this.setMetaData()
	};
	this.getMetadata = function(c, b) {
		var d = this.meta.data;
		if (b) {
			var e = c == "x" ? "z" : "x";
			if (c && d[c] && d[c].hasOwnProperty(b)) {
				return d[c][b]
			} else {
				if (d[e] && d[e].hasOwnProperty(b)) {
					return d[e][b]
				} else {
					if (d.x && d.x.hasOwnProperty(b)) {
						return d.x[b]
					} else {
						if (d.z && d.z.hasOwnProperty(b)) {
							return d.z[b]
						} else {
							return false
						}
					}
				}
			}
		} else {
			if (c) {
				if (c == "x") {
					return d.x
				} else {
					if (c == "z") {
						return d.z
					} else {
						return d[c] ? d[c] : false
					}
				}
			} else {
				return d
			}
		}
	};
	this.updateMetaData = function(B, T, R, C) {
		var y = this;
		var u = this.meta.data;
		var g = this.data;
		var l = ["x", "z", "w"];
		var O = this.font;
		var v = function(o, m, d) {
			var s = {};
			if (y.legendOrder && y.legendOrder[o]) {
				for (var r = 0; r < y.legendOrder[o].length; r++) {
					s[y.legendOrder[o][r]] = r
				}
				var t = y.legendOrder[o].length;
				if (m) {
					for (var r in m) {
						if (!s.hasOwnProperty(r)) {
							s[r] = t++
						}
					}
				} else {
					for (var r = 0; r < d.length; r++) {
						if (!s.hasOwnProperty(d[r])) {
							s[r] = t++
						}
					}
				}
				return s
			} else {
				return false
			}
		};
		if (!B || B == "w" || B == "x" || B == "z") {
			if (B && R) {
				if (!T) {
					delete(u[B])
				} else {
					if (u[B][T]) {
						delete(u[B][T])
					}
				}
			}
			for (var N = 0; N < l.length; N++) {
				var I = l[N];
				if (B) {
					if (B != I) {
						continue
					}
				}
				O = I == "z" ? this.varLabelFont : this.smpLabelFont;
				if (g[I]) {
					for (var J in g[I]) {
						if (T) {
							if (T != J) {
								continue
							}
						}
						if (I == "w") {
							if (J != "smps" && J != "grps") {
								continue
							}
							if (J = "grps") {
								u[I][J] = g[I][J];
								u[I].smps = {};
								for (var K = 0; K < g[I].smps.length; K++) {
									u[I].smps[g[I].smps[K]] = K
								}
								continue
							}
						}
						u[I][J] = {};
						u[I][J].len = this.measureText(J, O);
						var S = u[I][J].len;
						var b = J.length;
						var L = J;
						var P = this.isNumeric(g[I][J]) && !this.isEmpty(g[I][J]);
						u[I][J].type = P ? "Numeric" : "String";
						var U = 0;
						var c = 0;
						var Q = "";
						if (u[I][J].type == "String") {
							u[I][J].unique = this.isUnique(g[I][J]);
							this.updateVocabulary(g[I][J]);
							var G = {};
							for (var K = 0; K < g[I][J].length; K++) {
								G[g[I][J][K]] = true
							}
							var e = v(J, G);
							G = this.stringRangeSort(this.getKeys(G));
							u[I][J].levels = G;
							u[I][J].order = {};
							for (var K = 0; K < G.length; K++) {
								u[I][J].order[G[K]] = e ? e[G[K]] : K;
								var w = this.measureText(G[K], O);
								if (w > U) {
									U = w;
									c = G[K].length;
									Q = G[K]
								}
							}
							u[I][J].maxLevLen = U;
							u[I][J].maxLevChr = c;
							u[I][J].maxLevStr = Q;
							if (this.colorKey && this.colorKey[J]) {
								if (this.isObject(this.colorKey[J])) {
									u[I][J].colorBy = this.colorKey[J];
									for (var K = 0; K < G.length; K++) {
										if (!u[I][J].colorBy.hasOwnProperty(G[K])) {
											u[I][J].colorBy[G[K]] = this.colors[K % this.colors.length]
										}
									}
								} else {
									if (this.isArray(this.colorKey[J])) {
										u[I][J].colors = mcp[J].colors
									} else {
										var H = G.length;
										if (this.meta.def.colorSchemes[this.colorKey[J]][H]) {
											u[I][J].colors = this.meta.def.colorSchemes[this.colorKey[J]][H]
										} else {
											var M = this.getKeys(this.meta.def.colorSchemes[this.colorKey[J]]);
											M.sort(function(k, d) {
												return k - d
											});
											if (H > M[M.length - 1]) {
												H--;
												while (!this.meta.def.colorSchemes[this.colorKey[J]][H]) {
													H--
												}
											} else {
												H++;
												while (!this.meta.def.colorSchemes[this.colorKey[J]][H]) {
													H++
												}
											}
											u[I][J].colors = this.meta.def.colorSchemes[this.colorKey[J]][H]
										}
									}
								}
							} else {
								u[I][J].colors = [];
								var A = 0;
								for (var K = 0; K < G.length; K++) {
									u[I][J].colors.push(this.colors[A % this.colors.length]);
									A++
								}
							}
							if (this.shapeKey && this.shapeKey[J]) {
								if (this.isObject(this.shapeKey[J])) {
									u[I][J].shapeBy = this.shapeKey[J];
									for (var K = 0; K < G.length; K++) {
										if (!u[I][J].shapeBy.hasOwnProperty(G[K])) {
											u[I][J].shapeBy[G[K]] = this.shapes[K % this.shapes.length]
										}
									}
								} else {
									u[I][J].shapes = this.shapeKey[J]
								}
							} else {
								u[I][J].shapes = [];
								var A = 0;
								for (var K = 0; K < G.length; K++) {
									u[I][J].shapes.push(this.shapes[A % this.shapes.length]);
									A++
								}
							}
							var q = this.getBestSizes(G.length);
							if (this.sizeKey && this.sizeKey[J]) {
								if (this.isObject(this.sizeKey[J])) {
									u[I][J].sizeBy = this.sizeKey[J];
									for (var K = 0; K < G.length; K++) {
										if (!u[I][J].sizeBy.hasOwnProperty(G[K])) {
											u[I][J].sizeBy[G[K]] = q[K % q.length]
										}
									}
								} else {
									u[I][J].sizes = this.sizeKey[J]
								}
							} else {
								u[I][J].sizes = [];
								var A = 0;
								for (var K = 0; K < G.length; K++) {
									u[I][J].sizes.push(q[A % q.length]);
									A++
								}
							}
							if (this.patternKey && this.patternKey[J]) {
								if (this.isObject(this.patternKey[J])) {
									u[I][J].patternBy = this.patternKey[J];
									for (var K = 0; K < G.length; K++) {
										if (!u[I][J].patternBy.hasOwnProperty(G[K])) {
											u[I][J].patternBy[G[K]] = this.patterns[K % this.patterns.length]
										}
									}
								} else {
									u[I][J].patterns = this.patternKey[J]
								}
							} else {
								u[I][J].patterns = [];
								var A = 0;
								for (var K = 0; K < G.length; K++) {
									u[I][J].patterns.push(this.patterns[A % this.patterns.length]);
									A++
								}
							}
						} else {
							u[I][J].unique = false;
							for (var K = 0; K < g[I][J].length; K++) {
								if (g[I][J][K] != null) {
									g[I][J][K] = Number(g[I][J][K])
								} else {
									g[I][J][K] = null
								}
							}
							var D = this.range(g[I][J]);
							u[I][J].rmin = D[0];
							u[I][J].rmax = D[1];
							u[I][J].n = g[I][J].length;
							var F = this.colorSpectrum;
							if (this.colorKey && this.colorKey[J]) {
								if (this.isObject(this.colorKey[J])) {
									u[I][J].colorBy = this.colorKey[J];
									for (var K = 0; K < g[I][J].length; K++) {
										if (!u[I][J].colorBy.hasOwnProperty(g[I][J][K])) {
											u[I][J].colorBy[g[I][J][K]] = this.colors[K % this.colors.length]
										}
									}
									u[I][J].orderS = v(J, false, g[I][J])
								} else {
									if (this.isArray(this.colorKey[J])) {
										F = this.colorKey[J]
									} else {
										var M = this.getKeys(this.meta.def.colorSchemes[this.colorKey[J]]);
										M.sort(function(k, d) {
											return k - d
										});
										F = this.meta.def.colorSchemes[this.colorKey[J]].hasOwnProperty(8) ? this.meta.def.colorSchemes[this.colorKey[J]][8] : this.meta.def.colorSchemes[this.colorKey[J]][M[0]]
									}
								}
							}
							u[I][J].colorBrew = this.getColorBrew(F, D[0], D[1], this.spectrumZeroValue, this.spectrumBreaks);
							u[I][J].min = u[I][J].colorBrew.min;
							u[I][J].max = u[I][J].colorBrew.max;
							u[I][J].zero = u[I][J].colorBrew.zero;
							u[I][J].vals = u[I][J].colorBrew.vals;
							u[I][J].incr = u[I][J].colorBrew.incr;
							u[I][J].decs = u[I][J].colorBrew.decs;
							u[I][J].levels = u[I][J].colorBrew.vals;
							u[I][J].order = {};
							for (var K = 0; K < u[I][J].levels.length; K++) {
								u[I][J].order[u[I][J].levels[K]] = K;
								var w = this.measureText(u[I][J].levels[K], O);
								if (w > U) {
									U = w;
									c = u[I][J].levels[K].toString().length;
									Q = u[I][J].levels[K]
								}
								u[I][J].maxLevLen = U;
								u[I][J].maxLevChr = c;
								u[I][J].maxLevStr = Q
							}
							if (this.shapeKey && this.shapeKey[J]) {
								if (this.isObject(this.shapeKey[J])) {
									u[I][J].shapeBy = this.shapeKey[J];
									for (var K = 0; K < g[I][J].length; K++) {
										if (!u[I][J].shapeBy.hasOwnProperty(g[I][J][K].toString())) {
											u[I][J].shapeBy[g[I][J][K].toString()] = this.shapes[K % this.shapes.length]
										}
									}
									u[I][J].orderS = v(J, false, g[I][J])
								}
							}
							u[I][J].shapes = this.shapes;
							if (this.sizeKey && this.sizeKey[J]) {
								if (this.isObject(this.sizeKey[J])) {
									u[I][J].sizeBy = this.sizeKey[J];
									for (var K = 0; K < g[I][J].length; K++) {
										if (!u[I][J].sizeBy.hasOwnProperty(g[I][J][K].toString())) {
											u[I][J].sizeBy[g[I][J][K].toString()] = this.sizes[K % this.sizes.length]
										}
									}
									u[I][J].orderS = v(J, false, g[I][J])
								}
							}
							u[I][J].sizes = this.sizes;
							if (this.patternKey && this.patternKey[J]) {
								if (this.isObject(this.patternKey[J])) {
									u[I][J].patternBy = this.patternKey[J];
									for (var K = 0; K < g[I][J].length; K++) {
										if (!u[I][J].patternBy.hasOwnProperty(g[I][J][K].toString())) {
											u[I][J].patternBy[g[I][J][K].toString()] = this.patterns[K % this.patterns.length]
										}
									}
									u[I][J].orderS = v(J, false, g[I][J])
								}
							}
							u[I][J].patterns = this.patterns
						}
						if (!u.m[I]) {
							u.m[I] = {}
						}
						if (u.m[I].maxFacLen) {
							if (S > u.m[I].maxFacLen) {
								u.m[I].maxFacLen = S;
								u.m[I].maxFacChr = b;
								u.m[I].maxFacStr = L
							}
						} else {
							u.m[I].maxFacLen = S;
							u.m[I].maxFacChr = b;
							u.m[I].maxFacStr = L
						}
					}
				}
				if (C) {
					return
				}
				var p, x, E;
				if (I == "z") {
					p = "y";
					x = "vars";
					E = "Var"
				}
				if (I == "x") {
					p = "y";
					x = "smps";
					E = "Smp"
				}
				if (I == "w") {
					p = "w";
					x = "smps";
					E = "Smp"
				}
				var U = 0;
				var c = 0;
				var Q = "";
				if (g[p]) {
					for (var K = 0; K < g[p][x].length; K++) {
						var z = g[p][x][K].length;
						if (z >= c) {
							var w = this.measureText(g[p][x][K], O);
							if (w > U) {
								U = w;
								c = z;
								Q = g[p][x][K]
							}
						}
					}
					u[p]["max" + E + "Len"] = U;
					u[p]["max" + E + "Chr"] = c;
					u[p]["max" + E + "Str"] = Q;
					if (I == "x") {
						if (!u[p]["range"]) {
							u[p]["range"] = {}
						}
						for (var K = 0; K < g.y.smps.length; K++) {
							var D = this.range(this.getDataForSmpAtPosition(K));
							u[p]["range"][g.y.smps[K]] = {};
							u[p]["range"][g.y.smps[K]].min = D[0];
							u[p]["range"][g.y.smps[K]].max = D[1];
							u[p]["range"][g.y.smps[K]].type = "Numeric"
						}
					}
					if (I == "z") {
						if (!u[p]["range"]) {
							u[p]["range"] = {}
						}
						for (var K = 0; K < g.y.data.length; K++) {
							var D = this.range(g.y.data[K]);
							u[p]["range"][g.y.vars[K]] = {};
							u[p]["range"][g.y.vars[K]].min = D[0];
							u[p]["range"][g.y.vars[K]].max = D[1];
							u[p]["range"][g.y.vars[K]].type = "Numeric"
						}
					}
					if (I == "w") {
						if (!u[p]["range"]) {
							u[p]["range"] = {}
						}
						var h = this.isGroupedData ? this.data.w : this.data.y;
						var f = this.isGroupedData ? this.grpIndices : this.smpIndices;
						for (var K = 0; K < f.length; K++) {
							var D = this.range(this.getDataForSmpGrpAtIndex(K));
							u[p]["range"][h.smps[K]] = {};
							u[p]["range"][h.smps[K]].min = D[0];
							u[p]["range"][h.smps[K]].max = D[1];
							u[p]["range"][h.smps[K]].type = "Numeric"
						}
					}
				}
			}
		} else {
			if (g.y[B]) {
				u[B] = {};
				var U = 0;
				var c = 0;
				var Q = "";
				if (this.isNumeric2DArray(g.y[B])) {
					for (var K = 0; K < g.y[B].length; K++) {
						for (var J = 0; J < g.y[B][K].length; J++) {
							if (g.y[B][K][J] != null) {
								g.y[B][K][J] = Number(g.y[B][K][J])
							} else {
								g.y[B][K][J] = null
							}
						}
					}
					var D = this.setRangeDataObject(g.y[B]);
					u[B].rmin = D[0];
					u[B].rmax = D[1];
					u[B].n = g.y[B].length * g.y[B][0].length;
					u[B].type = "Numeric";
					u[B].colorBrew = this.getColorBrew(this.colorSpectrum, D[0], D[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
					u[B].min = u[B].colorBrew.min;
					u[B].max = u[B].colorBrew.max;
					u[B].zero = u[B].colorBrew.zero;
					u[B].vals = u[B].colorBrew.vals;
					u[B].incr = u[B].colorBrew.incr;
					u[B].decs = u[B].colorBrew.decs;
					u[B].levels = u[B].colorBrew.vals;
					u[B].order = {};
					for (var K = 0; K < u[B].levels.length; K++) {
						u[B].order[u[B].levels[K]] = K;
						var w = this.measureText(u[B].levels[K], O);
						if (w > U) {
							U = w;
							c = u[B].levels[K].toString().length;
							Q = u[B].levels[K]
						}
						u[B].maxLevLen = U;
						u[B].maxLevChr = c;
						u[B].maxLevStr = Q
					}
					u[B].shapes = this.shapes;
					u[B].sizes = this.sizes;
					u[B].patterns = this.patterns
				} else {
					var G = {};
					for (var K = 0; K < g.y[B].length; K++) {
						for (var J = 0; J < g.y[B][K].length; J++) {
							G[g.y[B][K][J]] = true
						}
					}
					G = this.stringRangeSort(this.getKeys(G));
					u[B].levels = G;
					u[B].order = {};
					for (var K = 0; K < G.length; K++) {
						u[B].order[G[K]] = K;
						var w = this.measureText(G[K], O);
						if (w > U) {
							U = w;
							c = G[K].length;
							Q = G[K]
						}
					}
					u[B].maxLevLen = U;
					u[B].maxLevChr = c;
					u[B].maxLevStr = Q;
					u[B].type = "String";
					u[B].colors = [];
					var A = 0;
					for (var K = 0; K < G.length; K++) {
						u[B].colors.push(this.colors[A % this.colors.length]);
						A++
					}
					u[B].shapes = [];
					var A = 0;
					for (var K = 0; K < G.length; K++) {
						u[B].shapes.push(this.shapes[A % this.shapes.length]);
						A++
					}
					var q = this.getBestSizes(G.length);
					u[B].sizes = [];
					var A = 0;
					for (var K = 0; K < G.length; K++) {
						u[B].sizes.push(q[A % q.length]);
						A++
					}
					u[B].patterns = [];
					var A = 0;
					for (var K = 0; K < G.length; K++) {
						u[B].patterns.push(this.patterns[A % this.patterns.length]);
						A++
					}
				}
			} else {
				alert("Error while setting metadata. This may not work!")
			}
		}
	};
	this.setMetaData = function() {
		if (!this.meta.data) {
			if (this.graphType == "Network") {
				this.meta.data = {
					nodes: {},
					edges: {}
				}
			} else {
				this.meta.data = {
					w: {},
					x: {},
					y: {},
					z: {},
					m: {}
				};
				if (this.data.y) {
					var n = this.data.y;
					if (this.isRawData) {
						for (var g = 0; g < n.data.length; g++) {
							for (var f = 0; f < n.data[g].length; f++) {
								if (n.data[g][f] != null) {
									n.data[g][f] = n.data[g][f] == this.missingDataValue ? null : Number(n.data[g][f])
								}
							}
						}
					} else {
						var m = this.summaryType == "iqr" ? ["iqr1", "iqr3", "median", "qtl1", "qtl3", "out"] : [this.summaryType];
						for (var g = 0; g < m.length; g++) {
							var h = m[g];
							if (n.hasOwnProperty(h)) {
								for (var f = 0; f < n[h].length; f++) {
									for (var e = 0; e < n[h][f].length; e++) {
										if (h == "out") {
											for (var b = 0; b < n[h][f][e].length; b++) {
												if (n[h][f][e][b] != null) {
													n[h][f][e][b] = n.data[g][f] == this.missingDataValue ? null : Number(n[h][f][e][b])
												}
											}
										} else {
											if (n[h][f][e] != null) {
												n[h][f][e] = n.data[g][f] == this.missingDataValue ? null : Number(n[h][f][e])
											}
										}
									}
								}
							} else {
								n[h] = [];
								var c = this.summaryType == "iqr" ? "median" : this.summaryType;
								for (var f = 0; f < n[c].length; f++) {
									n[h][f] = [];
									for (var e = 0; e < n[c][f].length; e++) {
										n[h][f][e] = []
									}
								}
							}
						}
						var h = this.summaryType == "iqr" ? "median" : this.summaryType;
						n.data = [];
						for (var g = 0; g < n[h].length; g++) {
							n.data.push(n[h][g])
						}
					}
				}
			}
			this.updateMetaData();
			this.codeData()
		}
	};
	this.getIndices = function(b, f) {
		if (b != null && f) {
			var e = [];
			if (this.isArray(b)) {
				for (var c = 0; c < b.length; c++) {
					var d = f.indexOf(b[c]);
					if (d > -1) {
						e.push(d)
					}
				}
				return e
			} else {
				return f.indexOf(b)
			}
		}
	};
	this.getLevelsByAnnotation = function(c, k, h) {
		var b = [];
		var g = {};
		if (h && c && h[c]) {
			for (var e = 0; e < k.length; e++) {
				var f = k[e];
				var d = h[c][f] || "";
				if (!g.hasOwnProperty(d)) {
					b.push(d)
				}
				g[d] = true
			}
		}
		return b
	};
	this.getVariablesSamplesByAnnotationLevel = function(c, b, m, g, f) {
		var k = [];
		if (g && c && g[c]) {
			if (b) {
				for (var d = 0; d < m.length; d++) {
					var e = m[d];
					if (g[c][e] == b && !f[e]) {
						k.push(e)
					}
				}
			} else {
				for (var d = 0; d < m.length; d++) {
					var e = m[d];
					if (!g[c][e] && !f[e]) {
						k.push(e)
					}
				}
			}
		}
		return k
	};
	this.getVarSmpAnnotations = function(l, c, k, f, d) {
		var b = {};
		var g = [];
		var h = false;
		if (d && d.hasOwnProperty(l)) {
			for (var e = 0; e < c.length; e++) {
				var m = c[e];
				if (d[l][m] != null) {
					b[d[l][m]] = true;
					g.push(d[l][m])
				} else {
					h = true
				}
			}
			if (h) {
				g.push("")
			}
			if (f) {
				return k ? g.join("+") : g
			} else {
				g = []
			}
			for (var e in b) {
				g.push(e)
			}
			if (h) {
				g.push("")
			}
			return k ? g.join("+") : g
		}
	};
	this.setAllSamplesVisible = function(b, c) {
		var g = this.data;
		if (g.y) {
			var m = g.y.smps;
			if (!m && g.y.vars) {
				if (!g.y.data) {
					alert("Missing data object")
				}
				m = [];
				for (var f = 0; f < g.y.data[0].length; f++) {
					m.push("smp" + (f + 1))
				}
				g.y.smps = m
			}
			var k = [];
			var h = [];
			if (b) {
				for (var f = 0; f < b.length; f++) {
					k.push(indices[f]);
					h.push(false)
				}
			} else {
				for (var f = 0; f < m.length; f++) {
					k.push(f);
					h.push(false)
				}
			}
			if (!c && this.varIndices) {
				this.filterData()
			}
			this.smpIndices = k;
			this.hiddenSmps = h
		}
		if (this.data.w && this.data.w.smps) {
			this.grpIndices = [];
			this.hiddenGrps = [];
			for (var f = 0; f < this.data.w.smps.length; f++) {
				this.grpIndices.push(f);
				this.hiddenGrps.push(false)
			}
		}
		if (this.layoutComb && this.graphType != "Candlestick") {
			var l = this.layoutParams[this.layoutValidN || 0];
			var e = this.isGroupedData ? l.grpIndices : this.smpIndices;
			if (l && l.startingSmpIndices) {
				if (l.isGroupedData) {
					l.grpIndices = l.startingSmpIndices
				} else {
					l.smpIndices = l.startingSmpIndices
				}
				l.smpIndicesStart = -1
			}
		}
	};
	this.getSampleIndices = function(b, d, c) {
		var e = this.isGroupedData && !d ? this.data.w.smps : c ? this.dataStndBy.y.smps : this.data.y.smps;
		return this.getIndices(b, e)
	};
	this.getSamplesByAxis = function(b) {
		return this[b] || []
	};
	this.getSamplesByAnnotationLevel = function(c, b, d) {
		return this.getVariablesSamplesByAnnotationLevel(c, b, d || this.smpIndices, this.data.x, this.hiddenSmps)
	};
	this.getSampleLevelsByAnnotation = function(b, c) {
		return this.getLevelsByAnnotation(b, c || this.smpIndices, this.data.x)
	};
	this.setSamplesVisible = function(b, e) {
		if (this.isGroupedData) {
			this.grpIndices = [];
			for (var d = 0; d < b.length; d++) {
				this.grpIndices.push(b[d])
			}
		} else {
			this.smpIndices = [];
			for (var d = 0; d < b.length; d++) {
				this.smpIndices.push(b[d])
			}
		}
		if (status) {
			var c = this.getObjectArray(b);
			var g = this.isGroupedData ? this.data.w : this.data.y;
			var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
			for (var d = 0; d < g.smps.length; d++) {
				if (c.hasOwnProperty(d)) {
					f[d] = false
				} else {
					f[d] = true
				}
			}
		}
	};
	this.hideUnhideSmps = function(k) {
		this.functionCaller = "hideUnhideSmps";
		if (this.isTransition()) {
			return
		}
		if (k) {
			var c = this.isGroupedData ? this.data.w : this.data.y;
			var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
			var g = [];
			if (this.isArray(k)) {
				for (var e = 0; e < k.length; e++) {
					for (var d = 0; d < c.smps.length; d++) {
						if (c.smps[d] == k[e]) {
							if (f[d]) {
								f[d] = false
							} else {
								f[d] = true
							}
							break
						}
					}
				}
			} else {
				for (var e = 0; e < c.smps.length; e++) {
					if (c.smps[e] == k) {
						if (f[e]) {
							f[e] = false
						} else {
							f[e] = true
						}
						break
					}
				}
			}
			var b = [];
			for (var e = 0; e < c.smps.length; e++) {
				if (!f[e]) {
					b.push(e)
				}
			}
			this.setSamplesVisible(b);
			this.draw()
		}
	};
	this.getSamples = function() {
		var d = [];
		var h = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
		var k = this.isGroupedData ? this.data.w : this.data.y;
		var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
		var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
		for (var e = 0; e < h.length; e++) {
			var b = -1;
			for (var c = 0; c < g.length; c++) {
				if (g[c] == e) {
					b = c;
					break
				}
			}
			d.push({
				name: h[e],
				hidden: f[e],
				index: b
			})
		}
		return d
	};
	this.getSmpAnnotations = function(b, e, d, c) {
		return this.getVarSmpAnnotations(b, e, d, c, this.data.x)
	};
	this.setAllVariablesVisible = function(h, k) {
		var l = this.data;
		if (l.y) {
			var e = l.y.vars;
			if (!e && l.y.data) {
				e = [];
				for (var g = 0; g < l.y.data.length; g++) {
					e.push("var" + (g + 1))
				}
				l.y.vars = e
			}
			var b = [];
			var c = [];
			if (h) {
				for (var g = 0; g < h.length; g++) {
					b.push(h[g]);
					c.push(false)
				}
			} else {
				for (var g = 0; g < e.length; g++) {
					b.push(g);
					c.push(false)
				}
			}
			if (!k && this.smpIndices) {
				this.filterData()
			}
			if (this.layoutComb && this.graphType != "Candlestick") {
				var f = this.layoutParams[this.layoutValidN || 0];
				if (f && f.startingVarIndices) {
					f.varIndices = f.startingVarIndices;
					f.varIndicesStart = -1
				}
			}
			this.varIndices = b;
			this.hiddenVars = c
		}
	};
	this.getVariableIndices = function(b, d) {
		var c = d ? this.dataStndBy.y.vars : this.data.y.vars;
		return this.getIndices(b, c)
	};
	this.setVariablesVisibleByAxis = function(c, b) {
		var d = this[c + "VarIndices"];
		d = [];
		for (var e = 0; e < b.length; e++) {
			d.push(b[e])
		}
	};
	this.getVariablesVisibleByAxis = function(b) {
		return this[b + "VarIndices"]
	};
	this.getVariablesByAnnotationLevel = function(c, b, d) {
		return this.getVariablesSamplesByAnnotationLevel(c, b, d || this.varIndices, this.data.z, this.hiddenVars)
	};
	this.getVariableLevelsByAnnotation = function(b, c) {
		return this.getLevelsByAnnotation(b, c || this.varIndices, this.data.z)
	};
	this.setVariablesVisible = function(b) {
		this.varIndices = [];
		for (var c = 0; c < b.length; c++) {
			this.varIndices.push(b[c])
		}
	};
	this.hideUnhideVars = function(g) {
		this.functionCaller = "hideUnhideVars";
		if (this.isTransition()) {
			return
		}
		var f = this.data.y;
		var e = this.hiddenVars;
		if (g) {
			if (this.isArray(g)) {
				for (var d = 0; d < g.length; d++) {
					for (var c = 0; c < f.vars.length; c++) {
						if (f.vars[c] == g[d]) {
							if (e[c]) {
								e[c] = false
							} else {
								e[c] = true
							}
							break
						}
					}
				}
			} else {
				for (var d = 0; d < f.vars.length; d++) {
					if (f.vars[d] == g) {
						if (e[d]) {
							e[d] = false
						} else {
							e[d] = true
						}
						break
					}
				}
			}
			var b = [];
			for (var d = 0; d < f.vars.length; d++) {
				if (!e[d]) {
					b.push(d)
				}
			}
			this.setVariablesVisible(b);
			this.draw()
		}
	};
	this.getVariables = function() {
		var e = [];
		for (var d = 0; d < this.data.y.vars.length; d++) {
			var b = -1;
			for (var c = 0; c < this.varIndices.length; c++) {
				if (this.varIndices[c] == d) {
					b = c;
					break
				}
			}
			e.push({
				name: this.data.y.vars[d],
				hidden: this.hiddenVars[d],
				index: b
			})
		}
		return e
	};
	this.getVarAnnotations = function(b, e, d, c) {
		return this.getVarSmpAnnotations(b, e, d, c, this.data.z)
	};
	this.setNodeIndices = function() {
		var e = this.data.nodes;
		var g = {};
		var f = {};
		for (var b = 0; b < e.length; b++) {
			var c = e[b];
			g[c.id] = c;
			f[c.id] = b
		}
		this.nodes = g;
		this.data.nodeIndices = f
	};
	this.setNodes = function() {
		if (this.data.nodeIndices) {
			var b = this.data.nodeIndices;
			var e = this.data.nodes;
			var g = {};
			for (var b = 0; b < e.length; b++) {
				var c = e[b];
				g[c.id] = c
			}
			e = [];
			for (var f in b) {
				e[b[f]] = g[f]
			}
			this.data.nodes = e;
			this.nodes = g
		} else {
			this.setNodeIndices()
		}
	};
	this.setAllNodesVisible = function(d) {
		this.nodes = {};
		this.data.nodeIndices = {};
		var g = this.data.nodes;
		for (var b = 0; b < g.length; b++) {
			var c = g[b];
			c.hide = false;
			this.nodes[c.id] = c;
			this.data.nodeIndices[c.id] = b
		}
		var f = this.data.edges;
		for (var b = 0; b < f.length; b++) {
			f[b].hide = false
		}
		if (!d) {
			this.filterData()
		}
	};
	this.hideUnhideNodes = function(c, e) {
		e = e ? true : false;
		var g = this.data.nodes;
		var l = this.nodes;
		if (c) {
			if (this.isArray(c)) {
				for (var b = 0; b < c.length; b++) {
					var k = c[b];
					var f = g[this.data.nodeIndices[k]];
					f.hide = e;
					if (l && l[k]) {
						l[k].hide = e
					}
				}
			}
		} else {
			for (var b = 0; b < g.length; b++) {
				var f = g[b];
				f.hide = e;
				f.hideChildren = e;
				if (l && l[f.id]) {
					l[f.id].hide = e;
					l[f.id].hideChildren = e
				}
			}
		}
	};
	this.hideUnhideChildrenNodes = function(f, c) {
		c = c ? true : false;
		var d = this.nodeParentHood;
		if (d[f] && d[f].children) {
			for (var b = 0; b < d[f].children.length; b++) {
				var e = d[f].children[b];
				this.data.nodes[this.data.nodeIndices[e]].hiddenParent = c;
				this.hideUnhideChildrenNodes(e, c)
			}
		}
	};
	this.setAllFeaturesVisible = function() {
		var e = this.data.tracks;
		for (var d = 0; d < e.length; d++) {
			var b = e[d];
			b.hide = false;
			var f = b.data;
			for (var c = 0; c < f.length; c++) {
				f[c].hide = false
			}
		}
	};
	this.setIndices = function(c, b) {
		if (this.graphType == "Network") {
			this.setNodes()
		} else {
			if (this.graphType != "Genome" && this.graphType != "Venn") {
				this.setAllVariablesVisible(c);
				this.setAllSamplesVisible(b)
			}
		}
	};
	this.resetIndices = function() {
		if (this.isGroupedData) {
			this.setIndices()
		}
	};
	this.initializeDataAttributes = function(f, c) {
		var e = this.graphType;
		var b = ["outlineByData", "shapeByData", "sizeByData", "patternByData"];
		this.setIndices(f, c);
		if (e == "Network") {
			this.setMetaData()
		} else {
			if (e != "Genome" && e != "Venn") {
				this.setMetaData();
				for (var d = 0; d < b.length; d++) {
					if (this[b[d]] && this.data.y.hasOwnProperty(this[b[d]])) {
						this.updateMetaData(this[b[d]])
					} else {
						this[b[d]] = false
					}
				}
			}
		}
	};
	this.setFrameData = function() {
		if (this.data.dataframe) {
			var f = this.data.dataframe;
			var g = f.shift();
			var e = {
				y: {
					vars: [],
					smps: [],
					data: []
				}
			};
			for (i = 0; i < f.length; i++) {
				e.y.data[i] = [];
				e.y.vars.push("V" + (i + 1))
			}
			for (i = 0; i < g.length; i++) {
				var b = [];
				for (j = 0; j < f.length; j++) {
					b.push(f[j][i])
				}
				if (this.isNumeric(b)) {
					e.y.smps.push(g[i]);
					for (j = 0; j < b.length; j++) {
						e.y.data[j].push(b[j])
					}
				} else {
					if (!e.z) {
						e.z = {}
					}
					if (!e.z[g[i]]) {
						e.z[g[i]] = []
					}
					for (j = 0; j < b.length; j++) {
						e.z[g[i]].push(b[j])
					}
				}
			}
			this.data = e
		}
	};
	this.setMarketData = function() {
		if (this.data.market && !this.isMarketDataFormated) {
			var c = this.data.market;
			var h = {};
			h.smps = [];
			h.vars = [];
			h.close = [];
			h.open = [];
			h.high = [];
			h.low = [];
			h.volume = [];
			var b = {};
			var m = 0;
			for (var g = 0; g < c.length; g++) {
				h.vars.push(c[g].symbol);
				h.close[g] = [];
				h.open[g] = [];
				h.high[g] = [];
				h.low[g] = [];
				h.volume[g] = [];
				var f = c[g].data;
				for (var e = f.length - 1; e >= 0; e--) {
					var k = this.parseDate(f[e][0]);
					var l = 0;
					if (!b.hasOwnProperty(k)) {
						l = m;
						b[k] = m;
						h.smps.push(k);
						m++
					} else {
						l = b[k]
					}
					h.open[g][l] = f[e][1];
					h.high[g][l] = f[e][2];
					h.low[g][l] = f[e][3];
					h.close[g][l] = f[e][4];
					h.volume[g][l] = f[e][5]
				}
			}
			this.data.market = h;
			this.xAxisTitle = "Price";
			this.xAxisTitle2 = "Vol"
		}
		this.isMarketDataFormated = true
	};
	this.setSankeyData = function() {
		if (this.sankeySource && this.sankeyTarget) {
			this.data.sankey = {
				nodes: [],
				links: []
			};
			var h = {};
			for (var d = 0; d < this.smpIndices.length; d++) {
				var f = this.smpIndices[d];
				var e = this.data.x[this.sankeySource][f];
				var c = this.data.x[this.sankeyTarget][f];
				var b = this.getDataAtPos(this.hierarchyVarIndex, f, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue);
				this.data.sankey.links.push({
					source: e,
					target: c,
					value: b,
					id: f
				});
				h[e] = true;
				h[c] = true
			}
			var k = 0;
			for (var d in h) {
				this.data.sankey.nodes.push({
					name: d,
					id: k++
				})
			}
			var g = {};
			this.data.sankey.nodes.forEach(function(l) {
				g[l.name] = l
			});
			this.data.sankey.links = this.data.sankey.links.map(function(l) {
				return {
					source: g[l.source],
					target: g[l.target],
					value: l.value,
					id: l.id
				}
			})
		} else {
			if (this.data.sankey) {
				delete(this.data.sankey)
			}
		}
	};
	this.setHierarchyData = function(h) {
		if (this.graphType == "Sankey" || (this.graphType == "Circular" && (this.circularType == "sunburst" || this.circularType == "bubble"))) {
			var e = this.hierarchyVar ? this.getVariableIndeces(this.hierarchyVar) : 0;
			this.hierarchyVarIndex = e >= 0 ? e : 0
		}
		if (this.hierarchy.length > 0) {
			if (!this.data[h]) {
				this.data[h] = {};
				this.data[h]["data"] = {
					name: this.hierarchy[0],
					children: []
				};
				for (var e = 0; e < this.data.y.smps.length; e++) {
					var f = this.data[h]["data"].children;
					for (var d = 0; d < this.hierarchy.length; d++) {
						var g = this.hierarchy[d];
						var b = -1;
						for (var c = 0; c < f.length; c++) {
							if (this.data.x[g][e] == f[c].name) {
								b = c
							}
						}
						if (b == -1) {
							f.push({
								name: this.data.x[g][e],
								children: []
							});
							b = f.length - 1
						}
						f = f[b].children;
						if (d === this.hierarchy.length - 1) {
							f.push({
								name: this.data.y.smps[e],
								size: this.data.y.data[this.hierarchyVarIndex][e],
								idx: e
							})
						}
					}
				}
			}
		} else {
			this.data[h] = {};
			this.data[h]["data"] = {
				name: "Samples",
				children: []
			};
			for (var e = 0; e < this.data.y.smps.length; e++) {
				var f = this.data[h]["data"].children;
				f.push({
					name: this.data.y.smps[e],
					size: this.data.y.data[this.hierarchyVarIndex][e],
					idx: e
				})
			}
		}
	};
	this.initializeData = function(b, c) {
		this.data = a && !b ? a : b || this.dataSetExample;
		this.isExample = a || b ? false : true;
		if (this.isExample) {
			this.$(this.target).style.display = "none"
		}
		this.nodesData = false;
		this.edgesData = false;
		this.featuresData = false;
		if (c) {
			delete this.meta.data
		}
		this.validGraphTypes = [];
		if (this.data && (this.data.y || this.data.dataframe || this.data.venn || this.data.nodes || this.data.tracks || this.data.market || this.data.fx || this.data.video)) {
			this.FunctionData(this.data.fx ? true : false);
			if (this.data.dataframe) {
				this.setFrameData()
			}
			if (this.data.market) {
				this.setMarketData();
				this.summaryType = "candle";
				this.validGraphTypes.push("Candlestick")
			}
			if (this.data.venn) {
				this.summaryType = "venn";
				this.validGraphTypes.push("Venn")
			}
			if (this.data.video) {
				this.summaryType = "video";
				this.validGraphTypes.push("Video")
			}
			if (this.data.nodes) {
				this.summaryType = "network";
				this.validGraphTypes.push("Network")
			}
			if (this.data.tracks) {
				this.summaryType = "genome";
				this.validGraphTypes.push("Genome")
			}
			if (this.data.y) {
				if (!this.data.y && !this.data.y.cor && !this.data.y.close) {
					alert("Dude! there is not a valid data structure");
					return
				} else {
					if (this.data.y.data) {
						this.isRawData = true;
						this.summaryType = this.summaryType ? this.summaryType : "raw"
					} else {
						this.isRawData = false;
						if (this.data.y.iqr1 && this.data.y.qtl1 && this.data.y.median && this.data.y.qtl3 && this.data.y.iqr3) {
							this.summaryType = "iqr"
						} else {
							if (this.data.y.median) {
								this.summaryType = "median"
							} else {
								if (this.data.y.mean) {
									this.summaryType = "mean"
								} else {
									if (this.data.y.cor) {
										this.summaryType = "cor"
									} else {
										if (this.data.y.sum) {
											this.summaryType = "sum"
										} else {
											if (this.data.y.max) {
												this.summaryType = "max"
											} else {
												if (this.data.y.min) {
													this.summaryType = "min"
												}
											}
										}
									}
								}
							}
						}
					}
				}
				this.validGraphTypes.push("Bar");
				this.validGraphTypes.push("Line");
				this.validGraphTypes.push("Area");
				this.validGraphTypes.push("AreaLine");
				this.validGraphTypes.push("BarLine");
				this.validGraphTypes.push("Boxplot");
				this.validGraphTypes.push("Dotplot");
				this.validGraphTypes.push("DotLine");
				this.validGraphTypes.push("Heatmap");
				this.validGraphTypes.push("Stacked");
				this.validGraphTypes.push("StackedLine");
				this.validGraphTypes.push("StackedPercent");
				this.validGraphTypes.push("StackedPercentLine");
				this.validGraphTypes.push("Pie");
				this.validGraphTypes.push("Correlation");
				this.validGraphTypes.push("Circular");
				if (this.data.y.smps || this.isDOE) {
					if (this.data.y.smps.length > 2 || this.isDOE) {
						this.validGraphTypes.push("Scatter2D");
						this.validGraphTypes.push("ScatterBubble2D");
						this.validGraphTypes.push("Scatter3D")
					} else {
						if (this.data.y.smps.length > 1 || this.isDOE) {
							this.validGraphTypes.push("Scatter2D")
						}
					}
				}
			}
			this.validGraphTypes.sort()
		}
		this.initializeDataAttributes()
	};
	this.initializeData()
};
CanvasXpress.prototype.initDataUtils = function() {
	this.switchVarIdToAnnotation = function() {
		this.functionCaller = "switchVarIdToAnnotation";
		if (this.isTransition()) {
			return
		}
		var g = this.data;
		var b = this.meta.data;
		var f = function() {
			var d = 0;
			var a = "Var-Name-" + d;
			while (g.z.hasOwnProperty(a) && b.z[a]) {
				d++;
				a = "Var-Name-" + d
			}
			return a
		};
		var c = f();
		g.z[c] = [];
		for (var e = 0; e < g.y.vars.length; e++) {
			g.z[c].push("var" + (e + 1))
		}
		this.updateMetaData("z", c);
		this.switchVarAnnotationToId(c)
	};
	this.switchVarAnnotationToId = function(e) {
		this.functionCaller = "switchVarAnnotationToId";
		if (this.isTransition()) {
			return
		}
		var j = this.data;
		var c = this.meta.data;
		if (j.z.hasOwnProperty(e) && this.isUnique(j.z[e])) {
			var i = this.rebuildDataTableFilter();
			var b = this.groupingFactors;
			var g = this.cloneObject(j.y.vars);
			var h = this.cloneObject(j.z[e]);
			var f = e.match(/^--/) ? e.replace(/^--/, "") : "--" + e;
			j.z[f] = g;
			j.y.vars = h;
			delete(j.z[e]);
			this.resetMetaData();
			if (b && b.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(b)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(i, true)
		} else {
			alert("Annotation " + e + " is not unique!")
		}
	};
	this.switchAnnotationToVar = function(h) {
		this.functionCaller = "switchAnnotationToVar";
		if (this.isTransition()) {
			return
		}
		var g = this.data;
		var c = this.meta.data;
		if (g.x.hasOwnProperty(h)) {
			var b = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.z) {
				c.modified.z = {}
			}
			if (!c.modified.z[h]) {
				c.modified.z[h] = {}
			}
			var j = this.groupingFactors;
			this.isGroupedData = false;
			g.y.vars.push(h);
			if (this.isNumeric(g.x[h])) {
				g.y.data.push(g.x[h])
			} else {
				var l = [];
				for (var f = 0; f < g.y.smps.length; f++) {
					l.push(c.x[h].order[g.x[h][f]])
				}
				g.y.data.push(l);
				if (!c.modified.x) {
					c.modified.x = {}
				}
				if (!c.modified.x[h]) {
					c.modified.x[h] = this.cloneObject(c.x[h].levels)
				}
			}
			delete(g.x[h]);
			var k = this.getKeys(g.x);
			if (k.length < 1) {
				delete(g.x)
			}
			if (g.z) {
				var k = this.getKeys(g.z);
				for (var f = 0; f < k.length; f++) {
					g.z[k[f]].push(c.modified.z[h][k[f]] || "")
				}
			}
			var e = this.cloneObject(c.modified);
			this.updateMetaData("x", h, true);
			this.updateData(g, false, true);
			this.meta.data.modified = e;
			if (j && j.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(j)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(b, true)
		}
	};
	this.switchVarToAnnotation = function(k) {
		this.functionCaller = "switchVarToAnnotation";
		if (this.isTransition()) {
			return
		}
		var g = this.getVariableIndices(k);
		if (g >= 0) {
			var h = this.data;
			var c = this.meta.data;
			var a = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.z) {
				c.modified.z = {}
			}
			if (!c.modified.z[k]) {
				c.modified.z[k] = {}
			}
			var l = this.groupingFactors;
			this.isGroupedData = false;
			if (!h.x) {
				h.x = {}
			}
			if (c.modified && c.modified.x && c.modified.x[k]) {
				var o = [];
				for (var f = 0; f < h.y.smps.length; f++) {
					o.push(c.modified.x[k][h.y.data[g][f]])
				}
				h.x[k] = o
			} else {
				h.x[k] = h.y.data[g]
			}
			h.y.vars.splice(g, 1);
			h.y.data.splice(g, 1);
			if (h.z) {
				var n = this.getKeys(h.z);
				for (var f = 0; f < n.length; f++) {
					var b = h.z[n[f]].splice(g, 1);
					c.modified.z[k][n[f]] = b[0]
				}
			}
			var e = this.cloneObject(c.modified);
			this.updateMetaData("x");
			this.updateData(h, false, true);
			this.meta.data.modified = e;
			if (l && l.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(l)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(a, true)
		}
	};
	this.rebuildDataTableFilter = function(c, h) {
		if (c) {
			var j = this;
			if (c[3] && !h) {
				j.resetDataExplorer()
			}
			setTimeout(function() {
				if (c[0]) {
					j.clickLayout();
					setTimeout(function() {
						j.activeAccordion = false;
						j.activateAccordion(false, j.$(j.target + "-cX-DataFilterVariableHeader"))
					}, j.showFadeResizeMoveAnimation ? 500 : 0)
				} else {
					if (c[1]) {
						j.clickDataFilter()
					}
					if (c[2]) {
						j.clickDataTable()
					}
				}
			}, 2000)
		} else {
			var j = this;
			var f = this.$(this.target + "-cX-DataFilter");
			var i = f && f.style.display == "block" ? true : false;
			var d = this.$(this.target + "-cX-DataTable");
			var a = this.dataTableLastState;
			var g = this.$(this.target + "-cX-DataExplorer");
			var e = g ? true : false;
			var b = this.appLayout;
			if (b) {
				this.clickLayout()
			} else {
				if (i) {
					this.hideDataFilter()
				}
				if (a) {
					this.hideTable()
				}
			}
			setTimeout(function() {
				j.rebuildDataTable();
				j.rebuildDataFilter()
			}, 500);
			return [b, i, a, e]
		}
	};
	this.switchSmpIdToAnnotation = function() {
		this.functionCaller = "switchSmpIdToAnnotation";
		if (this.isTransition()) {
			return
		}
		var g = this.data;
		var b = this.meta.data;
		var f = function() {
			var d = 0;
			var a = "Smp-Name-" + d;
			while (g.x.hasOwnProperty(a) && b.x[a]) {
				d++;
				a = "Smp-Name-" + d
			}
			return a
		};
		var c = f();
		g.x[c] = [];
		for (var e = 0; e < g.y.smps.length; e++) {
			g.x[c].push("smp" + (e + 1))
		}
		this.updateMetaData("x", c);
		this.switchSmpAnnotationToId(c)
	};
	this.switchSmpAnnotationToId = function(e) {
		this.functionCaller = "switchSmpAnnotationToId";
		if (this.isTransition()) {
			return
		}
		var j = this.data;
		var c = this.meta.data;
		if (j.x.hasOwnProperty(e) && this.isUnique(j.x[e])) {
			var h = this.rebuildDataTableFilter();
			var b = this.groupingFactors;
			var g = this.cloneObject(j.y.smps);
			var i = this.cloneObject(j.x[e]);
			var f = e.match(/^--/) ? e.replace(/^--/, "") : "--" + e;
			j.x[f] = g;
			j.y.smps = i;
			delete(j.x[e]);
			this.resetMetaData();
			if (b && b.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(b)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(h, true)
		} else {
			alert("Annotation " + e + " is not unique!")
		}
	};
	this.switchAnnotationToSmp = function(k) {
		this.functionCaller = "switchAnnotationToSmp";
		if (this.isTransition()) {
			return
		}
		var h = this.data;
		var c = this.meta.data;
		if (h.z.hasOwnProperty(k)) {
			var b = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.x) {
				c.modified.x = {}
			}
			if (!c.modified.x[k]) {
				c.modified.x[k] = {}
			}
			var l = this.groupingFactors;
			this.isGroupedData = false;
			h.y.smps.push(k);
			if (this.isNumeric(h.z[k])) {
				for (var g = 0; g < h.y.vars.length; g++) {
					h.y.data[g].push(h.z[k][g])
				}
			} else {
				for (var g = 0; g < h.y.vars.length; g++) {
					h.y.data[g].push(c.z[k].order[h.z[k][g]])
				}
				if (!c.modified.z) {
					c.modified.z = {}
				}
				if (!c.modified.z[k]) {
					c.modified.z[k] = this.cloneObject(c.z[k].levels)
				}
			}
			delete(h.z[k]);
			var n = this.getKeys(h.z);
			if (n.length < 1) {
				delete(h.z)
			}
			if (h.x) {
				var n = this.getKeys(h.x);
				for (var f = 0; f < n.length; f++) {
					h.x[n[f]].push(c.modified.x[k][n[f]] || "")
				}
			}
			var e = this.cloneObject(c.modified);
			this.updateMetaData("z", k, true);
			this.updateData(h, false, true);
			this.meta.data.modified = e;
			if (l && l.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(l)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(b, true)
		}
	};
	this.switchSmpToAnnotation = function(o) {
		this.functionCaller = "switchSmpToAnnotation";
		if (this.isTransition()) {
			return
		}
		var g = this.getSampleIndices(o, true);
		if (g >= 0) {
			var h = this.data;
			var c = this.meta.data;
			var a = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.x) {
				c.modified.x = {}
			}
			if (!c.modified.x[o]) {
				c.modified.x[o] = {}
			}
			var l = this.groupingFactors;
			this.isGroupedData = false;
			if (!h.z) {
				h.z = {}
			}
			h.y.smps.splice(g, 1);
			h.z[o] = [];
			if (c.modified && c.modified.z && c.modified.z[o]) {
				for (var f = 0; f < h.y.vars.length; f++) {
					var k = h.y.data[f].splice(g, 1);
					h.z[o].push(c.modified.z[o][k])
				}
			} else {
				for (var f = 0; f < h.y.vars.length; f++) {
					h.z[o].push(h.y.data[f].splice(g, 1))
				}
			}
			if (h.x) {
				var n = this.getKeys(h.x);
				for (var f = 0; f < n.length; f++) {
					var b = h.x[n[f]].splice(g, 1);
					c.modified.x[o][n[f]] = b[0]
				}
			}
			var e = this.cloneObject(c.modified);
			this.updateMetaData("z");
			this.updateData(h, false, true);
			this.meta.data.modified = e;
			if (l && l.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(l)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(a, true)
		}
	};
	this.switchNumericToString = function(f, e) {
		this.functionCaller = "switchNumericToString";
		if (this.isTransition()) {
			return
		}
		var d = e ? "x" : "z";
		var b = e ? "smps" : "vars";
		if (f && this.data[d][f]) {
			var c = this.rebuildDataTableFilter();
			for (var a = 0; a < this.data.y[b].length; a++) {
				this.data[d][f][a] = this.data[d][f][a] + "\x00"
			}
			if (e) {
				this.updateMetaData("x", f)
			} else {
				this.updateMetaData("z", f)
			}
			this.rebuildDataTableFilter(c, true)
		}
		this.removeMenus();
		this.draw()
	};
	this.switchStringToNumeric = function(f, e) {
		this.functionCaller = "switchStringToNumeric";
		if (this.isTransition()) {
			return
		}
		var d = e ? "x" : "z";
		var b = e ? "smps" : "vars";
		if (f && this.data[d][f]) {
			var c = this.rebuildDataTableFilter();
			for (var a = 0; a < this.data.y[b].length; a++) {
				this.data[d][f][a] = this.data[d][f][a].replace("\x00", "")
			}
			if (e) {
				this.updateMetaData("x", f)
			} else {
				this.updateMetaData("z", f)
			}
			this.rebuildDataTableFilter(c, true)
		}
		this.removeMenus();
		this.draw()
	};
	this.modifyTransform = function(a) {
		v = a.shift();
		t = a[0];
		if (t == "tceil") {
			t = "ceil";
			this.transformCeilValue = parseInt(v)
		} else {
			if (t = "tfloor") {
				t = "floor";
				this.transformFloorValue = parseInt(v)
			}
		}
		this.transform(t)
	};
	this.showSorting = function(f, n, m) {
		var h = this;
		var e = ["sortingSampleCategories", "sortingVariables"];
		var b = ["sortingVariableCategories", "sortingSamples"];
		var j = n == "smp" ? e : b;
		j = f == "cat" ? [j[0]] : [j[1]];
		var l = function(q, k) {
			var o = [];
			for (var p = 0; p < h[q].length; p++) {
				if (h[q][p] != k) {
					o.push(h[q][p])
				}
			}
			if (o.length > 0) {
				h[q] = o
			} else {}
		};
		var a = function(k, i) {
			if (h[k].length < 3) {
				h[k].push(m)
			} else {
				h.removeMenus();
				alert("Maximum of three sorting levels reached")
			}
		};
		if (m != "samples" && m != "variables") {
			for (var g = 0; g < j.length; g++) {
				if (!this[j[g]]) {
					this[j[g]] = []
				}
				var d = this.getObjectArray(this[j[g]]);
				var c = null;
				if (j[g] == "sortingVariables") {
					c = this.getVariableIndices(m)
				} else {
					if (j[g] == "sortingSamples") {
						c = this.getSampleIndices(m)
					}
				}
				if (c != null && c < 0) {
					c = null
				}
				if (d.hasOwnProperty(c != null ? c + 1 : m)) {
					l(j[g], c != null ? c + 1 : m)
				} else {
					a(j[g], c != null ? c + 1 : m)
				}
			}
		}
		if (n == "smp") {
			if (f == "cat") {
				this.sortSamplesByCategory(this.sortingSampleCategories)
			} else {
				if (f == "var") {
					this.sortSamplesByVariable(this.sortingVariables)
				} else {
					if (m == "samples") {
						this.sortSamples()
					}
				}
			}
		} else {
			if (n == "var") {
				if (f == "cat") {
					this.sortVariablesByCategory(this.sortingVariableCategories)
				} else {
					if (f == "smp") {
						this.sortVariablesBySample(this.sortingSamples)
					} else {
						if (m == "variables") {
							this.sortVariables()
						}
					}
				}
			}
		}
	};
	this.sortSamples = function(g, i, e, b, f, h) {
		this.functionCaller = "sortSamples";
		if (this.isTransition()) {
			return
		}
		this.sortIndices("smps", g, i, false, e, b, f);
		this.setOriginalIndices(false, false, false, true);
		if (!h) {
			this.draw()
		}
	};
	this.sortSamplesByName = function(a) {
		this.sortSamples()
	};
	this.sortSamplesByCategory = function(b, a) {
		this.functionCaller = "sortSamplesByCategory";
		if (this.isTransition()) {
			return
		}
		this.sortIndices("smps", false, b);
		this.setOriginalIndices(false, false, false, true);
		if (!a) {
			this.draw()
		}
	};
	this.sortSamplesByVariable = function(c, b, e) {
		this.functionCaller = "sortSamplesByVariable";
		if (this.isTransition()) {
			return
		}
		var d = parseInt(this.getVariableIndices(c));
		this.sortIndices("smps", false, false, false, d + 1, b);
		this.setOriginalIndices(false, false, false, true);
		if (!e) {
			this.draw()
		}
	};
	this.sortVariables = function(g, i, e, b, f, h) {
		this.functionCaller = "sortVariables";
		if (this.isTransition()) {
			return
		}
		this.sortIndices("vars", g, i, e, false, b, f, h);
		this.setOriginalIndices(false, false, false, true);
		if (!h) {
			this.draw()
		}
	};
	this.sortVariablesByName = function(a) {
		this.sortVariables()
	};
	this.sortVariablesByCategory = function(b, a) {
		this.functionCaller = "sortVariablesByCategory";
		if (this.isTransition()) {
			return
		}
		this.sortIndices("vars", false, b);
		this.setOriginalIndices(false, false, false, true);
		if (!a) {
			this.draw()
		}
	};
	this.sortVariablesBySample = function(a, c) {
		this.functionCaller = "sortVariablesBySample";
		if (this.isTransition()) {
			return
		}
		var b = parseInt(this.getSampleIndices(a));
		this.sortIndices("vars", false, false, b + 1);
		this.setOriginalIndices(false, false, false, true);
		if (!c) {
			this.draw()
		}
	};
	this.resetLegendPosition = function() {
		this.functionCaller = "resetLegendPosition";
		if (this.isTransition()) {
			return
		}
		this.resetLegends(true);
		this.draw()
	};
	this.resetDendrograms = function() {
		delete(this.varDendrogram);
		delete(this.smpDendrogram)
	};
	this.filterOncoprint = function(e) {
		this.functionCaller = "filterOncoprint";
		if (this.isTransition()) {
			return
		}
		var g = {};
		for (var d = 0; d < this.data.y.vars.length; d++) {
			for (var c = 0; c < this.data.y.smps.length; c++) {
				var b = this.getDataAtPos(d, c, false, this.xAxisTransform, this.minData, this.maxData);
				var a = this.getDataAtPos(d, c, false, this.xAxisTransform, this.minData, this.maxData, true);
				switch (e) {
					case "Amplification":
						if (b >= this.oncoprintAmplification) {
							g[d] = true
						}
						break;
					case "Deletion":
						if (b <= this.oncoprintDeletion) {
							g[d] = true
						}
						break;
					case "Mutation":
						if (a && ((isNaN(a) && !a.toString().match(/^no$|^-$|^neg$/i)) || a > 0)) {
							g[d] = true
						}
						break
				}
			}
		}
		var f = [];
		for (var d = 0; d < this.data.y.vars.length; d++) {
			if (g[d]) {
				f.push(d)
			}
		}
		this.varIndices = f;
		this.draw()
	};
	this.getGroupingFactors = function(a) {
		if (a) {
			return this.groupingFactors
		} else {
			return this.getObjectArray(this.groupingFactors)
		}
	};
	this.modifyGroupingFactors = function(b, a) {
		this.modifyObjectArray(b, a, "groupingFactors")
	};
	this.showVariableOverlays = function(c) {
		this.functionCaller = "showVariableOverlays";
		if (this.isTransition()) {
			return
		}
		var a = {};
		if (this.graphType == "Heatmap" && this.data.z) {
			for (var b = 0; b < this.varOverlays.length; b++) {
				a[this.varOverlays[b]] = true
			}
			if (a[c]) {
				delete(a[c])
			} else {
				a[c] = true
			}
			this.varOverlays = this.getKeys(a);
			this.draw()
		}
	};
	this.showSampleOverlays = function(c) {
		this.functionCaller = "showSampleOverlays";
		if (this.isTransition()) {
			return
		}
		var b = {};
		if (this.data.x) {
			for (var a = 0; a < this.smpOverlays.length; a++) {
				b[this.smpOverlays[a]] = true
			}
			if (b[c]) {
				delete(b[c])
			} else {
				b[c] = true
			}
			this.smpOverlays = this.getKeys(b);
			this.draw()
		}
	};
	this.showSampleGroups = function(c) {
		var b = {};
		if (this.data.x) {
			for (var a = 0; a < this.groupingFactors.length; a++) {
				b[this.groupingFactors[a]] = true
			}
			if (b[c]) {
				delete(b[c])
			} else {
				b[c] = true
			}
			this.groupSamples(this.getKeys(b))
		}
	};
	this.showTreemapGroups = function(c) {
		this.functionCaller = "showTreemapGroups";
		if (this.isTransition()) {
			return
		}
		var a = {};
		for (var b = 0; b < this.treemapBy.length; b++) {
			a[this.treemapBy[b]] = true
		}
		if (a[c]) {
			delete(a[c])
		} else {
			a[c] = true
		}
		this.treemapBy = this.getKeys(a);
		this.draw()
	};
	this.showSampleSegregation = function(d) {
		var a = {};
		var c = this.segregateSamplesBy;
		for (var b = 0; b < this.segregateSamplesBy.length; b++) {
			a[this.segregateSamplesBy[b]] = true
		}
		if (a[d]) {
			delete(a[d])
		} else {
			a[d] = true
		}
		this.segregateSamplesBy = this.getKeys(a);
		if (this.validateSegregation()) {
			a = this.segregateSamplesBy;
			this.segregateSamplesBy = [];
			this.segregateSamples(a, false, true)
		} else {
			this.segregateSamplesBy = c
		}
	};
	this.showVariableSegregation = function(d) {
		var a = {};
		var c = this.segregateVariablesBy;
		for (var b = 0; b < this.segregateVariablesBy.length; b++) {
			a[this.segregateVariablesBy[b]] = true
		}
		if (a[d]) {
			delete(a[d])
		} else {
			a[d] = true
		}
		this.segregateVariablesBy = this.getKeys(a);
		if (this.validateSegregation()) {
			a = this.segregateVariablesBy;
			this.segregateVariablesBy = [];
			this.segregateVariables(a, false, true)
		} else {
			this.segregateVariablesBy = c
		}
	};
	this.changeColorScheme = function() {
		this.functionCaller = "changeColorScheme";
		if (this.isTransition()) {
			return
		}
		this.setColorScheme();
		this.resetMetaData();
		this.draw()
	};
	this.changeColorSpectrumZeroValue = function(a) {
		this.functionCaller = "changeColorSpectrumZeroValue";
		if (this.isTransition()) {
			return
		}
		this.colorSpectrumZeroValue = parseFloat(a[0]);
		this.setColorBrew(true);
		this.resetMetaData();
		this.draw()
	};
	this.changeColorSpectrum = function(a) {
		this.functionCaller = "changeColorSpectrum";
		this.removeMenus();
		if (this.isTransition()) {
			return
		}
		if (this.isInArray(a, this.colorSpectrum)) {
			if (this.colorSpectrum.length == 2) {
				alert("Ooops... Can't do... Need at least two colors!");
				return
			} else {
				this.colorSpectrum = this.removeFromArray(a, this.colorSpectrum)
			}
		} else {
			this.colorSpectrum.push(a)
		}
		this.setColorBrew(true);
		this.resetMetaData();
		this.draw()
	};
	this.changeTheme = function(c) {
		this.functionCaller = "changeTheme";
		if (this.isTransition()) {
			return
		}
		if (c && this.meta.def.themes.hasOwnProperty(c)) {
			var a = this.meta.def.themes[c];
			for (var b in a) {
				this[b] = a[b]
			}
			this.theme = c;
			this.setColorScheme();
			this.resetMetaData();
			this.draw()
		}
	};
	this.modifyColorProperties = function(b, e, g, c) {
		this.functionCaller = "modifyColorProperties";
		if (this.isTransition()) {
			return
		}
		var a = this.meta.data[g][e];
		var h = a.levels.length;
		if (this.meta.def.colorSchemes[b][h]) {
			a.colors = this.meta.def.colorSchemes[b][h]
		} else {
			var d = this.getKeys(this.meta.def.colorSchemes[b]);
			d.sort(function(i, f) {
				return i - f
			});
			if (h > d[d.length - 1]) {
				h--;
				while (!this.meta.def.colorSchemes[b][h]) {
					h--
				}
			} else {
				h++;
				while (!this.meta.def.colorSchemes[b][h]) {
					h++
				}
			}
			a.colors = this.meta.def.colorSchemes[b][h]
		}
		this.draw()
	};
	this.toggleAttribute = function(a, d, b) {
		this.functionCaller = "toggleAttribute";
		if (this.isTransition()) {
			return
		}
		this[a] = this[a] ? false : true;
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(a)) {
			this.layoutRestore[a] = this[a]
		}
		if (d) {
			this[d](b)
		} else {
			this.draw()
		}
	};
	this.changeAttribute = function(b, a, h, j, g) {
		this.functionCaller = "changeAttribute";
		if (this.isTransition()) {
			return
		}
		var f = {
			graphType: true
		};
		if (CanvasXpress.doc.P[b] && CanvasXpress.doc.P[b].T == "option" && CanvasXpress.doc.P[b].O[0] != "false") {
			this[b] = a
		} else {
			if (typeof(a) == "boolean" || this.hasOwnProperty(b)) {
				this[b] = this[b] && this[b] == a && !h ? false : this[b] && this[b] == a && h ? h : a
			} else {
				if (b && a) {
					this[b] = a
				}
			}
		}
		if (this.layoutValid && b == "graphType") {
			for (var e = 0; e < this.data.l.type.length; e++) {
				this.data.l.type[e] = a
			}
		}
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(b)) {
			this.layoutRestore[b] = this[b]
		}
		if (this.layoutValid || f.hasOwnProperty(b)) {
			this.removeMenus()
		}
		if (j) {
			this[j](g)
		} else {
			this.draw()
		}
	};
	this.changeTextColorAttribute = function(b, a) {
		this.updateTextColorAttribute(b, this.$(a).value)
	};
	this.updateTextColorAttribute = function(b, a) {
		this.functionCaller = "updateTextColorAttribute";
		if (this.isTransition()) {
			return
		}
		var f = b[0];
		var e = b[1];
		var d = b[2];
		if (f) {
			if (CanvasXpress.doc.P[f] && CanvasXpress.doc.P[f].T == "integer") {
				this[f] = a != "" ? parseInt(a) : null
			} else {
				if (CanvasXpress.doc.P[f] && CanvasXpress.doc.P[f].T == "float") {
					this[f] = a != "" ? parseFloat(a) : null
				} else {
					if (b == "height" || b == "width") {
						a = Number(a) + 18;
						if (!d) {
							d = [a]
						}
					} else {
						this[f] = a
					}
				}
			}
		} else {
			d.unshift(a)
		}
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(f)) {
			this.layoutRestore[f] = this[f]
		}
		if (e) {
			this[e](d)
		} else {
			this.setColorBrew(true);
			this.resetMetaData();
			this.draw()
		}
	};
	this.changeVariableInAxis = function(b, d) {
		this.functionCaller = "changeVariableInAxis";
		if (this.isTransition()) {
			return
		}
		if (this.xAxis && this.xAxis2) {
			var c = this.getObjectArray(this.xAxis);
			var a = this.getObjectArray(this.xAxis2);
			if (d == "xAxis") {
				if (a[b]) {
					if (this.xAxis2.length > 1) {
						this.removeVariablesFromAxis([b], "xAxis2")
					} else {
						alert("Cannot remove " + b + " from X-Axis 2");
						this.removeMenus();
						return
					}
					this.addVariablesToAxis([b], d)
				} else {
					if (c[b]) {
						if (this.xAxis.length > 1) {
							this.removeVariablesFromAxis([b], d)
						} else {
							alert("Cannot remove " + b + " from X-Axis");
							this.removeMenus();
							return
						}
					} else {
						this.addVariablesToAxis([b], d)
					}
				}
			} else {
				if (d == "xAxis2") {
					if (c[b]) {
						if (this.xAxis.length > 1) {
							this.removeVariablesFromAxis([b], "xAxis")
						} else {
							alert("Cannot remove " + b + " from X-Axis");
							this.removeMenus();
							return
						}
						this.addVariablesToAxis([b], d)
					} else {
						if (a[b]) {
							if (this.xAxis2.length > 1) {
								this.removeVariablesFromAxis([b], d)
							} else {
								alert("Cannot remove " + b + " from X-Axis 2");
								this.removeMenus();
								return
							}
						} else {
							this.addVariablesToAxis([b], d)
						}
					}
				}
			}
		}
		this.draw()
	};
	this.changeTransformRatio = function(a, b) {
		if (a == "sample") {
			if (this.ratioSampleReference == b) {
				this.ratioSampleReference = false;
				this.transform("reset")
			} else {
				this.ratioSampleReference = b;
				this.transform("ratio")
			}
		} else {
			if (a == "group") {
				if (this.ratioGroupReference == b) {
					this.ratioLevelReference = false;
					this.ratioGroupReference = false;
					this.transform("reset")
				} else {
					this.ratioGroupReference = b;
					this.ratioLevelReference = false;
					this.transform("ratio")
				}
				this.removeMenus()
			} else {
				if (a == "level") {
					this.transform("reset");
					if (this.ratioLevelReference == b) {
						this.ratioLevelReference = false
					} else {
						this.ratioLevelReference = b
					}
					this.transform("ratio")
				}
			}
		}
	};
	this.changeSampleInAxis = function(e, f, b) {
		this.functionCaller = "changeSampleInAxis";
		if (this.isTransition()) {
			return
		}
		if (this.graphType.match(/Scatter/)) {
			var c, a, g, d;
			c = this.getObjectArray(this.xAxis);
			a = this.getObjectArray(this.yAxis);
			if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
				g = this.getObjectArray(this.zAxis);
				d = true
			}
			if (f == "xAxis") {
				if (b) {
					this.switchSampleInAxis([e], f)
				} else {
					if (a[e] && !d) {
						if (this.yAxis.length > 1) {
							this.removeSamplesFromAxis([e], "yAxis")
						} else {
							alert("Cannot remove " + e + " from Y-Axis");
							this.removeMenus();
							return
						}
						this.addSamplesToAxis([e], f)
					} else {
						if (g && g[e] && !d) {
							if (this.zAxis.length > 1) {
								this.removeSamplesFromAxis([e], "zAxis")
							} else {
								alert("Cannot remove " + e + " from Z-Axis");
								this.removeMenus();
								return
							}
						} else {
							if (c[e] && !d) {
								if (this.xAxis.length > 1) {
									this.removeSamplesFromAxis([e], f)
								} else {
									alert("Cannot remove " + e + " from X-Axis");
									this.removeMenus();
									return
								}
							} else {
								if (d) {
									this[f] = [];
									this.addSamplesToAxis([e], f)
								} else {
									this.addSamplesToAxis([e], f)
								}
							}
						}
					}
				}
			} else {
				if (f == "yAxis") {
					if (b) {
						this.switchSampleInAxis([e], f)
					} else {
						if (c[e] && !d) {
							if (this.xAxis.length > 1) {
								this.removeSamplesFromAxis([e], "xAxis")
							} else {
								alert("Cannot remove " + e + " from X-Axis");
								this.removeMenus();
								return
							}
							this.addSamplesToAxis([e], f)
						} else {
							if (g && g[e] && !d) {
								if (this.zAxis.length > 1) {
									this.removeSamplesFromAxis([e], "zAxis")
								} else {
									alert("Cannot remove " + e + " from Z-Axis");
									this.removeMenus();
									return
								}
							} else {
								if (a[e] && !d) {
									if (this.yAxis.length > 1) {
										this.removeSamplesFromAxis([e], f)
									} else {
										alert("Cannot remove " + e + " from Y-Axis");
										this.removeMenus();
										return
									}
								} else {
									if (d) {
										this[f] = [];
										this.addSamplesToAxis([e], f)
									} else {
										this.addSamplesToAxis([e], f)
									}
								}
							}
						}
					}
				} else {
					if (f == "zAxis") {
						if (b) {
							this.switchSampleInAxis([e], f)
						} else {
							if (c[e] && !d) {
								if (this.xAxis.length > 1) {
									this.removeSamplesFromAxis([e], "xAxis")
								} else {
									alert("Cannot remove " + e + " from X-Axis");
									this.removeMenus();
									return
								}
								this.addSamplesToAxis([e], f)
							} else {
								if (a[e] && !d) {
									if (this.yAxis.length > 1) {
										this.removeSamplesFromAxis([e], "yAxis")
									} else {
										alert("Cannot remove " + e + " from Y-Axis");
										this.removeMenus();
										return
									}
								} else {
									if (g[e] && !d) {
										if (this.zAxis.length > 1) {
											this.removeSamplesFromAxis([e], f)
										} else {
											alert("Cannot remove " + e + " from Z-Axis");
											this.removeMenus();
											return
										}
									} else {
										if (d) {
											this[f] = [];
											this.addSamplesToAxis([e], f)
										} else {
											this.addSamplesToAxis([e], f)
										}
									}
								}
							}
						}
					}
				}
			}
			this.draw()
		}
	};
	this.showConfiguratorCategory = function(b, a) {
		this.removeMenus();
		this.addConfigurator(b);
		this.clickSearch(b);
		this.changeCategory(b, false, a);
		this.hideCategories()
	};
	this.setFontAttributeStyle = function(b, a) {
		this.functionCaller = "setFontAttributeStyle";
		if (this.isTransition()) {
			return
		}
		var c = this[b];
		if (a == "bold") {
			if (this[b].match(a)) {
				this[b] = this[b].replace("bold", "")
			} else {
				if (c == "italic") {
					this[b] = "bold italic"
				} else {
					this[b] = "bold"
				}
			}
		} else {
			if (a == "italic") {
				if (this[b].match(a)) {
					this[b] = this[b].replace("italic", "")
				} else {
					if (c == "bold") {
						this[b] = "bold italic"
					} else {
						this[b] = "italic"
					}
				}
			} else {
				this[b] = this[b].replace("bold italic", "");
				this[b] = this[b].replace("bold", "");
				this[b] = this[b].replace("italic", "")
			}
		}
		this.draw()
	};
	this.setFontAttributeSize = function(b, a) {
		this.functionCaller = "setFontAttributeSize";
		if (this.isTransition()) {
			return
		}
		if (a == "increase") {
			this[b] = this[b] * 1.1
		} else {
			this[b] = this[b] / 1.1
		}
		this.draw()
	};
	this.modifySummaryType = function(b) {
		this.functionCaller = "modifySummaryType";
		if (this.summaryType != b) {
			if (this.isGroupedData) {
				var a = this.groupingFactors;
				this.ungroupSamples(true);
				this.summaryType = b;
				this.meta.config.user.summaryType = b;
				this.groupSamples(a)
			} else {
				this.summaryType = b
			}
		}
	};
	this.showHideDendrogram = function(a) {
		this.functionCaller = "showHideDendrogram";
		if (this.isTransition()) {
			return
		}
		if (this[a]) {
			this[a] = false
		} else {
			this[a] = true
		}
		this.draw()
	};
	this.changeDendrogramPosition = function(a) {
		if (this[a] == "left") {
			this[a] = "right"
		} else {
			if (this[a] == "right") {
				this[a] = "left"
			} else {
				if (this[a] == "top") {
					this[a] = "bottom"
				} else {
					if (this[a] == "bottom") {
						this[a] = "top"
					}
				}
			}
		}
	};
	this.exploreData = function() {
		this.addDataExplorer();
		this.removeMenus()
	};
	this.segregateSamplesVariables = function(d) {
		this.functionCaller = "segregateSamplesVariables";
		if (this.isTransition()) {
			return
		}
		var b = this.getSegregationObject("x");
		var a = this.getSegregationObject("z");
		var m = b.idx;
		var l = a.idx;
		var h = b.nme;
		var n = a.nme;
		if (this.isGroupedData) {
			this.groupingFactorsStdBy = this.groupingFactors;
			this.ungroupSamples(true, true)
		}
		delete(this.data.l);
		this.data.l = {};
		this.data.l.smps = m;
		this.data.l.vars = l;
		this.data.l.weight = [];
		this.data.l.type = [];
		this.data.l.name = [];
		this.data.l.desc = [];
		if (this.groupingFactorsStdBy) {
			this.data.l.group = this.groupingFactorsStdBy
		}
		var k = this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[1] : 1 / m.length;
		var f = this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[0] : 1 / l.length;
		var g = this.xAxisTitle || "";
		for (var e = 0; e < m.length; e++) {
			for (var c = 0; c < l.length; c++) {
				this.data.l.weight.push([f, k]);
				this.data.l.type.push(this.graphType);
				this.data.l.name.push([h[e], n[c]]);
				this.data.l.desc.push(g)
			}
		}
		this.layoutIndices = false;
		this.layoutComb = true;
		this.layout = m.length + "X" + l.length;
		this.isValidLayout();
		if (!d) {
			this.draw()
		}
	};
	this.getSegregationObject = function(j) {
		var g = {
			lay: {},
			idx: [],
			nme: [],
			n: 0
		};
		var f = j == "x" ? "smps" : "vars";
		var b = j == "x" ? this.segregateSamplesBy[0] : this.segregateVariablesBy[0];
		var h = 0;
		if (b == "variable") {
			j = "y";
			b = "vars"
		} else {
			if (b == "sample") {
				j = "y";
				b = "smps"
			}
		}
		for (var e = 0; e < this.data[j][b].length; e++) {
			var d = this.data[j][b][e];
			if (!g.lay.hasOwnProperty(d)) {
				g.lay[d] = [];
				g.n++
			}
			g.lay[d].push(this.data.y[f][e])
		}
		for (var d in g.lay) {
			g.nme.push(d);
			g.idx.push(g.lay[d])
		}
		return g
	};
	this.segregate = function(d, g, m, A) {
		this.functionCaller = "segregate";
		if (this.isTransition()) {
			return
		}
		var H = "segregate" + d + "By";
		var f = "desegregate" + d;
		var b = d == "Samples" ? "segregateVariablesBy" : "segregateSamplesBy";
		var u = d == "Samples" ? "x" : "z";
		var K = this[H];
		if (A) {
			this.modifyObjectArray(g, false, H, true, false);
			if (this[H].length == 0) {
				this[f](m);
				return
			}
		} else {
			if (this[H].length == 0) {
				if (!this.isArray(g)) {
					g = [g]
				}
				this[H] = g;
				if (!this.validateSegregation()) {
					this[H] = K;
					return
				}
			}
		}
		if (this.isGroupedData) {
			this.groupingFactorsStdBy = this.groupingFactors;
			this.ungroupSamples(true, true)
		}
		this.resetLayout();
		if (this[H].length == 1) {
			var F = this.getSegregationObject(u);
			if (this[b].length > 0) {
				this.segregateSamplesVariables(m);
				m = true
			} else {
				this.data.l = {};
				if (d == "Samples") {
					this.data.l.smps = []
				} else {
					this.data.l.vars = []
				}
				this.data.l.weight = [];
				this.data.l.type = [];
				this.data.l.name = [];
				this.data.l.desc = [];
				if (this.groupingFactorsStdBy) {
					this.data.l.group = this.groupingFactorsStdBy
				}
				for (var w in F.lay) {
					if (d == "Samples") {
						this.data.l.smps.push(F.lay[w])
					} else {
						this.data.l.vars.push(F.lay[w])
					}
					this.data.l.type.push(this.graphType);
					this.data.l.name.push(w);
					this.data.l.desc.push(this.xAxisTitle || "")
				}
				this.layoutIndices = false;
				this.layoutComb = this.graphType == "Circular" ? false : true;
				this.showAnimationTemp = this.showAnimation;
				this.showAnimation = false;
				var z = d == "Samples" ? this.data.l.smps.length : this.data.l.vars.length;
				var w = Math.ceil(Math.sqrt(z));
				var x = w * (w - 1) >= z ? w - 1 : w;
				var J = w;
				this.layout = x + "X" + J;
				for (var w in F.lay) {
					this.data.l.weight.push([this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[1] : 1 / J, this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[0] : 1 / x])
				}
				this.isValidLayout()
			}
		} else {
			var B = {};
			var q = d == "Samples" ? this.getSampleLevelsByAnnotation(this.segregateSamplesBy[0]) : this.getVariableLevelsByAnnotation(this.segregateVariablesBy[0]);
			var I = d == "Samples" ? this.getSampleLevelsByAnnotation(this.segregateSamplesBy[1]) : this.getVariableLevelsByAnnotation(this.segregateVariablesBy[1]);
			var p = 1 / q.length;
			var a = 1 / I.length;
			var G = this.xAxisTitle || "";
			for (var E = 0; E < q.length; E++) {
				B[q[E]] = {};
				for (var D = 0; D < I.length; D++) {
					B[q[E]][I[D]] = [];
					if (d == "Samples") {
						for (var C = 0; C < this.data.y.smps.length; C++) {
							if (this.data[u][this[H][0]][C] == q[E] && this.data[u][this[H][1]][C] == I[D]) {
								B[q[E]][I[D]].push(this.data.y.smps[C])
							}
						}
					} else {
						for (var C = 0; C < this.data.y.vars.length; C++) {
							if (this.data[u][this[H][0]][C] == q[E] && this.data[u][this[H][1]][C] == I[D]) {
								B[q[E]][I[D]].push(this.data.y.vars[C])
							}
						}
					}
				}
			}
			var h = 0;
			for (var D = 0; D < I.length; D++) {
				var y = 0;
				for (var E = 0; E < q.length; E++) {
					if (B[q[E]][I[D]].length > 0) {
						y++
					}
				}
				h = Math.max(h, y)
			}
			var e = 0;
			for (var E = 0; E < q.length; E++) {
				var o = 0;
				for (var D = 0; D < I.length; D++) {
					if (B[q[E]][I[D]].length > 0) {
						o++
					}
				}
				e = Math.max(e, o)
			}
			if (this.layoutRemoveEmpty) {
				p = 1 / h;
				a = 1 / e
			}
			this.data.l = {};
			if (d == "Samples") {
				this.data.l.smps = []
			} else {
				this.data.l.vars = []
			}
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.name = [];
			this.data.l.desc = [];
			if (this.groupingFactorsStdBy) {
				this.data.l.group = this.groupingFactorsStdBy
			}
			for (var E = 0; E < q.length; E++) {
				for (var D = 0; D < I.length; D++) {
					if (this.layoutRemoveEmpty) {
						if (B[q[E]][I[D]].length < 1) {
							continue
						}
					}
					this.data.l.weight.push([this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[1] : a, this.layoutTopology ? 1 / this.layoutTopology.split(/X/i)[0] : p]);
					this.data.l.type.push(this.graphType);
					this.data.l.name.push([q[E], I[D]]);
					this.data.l.desc.push(G);
					if (d == "Samples") {
						this.data.l.smps.push(B[q[E]][I[D]])
					} else {
						this.data.l.vars.push(B[q[E]][I[D]])
					}
				}
			}
			this.layoutIndices = false;
			this.layoutComb = this.graphType == "Circular" ? false : true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.layout = this.layoutRemoveEmpty ? h + "X" + e : q.length + "X" + I.length;
			this.isValidLayout()
		}
		if (!m) {
			this.draw()
		}
	};
	this.desegregate = function(c, d) {
		this.functionCaller = "desegregate";
		if (this.isTransition()) {
			return
		}
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		var b = c == "Samples" ? "segregateSamplesBy" : "segregateVariablesBy";
		var a = c == "Samples" ? "segregateSamples" : "segregateVariables";
		if (this[b].length > 0) {
			this[a](this[b], d)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!d) {
			this.draw()
		}
	};
	this.desegregateSamples = function(a) {
		this.functionCaller = "desegregateSamples";
		if (this.isTransition()) {
			return
		}
		this.desegregate("Samples", a);
		return;
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		if (this.segregateVariablesBy.length > 0) {
			this.segregateVariables(this.segregateVariablesBy, a)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!a) {
			this.draw()
		}
	};
	this.segregateSamples = function(c, b, a) {
		this.segregate("Samples", c, b, a);
		return
	};
	this.desegregateVariables = function(a) {
		this.functionCaller = "desegregateVariables";
		if (this.isTransition()) {
			return
		}
		this.desegregate("Variables", a);
		return;
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		if (this.segregateSamplesBy.length > 0) {
			this.segregateSamples(this.segregateSamplesBy, a)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!a) {
			this.draw()
		}
	};
	this.segregateVariables = function(b, c, a) {
		this.segregate("Variables", b, c, a);
		return
	};
	this.changeLayoutType = function(a) {
		this.functionCaller = "changeLayoutType";
		this.removeMenus();
		this.unsetScatterPlotMatrix();
		this.scatterPlotMatrixType = a;
		this.scatterPlotMatrix = true;
		this.setScatterPlotMatrix();
		this.draw()
	};
	this.unsetScatterPlotMatrix = function() {
		if (this.graphType.match(/Scatter/)) {
			if (this.xAxisTemp && this.xAxisTemp.length > 0) {
				this.xAxis = this.xAxisTemp;
				this.xAxisTmp = []
			}
			if (this.yAxisTemp && this.yAxisTemp.length > 0) {
				this.yAxis = this.yAxisTemp;
				this.yAxisTmp = []
			}
			if (this.zAxisTemp && this.zAxisTemp.length > 0) {
				this.zAxis = this.zAxisTemp;
				this.zAxisTmp = []
			}
			if (!this.xAxis || !this.yAxis) {
				this.xAxis = [];
				this.yAxis = [];
				this.xAxisIndices = [];
				this.yAxisIndices = [];
				this.xAxis = [this.data.y.smps[0]];
				for (var a = 1; a < this.data.y.smps.length; a++) {
					this.yAxis.push(this.data.y.smps[a])
				}
				this.xAxisIndices = this.getSampleIndices(this.xAxis);
				this.yAxisIndices = this.getSampleIndices(this.yAxis);
				this.initAxes()
			}
			this.scatterPlotMatrix = false;
			if (this.showAnimationTemp) {
				this.showAnimation = this.showAnimationTemp
			}
			this.resetLayout();
			this.isValidLayout()
		}
	};
	this.setScatterPlotMatrix = function() {
		if (this.graphType.match(/Scatter/)) {
			var e, b, h, k, g;
			var a = this.scatterPlotMatrixType.match(/complete/) ? this.data.y.smps.length : this.data.y.smps.length - 1;
			var l = Math.ceil(Math.sqrt(a));
			this.data.l = {};
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			this.xAxisTemp = this.xAxisTemp || this.xAxis;
			this.xAxis = [];
			this.yAxisTemp = this.yAxisTemp || this.yAxis;
			this.yAxis = [];
			this.zAxisTemp = this.zAxisTemp || this.zAxis;
			this.zAxis = [];
			if (this.scatterPlotMatrixType.match(/complete/)) {
				k = a;
				h = a;
				e = 1 / h;
				b = 1 / k;
				for (var f = 0; f < a; f++) {
					for (var d = 0; d < a; d++) {
						this.data.l.weight.push([e, b]);
						this.data.l.desc.push(this.xAxisTitle || "");
						this.data.l.type.push(this.graphType);
						if (f == d) {
							this.data.l.smps.push({})
						} else {
							if (this.scatterPlotMatrixType.match(/Upper/)) {
								if (d > f) {
									this.data.l.smps.push({
										xAxis: [this.data.y.smps[d]],
										yAxis: [this.data.y.smps[f]]
									})
								} else {
									this.data.l.smps.push({})
								}
							} else {
								if (this.scatterPlotMatrixType.match(/Lower/)) {
									if (f > d) {
										this.data.l.smps.push({
											xAxis: [this.data.y.smps[d]],
											yAxis: [this.data.y.smps[f]]
										})
									} else {
										this.data.l.smps.push({})
									}
								} else {
									this.data.l.smps.push({
										xAxis: [this.data.y.smps[d]],
										yAxis: [this.data.y.smps[f]]
									})
								}
							}
						}
					}
				}
			} else {
				k = l * (l - 1) >= a ? l - 1 : l;
				h = l;
				e = 1 / h;
				b = 1 / k;
				g = 1;
				for (var f = 0; f < k; f++) {
					for (var d = 0; d < h; d++) {
						this.data.l.weight.push([e, b]);
						this.data.l.desc.push(this.xAxisTitle || "");
						this.data.l.type.push(this.graphType);
						if (this.data.y.smps[g]) {
							this.data.l.smps.push({
								xAxis: [this.data.y.smps[0]],
								yAxis: [this.data.y.smps[g]]
							})
						} else {
							this.data.l.smps.push({});
							break
						}
						g++
					}
				}
			}
			this.layout = k + "X" + h;
			this.layoutIndices = false;
			this.layoutComb = true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.isValidLayout()
		}
	};
	this.setMultiplePies = function() {
		if (this.graphType.match(/Pie/)) {
			var f, h;
			var g = this.xAxis.length;
			if (this.layout) {
				var b = this.layout.split(/X/i);
				f = parseInt(b[0]);
				h = parseInt(b[1]);
				if (f * h < g) {
					f = Math.ceil(Math.sqrt(g));
					h = Math.floor(Math.sqrt(g));
					this.layout = f + "X" + h
				}
			} else {
				f = Math.ceil(Math.sqrt(g));
				h = Math.floor(Math.sqrt(g));
				this.layout = f + "X" + h
			}
			var a = 1 / f;
			var e = 1 / h;
			delete(this.layoutParams);
			delete(this.data.l);
			this.data.l = {};
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			for (var d = 0; d < g; d++) {
				this.data.l.smps.push([this.xAxis[d]]);
				this.data.l.weight.push([e, a]);
				this.data.l.desc.push(this.xAxisTitle || "");
				this.data.l.type.push(this.graphType)
			}
			this.layoutIndices = false;
			this.layoutComb = true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.isValidLayout()
		}
	};
	this.createContour = function() {
		this.functionCaller = "createContour";
		if (this.isTransition()) {
			return
		}
		var l, A, r, G, f, q, F, m, s;
		if (this.graphType.match(/Scatter/)) {
			l = this.contourXBinSize || this.freedmanDiaconis(this.getDataForSmpGrpAtIndex(this.xAxisIndices[this.xAxisCurrent]));
			A = this.contourYBinSize || this.freedmanDiaconis(this.getDataForSmpGrpAtIndex(this.yAxisIndices[this.yAxisCurrent]));
			r = this.xAxisIndices[this.xAxisCurrent];
			G = this.yAxisIndices[this.yAxisCurrent];
			f = this.zAxisIndices && this.zAxisIndices.length > 0 ? this.zAxisIndices[this.zAxisCurrent] : false;
			q = Math.ceil(this.xAxisRange / l);
			F = Math.ceil(this.yAxisRange / A)
		} else {
			s = this.isGroupedData ? this.data.w : this.data.y;
			m = this.isGroupedData ? this.grpIndices : this.smpIndices;
			l = 1;
			A = 1;
			q = m.length;
			F = this.varIndices.length
		}
		var H = [];
		var a = [];
		var w = [];
		var b = [];
		for (var C = 0; C < q; C++) {
			w.push(C)
		}
		for (var C = 0; C < F; C++) {
			b.push(C)
		}
		if (this.graphType.match(/Scatter/)) {
			for (var C = 0; C < q; C++) {
				H[C] = [];
				for (var B = 0; B < F; B++) {
					H[C][B] = 0
				}
			}
			for (var C = 0; C < this.varIndices.length; C++) {
				var p = this.varIndices[C];
				var g = this.getDataAtPos(p, r) - this.xAxisMin;
				var u = this.getDataAtPos(p, G) - this.yAxisMin;
				var o = Math.min(Math.floor(g / l), q - 1);
				var n = Math.min(Math.floor(u / A), F - 1);
				var k = this.zAxisIndices && this.zAxisIndices.length > 0 ? this.getDataAtPos(p, f) : 1;
				H[o][n] += k
			}
			for (var C = 0; C < q; C++) {
				for (var B = 0; B < F; B++) {
					a.push(H[C][B])
				}
			}
		} else {
			this.setRangeData();
			for (var C = 0; C < m.length; C++) {
				H[C] = [];
				for (var B = 0; B < this.varIndices.length; B++) {
					H[C][B] = this.getDataAtPos(this.varIndices[B], m[C]) - this.minData;
					a.push(H[C][B])
				}
			}
		}
		var D = this.range(a);
		var d = this.contourZBin || this.freedmanDiaconis(a);
		var h = [];
		var e = Math.ceil(D[1] / d);
		for (var C = 0; C < e; C++) {
			h.push(C * d)
		}
		var E = new Conrec();
		if (this.graphType.match(/Scatter/)) {
			E.contour(H, 0, q - 1, 0, F - 1, w, b, h.length, h)
		} else {
			E.contour(this.transpose(H), 0, F - 1, 0, q - 1, b, w, h.length, h)
		}
		this.configStndBy = this.getConfig();
		this.data.y.contour = {};
		this.data.y.contour.list = E.contourList();
		if (this.graphType.match(/Scatter/)) {
			this.data.y.contour.xs = q - 1;
			this.data.y.contour.ys = F - 1;
			this.configStndBy.xAxisExact = this.xAxisExact;
			this.configStndBy.yAxisExact = this.yAxisExact;
			this.xAxisExact = true;
			this.yAxisExact = true
		} else {
			this.data.y.contour.xs = F - 1;
			this.data.y.contour.ys = q - 1;
			this.graphType = "Heatmap"
		}
		this.isContour = true;
		this.draw()
	};
	this.removeContour = function() {
		this.functionCaller = "removeContour";
		if (this.data.y.contour) {
			delete this.data.y.contour;
			this.switchData();
			this.isContour = false;
			this.draw()
		}
	};
	this.createHierarchy = function(d, h) {
		var e = this;
		var k = this.meta.data.x;
		var g = this.colorBy && k && k.hasOwnProperty(this.colorBy);
		var c = d && k && k.hasOwnProperty(d[0]);
		var f = g ? this.getCustomColorScheme(k[this.colorBy].colors.length) : c ? this.getCustomColorScheme(k[d[0]].colors.length) : this.colors;
		var a = g ? k[this.colorBy].order : c ? k[d[0]].order : false;
		if (!h) {
			h = 0
		}
		var j = function(m, n) {
			if (a) {
				return a.hasOwnProperty(m) ? f[a[m]] : n ? n : e.missingDataColor
			} else {
				return n || e.missingDataColor
			}
		};
		var i = function(s, x, p) {
			if (s.length > 0) {
				if (d && x + 1 < d.length) {
					x++;
					var w = e.getSampleLevelsByAnnotation(d[x], s);
					var r = [];
					var z = 0;
					for (var q = 0; q < w.length; q++) {
						var u = j(w[q], p);
						var y = e.getSamplesByAnnotationLevel(d[x], w[q], s);
						var m = i(y, x, u);
						z += m[1];
						r.push({
							name: w[q],
							children: m[0],
							value: m[1],
							depth: x,
							color: u,
							tooltip: "<b>" + w[q] + "</b><br>" + e.bestFormatNumber(m[1]) + " (" + e.bestFormatNumber(m[1] * 100 / l) + "%)"
						})
					}
				} else {
					var r = [];
					var z = 0;
					for (var q = 0; q < s.length; q++) {
						var n = e.getDataAtPos(h, s[q]);
						z += n;
						r.push({
							name: e.data.y.smps[s[q]],
							value: n,
							depth: x + 1,
							color: f[s[q] % f.length],
							tooltip: "<b>" + e.data.y.smps[s[q]] + "</b><br>" + e.bestFormatNumber(n) + " (" + e.bestFormatNumber(n * 100 / l) + "%)"
						})
					}
				}
				return [r, z]
			}
		};
		var l = this.sum(this.data.y.data[h], true);
		var b = i(this.smpIndices, -1);
		return [{
			name: "root",
			children: b[0],
			value: b[1],
			depth: -1,
			color: this.missingDataColor
		}]
	};
	this.createDOE = function(d) {
		this.functionCaller = "createDOE";
		if (this.isTransition()) {
			return
		}
		var b, f, m;
		var n = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var j = this.plotByVariable;
		var k = this.initialGraphType || this.graphType;
		if (n) {
			this.ungroupSamples(true, false, true)
		}
		this.resetFilters();
		if (k.match(/Scatter/i)) {
			this.isDOE = 2;
			b = this.varIndices;
			dat = this.data.z
		} else {
			this.isDOE = 1;
			b = this.smpIndices;
			dat = this.data.x
		}
		m = this.getKeys(dat);
		if (this.includeDOE.length < 1) {
			for (var g = 0; g < m.length; g++) {
				if (g >= this.maxDOENumber) {
					break
				}
				this.includeDOE.push(m[g])
			}
		}
		var a = this.layout.split("X")[0];
		var h = this.layout.split("X")[1];
		if (this.includeDOE.length + (this.showDOEData ? 1 : 0) > (a * h)) {
			a = Math.ceil(Math.sqrt(this.includeDOE.length + (this.showDOEData ? 1 : 0)));
			h = a * (a - 1) >= (this.includeDOE.length + (this.showDOEData ? 1 : 0)) ? a - 1 : a;
			this.layout = a + "X" + h
		}
		delete(this.layoutParams);
		delete(this.data.l);
		this.data.l = {};
		if (this.showDOEData) {
			this.data.l.smps = [
				[b]
			];
			this.data.l.weight = [
				[1 / h, 1 / a]
			];
			this.data.l.type = [this.graphType];
			this.data.l.desc = [this.xAxisTitle || ""];
			this.data.l.doe = b
		} else {
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			this.data.l.doe = b
		}
		for (var g = 0; g < this.includeDOE.length; g++) {
			this.data.l.smps.push([this.includeDOE[g]]);
			this.data.l.weight.push([1 / h, 1 / a]);
			this.data.l.desc.push(this.xAxisTitle || "");
			if (this.isNumeric(dat[this.includeDOE[g]])) {
				this.data.l.type.push("Scatter2D")
			} else {
				var e = this.unique(dat[this.includeDOE[g]]);
				this.data.l.type.push(e.length < this.maxPieSectors ? "Pie" : "Treemap")
			}
		}
		this.layoutIndices = false;
		this.layoutComb = true;
		this.plotByVariable = false;
		this.isValidLayout();
		this.dataStndBy = this.data;
		this.configStndBy = this.getConfig();
		this.configStndBy.groupingFactors = n;
		this.configStndBy.plotByVariable = j;
		this.showAnimation = false;
		if (!this.initialGraphType) {
			this.initialGraphType = this.graphType
		}
		this.title = "";
		this.subtitle = "";
		if (!d) {
			this.removeMenus();
			this.draw()
		}
	};
	this.removeDOE = function(b) {
		this.functionCaller = "removeDOE";
		if (this.isTransition()) {
			return
		}
		var a = this.configStndBy ? this.configStndBy.groupingFactors : false;
		this.graphType = this.initialGraphType;
		this.isDOE = false;
		this.isPie = false;
		this.isPieGroup = false;
		this.isHistogram = false;
		this.isCreateHistogram = false;
		this.layoutValid = false;
		this.removeMenus();
		this.switchData();
		delete(this.data.l);
		this.layoutComb = false;
		this.isValidLayout();
		if (a) {
			this.groupSamples(a, false, false, false, b)
		} else {
			if (!b) {
				this.draw()
			}
		}
	};
	this.resetDOE = function() {
		this.functionCaller = "resetDOE";
		if (this.isTransition()) {
			return
		}
		var a = [];
		var b = this.isDOE > 1 ? this.dataStndBy.y.vars.length : this.dataStndBy.y.smps.length;
		for (var c = 0; c < b; c++) {
			a.push(c)
		}
		this.dataStndBy.l.doe = a;
		if (this.configStndBy.groupingFactors.length > 0) {
			this.layoutComb = false;
			this.groupSamples(this.configStndBy.groupingFactors, false, false, false, true);
			this.layoutComb = true
		}
		this.toDoFilter = {};
		this.draw()
	};
	this.modifyDOE = function(d) {
		this.functionCaller = "modifyDOE";
		if (this.isTransition()) {
			return
		}
		var b = this.getObjectArray(this.includeDOE);
		if (b.hasOwnProperty(d)) {
			var a = [];
			for (var c = 0; c < this.includeDOE.length; c++) {
				if (this.includeDOE[c] != d) {
					a.push(this.includeDOE[c])
				}
			}
			this.includeDOE = a
		} else {
			this.includeDOE.push(d)
		}
		while (this.includeDOE.length > this.maxDOENumber + (this.showDOEData ? 1 : 0)) {
			this.includeDOE.shift()
		}
		this.createDOE(true);
		this.draw()
	};
	this.createTreemap = function(j) {
		this.functionCaller = "createTreemap";
		if (this.isTransition()) {
			return
		}
		var b = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var h = {
			data: {},
			vars: {}
		};
		var f = {
			y: {
				data: [
					[]
				],
				vars: [],
				smps: [],
				treemap: []
			}
		};
		if (b) {
			this.ungroupSamples(true)
		}
		var a, e;
		if (this.isDOE) {
			a = this.dataStndBy.l.doe;
			e = this.isDOE > 1 ? this.dataStndBy.z[j] : this.dataStndBy.x[j]
		} else {
			a = this.smpIndices;
			e = this.data.x[j]
		}
		for (var d = 0; d < a.length; d++) {
			var g = e[a[d]];
			if (!h.data[g]) {
				h.data[g] = 0;
				h.vars[g] = []
			}
			h.data[g]++;
			h.vars[g].push(a[d])
		}
		f.y.vars.push(j);
		for (var d in h.data) {
			f.y.smps.push(d);
			f.y.data[0].push(h.data[d]);
			f.y.treemap.push(h.vars[d])
		}
		if (this.isDOE) {
			this.graphType = "Treemap";
			this.initializeData(f)
		} else {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			this.configStndBy.isTreemap = false;
			this.data = {};
			this.graphType = "Treemap";
			this.isTreemap = true;
			this.isTreemapGroup = b;
			this.initializeData(f);
			this.removeMenus();
			this.draw()
		}
	};
	this.removeTreemap = function() {
		this.functionCaller = "removeTreemap";
		if (this.isTransition()) {
			return
		}
		var a = this.isTreemapGroup;
		this.isTreemap = false;
		this.isTreemapGroup = false;
		this.removeMenus();
		this.switchData();
		if (a) {
			this.groupSamples(a)
		} else {
			this.draw()
		}
	};
	this.createPie = function(j) {
		this.functionCaller = "createPie";
		if (this.isTransition()) {
			return
		}
		var d = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var b = {
			data: {},
			smps: {}
		};
		var g = {
			y: {
				data: [],
				vars: [],
				smps: [],
				pie: []
			}
		};
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				that.createPie(j)
			}, 200)
		} else {
			if (d) {
				this.ungroupSamples(true)
			}
			var a, f;
			if (this.isDOE) {
				a = this.dataStndBy.l.doe;
				f = this.isDOE > 1 ? this.dataStndBy.z[j] : this.dataStndBy.x[j]
			} else {
				a = this.smpIndices;
				f = this.data.x[j]
			}
			for (var e = 0; e < a.length; e++) {
				var h = f[a[e]];
				if (!b.data[h]) {
					b.data[h] = 0;
					b.smps[h] = []
				}
				b.data[h]++;
				b.smps[h].push(a[e])
			}
			g.y.smps.push(j);
			for (var e in b.data) {
				g.y.vars.push(e);
				g.y.data.push([b.data[e]]);
				g.y.pie.push(b.smps[e])
			}
			if (this.isDOE) {
				this.graphType = "Pie";
				this.initializeData(g)
			} else {
				this.dataStndBy = this.data;
				this.configStndBy = this.getConfig();
				this.configStndBy.isPie = false;
				this.data = {};
				this.graphType = "Pie";
				this.isPie = true;
				this.isPieGroup = d;
				this.initializeData(g);
				this.removeMenus();
				this.draw()
			}
		}
	};
	this.removePie = function() {
		this.functionCaller = "removePie";
		if (this.isTransition()) {
			return
		}
		var a = this.isPieGroup;
		this.isPie = false;
		this.isPieGroup = false;
		this.removeMenus();
		this.switchData();
		if (a) {
			this.groupSamples(a)
		} else {
			this.draw()
		}
	};
	this.getViolin = function(i, c) {
		if (i && i.length > 0) {
			var h, g, f, a;
			var e = this.range(i);
			if (c) {
				h = c;
				g = this.pretty((e[1] - e[0]) / h);
				f = this.getHistogramBin(e[0], g);
				a = this.getHistogramBin(g + e[1], g)
			} else {
				g = this.freedmanDiaconis(i);
				f = this.getHistogramBin(e[0], g);
				a = this.getHistogramBin(g + e[1], g);
				h = (a - f) / g
			}
			return {
				len: i.length,
				size: g,
				kde: this.kde(this.histogramDensityKernel, false, [f, a], g, i)
			}
		} else {
			return false
		}
	};
	this.modifyHistogram = function() {
		if (this.isHistogram) {
			var d = this.isCreateHistogram[2];
			var a = this.isCreateHistogram[3];
			var b = this.histogramBins;
			var c = this.histogramStagger;
			this.removeHistogram();
			this.histogramBins = b;
			this.histogramStagger = c;
			if (d) {
				this.transpose()
			}
			this.createHistogram(d, a)
		}
	};
	this.createHistogramTr = function() {
		var a = this.groupingFactors;
		this.transpose();
		this.createHistogram(true, a)
	};
	this.createHistogram = function(c, d, h) {
		this.functionCaller = "createHistogram";
		if (this.isTransition()) {
			return
		}
		var k = this;
		var b = [];
		var C = [];
		var f = [];
		var w = [];
		var E = [];
		var x, A, q, B, a, o, e, p, D, m, s, u;
		var F = {};
		var G = {};
		G.y = {};
		G.y.data = [];
		G.y.vars = [];
		G.y.smps = [];
		G.y.histogram = [];
		G.y.kde = [];
		G.y.stats = [];
		G.y.all = [];
		if (!CanvasXpress.cacheImagesReady || !this.getAxisIncrements) {
			setTimeout(function() {
				k.createHistogram(c, d)
			}, 200)
		} else {
			if (this.isDOE && h) {
				p = this.dataStndBy.l.doe;
				D = this.isDOE > 1 ? this.dataStndBy.z[h] : this.dataStndBy.x[h];
				for (var z = 0; z < p.length; z++) {
					var l = D[p[z]];
					if (l != null && l != "" && !isNaN(l)) {
						b.push(l)
					}
				}
			} else {
				for (var z = 0; z < this.smpIndices.length; z++) {
					for (var y = 0; y < this.varIndices.length; y++) {
						var l = this.data.y.data[this.varIndices[y]][this.smpIndices[z]];
						if (l != null && l != "" && !isNaN(l)) {
							b.push(l)
						}
					}
				}
			}
			o = this.range(b);
			if (this.histogramBins) {
				u = this.histogramBins;
				q = this.pretty(((o[1] * 10) - (o[0] * 10)) / (u * 10));
				x = this.getHistogramBin(o[0], q);
				A = this.getHistogramBin(q + o[1], q);
				u = 1;
				while (x + (q * u) < A) {
					u++
				}
			} else {
				q = this.freedmanDiaconis(b);
				x = this.getHistogramBin(o[0], q);
				A = this.getHistogramBin(q + o[1], q);
				u = ((A * 10) - (x * 10)) / (q * 10)
			}
			e = this.isDOE && h ? 1 : this.smpIndices.length;
			for (var z = 0; z <= u; z++) {
				F[x + (q * z)] = z;
				G.y.vars.push("Bin" + (z + 1) + " (" + (((x * 10) + (q * z * 10)) / 10) + " - " + (((x * 10) + (q * (z + 1) * 10)) / 10) + ")");
				G.y.data[z] = [];
				G.y.data[z][0] = (q * (z + 1) * 10) / 10;
				G.y.histogram[z] = [];
				for (var y = 0; y < e; y++) {
					G.y.histogram[z][y] = []
				}
			}
			G.y.smps.push("Bin");
			C.push("Bin");
			if (this.isDOE && h) {
				G.y.smps.push(h);
				f.push(h);
				var g = [];
				for (var z = 0; z <= u; z++) {
					g[z] = 0
				}
				for (var z = 0; z < p.length; z++) {
					var l = D[p[z]];
					if (l != null && l != "" && !isNaN(l)) {
						var r = F[this.getHistogramBin(l, q)];
						g[r]++;
						G.y.histogram[r][0].push(z);
						G.y.all.push(z)
					}
				}
				w = [1];
				for (var y = 0; y < u; y++) {
					G.y.data[y][1] = g[y]
				}
				if (this.showHistogramDensity) {
					G.y.kde.push(this.kde(this.histogramDensityKernel, false, [x, A], q, b));
					G.y.stats.push([b.length, q])
				}
			} else {
				for (var z = 0; z < this.smpIndices.length; z++) {
					s = 0;
					b = [];
					G.y.smps.push(this.data.y.smps[this.smpIndices[z]]);
					f.push(this.data.y.smps[this.smpIndices[z]]);
					var g = [];
					for (var y = 0; y <= u; y++) {
						g[y] = 0
					}
					for (var y = 0; y < this.varIndices.length; y++) {
						var l = this.data.y.data[this.varIndices[y]][this.smpIndices[z]];
						if (l != null && l != "" && !isNaN(l)) {
							var r = Math.min(Math.floor((l - x) / q), u - 1);
							b.push(parseFloat(this.data.y.data[this.varIndices[y]][this.smpIndices[z]]));
							if (!isNaN(r)) {
								g[r]++;
								G.y.histogram[r][z].push(this.varIndices[y]);
								G.y.all.push(this.varIndices[y])
							}
							s++
						}
					}
					w.push(s);
					for (var y = 0; y <= u; y++) {
						G.y.data[y][z + 1] = g[y]
					}
					if (this.showHistogramDensity) {
						G.y.kde.push(this.kde(this.histogramDensityKernel, false, [x, A], q, b));
						G.y.stats.push([b.length, q])
					}
				}
			}
			for (var z = 0; z < w.length; z++) {
				E.push(z)
			}
			E.sort(function(j, i) {
				return w[i] - w[j]
			});
			if (!this.isDOE) {
				this.dataStndBy = this.data;
				this.configStndBy = this.getConfig();
				this.configStndBy.isCreateHistogram = false;
				this.configStndBy.isHistogram = false
			}
			this.data = {};
			this.graphType = "Scatter2D";
			this.isHistogram = true;
			this.isCreateHistogram = [x, q, c, d, E];
			this.xAxis = C;
			this.yAxis = f;
			this.setMinX = null;
			this.setMaxX = null;
			this.setMinX2 = null;
			this.setMaxX2 = null;
			this.setMinY = null;
			this.setMaxY = null;
			this.setMinZ = null;
			this.setMaxZ = null;
			this.xAxisExact = true;
			this.initializeData(G);
			if (!this.isDOE) {
				this.removeMenus();
				this.draw()
			}
		}
	};
	this.removeHistogram = function() {
		this.functionCaller = "removeHistogram";
		if (this.isTransition()) {
			return
		}
		var d = this.isCreateHistogram[2];
		var b = this.isCreateHistogram[3];
		var c = this.histogramDensityKernel;
		var a = this.showHistogramDensity;
		this.removeMenus();
		this.switchData(false, true);
		this.histogramDensityKernel = c;
		this.showHistogramDensity = a;
		if (d) {
			this.transpose(false, true)
		}
		if (b) {
			this.groupSamples(b)
		} else {
			this.draw()
		}
	};
	this.correlateData = function(d, c) {
		this.functionCaller = "correlateData";
		if (this.isTransition()) {
			return
		}
		if (this.graphType.match(/Scatter/i)) {
			this.addRegressionLine()
		} else {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			var b = this.groupingFactors;
			if (c) {
				if (d) {
					this.switchAnnotationToVar(c)
				} else {
					this.switchAnnotationToSmp(c)
				}
			}
			var a = d ? this.data.y.vars : this.data.y.smps;
			this.graphType = "Scatter2D";
			this.type2D = "XY";
			if (b) {
				this.ungroupSamples(true)
			}
			if (d) {
				this.transpose(false, true)
			}
			this.xAxis = [a[0]];
			this.xAxisTitle = a[0];
			this.xAxisIndices = [0];
			this.yAxis = [a[1]];
			this.yAxisTitle = a[1];
			this.yAxisIndices = [1];
			this.showAnimation = false;
			this.addRegressionLine(false, true);
			this.isCorrelate = true;
			this.isCorrelateTranspose = d;
			this.isCorrelateGroup = b;
			this.isCorrelateKey = c;
			this.draw(false, false, false, false, true)
		}
		this.removeMenus()
	};
	this.removeCorrelation = function() {
		this.functionCaller = "removeCorrelation";
		this.removeMenus();
		if (this.isTransition()) {
			return
		}
		if (this.isCorrelate) {
			if (this.decorations && this.decorations.reg) {
				delete(this.decorations.reg)
			}
			if (this.data.l && this.data.l.reg) {
				delete(this.data.l.reg)
			}
			this.switchData();
			if (this.isCorrelateTranspose) {
				this.transpose()
			}
			if (this.isCorrelateKey) {
				if (this.isCorrelateTranspose) {
					this.switchVarToAnnotation(this.isCorrelateKey)
				} else {
					this.switchSmpToAnnotation(this.isCorrelateKey)
				}
			}
			if (this.isCorrelateGroup) {
				this.groupSamples(this.isCorrelateGroup)
			} else {
				this.draw()
			}
			this.isCorrelate = false;
			this.isCorrelateTranspose = false;
			this.isCorrelateGroup = false;
			this.isCorrelateKey = false
		} else {
			if (this.decorations && this.decorations.reg) {
				delete(this.decorations.reg)
			}
			if (this.data.l && this.data.l.reg) {
				delete(this.data.l.reg)
			}
			this.draw()
		}
	};
	this.updateCorrelation = function() {
		if (this.decorations && this.decorations.reg) {
			delete(this.decorations.reg)
		}
		this.addRegressionLine(false, true)
	};
	this.addRegressionLine = function(e, c) {
		this.functionCaller = "addRegressionLine";
		if (this.isTransition()) {
			return
		}
		var j = this;
		var m, d, l, k, a, h, b, g;
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				j.addRegressionLine(e, c)
			}, 100)
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.isDOE) {} else {
					if (this.scatterPlotMatrix) {
						this.data.l.reg = [];
						for (var f = 0; f < this.data.l.smps.length; f++) {
							g = this.data.l.smps[f];
							if (g.xAxis && g.yAxis) {
								m = this.getSampleIndices(g.xAxis[0]);
								d = this.getSampleIndices(g.yAxis[0]);
								h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
								l = this.getDataForSmpGrpAtIndex(m);
								k = this.getDataForSmpGrpAtIndex(d);
								a = this.regression(l, k);
								this.data.l.reg[f] = {
									reg: a,
									lab: h,
									col: e ? e : this.colors[0]
								}
							} else {
								this.data.l.reg[f] = false
							}
						}
					} else {
						if (this.type2D == "XYZ") {
							m = this.xAxisIndices[this.xAxisCurrent];
							d = this.yAxisIndices[this.yAxisCurrent];
							h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
							l = this.getDataForSmpGrpAtIndex(m);
							k = this.getDataForSmpGrpAtIndex(d);
							a = this.regression(l, k);
							this.addRegressionDecoration(a, h, this.foreground)
						} else {
							if (this.type2D == "XY") {
								for (var f = 0; f < this.xAxisIndices.length; f++) {
									b = e ? e : this.colors[f % this.colors.length];
									m = this.xAxisIndices[f];
									d = this.yAxisIndices[f];
									h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
									l = this.getDataForSmpGrpAtIndex(m);
									k = this.getDataForSmpGrpAtIndex(d);
									a = this.regression(l, k);
									this.addRegressionDecoration(a, h, b)
								}
							} else {
								if (this.type2D == "X") {
									d = this.yAxisIndices[this.yAxisCurrent];
									k = this.getDataForSmpGrpAtIndex(d);
									for (var f = 0; f < this.xAxisIndices.length; f++) {
										b = e ? e : this.colors[f % this.colors.length];
										m = this.xAxisIndices[f];
										h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
										l = this.getDataForSmpGrpAtIndex(m);
										a = this.regression(l, k);
										this.addRegressionDecoration(a, h, b)
									}
								} else {
									m = this.xAxisIndices[this.xAxisCurrent];
									l = this.getDataForSmpGrpAtIndex(m);
									for (var f = 0; f < this.yAxisIndices.length; f++) {
										b = e ? e : this.colors[f % this.colors.length];
										d = this.yAxisIndices[f];
										k = this.getDataForSmpGrpAtIndex(d);
										h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
										a = this.regression(l, k);
										this.addRegressionDecoration(a, h, b)
									}
								}
							}
						}
					}
				}
				if (!c) {
					this.draw()
				}
			}
		}
	};
	this.addRegressionDecoration = function(c, b, a) {
		this.showDecorations = true;
		if (!this.decorations) {
			this.decorations = {}
		}
		if (!this.decorations.reg) {
			this.decorations.reg = []
		}
		this.decorations.reg.push({
			slope: c[0],
			intercept: c[1],
			cor: c[2],
			ci: c[3],
			label: b,
			color: a
		})
	};
	this.addNormalDistributionLine = function(c, b) {
		this.functionCaller = "addNormalDistributionLine";
		if (this.isTransition()) {
			return
		}
		var k = this;
		var p, g, n, h, j, l, m, f, d, f, a, o;
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				k.addNormalDistributionLine(c)
			}, 100)
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.type2D == "XYZ") {
					n = c == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
					h = c == "y" ? this.xAxisIndices[this.xAxisCurrent] : this.yAxisIndices[this.yAxisCurrent];
					j = this.getDataForSmpGrpAtIndex(n);
					l = this.getDataForSmpGrpAtIndex(h);
					m = this.max(l);
					f = this.data.y.smps[n];
					d = this.meanStandardDeviationN(j);
					this.addNormalDistributionDecoration(d, m, f, this.foreground, c)
				} else {
					p = c == "y" ? this.yAxisIndices : this.xAxisIndices;
					g = c == "y" ? this.xAxisIndices : this.yAxisIndices;
					o = c == "y" ? this.xAxisCurrent : this.yAxisCurrent;
					for (var e = 0; e < p.length; e++) {
						a = e % this.colors.length;
						n = p[e];
						h = g[e] ? g[e] : g[o];
						j = this.getDataForSmpGrpAtIndex(n);
						l = this.getDataForSmpGrpAtIndex(h);
						m = this.max(l);
						f = this.data.y.smps[n];
						d = this.meanStandardDeviationN(j);
						this.addNormalDistributionDecoration(d, m, f, this.colors[a], c)
					}
				}
				if (!b) {
					this.draw()
				}
			}
		}
	};
	this.addNormalDistributionDecoration = function(e, a, c, b, d) {
		this.showDecorations = true;
		if (!this.decorations) {
			this.decorations = {}
		}
		if (!this.decorations.nor) {
			this.decorations.nor = []
		}
		if (d && d == "y") {
			this.decorations.nor.push({
				mu: e[0],
				sigma: e[1],
				yAxis: true,
				max: a,
				label: c,
				color: b
			})
		} else {
			this.decorations.nor.push({
				mu: e[0],
				sigma: e[1],
				max: a,
				label: c,
				color: b
			})
		}
	};
	this.addKaplanMeierCurve = function(f, B, g, A, w) {
		this.functionCaller = "addKaplanMeierCurve";
		if (this.isTransition()) {
			return
		}
		var b = false;
		var F = {
			d: {},
			c: {}
		};
		var a = {};
		var h = 1.95996;
		var k = h * h;
		var s, r, x, D, m, y;
		if (f && B) {
			var e = this.getSampleIndices(f);
			var j = this.getSampleIndices(B);
			if (e != null && j != null) {
				for (var C = 0; C < this.varIndices.length; C++) {
					var o = this.data.y.data[C][e];
					var E = this.data.y.data[C][j];
					if (!isNaN(E)) {
						if (!isNaN(E) && E == 0) {
							F.d[o] = F.d[o] ? F.d[o] + 1 : 1;
							a[o] = true
						} else {
							F.c[o] = F.c[o] ? F.c[o] + 1 : 1;
							a[o] = true
						}
					}
				}
				a = this.getKeys(a);
				a.sort(function(d, c) {
					return d - c
				});
				b = {
					times: a,
					data: []
				};
				for (var C = 0; C < a.length; C++) {
					b.data.push([F.c[a[C]] || 0, F.d[a[C]] || 0])
				}
				b.data[0].push(this.varIndices.length);
				for (var C = 1; C < a.length; C++) {
					b.data[C].push(b.data[C - 1][2] - (b.data[C - 1][0] + b.data[C - 1][1]))
				}
				s = 1;
				for (var C = 0; C < a.length; C++) {
					s = s * (1 - (b.data[C][1] / b.data[C][2]));
					r = 1 - s;
					x = (2 * s * this.varIndices.length) + k + 1 + (h * Math.sqrt(k + 2 - (1 / this.varIndices.length) + 4 * s * ((r * this.varIndices.length) - 1)));
					D = 2 * (this.varIndices.length + k);
					m = x / D;
					if (s == 1) {
						m = 1
					}
					x = (2 * s * this.varIndices.length) + k - 1 - (h * Math.sqrt(k - 2 - (1 / this.varIndices.length) + 4 * s * ((r * this.varIndices.length) + 1)));
					y = x / D;
					if (s == 0) {
						y = 0
					}
					b.data[C].push(s, m, y)
				}
				this.addKaplanMeierDecoration(f, b, g, A)
			}
		}
		if (!w) {
			this.draw()
		}
	};
	this.addKaplanMeierDecoration = function(d, c, b, a) {
		this.showDecorations = true;
		if (!this.decorations) {
			this.decorations = {}
		}
		if (!this.decorations.kaplanMeier) {
			this.decorations.kaplanMeier = []
		}
		this.decorations.kaplanMeier.push({
			time: d,
			data: c,
			label: b || "Kaplan - Meyer " + (this.decorations.kaplanMeier.length + 1),
			color: a || this.colors[this.decorations.kaplanMeier.length % this.colors.length]
		})
	};
	this.addLineDecoration = function(d, e, b, a) {
		if (!this.graphType.match(/Scatter|Network|Genome|Correlation|Venn|Circular/)) {
			if (!this.decorations) {
				this.decorations = {}
			}
			if (!this.decorations.lines) {
				this.decorations.lines = []
			}
			if (d && d == "solid") {
				d = "line"
			}
			this.decorations.lines.push({
				type: d || "line",
				color: e || this.foreground,
				value: b || 0,
				label: a || false
			})
		}
	};
	this.createRandomData = function(f) {
		var h = {};
		if (this.graphType == "Network") {
			h = this.createRandomNetwork();
			if (f) {
				return h
			}
			this.calculateLayout = true;
			this.layoutDone = false
		} else {
			if (this.graphType == "Venn" || this.graphType == "Genome" || this.graphType == "Candlestick") {
				h = this.dataSetExample
			} else {
				h.y = {};
				h.y.data = [];
				h.y.vars = [];
				h.y.smps = [];
				for (var k = 0; k < this.randomDataSamples; k++) {
					if (this.isGraphTime) {
						h.y.smps[k] = new Date(this.meta.time.start + (k * this.times.day))
					} else {
						h.y.smps[k] = "Sample" + (k + 1)
					}
				}
				var m = this.rnorm(this.randomDataVariables * this.randomDataSamples, this.randomDataMean, this.randomDataSigma);
				var d = 0;
				for (var k = 0; k < this.randomDataVariables; k++) {
					h.y.data[k] = [];
					h.y.vars[k] = "Variable" + (k + 1);
					for (var g = 0; g < this.randomDataSamples; g++) {
						if (this.randomDataUniform) {
							h.y.data[k].push(100)
						} else {
							if (this.randomDataSymmetrical) {
								h.y.data[k].push((k * 10) + ((g + 1) * 5))
							} else {
								h.y.data[k][g] = m[d];
								d++
							}
						}
					}
				}
				h.x = {};
				var b = Math.floor(this.randomDataSamples / this.randomDataSampleAnnotationRatio);
				for (var k = 0; k < this.randomDataSampleAnnotations; k++) {
					var o = this.rnorm(this.randomDataSamples, this.randomDataMean, this.randomDataSigma);
					h.x["Factor" + (k + 1)] = [];
					h.x["SCovar" + (k + 1)] = [];
					for (var g = 0; g < this.randomDataSamples; g++) {
						if (this.randomDataSymmetrical) {
							h.x["Factor" + (k + 1)][g] = "Lev:" + (Math.floor(k / (g + 1)) + 1);
							h.x["SCovar" + (k + 1)][g] = Math.floor(k / (g + 1)) + 1
						} else {
							var e = Math.floor(this.random() * b);
							h.x["Factor" + (k + 1)][g] = "Lev:" + (e + 1);
							h.x["SCovar" + (k + 1)][g] = o[g]
						}
					}
				}
				h.z = {};
				var b = Math.min(10, Math.floor(this.randomDataVariables / this.randomDataVariableAnnotationRatio));
				for (var k = 0; k < this.randomDataVariableAnnotations; k++) {
					var o = this.rnorm(this.randomDataVariables, this.randomDataMean, this.randomDataSigma);
					h.z["Annt" + (k + 1)] = [];
					h.z["VCov" + (k + 1)] = [];
					for (var g = 0; g < this.randomDataVariables; g++) {
						if (this.randomDataSymmetrical) {
							h.z["Annt" + (k + 1)][g] = "Desc:" + (Math.floor(k / (g + 1)) + 1);
							h.z["VCov" + (k + 1)][g] = Math.floor(k / (g + 1)) + 1
						} else {
							var e = Math.floor(this.random() * b);
							h.z["Annt" + (k + 1)][g] = "Desc:" + (e + 1);
							h.z["VCov" + (k + 1)][g] = o[g]
						}
					}
				}
				if (this.randomMissingDataPercentage > 0 && this.randomMissingDataPercentage < 1) {
					var c = 0;
					var a = this.randomDataVariables * this.randomDataSamples * this.randomMissingDataPercentage;
					while (c < a) {
						var k = Math.floor(this.random() * this.randomDataVariables);
						var g = Math.floor(this.random() * this.randomDataSamples);
						if (h.y.data[k][g]) {
							delete(h.y.data[k][g]);
							c++
						}
					}
				}
			}
		}
		if (f) {
			return h
		}
		this.randomData = true;
		if (this.data && !this.dataStndBy) {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			this.data = {}
		}
		this.resetConfig(["graphType", "imageDir"]);
		this.updateData(h, true)
	};
	this.restoreRandomData = function() {
		this.switchData(true)
	};
	this.binDataByPercentile = function(g, f) {
		var d = this.range(this.data.y.data[g]);
		if (!this.data.x) {
			this.data.x = {}
		}
		var a = this.data.y.vars[g] + " Percentile" + (f ? "" : " Category");
		this.data.x[a] = [];
		for (var c = 0; c < this.data.y.data[g].length; c++) {
			var b = this.data.y.data[g][c];
			if (!isNaN(b) && b != "" && b != null) {
				var e = this.parseInt(this.percentile(d[0], d[1], b) / 10);
				if (e == 10) {
					e--
				}
				this.data.x[a][c] = f ? e + 1 : (e * 10) + "-" + ((e + 1) * 10) + "%"
			} else {
				this.data.x[a][c] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data, false, true);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a]);
		this.removeMenus()
	};
	this.binDataByQuantile = function(g, f) {
		var c = this.quants(this.data.y.data[g]);
		if (!this.data.x) {
			this.data.x = {}
		}
		var a = this.data.y.vars[g] + " Quantile" + (f ? "" : " Category");
		this.data.x[a] = [];
		for (var d = 0; d < this.data.y.data[g].length; d++) {
			var b = this.data.y.data[g][d];
			if (!isNaN(b) && b != "" && b != null) {
				var e = this.quantile(c, b);
				if (f) {
					this.data.x[a][d] = e + 1
				} else {
					if (e == 0) {
						this.data.x[a][d] = "1st Quantile"
					} else {
						if (e == 1) {
							this.data.x[a][d] = "2nd Quantile"
						} else {
							if (e == 2) {
								this.data.x[a][d] = "3rd Quantile"
							} else {
								this.data.x[a][d] = "4th Quantile"
							}
						}
					}
				}
			} else {
				this.data.x[a][d] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data, false, true);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a]);
		this.removeMenus()
	};
	this.binDataCustom = function(a, b) {
		this.addBinConfigurator(a, b);
		this.removeMenus()
	};
	this.setMarketTechnicalData = function() {
		if (this.stockIndicators.length > 0) {
			var b = {};
			var g = false;
			var h = {
				Sma5: 5,
				Sma10: 10,
				Sma20: 20,
				Sma25: 25,
				Sma50: 50
			};
			var a = [];
			for (var f = 0; f < this.stockIndicators.length; f++) {
				if (h.hasOwnProperty(this.stockIndicators[f])) {
					a.push(this.stockIndicators[f])
				}
			}
			if (a.length > 0) {
				this.stockIndicators = a;
				var l = {};
				for (var f = 0; f < this.stockIndicators.length; f++) {
					var m = this.stockIndicators[f];
					if (h.hasOwnProperty(m) && !this.data.y.hasOwnProperty(m)) {
						b[m] = true;
						g = true;
						l[m] = [];
						this.data.y[m] = [];
						for (var d = 0; d < this.data.y.vars.length; d++) {
							l[m][d] = [];
							this.data.y[m][d] = []
						}
					}
				}
				if (g) {
					for (var f = 0; f < this.data.y.smps.length; f++) {
						for (var d = 0; d < this.data.y.vars.length; d++) {
							for (var c = 0; c < this.stockIndicators.length; c++) {
								var m = this.stockIndicators[c];
								if (b.hasOwnProperty(m)) {
									if (!isNaN(this.data.y.close[d][f])) {
										l[m][d].push(this.data.y.close[d][f]);
										if (l[m][d].length == h[m]) {
											if (m.match(/Sma/)) {
												this.data.y[m][d][f] = this.mean(l[m][d]);
												l[m][d].shift()
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.switchToMarketData = function() {
		var a = this.data.market;
		this.dataStndBy = this.data;
		this.configStndBy = this.getConfig();
		this.data = {};
		this.data.y = a;
		this.initializeDataAttributes();
		if (this.showVolume) {
			this.data.l = {};
			this.data.l.vars = [this.data.y.vars, this.data.y.vars];
			this.data.l.weight = this.graphOrientation == "vertical" ? [
				[1, 0.75],
				[1, 0.25]
			] : [
				[1, 0.25],
				[1, 0.75]
			];
			this.data.l.type = ["Candlestick", "Candlestick"];
			this.data.l.name = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
			this.data.l.desc = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
			this.segregateSamplesBy = [];
			this.segregateVariablesBy = [];
			this.layoutComb = true;
			this.layout = this.graphOrientation == "vertical" ? "2X1" : "1X2";
			this.isValidLayout()
		}
	};
	this.switchFromMarketData = function() {
		this.switchData(true);
		if (this.showVolume) {
			this.resetLayout();
			this.isValidLayout()
		}
	};
	this.switchData = function(a, b) {
		if (this.dataStndBy && this.configStndBy) {
			this.data = this.dataStndBy;
			this.resetConfig();
			this.updateConfig(this.configStndBy);
			this.updateData(this.data, a, b)
		}
	};
	this.setParalleCoordinates = function() {
		this.paralleCoordinates = [];
		var c = this.isGroupedData ? this.data.w : this.data.y;
		var m = this.isGroupedData ? this.grpIndices : this.smpIndices;
		for (var j = 0; j < m.length; j++) {
			var n = m[j];
			var g = c.smps[n];
			var k = this.getDataForSmpGrpAtIndex(n);
			var a = this.range(k);
			var d = this[this.axisAlgorithm](a[0], a[1], this.xAxisTicks, this.axisWilkinsonLoose);
			var e = this.getMaxText(d);
			var l = this.measureText(e, this.axisTickFont);
			var f = {
				si: n,
				smp: g,
				range: a[1] - a[0],
				min: a[0],
				max: a[1],
				vals: d,
				maxStr: e,
				maxStrLen: l
			};
			if (this.meta.data.modified && this.meta.data.modified.z[g]) {
				f.type = "string";
				f.levels = this.meta.data.modified.z[g];
				var b = this.getMaxText(this.meta.data.modified.z[g]);
				var h = this.measureText(b, this.axisTickFont);
				f.maxLevStr = b;
				f.maxLevStrLen = h
			} else {
				f.type = "numeric"
			}
			this.paralleCoordinates.push(f)
		}
	};
	this.updateData = function(b, c, a) {
		delete(this.data.initialVarIndices);
		delete(this.data.initialSmpIndices);
		delete(this.meta.data);
		this.initializeData(b);
		if (!a) {
			this.initializeGraph(c)
		}
	}
};
CanvasXpress.prototype.FunctionData = function(a) {
	this.add = function(c, b) {
		return new Number(b) + new Number(c)
	};
	this.sub = function(c, b) {
		return b - c
	};
	this.mul = function(c, b) {
		return b * c
	};
	this.div = function(c, b) {
		return b / c
	};
	this.sin = function(b) {
		return Math.sin(b)
	};
	this.cos = function(b) {
		return Math.cos(b)
	};
	this.tan = function(b) {
		return Math.tan(b)
	};
	this.sec = function(b) {
		return 1 / Math.cos(b)
	};
	this.csc = function(b) {
		return 1 / Math.sin(b)
	};
	this.cot = function(b) {
		return 1 / Math.tan(b)
	};
	this.asin = function(b) {
		return Math.asin(b)
	};
	this.acos = function(b) {
		return Math.acos(b)
	};
	this.atan = function(b) {
		return Math.atan(b)
	};
	this.asec = function(b) {
		return Math.acos(1 / b)
	};
	this.acsc = function(b) {
		return Math.asin(1 / b)
	};
	this.acot = function(b) {
		return Math.atan(1 / b)
	};
	this.sinh = function(b) {
		return (Math.exp(b) - Math.exp(-b)) * 0.5
	};
	this.cosh = function(b) {
		return (Math.exp(b) + Math.exp(-b)) * 0.5
	};
	this.tanh = function(b) {
		return (Math.exp(b) - Math.exp(-b)) / (Math.exp(b) + Math.exp(-b))
	};
	this.sech = function(b) {
		return 1 / cosh(b)
	};
	this.csch = function(b) {
		return 1 / sinh(b)
	};
	this.coth = function(b) {
		return 1 / tanh(b)
	};
	this.asinh = function(b) {
		return Math.log(b + Math.sqrt(b * b + 1))
	};
	this.acosh = function(b) {
		return Math.log(b + Math.sqrt(b * b - 1))
	};
	this.atanh = function(b) {
		return Math.log((1 + b) / (1 - b)) * 0.5
	};
	this.asech = function(b) {
		return acosh(1 / b)
	};
	this.acsch = function(b) {
		return asinh(1 / b)
	};
	this.acoth = function(b) {
		return atanh(1 / b)
	};
	this.exp = function(b) {
		return Math.exp(b)
	};
	this.ln = function(b) {
		return Math.log(b)
	};
	this.log = function(b) {
		return Math.log(b) / Math.LN10
	};
	this.logb = function(c, b) {
		return Math.log(b) / Math.log(c)
	};
	this.pow = function(c, b) {
		return Math.pow(b, c)
	};
	this.pow10 = function(b) {
		return Math.pow(10, b)
	};
	this.sq = function(b) {
		return b * b
	};
	this.sqrt = function(b) {
		return Math.sqrt(b)
	};
	this.abs = function(b) {
		return b >= 0 ? b : -b
	};
	this.sgn = function(b) {
		return b == 0 ? 0 : (b > 0 ? 1 : -1)
	};
	this.chs = function(b) {
		return -b
	};
	this.neg = function(b) {
		return -b
	};
	this.floor = function(b) {
		return Math.floor(b)
	};
	this.ceil = function(b) {
		return Math.ceil(b)
	};
	this.ip = function(b) {
		return parseInt(b)
	};
	this.fp = function(b) {
		return abs(b) - ip(abs(b))
	};
	this.inv = function(b) {
		return 1 / b
	};
	this.idiv = function(c, b) {
		return parseInt(b / c)
	};
	this.mod = function(c, b) {
		return b % c
	};
	this.and = function(c, b) {
		return b & c
	};
	this.or = function(c, b) {
		return b | c
	};
	this.xor = function(c, b) {
		return b ^ c
	};
	this.not = function(b) {
		return ~b
	};
	this.lt = function(c, b) {
		return b < c ? 1 : 0
	};
	this.le = function(c, b) {
		return b <= c ? 1 : 0
	};
	this.eq = function(c, b) {
		return b == c ? 1 : 0
	};
	this.ne = function(c, b) {
		return b != c ? 1 : 0
	};
	this.ge = function(c, b) {
		return b >= c ? 1 : 0
	};
	this.gt = function(c, b) {
		return b > c ? 1 : 0
	};
	this.Min = function(c, b) {
		return Math.min(b, c)
	};
	this.Max = function(c, b) {
		return Math.max(b, c)
	};
	this.pc = function(c, b) {
		return b * c / 100
	};
	this.pcch = function(c, b) {
		return 100 * c / b
	};
	this.gammaLn = function(c) {
		var b = new Array(76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953);
		var g = new Number(c);
		var f = new Number(c + 5.5);
		var d = new Number(1.000000000190015);
		f -= (c + 0.5) * Math.log(f);
		for (var e in b) {
			d += b[e] / ++g
		}
		return Math.log(2.5066282746310007 * d / c) - f
	};
	this.gammaLn2 = function(b) {
		var d = 0;
		var g = [76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953];
		var c = 1.000000000190015;
		var f, h, e;
		e = (h = f = b) + 5.5;
		e -= (f + 0.5) * Math.log(e);
		for (; d < 6; d++) {
			c += g[d] / ++h
		}
		return Math.log(2.5066282746310007 * c / f) - e
	};
	this.betaCf = function(q, p, o) {
		var i = 1e-30;
		var g = 1;
		var k = p + o;
		var t = p + 1;
		var f = p - 1;
		var n = 1;
		var l = 1 - k * q / t;
		var s, e, r, j;
		if (Math.abs(l) < i) {
			l = i
		}
		l = 1 / l;
		j = l;
		for (; g <= 100; g++) {
			s = 2 * g;
			e = g * (o - g) * q / ((f + s) * (p + s));
			l = 1 + e * l;
			if (Math.abs(l) < i) {
				l = i
			}
			n = 1 + e / n;
			if (Math.abs(n) < i) {
				n = i
			}
			l = 1 / l;
			j *= l * n;
			e = -(p + g) * (k + g) * q / ((p + s) * (t + s));
			l = 1 + e * l;
			if (Math.abs(l) < i) {
				l = i
			}
			n = 1 + e / n;
			if (Math.abs(n) < i) {
				n = i
			}
			l = 1 / l;
			r = l * n;
			j *= r;
			if (Math.abs(r - 1) < 3e-7) {
				break
			}
		}
		return j
	};
	this.beta = function(d, e, c) {
		var f = (d === 0 || d === 1) ? 0 : Math.exp(this.gammaLn2(e + c) - this.gammaLn2(e) - this.gammaLn2(c) + e * Math.log(d) + c * Math.log(1 - d));
		if (d < 0 || d > 1) {
			return false
		}
		if (d < (e + 1) / (e + c + 2)) {
			return f * this.betaCf(d, e, c) / e
		}
		return 1 - f * this.betaCf(1 - d, c, e) / c
	};
	this.betaInv = function(m, z, y) {
		var n = 1e-8;
		var A = z - 1;
		var f = y - 1;
		var q = 0;
		var d, c, r, l, k, e, g, o, v, i, s;
		if (m <= 0) {
			return 0
		}
		if (m >= 1) {
			return 1
		}
		if (z >= 1 && y >= 1) {
			r = (m < 0.5) ? m : 1 - m;
			l = Math.sqrt(-2 * Math.log(r));
			g = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l;
			if (m < 0.5) {
				g = -g
			}
			o = (g * g - 3) / 6;
			v = 2 / (1 / (2 * z - 1) + 1 / (2 * y - 1));
			i = (g * Math.sqrt(o + v) / v) - (1 / (2 * y - 1) - 1 / (2 * z - 1)) * (o + 5 / 6 - 2 / (3 * v));
			g = z / (z + y * Math.exp(2 * i))
		} else {
			d = Math.log(z / (z + y));
			c = Math.log(y / (z + y));
			l = Math.exp(z * d) / z;
			k = Math.exp(y * c) / y;
			i = l + k;
			if (m < l / i) {
				g = Math.pow(z * i * m, 1 / z)
			} else {
				g = 1 - Math.pow(y * i * (1 - m), 1 / y)
			}
		}
		s = -this.gammaLn2(z) - this.gammaLn2(y) + this.gammaLn2(z + y);
		for (; q < 10; q++) {
			if (g === 0 || g === 1) {
				return g
			}
			e = this.beta(g, z, y) - m;
			l = Math.exp(A * Math.log(g) + f * Math.log(1 - g) + s);
			k = e / l;
			g -= (l = k / (1 - 0.5 * Math.min(1, k * (A / g - f / (1 - g)))));
			if (g <= 0) {
				g = 0.5 * (g + l)
			}
			if (g >= 1) {
				g = 0.5 * (g + l + 1)
			}
			if (Math.abs(l) < n * g && q > 0) {
				break
			}
		}
		return g
	};
	this.lowRegGamma = function(r, s) {
		var p = this.gammaLn(r);
		var f = r;
		var m = 1 / r;
		var t = m;
		var q = s + 1 - r;
		var o = 1 / 1e-30;
		var n = 1 / q;
		var k = n;
		var g = 1;
		var e = -~(Math.log((r >= 1) ? r : 1 / r) * 8.5 + r * 0.4 + 17);
		var j, l;
		if (s < 0 || r <= 0) {
			return NaN
		} else {
			if (s < r + 1) {
				for (; g <= e; g++) {
					m += t *= s / ++f
				}
				return (m * Math.exp(-s + r * Math.log(s) - (p)))
			}
		}
		for (; g <= e; g++) {
			j = -g * (g - r);
			q += 2;
			n = j * n + q;
			o = q + j / o;
			n = 1 / n;
			k *= n * o
		}
		return (1 - k * Math.exp(-s + r * Math.log(s) - (p)))
	};
	this.gammaPinv = function(c, i) {
		var g = 0;
		var d = i - 1;
		var h = 1e-8;
		var b = this.gammaLn(i);
		var k, f, o, n, e, m, l;
		if (c >= 1) {
			return Math.max(100, i + 100 * Math.sqrt(i))
		}
		if (c <= 0) {
			return 0
		}
		if (i > 1) {
			m = Math.log(d);
			l = Math.exp(d * (m - 1) - b);
			e = (c < 0.5) ? c : 1 - c;
			o = Math.sqrt(-2 * Math.log(e));
			k = (2.30753 + o * 0.27061) / (1 + o * (0.99229 + o * 0.04481)) - o;
			if (c < 0.5) {
				k = -k
			}
			k = Math.max(0.001, i * Math.pow(1 - 1 / (9 * i) - k / (3 * Math.sqrt(i)), 3))
		} else {
			o = 1 - i * (0.253 + i * 0.12);
			if (c < o) {
				k = Math.pow(c / o, 1 / i)
			} else {
				k = 1 - Math.log(1 - (c - o) / (1 - o))
			}
		}
		for (; g < 12; g++) {
			if (k <= 0) {
				return 0
			}
			f = this.lowRegGamma(i, k) - c;
			if (i > 1) {
				o = l * Math.exp(-(k - d) + d * (Math.log(k) - m))
			} else {
				o = Math.exp(-k + d * Math.log(k) - b)
			}
			n = f / o;
			k -= (o = n / (1 - 0.5 * Math.min(1, n * ((i - 1) / k - 1))));
			if (k <= 0) {
				k = 0.5 * (k + o)
			}
			if (Math.abs(o) < h * k) {
				break
			}
		}
		return k
	};
	this.tinv = function(d, e, c) {
		if (c) {
			d /= 2
		}
		var b = this.betaInv(2 * Math.min(d, 1 - d), 0.5 * e, 0.5);
		b = Math.sqrt(e * (1 - b) / b);
		return (d > 0.5) ? b : -b
	};
	this.gamma = function(b) {
		return Math.exp(this.gammaLn(b))
	};
	this.fact = function(c) {
		var b = new Number(c);
		if (c <= 1) {
			return 1
		}
		if (c > 100 || (c % 1)) {
			return Math.exp(this.gammaLn(c + 1))
		}
		while (--c) {
			b *= c
		}
		return b
	};
	this.comb = function(c, b) {
		return Math.floor(0.5 + Math.exp(this.gammaLn(b + 1) - this.gammaLn(c + 1) - this.gammaLn(b - c + 1)))
	};
	this.perm = function(c, b) {
		return Math.floor(0.5 + Math.exp(this.gammaLn(b + 1) - this.gammaLn(b - c + 1)))
	};
	this.gcd = function(d, c) {
		if (d == 0) {
			return (c || 1)
		}
		return (c ? this.gcd(c, d % c) : d)
	};
	this.lcm = function(d, c) {
		return (d / this.gcd(d, c)) * c
	};
	this.prime = function(f) {
		var e = new Number(5);
		var b = new Number(4);
		var c = parseInt(f / e);
		if (f == 2 || f == 3 || f == 5) {
			return 1
		}
		if (f < 5 || (f & 1) == 0 || (f % 3) == 0) {
			return 0
		}
		while (e * c < f && e < c) {
			c = parseInt(f / (e += (b = 6 - b)))
		}
		return (e * c == f ? 0 : 1)
	};
	this.implied = function(b) {
		if (b == "neg") {
			return false
		}
		return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|\w+$/.test(b)
	};
	this.tokenize = function(g) {
		var c;
		var b = [];
		var f = new String("");
		var d = /(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[xy]|[a-z]+|[-+*\/(),^]|<=?|>=?|==|!=|&&|\|\|/g;
		g = g.toLowerCase();
		g = g.replace(/\s/g, "");
		g = g.replace(/\+\+/g, "+");
		g = g.replace(/\+-/g, "-");
		g = g.replace(/-\+/g, "-");
		g = g.replace(/--/g, "+");
		g = g.replace(/^\+/, "");
		g = g.replace(/([(*\/&\|<>=])\+/g, "$1");
		g = g.replace(/^-/, "neg ");
		g = g.replace(/([(*\/&\|<>=])-/g, "$1neg ");
		g = g.replace(/\)(\(|\w)/g, ")*$1");
		g = g.replace(/(\d)\(/g, "$1*(");
		while (c = d.exec(g)) {
			if (this.implied(f) && this.implied(c[0].toString())) {
				b.push("*")
			}
			b.push(f = c[0])
		}
		return b
	};
	this.isValidEnd = function(b) {
		return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[)xye]|pi|rand$/.test(b)
	};
	this.toPostFx = function(f) {
		var c = {
			sin: 16,
			cos: 16,
			tan: 16,
			sec: 16,
			csc: 16,
			cot: 16,
			asin: 16,
			acos: 16,
			atan: 16,
			asec: 16,
			acsc: 16,
			acot: 16,
			sinh: 16,
			cosh: 16,
			tanh: 16,
			sech: 16,
			csch: 16,
			coth: 16,
			asinh: 16,
			acosh: 16,
			atanh: 16,
			asech: 16,
			acsch: 16,
			acoth: 16,
			exp: 16,
			ln: 16,
			log: 16,
			logb: 16,
			pow: 16,
			sq: 16,
			sqrt: 16,
			abs: 16,
			sgn: 16,
			chs: 16,
			floor: 16,
			ceil: 16,
			ip: 16,
			fp: 16,
			inv: 16,
			min: 16,
			max: 16,
			gamma: 16,
			fact: 16,
			comb: 16,
			perm: 16,
			rand: 16,
			gcd: 16,
			lcm: 16,
			prime: 16,
			and: 16,
			or: 16,
			xor: 16,
			x: 16,
			y: 16,
			pi: 16,
			e: 16,
			neg: 15,
			not: 15,
			"^": 14,
			"*": 13,
			"/": 13,
			mod: 13,
			div: 13,
			"+": 12,
			"-": 12,
			"<": 10,
			"<=": 10,
			"==": 10,
			"!=": 10,
			">=": 10,
			">": 10,
			"&&": 5,
			"||": 4,
			",": 1
		};
		var d = new String();
		var e = new String("");
		var b = new Array();
		var g = new Array();
		while (d = f.shift()) {
			if (d == "(") {
				b.push(d)
			} else {
				if (c[d]) {
					while (b.length && b[b.length - 1] != "(" && c[b[b.length - 1]] >= c[d]) {
						g.push(b.pop())
					}
					if (d == "," && !this.isValidEnd(e)) {
						g.push("Unexpected: " + e)
					}
					if (d != ",") {
						b.push(d)
					}
				} else {
					if (d == ")") {
						if (!this.isValidEnd(e)) {
							g.push("Unexpected: " + e)
						}
						while (b.length && b[b.length - 1] != "(") {
							g.push(b.pop())
						}
						if (b.length == 0) {
							g.push("Unmatched: )")
						}
						b.pop()
					} else {
						if (/^[-+]?(\d+\.?|\d*\.\d+)(e[-+]?\d+)?$/.test(d)) {
							g.push(d)
						} else {
							g.push("Unknown: " + d)
						}
					}
				}
			}
			e = d
		}
		if (!this.isValidEnd(e)) {
			g.push("Unexpected: " + e)
		}
		while (d = b.pop()) {
			if (d == "(") {
				g.push("Unmatched: (")
			}
			g.push(d)
		}
		return g
	};
	this.syntaxCheck = function(f) {
		var e = {
			sin: 1,
			cos: 1,
			tan: 1,
			sec: 1,
			csc: 1,
			cot: 1,
			asin: 1,
			acos: 1,
			atan: 1,
			asec: 1,
			acsc: 1,
			acot: 1,
			sinh: 1,
			cosh: 1,
			tanh: 1,
			sech: 1,
			csch: 1,
			coth: 1,
			asinh: 1,
			acosh: 1,
			atanh: 1,
			asech: 1,
			acsch: 1,
			acoth: 1,
			exp: 1,
			ln: 1,
			log: 1,
			logb: 2,
			pow: 2,
			sq: 1,
			sqrt: 1,
			abs: 1,
			sgn: 1,
			chs: 1,
			floor: 1,
			ceil: 1,
			ip: 1,
			fp: 1,
			inv: 1,
			min: 2,
			max: 2,
			gamma: 1,
			fact: 1,
			comb: 2,
			perm: 2,
			gcd: 2,
			lcm: 2,
			prime: 1,
			and: 2,
			or: 2,
			xor: 2,
			neg: 1,
			not: 1,
			"^": 2,
			"*": 2,
			"/": 2,
			mod: 2,
			div: 2,
			"+": 2,
			"-": 2,
			"<": 2,
			"<=": 2,
			"==": 2,
			"!=": 2,
			">=": 2,
			">": 2,
			"&&": 2,
			"||": 2
		};
		var b = new Number(0);
		var d = new String();
		for (var c = 0; c < f.length; c++, b++) {
			if (/^Un(matched|known|expected).*/.test(d = f[c])) {
				return d
			}
			if (e[d]) {
				if (b < e[d]) {
					return "Invalid use of: " + d
				}
				b -= e[d]
			}
		}
		return b == 1 ? false : (f.length ? "Unused arguments" : "No function")
	};
	this.evaluate = function(f, c, g) {
		alias = {
			"+": "add",
			"-": "sub",
			"*": "mul",
			"/": "div",
			"!": "fact",
			"x^y": "pow",
			"^": "pow",
			"10^": "pow10",
			div: "idiv",
			"<": "lt",
			"<=": "le",
			"==": "eq",
			"!=": "ne",
			">=": "ge",
			">": "gt",
			"%": "pc",
			"%ch": "pcch"
		};
		var b = new Array();
		var e = new String();
		for (var d = 0; d < f.length; d++) {
			e = f[d];
			if (e == "x") {
				b.push(c)
			} else {
				if (e == "y") {
					b.push(g)
				} else {
					if (e == "pi") {
						b.push(Math.PI)
					} else {
						if (e == "e") {
							b.push(Math.E)
						} else {
							if (e == "rand") {
								b.push(Math.random())
							} else {
								if (this[alias[e] || e]) {
									b.push(this[alias[e] || e](b.pop(), this[alias[e] || e].length > 1 ? b.pop() : 0))
								} else {
									b.push(e)
								}
							}
						}
					}
				}
			}
			if (isNaN(b[b.length - 1])) {
				return Number.NaN
			}
		}
		return parseFloat(b.pop())
	};
	this.set2DPlot = function(k, h) {
		var l = {
			vars: [],
			smps: ["X", "Y"],
			data: []
		};
		var g = this.setMinX ? this.setMinX : (0 - 1);
		var c = this.setMaxX ? this.setMaxX : (1 - 0);
		var f = this.setMinY ? this.setMinY : (0 - 1);
		var b = this.setMaxY ? this.setMaxY : (1 - 0);
		var q = (c - g) / this.functionIntervals;
		var p = (b - f) / this.functionIntervals;
		var e = 1;
		if (h == 1) {
			var o = g;
			for (var j = 0; j < this.functionIntervals; j++) {
				var m = this.evaluate(k, o, 0);
				if (isNaN(m)) {
					m = ""
				}
				o += q;
				l.vars.push("v" + e);
				l.data.push([o, m]);
				e++
			}
		} else {
			var m = f;
			for (var j = 0; j < this.functionIntervals; j++) {
				var o = this.evaluate(k, 0, m);
				if (isNaN(o)) {
					o = ""
				}
				m += p;
				l.vars.push("v" + e);
				l.data.push([o, m]);
				e++
			}
		}
		return l
	};
	this.set3DPlot = function(l) {
		var m = {
			vars: [],
			smps: ["X", "Y", "Z"],
			data: []
		};
		var g = this.setMinX ? this.setMinX : -Math.PI / 2;
		var c = this.setMaxX ? this.setMaxX : Math.PI / 2;
		var f = this.setMinY ? this.setMinY : -Math.PI / 2;
		var b = this.setMaxY ? this.setMaxY : Math.PI / 2;
		var e = 1;
		for (var k = 0; k <= this.functionIntervals; k++) {
			var p = f + (b - f) * k / this.functionIntervals;
			for (var h = 0; h <= this.functionIntervals; h++) {
				var q = g + (c - g) * h / this.functionIntervals;
				var o = this.evaluate(l, q, p);
				if (!isFinite(o)) {
					o = 0
				}
				m.vars.push("v" + e);
				m.data.push([q, o, p]);
				e++
			}
		}
		return m
	};
	this.initializeFunctionData = function() {
		var f = this.toPostFx(this.tokenize(this.data.fx));
		var d = this.syntaxCheck(f);
		if (d) {
			alert(d);
			return
		}
		var b = 0;
		for (var c in f) {
			if (f[c] == "x") {
				b |= 1
			} else {
				if (f[c] == "y") {
					b |= 2
				}
			}
		}
		var e;
		if (b == 0) {
			b = 1
		}
		if (b == 3) {
			this.data.y = this.set3DPlot(f);
			this.graphType = "Scatter3D";
			this.colorBy = "Y"
		} else {
			this.data.y = this.set2DPlot(f, b);
			this.graphType = "Scatter2D";
			this.lineType = "spline"
		}
		this.scatterType = "function"
	};
	if (a) {
		this.initializeFunctionData()
	}
};
CanvasXpress.prototype.initRemote = function() {
	this.ajaxRequest = function(url, params, callback, format, method) {
		var http = this.getHttpRequest();
		var pars = "";
		for (var p in params) {
			pars += p + "=" + escape(params[p]) + "&"
		}
		pars += "uid=" + new Date().getTime();
		method = method == "POST" ? "POST" : "GET";
		if (http && url) {
			if (method == "GET") {
				if (url.match(/\?/)) {
					url += "&" + pars
				} else {
					url += "?" + pars
				}
				http.open(method, url, true);
				if (http.overrideMimeType) {
					http.overrideMimeType("text/xml")
				}
				if (format == "blob") {
					http.responseType = "blob"
				} else {
					if (format == "arraybuffer") {
						http.responseType = "arraybuffer"
					}
				}
				pars = null
			} else {
				http.open(method, url, true);
				http.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
			}
			http.onreadystatechange = function() {
				if (http.readyState == 4) {
					if (http.status == 200) {
						var result = "";
						if ((!format || format == "" || format == "text" || format == "json") && http.responseText) {
							result = http.responseText
						}
						if (format == "json") {
							result = result.replace(/[\n\r]/g, "");
							result = eval("(" + result + ")")
						} else {
							if (format == "blob") {
								result = http.response
							} else {
								if (format == "arraybuffer") {
									result = new Blob([http.response], {
										type: "image/png"
									})
								}
							}
						}
						if (callback) {
							callback(result)
						}
					} else {}
				}
			};
			http.send(pars)
		}
	};
	this.getHttpRequest = function() {
		var http;
		if (window.XMLHttpRequest) {
			try {
				http = new XMLHttpRequest()
			} catch (e) {
				http = false
			}
		} else {
			if (typeof ActiveXObject != "undefined") {
				try {
					http = new ActiveXObject("Msxml2.XMLHTTP")
				} catch (e) {
					try {
						http = new ActiveXObject("Microsoft.XMLHTTP")
					} catch (e) {
						http = false
					}
				}
			}
		}
		return http
	};
	this.setClientGeo = function() {
		var setInfo = function(t) {
			return function(r) {
				t.meta.geo = JSON.parse(r)
			}
		}(this);
		this.ajaxRequest("https://freegeoip.net/json/", false, setInfo)
	};
	this.requestRemoteData = function(ini) {
		var params = this.cloneObject(this.remoteParams);
		params.index = this.remoteDataIndex;
		params.dir = this.remoteDirection;
		if (ini) {
			params.records = true
		}
		if (this.remoteServiceType == "file") {
			this.ajaxRequest(this.remoteData[this.remoteDataIndex][1], params, this.updateRemoteData, "json", "GET")
		} else {
			this.ajaxRequest(this.remoteService, params, this.updateRemoteData, "json", "GET")
		}
	};
	this.requestRemoteIds = function(d) {
		if (this.remoteService && this.remoteUpdate) {
			var params = this.cloneObject(this.remoteParams);
			params.update = true;
			var that = this;
			var updater = function() {
				this.update = function() {
					clearInterval(cl);
					that.ajaxRequest(that.remoteService, params, that.updateRemoteIds, "json", "GET")
				};
				var cl = this.setInterval(this.update, d / 5 || 1)
			};
			updater.call()
		}
	};
	this.updateRemoteIds = function(t) {
		return function(res) {
			var that = t;
			var s = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
			if (s) {
				if (res.ids) {
					that.remoteIds = res.ids
				}
				var c = s.selectedIndex;
				var x = s.childNodes[c].text;
				var updater = function() {
					this.update = function() {
						if (s.childNodes.length >= that.remoteIds.length) {
							that.remoteUpdate = false;
							clearInterval(cl)
						} else {
							that.resetSelectOptionsRemoteData(s, x);
							that.requestRemoteIds()
						}
					};
					var cl = this.setInterval(this.update, that.remoteUpdateDelay)
				};
				updater.call()
			}
		}
	}(this);
	this.saveRemote = function(type, name, object) {
		var that = this;
		var params = this.cloneObject(this.remoteParams);
		params.index = this.remoteDataIndex;
		params.save = type;
		if (name) {
			params.name = JSON.stringify(name)
		}
		var config = object ? object : this.getConfig();
		if (this.graphType == "Network") {
			config.calculateLayout = false
		}
		params.params = JSON.stringify(config);
		params.afterRender = JSON.stringify(CanvasXpress.stack[this.target].afterRender);
		params.cxdata = JSON.stringify(this.cloneObject(this.data));
		this.ajaxRequest(this.remoteService, params, function() {
			alert("CanvasXpress data saved " + type + " in the server")
		}, "json", "POST")
	};
	this.clearRemote = function() {
		var that = this;
		params.clear = true;
		this.ajaxRequest(this.remoteService, params, function() {
			alert("CanvasXpress data parameters clear from the server")
		}, "json", "POST")
	};
	this.castRemoteParameters = function(o) {
		o.remoteParentId = this.remoteParentId;
		o.remoteService = this.remoteService;
		o.remoteDirection = this.remoteDirection;
		o.remoteDataIndex = this.remoteDataIndex;
		o.remoteAutoPlay = this.remoteAutoPlay;
		o.remoteAutoPlayDelay = this.remoteAutoPlayDelay;
		o.remoteData = this.remoteData;
		o.remoteIds = this.remoteIds;
		o.remoteServiceType = this.remoteServiceType;
		for (var p in this.remoteParams) {
			o.remoteParams[p] = this.remoteParams[p]
		}
		o.addRemoveNavigationListeners("addEvtListener")
	};
	this.getOriginalDimensions = function() {
		var o = this.$(this.target);
		return [parseInt(o.width) + 18, parseInt(o.height) + 18]
	};
	this.fitCanvasToCurrent = function(n) {
		var atts = ["resizable", "responsive", "aspectratio"];
		for (var i = 0; i < atts.length; i++) {
			var v = this.meta.canvas.ctx.canvas.getAttribute(atts[i]);
			if (v) {
				n.meta.canvas.ctx.canvas.setAttribute(atts[i], v)
			}
		}
		n.setDimensions(this.width + 18, this.height + 18);
		n.resizable = this.resizable;
		n.resizableX = this.resizableX;
		n.resizableY = this.resizableY
	};
	this.updateRemoteData = function(t) {
		return function(res, callback) {
			if ((res && res.data) || (res && res.config && res.config.graphType && res.config.graphType == "Map")) {
				var d;
				if (t.remoteServiceType == "file") {
					d = res.config ? res : res.data;
					d.renderTo = res.renderTo || t.remoteData[t.remoteDataIndex][0];
					var trt = d.renderTo;
					var cnt = 1;
					var nrt = t.$(d.renderTo);
					while (nrt) {
						d.renderTo = trt + "-" + cnt;
						nrt = t.$(d.renderTo);
						cnt++
					}
				} else {
					d = t.appendUserConfig(res.data)
				}
				var a = t.remoteDirection == "next" ? true : false;
				var w = t.$("container-" + t.target);
				if (w) {
					var p = w.parentNode;
					var o = t.getOriginalDimensions();
					var l = t.target;
					t.insertTarget(d.renderTo, w, d.config.width || o[0], d.config.height || o[1], a);
					d.hidden = d.uploadFile ? false : true;
					var n = new CanvasXpress(d);
					n.target0 = t.target0 ? t.target0 : t.target;
					t.castRemoteParameters(n);
					t.addSelectOptionsRemoteData(res.ids);
					t.resetInfoSpan(false, true);
					t.animateTransition(p, l);
					t.requestRemoteIds(t.remoteUpdateDelay);
					if (t.Ext) {
						if (!n.Ext) {
							n.Ext = {
								canvasId: d.renderTo,
								canvas: n,
								extId: t.Ext.id || t.Ext.extId
							}
						}
					}
					if (res.afterRender && ((res.config && res.config.graphType != "Map") || (res.data && res.data.config && res.data.config.graphType != "Map"))) {
						for (var i = 0; i < res.afterRender.length; i++) {
							var ar = res.afterRender[i];
							var fn = ar.shift();
							if (fn) {
								var pr = ar.length > 0 ? ar.shift() : [];
								var cn = ar.length > 0 ? ar.shift() : {};
								n.flashInfoSpan(20, 20, fn);
								for (var c in cn) {
									n[c] = cn[c]
								}
								n[fn].apply(n, pr)
							}
						}
						t.fitCanvasToCurrent(n)
					} else {
						if (res.postprocess) {
							for (var i = 0; i < res.postprocess.length; i++) {
								var fn = res.postprocess[i].func;
								var pr = res.postprocess[i].param;
								if (fn) {
									if (fn == "groupSamples" && n.isGroupedData) {
										continue
									}
									if (pr) {
										n[fn].apply(n, pr)
									} else {
										n[fn]()
									}
								}
							}
							t.fitCanvasToCurrent(n)
						}
					}
					if (!n.userEvents.remoteupdate && t.userEvents.remoteupdate) {
						n.userEvents.remoteupdate = t.userEvents.remoteupdate
					}
					if (n.userEvents.remoteupdate) {
						n.userEvents.remoteupdate.call(this, n)
					}
					if (res.info) {
						n.updateInfoDiv(res.info)
					}
					if (t.showCode) {
						n.updateCodeDiv()
					}
					if (callback) {
						callback()
					}
				}
			} else {
				t.remoteDataIndex = t.remoteDirection == "next" ? Math.max(0, t.remoteDataIndex - 1) : t.remoteDataIndex + 1;
				t.remoteUpdating = false
			}
		}
	}(this);
	this.appendUserConfig = function(d) {
		if (d.config) {
			for (var i in this.meta.config.user) {
				if (!i.match(/decrease|remote|^calculateLayout$|layoutComb/)) {
					if (!d.config[i]) {
						d.config[i] = this.meta.config.user[i]
					}
				}
			}
		}
		return d
	};
	this.updateCurrentRemoteData = function(s, c) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (!c) {
			c = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent")
		}
		if (s && c) {
			s.selectedIndex = this.remoteDataIndex;
			if (this.remoteIds.length == 0) {
				for (var i = 0; i < s.childNodes.length; i++) {
					this.remoteIds.push(s.childNodes[i].text)
				}
			}
			if (s.childNodes[s.selectedIndex]) {
				var v = s.childNodes[s.selectedIndex].text;
				c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
			} else {
				this.resetSelectOptionsRemoteData(s)
			}
		}
	};
	this.resetSelectOptionsRemoteData = function(s, t) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (s) {
			if (this.remoteIds.length == 0) {
				for (var i = 0; i < s.childNodes.length; i++) {
					this.remoteIds.push(s.childNodes[i].text)
				}
			}
			this.clearSelectOptionsRemoteData(s);
			this.addSelectOptionsRemoteData(this.remoteIds, s, t)
		}
	};
	this.clearSelectOptionsRemoteData = function(s) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (s && s.hasChildNodes()) {
			while (s.childNodes.length >= 1) {
				s.removeChild(s.firstChild)
			}
		}
	};
	this.addSelectOptionsRemoteData = function(ids, s, t) {
		if (ids && ids.length > 0) {
			this.remoteIds = ids;
			if (!s) {
				s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
			}
			if (s) {
				this.clearSelectOptionsRemoteData(s);
				for (var i = 0; i < this.remoteIds.length; i++) {
					var opt = this.$cX("option", {
						text: this.remoteIds[i],
						value: i
					}, {
						width: (this.meta.canvas.ctx.canvas.width - 134) + "px"
					});
					if (t) {
						if (this.remoteIds[i] == t) {
							opt.selected = "selected";
							this.remoteDataIndex = i;
							s.selectedIndex = this.remoteDataIndex
						}
					} else {
						if (this.remoteDataIndex == i) {
							opt.selected = "selected";
							s.selectedIndex = this.remoteDataIndex
						}
					}
					try {
						s.add(opt, null)
					} catch (ex) {
						s.add(opt)
					}
				}
				if (this.remoteIds.length == 1) {
					this.hideNavigation()
				} else {
					this.showNavigation()
				}
			}
		}
	};
	this.animateTransition = function(b, o) {
		if (b) {
			var c1, c2;
			var cn = b.childNodes;
			for (var i = 0; i < cn.length; i++) {
				if (cn[i].nodeName.toUpperCase() == "DIV") {
					c1 = cn[i];
					break
				}
			}
			for (var i = cn.length - 1; i >= 0; i--) {
				if (cn[i].nodeName.toUpperCase() == "DIV") {
					c2 = cn[i];
					break
				}
			}
			if (!b.id.match("canvasXpressRemoteWindowBuffer")) {
				b.removeChild(c1);
				this.remoteUpdating = false
			} else {
				var that = this;
				var step = 15;
				var s = 0;
				var w = c1.clientWidth ? c1.clientWidth : b.clientWidth;
				var h = c1.clientHeight ? c1.clientHeight : b.clientHeight;
				b.parentNode.style.overflow = "hidden";
				var updater = function() {
					this.update = function() {
						b.style.width = (c1.clientWidth + c2.clientWidth) + "px";
						b.style.height = (Math.max(c1.clientHeight, c2.clientHeight)) + "px";
						var n = Math.atan((s / step) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
						var l = w * n;
						var t = h * n;
						if (s >= step) {
							clearInterval(clearUpdateInt);
							that.destroy(o);
							if (that.remoteDirection == "next") {
								c2.style.left = 0 + "px"
							} else {
								c1.style.left = 0 + "px"
							}
							b.parentNode.style.overflow = "visible";
							b.style.width = w + "px";
							b.style.height = h + "px";
							that.remoteUpdating = false;
							that.updateCurrentRemoteData()
						} else {
							if (that.remoteDirection == "next") {
								c1.style.left = (l * -1) + "px";
								c2.style.left = (l * -1) + "px"
							} else {
								c1.style.left = (-w + l) + "px";
								c2.style.left = (-w + l) + "px"
							}
							c1.style.display = "block";
							c2.style.display = "block"
						}
						s++
					};
					var clearUpdateInt = this.setInterval(this.update, 100)
				};
				updater.call()
			}
		}
	};
	this.handleRemoteSelect = function(t) {
		return function(e) {
			var s = t.getTargetEvent(e);
			var i = s.children[s.selectedIndex].value;
			var c = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarCurrent");
			t.remoteDirection = i > t.remoteDataIndex ? "next" : "previous";
			t.remoteDataIndex = i;
			var v = s.children[s.selectedIndex].text;
			if (c && s) {
				s.style.display = "none";
				t.resetSelectOptionsRemoteData(s);
				c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
			}
			t.requestRemoteData()
		}
	}(this);
	this.handleRemoteClickStop = function(t) {
		return function(e) {
			t.remoteStop = true
		}
	}(this);
	this.handleRemoteClickPlay = function(t) {
		return function(e) {
			var r = t.getTargetEvent(e);
			t.remoteDirection = "next";
			t.remoteStop = false;
			t.playRemoteData(r.parentNode.lastChild)
		}
	}(this);
	this.playRemoteData = function(s) {
		var getRef = function(trg) {
			for (var i = 0; i < CanvasXpress.instances.length; i++) {
				if (trg == CanvasXpress.instances[i].target0) {
					return CanvasXpress.instances[i];
					break
				}
			}
			for (var i = 0; i < CanvasXpress.instances.length; i++) {
				if (trg == CanvasXpress.instances[i].target) {
					return CanvasXpress.instances[i];
					break
				}
			}
			return CanvasXpress.instances[0]
		};
		var id = this.target0 || this.target;
		var updater = function() {
			var that = getRef(id);
			if (that) {
				if (!that.remoteUpdating && !that.remoteStop) {
					that.remoteUpdating = true;
					that.showInfoSpan(false, "Updating ...", true);
					if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
						that.remoteDataIndex = 0
					} else {
						that.remoteDataIndex++
					}
					that.requestRemoteData()
				}
			}
			this.update = function() {
				var that = getRef(id);
				if (that) {
					if (!that.remoteUpdating && !that.remoteStop) {
						that.remoteUpdating = true;
						that.showInfoSpan(false, "Updating ...", true);
						if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
							that.remoteDataIndex = 0
						} else {
							that.remoteDataIndex++
						}
						that.requestRemoteData()
					}
					if (that.remoteStop) {
						clearInterval(cl)
					}
				} else {
					clearInterval(cl)
				}
			};
			var cl = this.setInterval(this.update, that.remoteAutoPlayDelay)
		};
		updater.call()
	};
	this.handleRemoteClickPrev = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var r = t.getTargetEvent(e);
				var s = r.parentNode.lastChild;
				t.remoteUpdating = true;
				t.showInfoSpan(false, "Updating ...", true);
				t.remoteDirection = "previous";
				if (s && s.tagName.match(/select/i) && t.remoteDataIndex <= 0) {
					t.remoteDataIndex = s.length - 1
				} else {
					t.remoteDataIndex = Math.max(0, t.remoteDataIndex - 1)
				}
				t.requestRemoteData()
			}
		}
	}(this);
	this.handleRemoteClickNext = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var r = t.getTargetEvent(e);
				var s = r.parentNode.lastChild;
				t.remoteUpdating = true;
				t.showInfoSpan(false, "Updating ...", true);
				t.remoteDirection = "next";
				if (s && s.tagName.match(/select/i) && t.remoteDataIndex >= s.length - 1) {
					t.remoteDataIndex = 0
				} else {
					t.remoteDataIndex++
				}
				t.requestRemoteData()
			}
		}
	}(this);
	this.handleRemoteClickDown = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var s = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
				if (s) {
					if (s.style.display == "none") {
						s.style.display = "block";
						s.options[s.selectedIndex].selected = true
					} else {
						s.style.display = "none"
					}
				}
			}
		}
	}(this);
	this.addRemoteNavigation = function(w) {
		var m = "5px";
		var n = this.$cX("div", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBar"
		}, {
			padding: "2px",
			color: "rgb(34,34,34)",
			border: "1px solid rgb(51,122,183)",
			backgroundColor: "rgb(245,245,245)",
			boxShadow: "2px 2px 2px rgba(154,154,154,0.2)",
			MozBoxShadow: "2px 2px 2px rgba(154,154,154,0.2)",
			borderRadius: "4px",
			width: (this.meta.canvas.ctx.canvas.width - 5) + "px",
			position: "absolute",
			marginLeft: w + "px",
			display: "none"
		});
		var r = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarPrev",
			src: CanvasXpress.images.controlRewindBlue,
			alt: "Previous graph",
			title: "Previous graph"
		}, {
			margin: m
		});
		n.appendChild(r);
		var p = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarPlay",
			src: CanvasXpress.images.controlPlayBlue,
			alt: "Iterate over graphs",
			title: "Iterate over graphs"
		}, {
			margin: m
		});
		n.appendChild(p);
		var e = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarStop",
			src: CanvasXpress.images.controlStopBlue,
			alt: "Stop iteration",
			title: "Stop iteration"
		}, {
			margin: m
		});
		n.appendChild(e);
		var f = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarNext",
			src: CanvasXpress.images.controlForwardBlue,
			alt: "Next graph",
			title: "Next graph"
		}, {
			margin: m
		});
		n.appendChild(f);
		var c = this.$cX("input", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent",
			type: "text"
		}, {
			padding: "1px 1px 2px 1px",
			position: "absolute",
			cursor: "default",
			display: "block",
			left: "102px",
			top: "0px",
			margin: "5px",
			width: (this.meta.canvas.ctx.canvas.width - 118) + "px",
			borderRadius: "4px",
			MozBorderRadius: "4px",
			lineHeight: "normal"
		});
		n.appendChild(c);
		var d = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarDown",
			src: CanvasXpress.images.menuDropdown,
			alt: "Select graph",
			title: "Select graph"
		}, {
			margin: m,
			position: "absolute",
			top: "3px",
			right: "10px"
		});
		n.appendChild(d);
		var s = this.$cX("select", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarSelect",
			size: 4
		}, {
			position: "absolute",
			margin: "5px",
			color: "rgb(34,34,34)",
			border: "1px solid rgb(51,122,183)",
			marginTop: "1px",
			left: "102px",
			top: "26px",
			maxWidth: "800px",
			display: "none",
			zIndex: 9500
		});
		n.appendChild(s);
		return n
	};
	this.addRemoveNavigationListeners = function(t) {
		var r = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarPrev");
		var p = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarPlay");
		var e = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarStop");
		var f = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarNext");
		var d = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarDown");
		var s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
		if (r) {
			this[t](r, "click", this.handleRemoteClickPrev, false)
		}
		if (p) {
			this[t](p, "click", this.handleRemoteClickPlay, false)
		}
		if (e) {
			this[t](e, "click", this.handleRemoteClickStop, false)
		}
		if (f) {
			this[t](f, "click", this.handleRemoteClickNext, false)
		}
		if (d) {
			this[t](d, "click", this.handleRemoteClickDown, false)
		}
		if (s) {
			this[t](s, "change", this.handleRemoteSelect, false)
		}
	};
	this.selectDataSet = function(e) {
		var t = document.activeElement;
		if (t.id == this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent") {
			var s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
			var p = [];
			if (s && t.value.length > 0) {
				if (this.remoteIds.length == 0) {
					for (var i = 0; i < s.childNodes.length; i++) {
						this.remoteIds.push(s.childNodes[i].text)
					}
				}
				this.clearSelectOptionsRemoteData(s);
				for (var i = 0; i < this.remoteIds.length; i++) {
					if (this.remoteIds[i].toLowerCase().indexOf(t.value.toLowerCase()) >= 0) {
						p.push(i)
					}
				}
				for (var i = 0; i < p.length; i++) {
					var o = this.$cX("option", {
						text: this.remoteIds[p[i]],
						value: p[i]
					}, {
						width: (this.meta.canvas.ctx.canvas.width - 134) + "px"
					});
					try {
						s.add(o, null)
					} catch (ex) {
						s.add(o)
					}
				}
				s.style.display = "block"
			}
		}
	};
	this.updateRemoteNavigationWindow = function() {
		var c = this.$(this.target);
		var x = 0;
		var y = 36;
		var w = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
		var b = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
		var t = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBar");
		if (c && w && b) {
			w.style.height = ((y * 2) + c.height) + "px";
			w.style.width = ((x * 2) + c.width) + "px";
			b.style.width = (parseInt(c.parentNode.parentNode.clientWidth) * 2) + "px";
			b.style.left = x + "px";
			b.style.top = y + "px";
			if (t) {
				t.style.width = (c.width - 5) + "px";
				var p = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent");
				var s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
				if (s && p) {
					p.style.width = (c.width - 118) + "px";
					for (var i = 0; i < s.childNodes.length; i++) {
						s.childNodes[i].style.width = (c.width - 134) + "px"
					}
				}
			}
			this.resizeExtContainer()
		}
	};
	this.addRemoteWindow = function() {
		var w = this.$("container-" + this.target);
		var c = this.$(this.target);
		var p = w.parentNode;
		var y = 36;
		if (p.id && !p.id.match(/canvasXpressRemoteWindow/)) {
			this.remoteParentId = p.id;
			var d = this.$cX("div", {
				id: this.remoteParentId + "-canvasXpressRemoteWindow"
			}, {
				height: (y + c.height) + "px",
				width: c.width + "px",
				position: "relative"
			});
			var t = this.addRemoteNavigation();
			var v = this.$cX("div", {
				id: this.remoteParentId + "-canvasXpressRemoteWindowBuffer"
			}, {
				position: "absolute",
				left: "0px",
				top: y + "px"
			});
			d.appendChild(t);
			d.appendChild(v);
			p.insertBefore(d, w);
			v.appendChild(w.parentNode.appendChild(w));
			this.addRemoveNavigationListeners("addEvtListener");
			this.requestRemoteData(true);
			this.initialRemoteDataRequest = true;
			if (this.remoteAutoPlay) {
				this.remoteUpdating = true;
				this.remoteDirection = "next";
				this.remoteStop = false;
				this.playRemoteData(t.lastChild)
			}
		} else {
			this.initialRemoteDataRequest = false
		}
	};
	this.resizeExtContainer = function(over) {
		if (this.Ext && this.Ext.extId && Ext) {
			var cnt = Ext.getCmp(this.Ext.extId);
			if (cnt) {
				var par = cnt.ownerCt;
				if (par) {
					var grp = par.ownerCt;
					if (grp) {
						grp.doLayout()
					} else {
						par.doLayout()
					}
				} else {
					con.doLayout()
				}
			}
		}
	};
	this.hideNavigation = function() {
		var t = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBar");
		if (t) {
			t.style.display = "none"
		}
	};
	this.showNavigation = function() {
		var t = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBar");
		if (t) {
			t.style.display = "block"
		}
	};
	this.initializeRemote = function() {
		if (this.remoteService || this.dataURL) {
			this.addRemoteWindow();
			this.setClientGeo()
		}
	};
	this.initializeRemote()
};
CanvasXpress.prototype.initGraph = function() {
	this.draw = function(b, e, a, d, c) {
		this.showMask();
		this.meta.time.start = new Date().getTime();
		this.setUserEvents();
		this.validateUserColors();
		this.stack();
		this.initializeGraph(true, b, e, a, d, c);
		this.redrawLeaflet();
		this.meta.time.end = new Date().getTime();
		this.meta.time.elapsed = this.meta.time.end - this.meta.time.start;
		this.hideMask()
	};
	this.redrawLeaflet = function() {
		if (this.isMap && this.meta.leaflet) {
			var b = this.meta.leaflet.map;
			var a = this;
			if (b._container.style.width != this.meta.canvas.ctx.canvas.width + "px" || b._container.style.height != this.meta.canvas.ctx.canvas.height + "px") {
				b._container.style.width = this.meta.canvas.ctx.canvas.width + "px";
				b._container.style.height = this.meta.canvas.ctx.canvas.height + "px";
				b.invalidateSize();
				setTimeout(function() {
					b.setView(b.options.center, b.options.zoom);
					a.meta.leaflet.state.ini = new L.Point(a.meta.canvas.ctx.canvas.width / 2, a.meta.canvas.ctx.canvas.height / 2)
				}, 10)
			}
			if (this.tmpLeafletResizeEv) {
				this.tmpLeafletResizeEv.target.style.cursor = "";
				delete this.tmpLeafletResizeEv
			}
		}
	};
	this.isValidGraphType = function(a) {
		switch (a) {
			case "Bar":
			case "Line":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "Heatmap":
			case "Stacked":
			case "StackedPercent":
			case "Boxplot":
			case "Correlation":
			case "Treemap":
			case "TagCloud":
			case "ParallelCoordinates":
			case "Sankey":
			case "Tree":
			case "Pie":
			case "Circular":
			case "Map":
			case "BarLine":
			case "DotLine":
			case "StackedLine":
			case "StackedPercentLine":
				if (this.data.y) {
					return true
				} else {
					return false
				}
			case "Scatter2D":
				if (this.data.y && this.data.y.smps && this.data.y.smps.length > 1) {
					return true
				} else {
					return false
				}
			case "ScatterBubble2D":
			case "Scatter3D":
				if (this.data.y && this.data.y.smps && this.data.y.smps.length > 2) {
					return true
				} else {
					return false
				}
			case "Candlestick":
				if (this.data.market) {
					return true
				} else {
					return false
				}
			case "Venn":
				if (this.data.venn) {
					return true
				} else {
					return false
				}
			case "Network":
				if (this.data.nodes) {
					return true
				} else {
					return false
				}
			case "Genome":
				if (this.data.tracks) {
					return true
				} else {
					return false
				}
			case "Video":
				if (this.data.video) {
					return true
				} else {
					return false
				}
		}
		return false
	};
	this.getCustomColorScheme = function(f) {
		if (!f) {
			f = 8
		}
		var b = this.getKeys(this.meta.def.colorSchemes[this.colorScheme]);
		b.sort(function(g, d) {
			return g - d
		});
		if (this.meta.def.colorSchemes[this.colorScheme]) {
			if (this.meta.def.colorSchemes[this.colorScheme][f]) {
				return this.meta.def.colorSchemes[this.colorScheme][f]
			} else {
				if (f > b[b.length - 1]) {
					var e = f - b.length;
					f--;
					while (!this.meta.def.colorSchemes[this.colorScheme][f]) {
						f--
					}
					var c = this.meta.def.colorSchemes[this.colorScheme][f];
					for (var a = 0; a < e; a++) {
						c.push(this.meta.def.colorSchemes[this.colorScheme][f][a % this.meta.def.colorSchemes[this.colorScheme][f].length])
					}
					return c
				} else {
					f++;
					while (!this.meta.def.colorSchemes[this.colorScheme][f]) {
						f++
					}
					return this.meta.def.colorSchemes[this.colorScheme][f]
				}
			}
		} else {
			return this.colors
		}
	};
	this.setColorScheme = function() {
		if (this.colorScheme == "User") {
			return
		} else {
			if (this.colorScheme == "ColorSpectrum") {
				var a = this.colorSpectrumNumber;
				this.colorSpectrumNumber = this.data.y.vars.length;
				var b = this.getColorBrew(this.colorSpectrum, 0, this.data.y.vars.length);
				this.colors = b.colors;
				this.colorSpectrumNumber = a
			} else {
				if (this.meta.def.colorSchemes[this.colorScheme]) {
					var d;
					var c = this.getKeys(this.meta.def.colorSchemes[this.colorScheme]);
					c.sort(function(f, e) {
						return f - e
					});
					if (this.graphType == "Video") {
						d = c[c.length - 1]
					} else {
						if (this.graphType.match(/Scatter/)) {
							d = this.colorBy && this.data.z.hasOwnProperty(this.colorBy) && this.meta.data.z[this.colorBy].colors ? this.meta.data.z[this.colorBy].colors.length : this.data.y.vars.length
						} else {
							if (this.graphType.match(/Scatter|Treemap|TagCloud|Sankey|Tree/)) {
								d = this.colorBy && this.data.x.hasOwnProperty(this.colorBy) && this.meta.data.x[this.colorBy].colors ? this.meta.data.x[this.colorBy].colors.length : this.data.y.smps.length
							} else {
								if (this.graphType.match(/Venn/)) {
									d = this.vennGroups
								} else {
									if (this.graphType.match(/Pie/)) {
										d = this.data.y.vars.length
									} else {
										if (this.graphType.match(/Network|Genome|Correlation/)) {
											d = c[c.length - 1]
										} else {
											if (this.graphType == "Line" || this.graphType == "ParallelCoordinates") {
												d = this.colorBy && this.data.x.hasOwnProperty(this.colorBy) && this.meta.data.x[this.colorBy].colors ? this.meta.data.x[this.colorBy].colors.length : this.data.y.vars.length
											} else {
												if (this.graphType.match(/BarLine|DotLine/) && this.coordinateLineColor) {
													d = Math.max(this.xAxis.length, this.xAxis2.length)
												} else {
													d = this.colorBy && this.data.x.hasOwnProperty(this.colorBy) && this.meta.data.x[this.colorBy].colors ? this.meta.data.x[this.colorBy].colors.length : this.data.y.vars.length
												}
											}
										}
									}
								}
							}
						}
					}
					if (this.meta.def.colorSchemes[this.colorScheme][d]) {
						this.colors = this.meta.def.colorSchemes[this.colorScheme][d]
					} else {
						if (d > c[c.length - 1]) {
							d--;
							while (!this.meta.def.colorSchemes[this.colorScheme][d]) {
								d--
							}
						} else {
							d++;
							while (!this.meta.def.colorSchemes[this.colorScheme][d]) {
								d++
							}
						}
						this.colors = this.meta.def.colorSchemes[this.colorScheme][d]
					}
				} else {
					this.colors = this.meta.def.colorSchemes.Balanced[20]
				}
			}
		}
	};
	this.reinitializeGraph = function() {
		if (this.graphType == "Tree") {
			this.setHierarchyData("tree")
		} else {
			if (this.graphType == "Circular" && this.circularType == "bubble") {
				this.setHierarchyData("bubble")
			} else {
				if (this.graphType == "Sankey" && !this.moveSankey) {
					if ((!this.sankeySource || !this.sankeyTarget) && this.data.x) {
						if (!this.sankeySource && this.data.x.hasOwnProperty("Source")) {
							this.sankeySource = "Source"
						}
						if (!this.sankeyTarget && this.data.x.hasOwnProperty("Target")) {
							this.sankeyTarget = "Target"
						}
						var b = this.meta.data.x;
						var d = this.sortObject(this.data.x);
						var a = [];
						for (var c = 0; c < d.length; c++) {
							if (b[d[c]].type == "String") {
								a.push(d[c])
							}
						}
						if (a.length > 0) {
							if (!this.sankeySource) {
								this.sankeySource = a.shift()
							}
							if (!this.sankeyTarget) {
								if (a.length > 0) {
									this.sankeyTarget = a.shift()
								} else {
									this.sankeyTarget = this.sankeySource
								}
							}
						}
					}
					var c = this.hierarchyVar ? this.getVariableIndeces(this.hierarchyVar) : 0;
					this.hierarchyVarIndex = c >= 0 ? c : 0;
					this.setSankeyData()
				} else {
					if (this.graphType == "Candlestick") {
						this.isGraphTime = true;
						if (!this.isMarketSwitched) {
							this.switchToMarketData();
							this.initAxes();
							this.summaryType = "candle";
							this.initializeDataAttributes();
							this.isMarketSwitched = true
						}
						this.setMarketTechnicalData()
					} else {
						if (this.isExample && this.isMarketSwitched) {
							this.switchFromMarketData();
							this.isMarketSwitched = false;
							this.summaryType = this.data.y.data ? "raw" : "mean";
							this.initializeDataAttributes();
							this.isGraphTime = false;
							if (this.showVolume) {
								this.layoutComb = false
							}
						} else {
							if (this.graphType.match(/Scatter/) && this.scatterPlotMatrix && !this.isDOE) {
								if (!this.data.l) {
									this.setScatterPlotMatrix()
								}
							} else {
								if (this.graphType.match(/Pie/) && this.xAxis.length > 1 && !this.isDOE) {
									this.setMultiplePies()
								}
							}
						}
					}
				}
			}
		}
	};
	this.getNetworkImages = function() {
		var a = [];
		if (this.graphType == "Network") {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (c.imagePath) {
					if (!c.imagePath.match(/^(http|file):\/\//)) {
						c.imagePath = this.imageDir + c.imagePath
					}
					a.push(c.imagePath)
				}
			}
		}
		return a
	};
	this.initializeGraph = function(o, a, n, k, c, d) {
		var f = this;
		var b = 0;
		var h = [];
		var l = [];
		var g = function(i) {
			var p = f.getFileName(i);
			return CanvasXpress.images[p] ? true : CanvasXpress.cacheImages.hasOwnProperty(p) && typeof(CanvasXpress.cacheImages[p]) == "object"
		};
		var m = function() {
			for (var p = 0; p < h.length; p++) {
				if (CanvasXpress.images[h[p]]) {
					continue
				}
				if (!g(h[p])) {
					return false
				}
			}
			return true
		};
		this.hideCanvas();
		this.createPatterns();
		if (this.graphType == "Network") {
			h = this.getNetworkImages()
		}
		if (this.graphType.match(/scatter/i)) {
			for (var e = 0; e < this.images.length; e++) {
				if (!this.images[e].match(/^(http|file):\/\//)) {
					this.images[e] = this.imageDir + this.images[e]
				}
				h.push(this.images[e])
			}
		}
		if (this.backgroundImage) {
			if (!this.backgroundImage.match(/^(http|file):\/\//)) {
				this.backgroundImage = this.imageDir + this.backgroundImage
			}
			h.push(this.backgroundImage)
		}
		if (h.length > 0) {
			if (this.graphType == "Network") {
				this.Network(true)
			} else {
				if (this.graphType == "Scatter3D") {
					this.Scatter3D(true)
				} else {
					if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
						this.Scatter2D(true)
					}
				}
			}
		} else {
			CanvasXpress.cacheImagesReady = true
		}
		if (h.length > 0 && !m() && !d) {
			for (var e = 0; e < h.length; e++) {
				if (!g(h[e])) {
					l.push(h[e])
				}
			}
			for (var e = 0; e < h.length; e++) {
				if (!g(h[e])) {
					var j = new Image;
					j.onload = function() {
						CanvasXpress.cacheImages[f.getFileName(this.src)] = this;
						b++;
						CanvasXpress.cacheImagesReady = b == l.length;
						if (CanvasXpress.cacheImagesReady) {
							f.renderGraph(o, a, n, k, c)
						}
					};
					j.src = h[e]
				}
			}
		} else {
			this.renderGraph(o, a, n, k, c)
		}
	};
	this.renderGraph = function(h, d, a, c, f) {
		var g = this.meta.def;
		if (this.initialRemoteDataRequest) {
			return
		}
		this.setColorScheme();
		this.reinitializeGraph();
		if (!c) {
			if (this.graphType != "Candlestick" || (this.graphType == "Candlestick" && !this.showVolume)) {
				if (!this.motionOn) {
					this.initAxes()
				}
				this.setColorBrew(true)
			}
		}
		if (h) {
			this.resizeCanvas(true, d, a)
		} else {
			this.resizeCanvas(false, d, a)
		}
		this.setAspectRatioProperties();
		if (this.isValidAnimation() && this.showAnimation && !this.isAnimation) {
			this.createAnimation(this.animationType)
		} else {
			var e = this.layoutComb ? true : false;
			switch (this.graphType) {
				case "Bar":
				case "Dotplot":
					if (this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					if (this.is3DPlot) {
						this.showTransition = false;
						this.Scatter3D()
					} else {
						this.oneDPlot()
					}
					break;
				case "Line":
				case "Area":
				case "AreaLine":
				case "BarLine":
				case "DotLine":
				case "Heatmap":
				case "Treemap":
				case "ParallelCoordinates":
				case "Stacked":
				case "StackedLine":
				case "StackedPercent":
				case "StackedPercentLine":
				case "Candlestick":
					if (this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					this.oneDPlot();
					break;
				case "TagCloud":
					this.oneDPlot();
					break;
				case "Boxplot":
					if (!this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					this.oneDPlot();
					break;
				case "Sankey":
					this.showTransition = !this.sankeyShowTransition;
					this.oneDPlot();
					this.sankeyShowTransition = true;
					break;
				case "Tree":
					this.showTransition = true;
					this.oneDPlot();
					break;
				case "Scatter2D":
				case "ScatterBubble2D":
					this.Scatter2D();
					break;
				case "Scatter3D":
					this.showTransition = false;
					this.Scatter3D();
					break;
				case "Correlation":
					this.Correlation();
					break;
				case "Venn":
					this.Venn();
					break;
				case "Pie":
					this.Pie();
					break;
				case "Circular":
					this.Circular();
					break;
				case "Network":
					this.showTransition = false;
					if (f) {
						var b = this.calculateLayout;
						var e = this.randomNetwork;
						this.calculateLayout = false;
						this.randomNetwork = false;
						this.Network();
						this.calculateLayout = b;
						this.randomNetwork = e
					} else {
						this.Network()
					}
					break;
				case "Genome":
					this.showTransition = false;
					this.Genome();
					break;
				case "Video":
					this.showTransition = false;
					this.Video();
					break;
				case "Map":
					this.showTransition = false;
					this.drawLeaflet();
					break
			}
			this.drawCanvasBox();
			if (this.showCode) {
				this.updateCodeDiv()
			}
			if (this.showDataTable) {
				this.updateDataTable()
			} else {
				if (this.dataTableLastState && this.dataTableLastState != "docked") {
					this.hideUnhideDataTable(true)
				}
			}
			this.setAcknowledgmentVisibility();
			if (this.graphType != "Network") {
				this.drawCitation()
			}
			this.setVideoControls();
			if (navigator.onLine) {
				if (!this.Rdatasets && this.loadRDatasets) {
					this.getRDatasets()
				}
			}
			this.resetAspectRatioProperties();
			this.resetGradientTransparencyShadow();
			if (this.userEvents.enddraw) {
				this.userEvents.enddraw.call(this)
			}
			this.monitorInstances();
			this.render();
			if (this.debug) {
				this.drawArea()
			}
			this.showCanvas();
			this.meta.last = this.getConfig();
			this.meta.vals.histogram = this.data.y && this.data.y.histogram ? this.cloneObject(this.data.y.histogram) : false;
			if (this.layoutValid) {
				this.meta.vals.layout = {
					l: this.cloneObject(this.data.l),
					g: this.data.w ? this.cloneObject(this.data.w.grps) : false,
					v: this.cloneObject(this.segregateVariablesBy),
					s: this.cloneObject(this.segregateSamplesBy)
				}
			} else {
				this.meta.vals.layout = false
			}
		}
	};
	this.initializeGraph()
};
CanvasXpress.prototype.initAxes = function(noInit) {
	this.getValidAxes = function(isPie) {
		var axes = [];
		if (this.graphType == "Scatter2D") {
			axes.push("xAxis");
			axes.push("yAxis")
		} else {
			if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
				axes.push("xAxis");
				axes.push("yAxis");
				axes.push("zAxis")
			} else {
				if (this.graphType.match(/Network|Genome|Correlation|Venn|Heatmap|Pie|Video/)) {
					if (isPie) {
						axes.push("xAxis")
					} else {
						return false
					}
				} else {
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) || (this.graphType == "Candlestick" && this.showVolume)) {
						axes.push("xAxis");
						axes.push("xAxis2")
					} else {
						if (this.graphType == "Circular") {
							axes.push("xAxis");
							axes.push("rAxis")
						} else {
							axes.push("xAxis")
						}
					}
				}
			}
		}
		return axes
	};
	this.addRemoveSamplesInAxis = function(smps, axis, check) {
		if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
			if (check) {
				return this.removeSamplesFromAxis(smps, axis)
			} else {
				return this.addSamplesToAxis(smps, axis)
			}
		} else {
			if (this.graphType == "Scatter3D" || this.graphType == "Pie") {
				return this.switchSampleInAxis(smps, axis)
			}
		}
	};
	this.addSamplesToAxis = function(smps, axis) {
		if (this[axis]) {
			if (this.isArray(smps)) {
				var sia = this.getObjectArray(this[axis]);
				for (var i = 0; i < smps.length; i++) {
					if (!sia.hasOwnProperty(smps[i])) {
						this[axis].push(smps[i])
					}
				}
			} else {
				this[axis].push(smps)
			}
			return false
		} else {
			return "Not a valid axis"
		}
	};
	this.removeSamplesFromAxis = function(smps, axis) {
		if (this[axis]) {
			if (this[axis].length > 1) {
				var seen = {};
				var temp = [];
				if (this.isArray(smps)) {
					for (var i = 0; i < smps.length; i++) {
						seen[smps[i]] = 1
					}
				} else {
					seen[smps] = 1
				}
				for (var i = 0; i < this[axis].length; i++) {
					if (!seen.hasOwnProperty(this[axis][i])) {
						temp.push(this[axis][i])
					}
				}
				this[axis] = temp;
				return false
			} else {
				return axis + " cannot be null"
			}
		} else {
			return "Not a valid axis"
		}
	};
	this.switchSampleInAxis = function(smp, axis) {
		if (this[axis]) {
			this[axis][0] = this.isArray(smp) ? smp[0] : smp;
			return false
		} else {
			return "Not a valid axis"
		}
	};
	this.addRemoveVariablesInAxis = function(vars, axis, check) {
		if (check) {
			return this.removeVariablesFromAxis(vars, axis)
		} else {
			return this.addVariablesToAxis(vars, axis)
		}
	};
	this.addVariablesToAxis = function(vars, axis) {
		if (this[axis]) {
			if (this.isArray(vars)) {
				for (var i = 0; i < vars.length; i++) {
					this[axis].push(vars[i])
				}
			} else {
				this[axis].push(vars)
			}
		}
		return false
	};
	this.removeVariablesFromAxis = function(vars, axis) {
		if (this[axis]) {
			var seen = {};
			var temp = [];
			if (this.isArray(vars)) {
				for (var i = 0; i < vars.length; i++) {
					seen[vars[i]] = 1
				}
			} else {
				seen[vars] = 1
			}
			for (var i = 0; i < this[axis].length; i++) {
				if (!seen.hasOwnProperty(this[axis][i])) {
					temp.push(this[axis][i])
				}
			}
			this[axis] = temp
		} else {
			return "Not a valid axis"
		}
		return false
	};
	this.formatAxisValue = function(val, axis) {
		if (this[axis + "TickFormat"]) {
			var frmt = this[axis + "TickFormat"];
			if (this.isArray(this[axis + "TickFormat"])) {
				frmt = this[axis + "TickFormat"][0];
				val = eval(this[axis + "TickFormat"][1])
			}
			if (this.graphType == "Candlestick" && this.summaryType == "volume") {
				if (this.xAxis2TickFormat) {
					return sprintf(this.xAxis2TickFormat, val)
				} else {
					return sprintf(this[axis + "TickFormat"], val)
				}
			} else {
				return val ? sprintf(frmt, val) : val.toString()
			}
		} else {
			if (this.graphType == "Candlestick" && this.summaryType == "volume") {
				return sprintf("%." + this.xAxis2Decs + "f", val)
			} else {
				if (val % 1 === 0) {
					if (val.toString().match("e")) {
						return val.toString()
					} else {
						var n = val.toString().length;
						if (n > 6) {
							return sprintf("%.1e", val)
						} else {
							return parseInt(val).toString()
						}
					}
				} else {
					var d = Math.min(this[axis + "Decs"], 20);
					var v = sprintf("%." + d + "f", val);
					var n = v.length;
					if (n > 8) {
						v = sprintf("%.3e", val)
					}
					while (v.substring(n - 1, n) == "0") {
						v = v.substring(0, n - 1);
						n = v.length
					}
					return v
				}
			}
		}
	};
	this.getAxisDataBySample = function(idx, axis) {
		var vals = [];
		var trn = false;
		var min = false;
		var max = false;
		if (axis) {
			trn = this[axis + "AxisTransform"];
			max = this[axis + "AxisTransformFloorValue"];
			min = this[axis + "AxisTransformCeilValue"]
		}
		if (this.isArray(idx)) {
			for (var i = 0; i < this.varIndices.length; i++) {
				var ii = this.varIndices[i];
				for (var j = 0; j < idx.length; j++) {
					vals.push(this.getDataAtPos(ii, idx[j], false, trn, min, max))
				}
			}
		} else {
			for (var i = 0; i < this.varIndices.length; i++) {
				var ii = this.varIndices[i];
				vals.push(this.getDataAtPos(ii, idx, false, trn, min, max))
			}
		}
		return vals
	};
	this.getAxisRangeBySample = function(idx) {
		return this.range(this.getAxisDataBySample(idx))
	};
	this.getAxisIncrements = function(min, max, ticks, exact, add) {
		var test, test2;
		var decs = 0;
		if (min == max) {
			return 0.1
		}
		if (exact) {
			test = parseFloat(this.formatNumber((max - min) / ticks, decs));
			while (test == 0) {
				decs++;
				test = parseFloat(this.formatNumber((max - min) / ticks, decs))
			}
			return test
		} else {
			if (max - min <= Number.MIN_VALUE) {
				return 0.1
			}
			var adj = ((add || max) - min) * this.axisExtension;
			var amin = min - adj;
			var amax = (add || max) + adj;
			var range = amax - amin;
			var len = -Math.floor(Math.log(range / ticks) / Math.LN10);
			var step = Math.pow(10, -len);
			var decs = this.getAxisDecimals(step);
			var norm = ((range / ticks) / step);
			if (norm < 1.5) {
				test = step
			} else {
				if (norm < 2) {
					test = step * 2
				} else {
					if (norm < 2.5) {
						test = step * 2.5
					} else {
						if (norm < 5) {
							test = step * 5;
							test2 = step * 2.5
						} else {
							if (norm < 7.5) {
								test = step * 7.5
							} else {
								test = step * 10;
								test2 = step * 5
							}
						}
					}
				}
			}
			if (this.getAxisMin(min, test) + (test * ticks) < max) {
				return this.getAxisIncrements(min, max, ticks, exact, (add || max) + test)
			} else {
				if (test2 && this.getAxisMin(min, test2) + (test2 * ticks) >= max) {
					return test2
				} else {
					return test
				}
			}
		}
	};
	this.getAxisMin = function(min, inc) {
		var mm = inc * Math.floor(min / inc);
		return isNaN(mm) ? 0 : mm < 0 && this.minData >= 0 ? 0 : mm
	};
	this.setAxis = function(axis, isVar) {
		var level = this.isGroupedData ? this.data.w : this.data.y;
		var indxs = isVar ? this.getVariableIndices(this[axis]) : this.getSampleIndices(this[axis]);
		if ((this.isArray(indxs) && indxs.length == 0) || (!this.isArray(indxs) && indxs == -1)) {
			this[axis] = []
		}
		if (this[axis].length == 0) {
			if (axis == "xAxis") {
				if (isVar) {
					for (var i = 0; i < this.varIndices.length; i++) {
						this[axis].push(this.data.y.vars[this.varIndices[i]])
					}
				} else {
					this[axis].push(level.smps[this.smpIndices[0]])
				}
			} else {
				if (axis == "xAxis2") {
					this[axis].push(this.data.y.vars[this.varIndices[this.varIndices.length - 1]])
				} else {
					if (axis == "yAxis") {
						if (level.smps.length > 1) {
							this[axis].push(level.smps[this.smpIndices[1]])
						} else {
							this[axis].push(level.smps[this.smpIndices[0]])
						}
					} else {
						if (axis == "zAxis") {
							if (level.smps.length > 2) {
								this[axis].push(level.smps[this.smpIndices[2]])
							} else {
								if (level.smps.length > 1) {
									this[axis].push(level.smps[this.smpIndices[1]])
								} else {
									this[axis].push(level.smps[this.smpIndices[0]])
								}
							}
						}
					}
				}
			}
		} else {
			if (this.graphType == "Scatter3D" && this[axis].length > 1) {
				this[axis] = [this[axis][0]]
			}
		}
	};
	this.setAxisValues = function(axis) {
		var val, str, prev, valn, mnri, pmnv, redo, msl, mval;
		var seen = {};
		var mnrv = axis + "MinorValues";
		var vals = axis + "Values";
		var vraw = axis + "ValuesRaw";
		var tick = axis + "Ticks";
		var frmt = axis + "TickFormat";
		var incr = axis + "Incr";
		var decs = axis + "Decs";
		var min = axis + "Min";
		var max = axis + "Max";
		var trns = axis + "Transform";
		var maxs = axis + "MaxStrLength";
		if (this[trns] == "percentile") {
			this[decs] = 0;
			this[vals] = [];
			this[vraw] = [];
			this[mnrv] = [];
			var ticks = [0, 25, 50, 75, 100];
			for (var i = 0; i < ticks.length; i++) {
				this[vals].push(ticks[i])
			}
			for (var i = 5; i < 100; i += 5) {
				this[mnrv].push(i)
			}
		} else {
			this[vals] = [];
			this[mnrv] = [];
			this[vraw] = [];
			val = this[min];
			mnri = this[incr] / this[tick];
			for (var i = 0; i <= this[tick] + 1; i++) {
				for (var j = 0; j < this[tick]; j++) {
					mval = val + (mnri * j);
					this[mnrv].push(mval)
				}
				if (this[decs] == 0 && val.toString().match(/\.5$/)) {
					this[decs] = 1
				}
				str = this.formatAxisValue(val, axis);
				if (seen.hasOwnProperty(str) && !this[frmt]) {
					redo = true
				} else {
					seen[str] = 1
				}
				if (str > this[max]) {
					break
				}
				this[vals].push(str);
				this[vraw].push(val);
				val += this[incr]
			}
		}
		if (redo && this[decs] < 20) {
			this[decs]++;
			this[vals] = [];
			this[mnrv] = [];
			this.setAxisValues(axis)
		} else {
			msl = this.getMaxText(this[vals]);
			if (this[frmt]) {
				this[maxs] = msl
			} else {
				this[maxs] = this.formatNumber(msl, this[decs])
			}
			this[mnrv].unshift(this[mnrv][0] - mnri)
		}
	};
	this.setAxisAttributes = function(axis, type, forceRaw, transform, stacked, noExt) {
		var that = this;
		var justPositive = transform && transform.match(/log/) ? true : false;
		var tick = axis + "Ticks";
		var incr = axis + "Incr";
		var exct = axis + "Exact";
		var amin = axis + "AbsMin";
		var amax = axis + "AbsMax";
		var min = axis + "Min";
		var max = axis + "Max";
		var rang = axis + "Range";
		var decs = axis + "Decs";
		var trns = axis + "Transform";
		this.setRangeData(type, forceRaw, justPositive, stacked);
		var getScatterPoint = function() {
			if (that.graphType.match(/Scatter|Dot/i)) {
				that.setScatterPointSize();
				var a = axis.substring(0, 1);
				var u = (a == "x" ? that.width : that.height) / (that.maxData - that.minData);
				return (that.scatterPointSize / u) * 1
			} else {
				return 0
			}
		};
		if (this.minData == this.maxData) {
			this.maxData += 0.5
		}
		if (transform) {
			if (transform == "log2") {
				this.minData = Math.log(this.minData) / Math.LN2;
				this.maxData = Math.log(this.maxData) / Math.LN2
			} else {
				if (transform == "log10") {
					this.minData = Math.log(this.minData) / Math.LN10;
					this.maxData = Math.log(this.maxData) / Math.LN10
				} else {
					if (transform == "exp2") {
						this.minData = Math.pow(2, this.minData);
						this.maxData = Math.pow(2, this.maxData)
					} else {
						if (transform == "exp10") {
							this.minData = Math.pow(10, this.minData);
							this.maxData = Math.pow(10, this.maxData)
						} else {
							if (transform == "percentile") {
								this.minData = this.minData < 0 ? -100 : 0;
								this.maxData = 100
							}
						}
					}
				}
			}
		}
		if (this.isHistogram) {
			this.minData = 0
		}
		this[amin] = this.setMin == null ? this.minData : this[amin];
		this[amax] = this.setMax == null ? this.maxData : this[amax];
		var excp = this.isHistogram || this.graphType.match(/Stacked|Bar|Area/) || (transform && transform == "percentile") || noExt;
		var vals = this[this.axisAlgorithm](this.minData, this.maxData, this[tick], this.axisWilkinsonLoose);
		var exts = (this.maxData - this.minData) * this.axisExtension / 2;
		var tmp = this[tick];
		var sctp = getScatterPoint();
		this[incr] = vals[1] - vals[0];
		this[decs] = this.getAxisDecimals(this[incr]);
		this[min] = vals[0];
		this[max] = vals[vals.length - 1];
		this[tick] = vals.length;
		this.setAxisValues(axis);
		if (vals[0] <= (this.minData - sctp) || excp) {
			this[min] = vals[0]
		} else {
			this[min] = this.minData - exts
		}
		if (vals[vals.length - 1] >= (this.maxData + sctp) || excp) {
			this[max] = vals[vals.length - 1]
		} else {
			this[max] = this.maxData + exts
		}
		this[rang] = this[max] - this[min];
		this[tick] = tmp
	};
	this.setAxes = function(km, noExt, frcStck) {
		if (this.smpIndices && this.smpIndices.length < 1) {
			return
		}
		if (this.graphType.match(/Venn|Network|Video|Sankey|Tree/)) {
			return
		} else {
			if (this.graphType.match(/Correlation/)) {
				var level = this.isGroupedData ? this.data.w : this.data.y;
				this.setMin = null;
				this.setMax = null;
				if (this.correlationAnchorLegend) {
					this.setAxisAttributes("xAxis")
				}
				if (!level.cor || level.cor.length == 0) {
					this.summarize("cor");
					this.setRangeData("cor")
				}
				if (!this.yAxisTitle) {
					this.yAxisTitle = "Correlation"
				}
			} else {
				if (this.graphType.match(/Scatter|Pie/)) {
					var smpIndices = this.smpIndices;
					var axes = ["xAxis"];
					var ax = ["X"];
					if (this.graphType.match(/Scatter/)) {
						axes.push("yAxis");
						ax.push("Y")
					}
					if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
						axes.push("zAxis");
						ax.push("Z")
					}
					if (this.graphType == "Scatter3D") {
						this.xAxisTicks = 10;
						this.yAxisTicks = 10;
						this.zAxisTicks = 10
					}
					for (var i = 0; i < axes.length; i++) {
						var indx = axes[i] + "Indices";
						var min = "setMin" + ax[i];
						var max = "setMax" + ax[i];
						this.setMin = null;
						this.setMax = null;
						this.setAxis(axes[i]);
						this[indx] = this.getSampleIndices(this[axes[i]]);
						if (this.scatterAxesEqual) {
							this.setSamplesVisible(smpIndices)
						} else {
							this.setSamplesVisible(this[indx])
						}
						if (this[min] != null) {
							this.setMin = this[min]
						}
						if (this[max] != null) {
							this.setMax = this[max]
						}
						this.setAxisAttributes(axes[i], i > 0 ? km : false, false, this[axes[i] + "Transform"]);
						this.setSamplesVisible(smpIndices)
					}
					if (!this.scatterPlotMatrix) {
						if (!this.xAxisTitle || this.xAxisTitleDynamic) {
							this.xAxisTitleDynamic = true;
							this.xAxisTitle = this.xAxis.length == 1 ? this.xAxis[0] : " "
						}
						if (this.graphType.match(/Scatter/)) {
							if (!this.yAxisTitle || this.yAxisTitleDynamic) {
								this.yAxisTitleDynamic = true;
								this.yAxisTitle = this.yAxis.length == 1 ? this.yAxis[0] : " "
							}
							if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
								if (!this.zAxisTitle || this.zAxisTitleDynamic) {
									this.zAxisTitleDynamic = true;
									this.zAxisTitle = this.zAxis.length == 1 ? this.zAxis[0] : " "
								}
							}
						}
					}
				} else {
					if (this.graphType.match(/Genome/)) {
						this.setMax = this.setMaxX != null ? this.setMaxX : null;
						this.setMin = this.setMinX != null ? this.setMinX : null;
						this.setRangeData("genome");
						this.xAxisExact = true;
						this.xAxisTransform = false;
						this.xAxisAbsMin = this.minData;
						this.xAxisAbsMax = this.maxData;
						this.xAxisMin = this.minData - 1;
						this.xAxisMax = this.maxData + 1;
						this.xAxisDecs = 0;
						this.xAxisRange = this.xAxisMax - this.xAxisMin;
						this.xAxisTicks = this.genomeTicks;
						this.xAxisIncr = this.xAxisRange / this.xAxisTicks;
						this.setAxisValues("xAxis")
					} else {
						if (this.graphType == "ParallelCoordinates") {
							this.parallelCoordinates = [];
							var level = this.isGroupedData ? this.data.w : this.data.y;
							var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
							for (var i = 0; i < indices.length; i++) {
								var ii = indices[i];
								var lenSmp = this.measureText(level.smps[ii], this.smpLabelFont);
								var rng = this.range(this.getDataForSmpGrpAtIndex(ii));
								var valst = this[this.axisAlgorithm](rng[0], rng[1], this.xAxisTicks, this.axisWilkinsonLoose);
								var vals = [];
								for (var j = 0; j < valst.length; j++) {
									if (valst[j] >= rng[0] && valst[j] <= rng[1]) {
										vals.push(valst[j])
									}
								}
								var maxText = this.getMaxText(vals);
								var len = this.measureText(maxText, this.axisTickFont);
								var o = {
									smp: level.smps[ii],
									lenSmp: lenSmp,
									range: rng,
									min: rng[0],
									max: rng[1],
									vals: vals,
									maxText: maxText,
									len: len
								};
								if (this.meta.data.modified && this.meta.data.modified.z && this.meta.data.modified.z[level.smps[ii]]) {
									var levs = this.meta.data.modified.z[level.smps[ii]];
									var maxTextLev = this.getMaxText(levs);
									var lenLev = this.measureText(maxTextLev, this.axisTickFont);
									o.levs = levs;
									o.maxTextLev = maxTextLev;
									o.lenLev = lenLev;
									o.type = "String"
								} else {
									o.type = "Numeric"
								}
								this.parallelCoordinates.push(o)
							}
						} else {
							var tSmpIdx = this.smpIndices;
							var tVarIdx = this.varIndices;
							var tGrpIdx = this.grpIndices;
							var varIndices = this.varIndices;
							var forceRaw = (this.graphType == "Dotplot" || this.graphType == "DotLine") && this.isGroupedData ? true : false;
							var transform = this.graphType.match(/Percent/) || (this.graphType.match(/Area/) && this.areaType.match(/percent/)) ? "percentile" : this.xAxisTransform;
							var stacked = this.graphType.match(/Stacked/) || (this.graphType.match(/Area/) && this.areaType.match(/stacked/)) || frcStck ? true : false;
							var type = this.graphType == "Candlestick" ? "candle" : transform ? transform : false;
							if (!this.is3DPlot) {
								this.setAxis("xAxis", true);
								this.xAxisVarIndices = this.getVariableIndices(this.xAxis);
								if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
									this.setAxis("xAxis2", true);
									this.xAxis2VarIndices = this.getVariableIndices(this.xAxis2)
								}
							}
							if (this.varIndicesStart > -1 || this.smpIndicesStart > -1) {
								if (this.graphType == "Heatmap") {
									this.graphOrientation = "horizontal"
								}
							} else {
								if (this.graphType == "StackedPercent" || this.graphType == "StackedPercentLine" || (this.graphType.match(/Area/) && this.areaType.match(/percent/))) {
									this.setMinX = null;
									this.setMaxX = null;
									this.xAxisExact = true
								} else {
									if ((this.graphType == "Boxplot" && !this.isGroupedData && this.groupingFactors.length == 0) || this.summarizeBoxplot) {
										this.summarize("iqr");
										delete(this.summarizeBoxplot)
									}
								}
							}
							this.xAxis2Ticks = this.xAxisTicks;
							if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
								this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis"))
							}
							this.setMax = this.setMaxX != null ? this.setMaxX : null;
							this.setMin = this.setMinX != null ? this.setMinX : null;
							this.setAxisAttributes("xAxis", type, forceRaw, transform, stacked, noExt);
							this.xAxisTitle = this.xAxisTitle || "";
							if ((this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) || (this.graphType == "Candlestick" && this.showVolume)) {
								type = this.graphType == "Candlestick" ? "volume" : false;
								if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
									this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis2"))
								}
								this.setMax = this.setMaxX2 != null ? this.setMaxX2 : null;
								this.setMin = this.setMinX2 != null ? this.setMinX2 : null;
								this.setAxisAttributes("xAxis2", type, forceRaw, transform, stacked);
								this.xAxis2Title = this.xAxis2Title || ""
							}
							this.setMax = this.setMaxR != null ? this.setMaxR : this.setMax;
							this.setMin = this.setMinR != null ? this.setMinR : this.setMin;
							if (this.graphType == "Circular" && (this.rAxis || this.circularType == "chord")) {
								this.setAxisAttributes("rAxis", "circular", forceRaw, transform, false, true)
							}
							this.setVariablesVisible(varIndices);
							this.smpIndices = tSmpIdx;
							this.varIndices = tVarIdx;
							this.grpIndices = tGrpIdx
						}
					}
				}
			}
		}
	};
	this.setScatterPointSize = function() {
		this.scatterPointSize = this.varIndices.length > 50 ? this.sizes[5] : this.varIndices.length > 20 ? this.sizes[6] : this.sizes[7];
		if (this.layoutComb) {
			this.scatterPointSize = Math.ceil(this.scatterPointSize / this.layoutRows)
		}
	};
	this.setAxisUnits = function(axis, gaxis) {
		var unit = axis + "Unit";
		var rang = axis + "Range";
		var a = gaxis ? gaxis : axis.substring(0, 1);
		this[unit] = this[a] / this[rang]
	};
	this.setAxisFont = function(title, axis) {
		if (this.autoScaleFont) {
			this.setPropertyFontSize(axis, "decorationFont");
			this.setPropertyFontSize(axis, "axisTickFont");
			this.setPropertyFontSize(axis, "axisTitleFont");
			this.adjustFont(title, "axisTitleFont", axis)
		} else {
			this.decorationFont = this.decorationFontStyle + " " + parseInt(this.decorationFontSize) + "px " + this.fontName;
			this.axisTickFont = this.axisTickFontStyle + " " + parseInt(this.axisTickFontSize) + "px " + this.fontName;
			this.axisTitleFont = this.axisTitleFontStyle + " " + parseInt(this.axisTitleFontSize) + "px " + this.fontName
		}
	};
	this.getAxisFont = function(axis) {
		if (axis >= 600) {
			return 12
		} else {
			if (axis >= 400) {
				return 10
			} else {
				if (axis >= 200) {
					return 8
				} else {
					return 6
				}
			}
		}
	};
	this.initializeAxis = function() {
		if (!this.graphType.match(/Venn|Network|Video/)) {
			if (!noInit) {
				this.setAxes();
				this.setColorBrew()
			}
		}
	};
	this.initializeAxis()
};
CanvasXpress.prototype.Pie = function(a) {
	this.setVarPie = function() {
		var g = [];
		var b = this.smpIndices[0];
		if (this.varIndices.length >= this.maxPieSectors - 1) {
			var f = this;
			this.varIndices.sort(function(h, d) {
				return f.data.y.data[d][b] - f.data.y.data[h][b]
			})
		}
		for (var c = 0; c < this.varIndices.length; c++) {
			var e = this.varIndices[c];
			g.push(this.getDataAtPos(e, b))
		}
		this.varPie = this.setPieData(g, true)
	};
	this.setPieFont = function() {
		if (this.autoScaleFont) {
			var b = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea);
			this.setAxisFont("Pie", b)
		}
	};
	this.setPieXYDimensions = function() {
		if (this.showLegend) {
			if (this.legendPosition == "right") {
				this.right = this.layoutComb && !this.isDOE ? this.layoutRight : this.layoutComb ? Math.min(this.layoutWidth / 3, this.legendVariableWidth) : Math.min(this.width / 3, this.legendVariableWidth)
			} else {
				this.bottom = this.layoutComb && !this.isDOE ? this.layoutBottom : this.layoutComb ? Math.min(this.layoutHeight / 3, this.legendVariableHeight) : Math.min(this.height / 3, this.legendVariableHeight)
			}
		}
		this.x = this.layoutComb && !this.isDOE ? this.layoutWidth : this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.layoutComb && !this.isDOE ? this.layoutHeight : this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
	};
	this.drawPieDataPoints = function() {
		this.addToRender(["setClipArea", this.setClipBoundaries()]);
		var c = Math.min(this.x, this.y);
		var d = (c - (c / 5)) / 2;
		var b = this.marginLeft + this.offsetX + this.left + (this.x / 2);
		var e = this.marginTop + this.offsetY + this.top + (this.y / 2);
		this.setVarPie();
		this.drawPie(this.varPie, b, e, d, true);
		this.addToRender(["resetClipArea"])
	};
	this.drawPiePlot = function() {
		this.setPieFont();
		this.setLegends();
		this.setPieXYDimensions();
		this.drawPieDataPoints();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializePiePlot = function() {
		if (this.xAxisMin < 0) {
			alert("Dude you can't draw a pie chart with negative numbers!");
			return
		}
		this.setPropertyFontSize(Math.min(this.width, this.height), "smpLabelFont");
		if (this.layoutValid) {
			this.drawLayoutCompartments(this.drawPiePlot)
		} else {
			this.drawPiePlot()
		}
	};
	if (!a) {
		this.initializePiePlot()
	}
};
CanvasXpress.prototype.Venn = function() {
	this.setVennXYDimensions = function() {
		var a;
		this.vennMarginLeft = 0;
		this.vennMarginTop = 0;
		this.setAxisFont("Venn", this.width);
		if (this.showLegend) {
			this.bottom = this.legendHeight
		}
		if (this.width <= this.height) {
			this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
		} else {
			this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
		}
		this.y = this.vennGroups == 4 ? this.x * 0.8 : this.vennGroups == 3 ? this.x * 0.95 : this.vennGroups == 2 ? this.x * 0.65 : this.x;
		this.vennMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
		this.vennMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2;
		if (this.x < 400) {
			var b = this.getFontPt(this.axisTickFont) - 2;
			if (this.x < 200) {
				b -= 1
			}
			this.axisTickFont = b + "px " + this.fontName
		}
		this.resizeCanvas()
	};
	this.drawVennBubble = function(f, g, i, c, d, b) {
		var a = this.marginLeft + this.left + (this.x / 2);
		var e = this.marginTop + this.top + (this.y / 2);
		this.functionCaller = "drawVennBubble";
		this.addToRender(["drawShape", i, f, g, c, c, d, this.foreground, "closed", b], false, false, null, false, [a, e, 0, 0])
	};
	this.drawVennLayoutBubbles = function() {
		this.functionCaller = "drawVennLayoutBubbles";
		var e, f, b, d;
		var a = [];
		for (var c in this.data.venn.legend) {
			a.push(c)
		}
		this.addToRender(["rectangleClear", 0, 0, this.width, this.height]);
		this.addToRender(["setGlobalCompositionOperation", "lighter"]);
		if (this.vennGroups == 4) {
			e = this.vennMarginLeft + this.marginLeft + this.margin;
			f = this.vennMarginTop + this.marginTop + this.top;
			this.drawVennBubble(e + (this.x / 4.94), f + (this.x / 13), "ellipse2", this.x / 1.4, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)", Math.PI / 4);
			this.drawVennBubble(e + (this.x / 2.72), f + (this.x / -40.31), "ellipse2", this.x / 1.4, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)", Math.PI / 4);
			this.drawVennBubble(e + (this.x / 3.43), f + (this.x / 1.72), "ellipse2", this.x / 1.4, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)", -Math.PI / 4);
			this.drawVennBubble(e + (this.x / 7.96), f + (this.x / 2.07), "ellipse2", this.x / 1.4, this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)", -Math.PI / 4);
			b = [11.2, 3.05, 1.46, 1.08];
			d = [7, 42, 42, 7]
		} else {
			if (this.vennGroups == 3) {
				e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
				f = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.86);
				this.drawVennBubble(e, f, "circle", this.x / 2, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
				f += (this.x / 3.33);
				e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
				this.drawVennBubble(e, f, "circle", this.x / 2, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
				e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
				this.drawVennBubble(e, f, "circle", this.x / 2, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)");
				b = [2, 8.66, 1.13];
				d = [20, 2.3, 2.3]
			} else {
				if (this.vennGroups == 2) {
					e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
					f = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
					this.drawVennBubble(e, f, "circle", this.x / 2, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
					e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
					f = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
					this.drawVennBubble(e, f, "circle", this.x / 2, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)");
					b = [3, 1.5];
					d = [16, 16]
				} else {
					if (this.vennGroups == 1) {
						e = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
						f = this.vennMarginTop + this.marginTop + this.top + (this.x / 2);
						this.addToRender(["drawShape", "circle", e, f, this.x, this.x, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)", this.foreground, "closed"]);
						b = [100];
						d = [100]
					}
				}
			}
		}
		this.addToRender(["setGlobalCompositionOperation", "source-over"]);
		this.drawVennLayout(b, d, a)
	};
	this.drawVennLayout = function(b, e, a) {
		this.functionCaller = "drawVennLayout";
		if (!this.vennLegendColors) {
			for (var d = 0; d < this.vennGroups; d++) {
				var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / b[d]);
				var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
				this.addToRender(["drawText", a[d], c, f, this.axisTickFont, this.axisTickColor, "center", "middle"])
			}
		}
	};
	this.drawVennDataPoints = function() {
		this.functionCaller = "drawVennDataPoints";
		var a, e, g;
		this.vennCompartments = this.vennCompartments.sort();
		if (this.vennGroups == 4) {
			g = [0, 8, 1, 12, 5, 9, 2, 14, 7, 11, 13, 4, 6, 10, 3];
			a = [5.6, 2.94, 3.5, 1.54, 3.29, 2, 2.59, 1.212, 2, 1.442, 1.4, 1.757, 2.31, 1.624, 2];
			e = [2.94, 7, 3.92, 7, 1.89, 4.06, 2.66, 2.94, 1.54, 1.89, 3.92, 1.729, 1.729, 2.66, 2.03];
			this.y = (this.x * 1.1) / 1.4
		} else {
			if (this.vennGroups == 3) {
				g = [0, 4, 1, 6, 3, 5, 2];
				a = [2, 3.5, 2.55, 1.4, 1.6, 2, 2];
				e = [3.6, 1.54, 2.07, 1.54, 2.07, 1.54, 1.83];
				this.y = this.x * 0.95
			} else {
				if (this.vennGroups == 2) {
					g = [0, 2, 1];
					a = [3.5, 1.4, 2];
					e = [2.66, 2.66, 2.66];
					this.y = this.x * 0.65
				} else {
					if (this.vennGroups == 1) {
						g = [0];
						a = [2];
						e = [2]
					}
				}
			}
		}
		for (var d = 0; d < g.length; d++) {
			var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / a[d]);
			var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
			var b = this.getFontPt(this.axisTickFont);
			var h = this.data.venn.data[this.vennCompartments[g[d]]] ? this.data.venn.data[this.vennCompartments[g[d]]] : 0;
			if (this.isArray(h)) {
				h = h[0]
			}
			this.addToRender(["drawText", h, c, f, this.axisTickFont, this.axisTickColor, "center", "middle"], [g[d]])
		}
	};
	this.validateVennCompartments = function() {
		var b = "";
		if (this.vennGroups == 4 && this.vennCompartments.length != 15) {
			this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
			b = "Unless there are exactly 15 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB', 'C', 'AC', 'BC', 'ABC', 'D', 'AD', 'BD', 'CD', 'ABD', 'ACD', 'BCD', 'ABCD'"
		} else {
			if (this.vennGroups == 3 && this.vennCompartments.length != 7) {
				this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC"];
				b = "Unless there are exactly 7 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB', 'C', 'AC', 'BC', 'ABC'"
			} else {
				if (this.vennGroups == 2 && this.vennCompartments.length != 3) {
					this.vennCompartments = ["A", "B", "AB"];
					b = "Unless there are exactly 3 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB'"
				} else {
					if (this.vennGroups == 1 && this.vennCompartments.length != 1) {
						this.vennCompartments = ["A"];
						b = "Unless there are exactly 1 vennCompartments the Venn data should be mapped to 'A'  "
					}
				}
			}
		}
		for (var a = 0; a < this.vennCompartments.length; a++) {
			if (!this.data.venn.data.hasOwnProperty(this.vennCompartments[a])) {
				alert("Data for Venn diagram do not conform to specifications. " + b);
				break
			}
		}
	};
	this.drawVennPlot = function() {
		this.validateVennCompartments();
		this.setLegends();
		this.setVennXYDimensions();
		this.showShadow = false;
		this.drawVennLayoutBubbles();
		this.showShadow = this.tmpshowShadow;
		this.drawVennDataPoints();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializeVennPlot = function() {
		this.transparency = null;
		this.tmpshowShadow = this.showShadow;
		this.background = "rgb(255,255,255)";
		this.foreground = "rgb(0,0,0)";
		this.drawVennPlot()
	};
	this.initializeVennPlot()
};
CanvasXpress.prototype.Correlation = function() {
	this.setCorrelationVarSmpLabelFont = function(a) {
		this.setPropertyFontSize(Math.min(this.width, this.height), "varLabelFont");
		this.setPropertyFontSize(Math.min(this.width, this.height), "smpLabelFont")
	};
	this.getCorrelationLabelsHeight = function() {
		var a = 0;
		if (this.correlationAxis == "samples") {
			if (this.meta.data.y.maxSmpChr > this.maxSmpStringLen) {
				a += this.measureText(this.meta.data.y.maxSmpStr.substring(0, this.maxSmpStringLen), this.smpLabelFont)
			} else {
				a += this.measureText(this.meta.data.y.maxSmpStr, this.smpLabelFont)
			}
		} else {
			if (this.meta.data.y.maxVarChr > this.maxVarStringLen) {
				a += this.measureText(this.meta.data.y.maxVarStr.substring(0, this.maxVarStringLen), this.varLabelFont)
			} else {
				a += this.measureText(this.meta.data.y.maxVarStr, this.varLabelFont)
			}
		}
		if (this.correlationAnchorLegend) {
			a += this.correlationAnchorLegendAlignWidth + this.margin
		}
		return a
	};
	this.setCorrelationXYDimensions = function() {
		this.corMarginLeft = 0;
		this.corMarginTop = 0;
		if (this.yAxisShow) {
			this.setAxisFont(this.yAxisTitle, Math.min(this.width, this.height));
			this.left = this.margin + this.getFontPt(this.axisTitleFont) + this.margin
		}
		if (this.width <= this.height) {
			this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
		} else {
			this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
		}
		var a = this.correlationAxis == "variables" ? this.varIndices.length : this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		this.diamondSize = this.x / a;
		this.setCorrelationVarSmpLabelFont(a);
		this.setLegendFont();
		this.y = this.x / 2 + (this.diamondSize / 2);
		if (this.xAxisShow) {
			this.top += this.margin + this.getCorrelationLabelsHeight() + this.margin
		}
		if (this.autoAdjust) {
			this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom;
			this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
		} else {
			this.corMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
			this.corMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2
		}
		this.resizeCanvas()
	};
	this.drawCorrelationLayout = function() {
		this.functionCaller = "drawCorrelationLayout";
		if (this.yAxisShow) {
			this.addToRender(["drawText", this.yAxisTitle, this.corMarginLeft + this.marginLeft + this.left / 2, this.marginTop + this.top + (this.y / 2), this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2])
		}
		if (this.xAxisShow) {
			var c = this.corMarginLeft + this.marginLeft + this.left + (this.diamondSize / 2);
			var p = (this.corMarginTop + this.marginTop + this.top) - this.margin;
			var o = (this.corMarginTop + this.marginTop + this.top) - (this.getCorrelationLabelsHeight() + this.margin);
			var n = o + this.correlationAnchorLegendAlignWidth;
			var k, f, h;
			var a = this.isGroupedData ? this.data.w : this.data.y;
			var r = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
			var m = this.correlationAxis == "samples" ? this.maxSmpStringLen : this.maxVarStringLen;
			if (this.correlationAnchorLegend) {
				h = this.correlationAxis == "samples" ? a.data[0] : this.getDataForSmpGrpAtIndex(0);
				if ((this.smpIndicesStart < 0 && this.correlationAxis == "samples") || (this.varIndicesStart < 0 && this.correlationAxis == "variables")) {
					r.sort(function(s, i) {
						return h[s] - h[i]
					})
				}
				this.setAxisUnits("xAxis")
			}
			if (this.correlationAxis == "samples") {
				k = a.smps;
				f = this.smpLabelFont
			} else {
				k = a.vars;
				f = this.varLabelFont
			}
			for (var g = 0; g < r.length; g++) {
				var q = r[g];
				var j = this.shortenText(k[q], m);
				var e = this.correlationAxis == "samples" ? this.getSmpColor(k[q]) : this.getVarColor(k[q]);
				var l = g / this.correlationLabelInterval;
				if (parseInt(l) == parseFloat(l)) {
					this.addToRender(["drawText", j, c, p, f, e, "left", "middle", -Math.PI / 2])
				}
				if (this.correlationAnchorLegend) {
					var d;
					if ((this.smpIndicesStart < 0 && this.correlationAxis == "samples") || (this.varIndicesStart < 0 && this.correlationAxis == "variables")) {
						d = h[q]
					} else {
						d = h[g]
					}
					var b = this.corMarginLeft + this.marginLeft + this.left + ((d - this.xAxisMin) * this.xAxisUnit);
					this.addToRender(["drawLine", "line", b, o - this.margin, b, o, e]);
					this.addToRender(["drawLine", "line", b, o, c, n, e])
				}
				c += this.diamondSize
			}
		}
		c = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 3)) - this.heatmapIndicatorWidth;
		p = this.width - (this.marginBottom + this.bottom + this.heatmapIndicatorHeight + (this.margin * 8));
		if (this.correlationAnchorLegend) {
			this.setRangeData("cor")
		}
		if (this.minData == null || this.maxData == null) {
			this.setRangeData("cor")
		}
		this.drawColorIndicator(c, p, this.getDefaultMetaDataObject(), "Correlation", true)
	};
	this.drawCorrelationDataPoints = function() {
		this.functionCaller = "drawCorrelationDataPoints";
		var b, o;
		var s = this.diamondSize / 2;
		var m = this.isGroupedData ? this.data.w.cor : this.data.y.cor;
		var r = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
		var c = this.corMarginLeft + this.marginLeft + this.left + s;
		var p = this.corMarginTop + this.marginTop + this.top + s;
		var f = [this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y];
		for (var l = 0; l < Math.ceil(r.length / 2); l++) {
			var q = r[l];
			b = c + (this.diamondSize * l);
			o = p;
			for (var h = l; h < r.length - l; h++) {
				var n = r[h];
				var e = m[q][n];
				var d = this.getColorForValue(false, e);
				if (isNaN(e)) {
					this.addToRender(["drawShape", "diamond", b, o, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"], [q, n], false, null, false, f)
				} else {
					this.addToRender(["drawShape", "diamond", b, o, this.diamondSize, this.diamondSize, d, d, "closed"], [q, n], false, null, false, f)
				}
				b += s;
				o += s
			}
			o -= this.diamondSize;
			for (var g = h - 2; g >= l; g--) {
				var a = r[(r.length - g) - 1];
				var e = m[a][n];
				var d = this.getColorForValue(false, e);
				if (isNaN(e)) {
					this.addToRender(["drawShape", "diamond", b, o, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"], [a, n], false, null, false, f)
				} else {
					this.addToRender(["drawShape", "diamond", b, o, this.diamondSize, this.diamondSize, d, d, "closed"], [a, n], false, null, false, f)
				}
				b += s;
				o -= s
			}
		}
		this.addToRender(["drawLine", "line", this.corMarginLeft + this.marginLeft + this.left, this.corMarginTop + this.marginTop + this.top + s, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt"], false, false, null, true);
		this.addToRender(["drawLine", "line", this.corMarginLeft + this.marginLeft + this.left + this.x, this.corMarginTop + this.marginTop + this.top + s, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt"], false, false, null, true);
		c = this.corMarginLeft + this.marginLeft + this.left + s;
		p = this.corMarginTop + this.marginTop + this.top;
		b = c + (this.x / 2);
		o = (this.corMarginTop + this.marginTop + this.top + this.y) - s;
		for (var l = 0; l < r.length; l++) {
			this.addToRender(["drawLine", "line", c, p, b, o, this.foreground, false, "butt"], false, false, null, true);
			c += this.diamondSize;
			b += s;
			o -= s
		}
		c = (this.corMarginLeft + this.marginLeft + this.left + this.x) - s;
		p = this.corMarginTop + this.marginTop + this.top;
		b = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 2)) - s;
		o = (this.corMarginTop + this.marginTop + this.top + this.y) - s;
		for (var l = 0; l < r.length; l++) {
			this.addToRender(["drawLine", "line", c, p, b, o, this.foreground, false, "butt"], false, false, null, true);
			c -= this.diamondSize;
			b -= s;
			o -= s
		}
	};
	this.drawCorrelationPlot = function() {
		this.setCorrelationXYDimensions();
		this.drawCorrelationLayout();
		this.drawTitle();
		this.drawCorrelationDataPoints()
	};
	this.initializeCorrelationPlot = function() {
		this.drawCorrelationPlot()
	};
	this.initializeCorrelationPlot()
};
CanvasXpress.prototype.Scatter2D = function(a) {
	this.get2DYAxisWidth = function(b) {
		if (this.scatterPlotMatrix && !this.layoutAdjust) {
			return this.yAxisShow || b ? this.measureText(this.yAxisMaxStrLength, this.axisTickFont) + (this.margin * 3) : this.margin
		} else {
			var c = this.isGraphTime == "y" ? dateFormat(new Date(this.yAxisMax), this.timeFormat) : this.yAxisMaxStrLength;
			c = this.formatAxisValue(parseFloat(c), "yAxis");
			if ((this.yAxisTitle && this.yAxisTitle != " ") || (this.yAxis2Title && this.yAxis2Title != " ")) {
				return this.yAxisShow || b ? this.getFontPt(this.axisTitleFont) + this.measureText(c, this.axisTickFont) + (this.margin * 5) : this.margin
			} else {
				return this.yAxisShow || b ? this.measureText(c, this.axisTickFont) + (this.margin * 3) : this.margin
			}
		}
	};
	this.get2DXAxisHeight = function(b) {
		if (this.scatterPlotMatrix && !this.layoutAdjust) {
			return this.xAxisShow || b ? this.getFontPt(this.axisTickFont) + (this.margin * 3) : this.margin
		} else {
			if ((this.yAxisTitle && this.yAxisTitle != " ") || (this.yAxis2Title && this.yAxis2Title != " ")) {
				return this.xAxisShow ? this.getFontPt(this.axisTickFont) + this.getFontPt(this.axisTitleFont) + (this.margin * 5) : this.margin
			} else {
				return this.xAxisShow ? this.getFontPt(this.axisTickFont) + (this.margin * 3) : this.margin
			}
		}
	};
	this.set2DType = function() {
		if (this.isValidKaplanMeier()) {
			this.type2D = "KM"
		} else {
			if (this.graphType == "ScatterBubble2D" && this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length == this.zAxisIndices.length) {
				this.type2D = "XYZ"
			} else {
				if (this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length) {
					this.type2D = "XY"
				} else {
					if (this.xAxisIndices.length > this.yAxisIndices.length) {
						this.type2D = "X"
					} else {
						this.type2D = "Y"
					}
				}
			}
		}
	};
	this.set2DFont = function() {
		var e = this.yAxisTitle.length > this.yAxis2Title.length ? this.yAxisTitle : this.yAxis2Title;
		var b = this.xAxisTitle.length > e.length ? this.xAxisTitle : e;
		var c = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea);
		this.setAxisFont(b, c)
	};
	this.reRangeData = function() {
		this.xAxis = [];
		for (var b = 0; b < this.decorations.kaplanMeier.length; b++) {
			this.xAxis.push(this.decorations.kaplanMeier[b].time);
			this.xAxisTitle = this.decorations.kaplanMeier[b].time
		}
		this.yAxisTitle = "Probability of Survival";
		this.setAxes("km")
	};
	this.set2DXYDimensions = function() {
		this.setLegends();
		var c = this.measureText(this.yAxisValues[this.yAxisValues.length - 1], this.axisTickFont) / 2;
		this.right = this.isDOE ? this.margin * 5 : this.layoutComb ? 0 : this.yAxis2Show ? this.get2DYAxisWidth(true) : Math.max(c, this.margin);
		if (!this.layoutComb) {
			if (!this.legendInside) {
				if (this.showLegend && this.legendPosition == "right") {
					this.right += this.legendWidth + this.margin
				}
				if (this.showDecorations && this.showDecorationsLegend && this.decorationsPosition == "right") {
					this.right += this.legendDecorationWidth + this.margin
				}
			}
			if (this.yAxisHistogramShow) {
				this.right += this.yAxisHistogramHeight + (this.margin * 3)
			}
			if (this.graphType == "ScatterBubble2D" && this.zAxisShow) {
				this.right += this.getFontPt(this.axisTitleFont) + this.margin
			} else {
				this.right += this.margin
			}
		}
		var c = this.measureText(this.yAxisValues[0], this.axisTickFont) / 2;
		this.left = this.isDOE ? this.get2DYAxisWidth() + (this.margin * 5) : this.layoutComb && !this.layoutAdjust ? this.margin : Math.max(c, this.get2DYAxisWidth());
		this.top = this.isDOE ? this.margin * 10 : this.layoutComb ? this.margin : this.marginTop + this.margin;
		if (!this.layoutComb) {
			this.top += this.getTitleSubtitleHeight();
			if (this.xAxisHistogramShow) {
				this.top += this.xAxisHistogramHeight + (this.margin * 2)
			}
		} else {
			if (!this.scatterPlotMatrixType.match(/complete/)) {
				this.top += this.getFontPt(this.axisTitleFont) + this.margin + this.margin
			}
		}
		this.bottom = this.isDOE ? this.get2DXAxisHeight() + (this.margin * 3) : this.layoutComb && !this.layoutAdjust ? 0 : this.get2DXAxisHeight() + this.margin;
		if (!this.legendInside && !this.layoutComb) {
			if (this.showLegend && this.legendPosition == "bottom") {
				this.bottom += this.legendHeight + this.margin
			}
			if (this.showDecorations && this.showDecorationsLegend && this.decorationsPosition == "bottom") {
				this.bottom += this.legendDecorationHeight + this.margin
			}
		}
		var b = this.motionBy ? this.width - 40 : this.width;
		var d = this.motionBy ? this.height - 40 : this.height;
		this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : b - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : d - (this.marginTop + this.top + this.bottom + this.marginBottom);
		this.setScatterPointSize();
		if (this.isValidKaplanMeier()) {
			this.reRangeData()
		}
		this.setAxisUnits("xAxis");
		this.setAxisUnits("yAxis");
		if (this.motionBy) {
			this.addMotionDiv()
		}
	};
	this.set2DWireFrame = function() {
		var c = this.marginLeft + this.offsetX + this.left;
		var b = c + this.x;
		var e = this.marginTop + this.offsetY + this.top;
		var d = e + this.y;
		this.set2DWireFrameY(c, b);
		this.set2DWireFrameX(e, d)
	};
	this.set2DWireFrameY = function(e, c, h) {
		this.functionCaller = "set2DWireFrameY";
		this.addToRender(["disableGradientTransparencyShadow"]);
		var b = this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
		if (this.yAxisMinorTicks) {
			for (var d = 0; d < this.yAxisMinorValues.length; d++) {
				var j = this.yAxisMinorValues[d];
				if (j >= this.yAxisMin && j <= this.yAxisMax) {
					var g = (this.marginTop + this.offsetY + this.top + this.y) - ((j - this.yAxisMin) * this.yAxisUnit);
					this.addToRender(["drawLine", b, e, g, c, g, this.yAxisTickColor, this.axisTickWidth / 3, "butt"])
				}
			}
		}
		for (var d = 0; d < this.yAxisValuesRaw.length; d++) {
			var j = this.yAxisValuesRaw[d];
			if (j >= this.yAxisMin && j <= this.yAxisMax) {
				var g = (this.marginTop + this.offsetY + this.top + this.y) - ((j - this.yAxisMin) * this.yAxisUnit);
				if (this.yAxisMajorTicks) {
					this.addToRender(["drawLine", b, e, g, c, g, this.yAxisTickColor, this.axisTickWidth, "butt"]);
					if (this.yAxisShow) {
						this.addToRender(["drawLine", "line", e - this.margin, g, e, g, this.yAxisTopBottomTickColor, 1, "butt"])
					} else {
						if (this.yAxis2Show) {
							this.addToRender(["drawLine", "line", c, g, c + this.margin, g, this.yAxisTopBottomTickColor, 1, "butt"])
						}
					}
				} else {
					this.addToRender(["drawLine", b, e - this.margin, g, e, g, this.yAxisTickColor, this.axisTickWidth, "butt"])
				}
			}
		}
		if (h) {
			var e = e - (this.axisMinMaxTickWidth / 2);
			var c = c - 0.5;
			var g = this.marginTop + this.offsetY + this.top;
			var f = g + this.y;
			if (this.xAxisLeftMajorTick) {
				this.addToRender(["drawLine", "line", e, g, c, g, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.xAxisRightMajorTick) {
				this.addToRender(["drawLine", "line", e, f, c, f, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.yAxisTopMajorTick) {
				this.addToRender(["drawLine", "line", c, g, c, f, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.yAxisBottomMajorTick) {
				this.addToRender(["drawLine", "line", e, g, e, f, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
		} else {
			if (this.yAxisTopMajorTick) {
				var g = this.marginTop + this.offsetY + this.top;
				this.addToRender(["drawLine", "line", e - (this.axisMinMaxTickWidth / 2), g, c + 0.5, g, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.yAxisBottomMajorTick) {
				var g = this.marginTop + this.offsetY + this.top + this.y;
				this.addToRender(["drawLine", "line", e - (this.axisMinMaxTickWidth / 2), g, c + 0.5, g, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"])
	};
	this.set2DWireFrameX = function(k, j, g) {
		this.functionCaller = "set2DWireFrameX";
		this.addToRender(["disableGradientTransparencyShadow"]);
		var e = this.xAxisTickStyle == "dotted" ? "dottedLine" : "line";
		if (this.xAxisMinorTicks) {
			for (var f = 0; f < this.xAxisMinorValues.length; f++) {
				var d = this.xAxisMinorValues[f];
				if (d >= this.xAxisMin && d <= this.xAxisMax) {
					var c = (this.marginLeft + this.offsetX + this.left) + ((d - this.xAxisMin) * this.xAxisUnit);
					this.addToRender(["drawLine", e, c, k, c, j, this.xAxisTickColor, this.axisTickWidth / 3, "butt"])
				}
			}
		}
		for (var f = 0; f < this.xAxisValuesRaw.length; f++) {
			var d = this.xAxisValuesRaw[f];
			if (d >= this.xAxisMin && d <= this.xAxisMax) {
				var c = (this.marginLeft + this.offsetX + this.left) + ((d - this.xAxisMin) * this.xAxisUnit);
				if (this.xAxisMajorTicks) {
					if (this.xAxisShow) {
						this.addToRender(["drawLine", e, c, k, c, j, this.xAxisTickColor, this.axisTickWidth, "butt"]);
						this.addToRender(["drawLine", "line", c, j + (this.axisTickWidth / 1), c, j + (this.axisTickWidth / 1) + this.margin, this.xAxisLeftRightTickColor, 1, "butt"])
					} else {
						if (this.xAxisS2Show) {
							if (!this.scatterPlotMatrixType.match(/complete/)) {
								var h = this.getFontPt(this.axisTitleFont) + this.margin + this.margin;
								this.addToRender(["drawLine", e, c, k, c, j, this.xAxisTickColor, this.axisTickWidth, "butt"]);
								this.addToRender(["drawLine", "line", c, k - (h + this.margin), c, k - h, this.xAxisLeftRightTickColor, 1, "butt"])
							} else {
								this.addToRender(["drawLine", e, c, k, c, j, this.xAxisTickColor, this.axisTickWidth, "butt"]);
								this.addToRender(["drawLine", "line", c, k - this.margin, c, k, this.xAxisLeftRightTickColor, 1, "butt"])
							}
						} else {
							this.addToRender(["drawLine", e, c, k, c, j, this.xAxisTickColor, this.axisTickWidth, "butt"])
						}
					}
				} else {
					this.addToRender(["drawLine", "line", c, j + (this.axisTickWidth / 1), c, j + (this.axisTickWidth / 1) + this.margin, this.xAxisTickColor, 1, "butt"])
				}
			}
		}
		if (g) {
			var c = this.marginLeft + this.offsetX + this.left;
			var b = c + this.x;
			var k = k - 1;
			var j = j + (this.axisMinMaxTickWidth / 2);
			if (this.xAxisLeftMajorTick) {
				this.addToRender(["drawLine", "line", c, k, c, j, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.xAxisRightMajorTick) {
				this.addToRender(["drawLine", "line", b, k, b, j, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.yAxisTopMajorTick) {
				this.addToRender(["drawLine", "line", c, k, b, k, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.yAxisBottomMajorTick) {
				this.addToRender(["drawLine", "line", c, j, b, j, this.yAxisTopBottomTickColor, this.axisMinMaxTickWidth, "butt"])
			}
		} else {
			if (this.xAxisLeftMajorTick) {
				var c = this.marginLeft + this.offsetX + this.left;
				this.addToRender(["drawLine", "line", c, k - 0.5, c, j + (this.axisMinMaxTickWidth / 2), this.xAxisLeftRightTickColor, this.axisMinMaxTickWidth, "butt"])
			}
			if (this.xAxisRightMajorTick) {
				var c = this.marginLeft + this.offsetX + this.left + this.x;
				this.addToRender(["drawLine", "line", c, k - 0.5, c, j + (this.axisMinMaxTickWidth / 2), this.xAxisLeftRightTickColor, this.axisMinMaxTickWidth, "butt"])
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"])
	};
	this.set2DLayout = function() {
		this.functionCaller = "set2DLayout";
		var d = this.marginLeft + this.offsetX + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
		var b = this.width - (this.margin + this.margin + (this.getFontPt(this.axisTitleFont) / 2));
		var f = this.marginTop + this.offsetY + this.top + (this.y / 2);
		if (this.yAxisShow && !this.scatterPlotMatrix) {
			this.addToRender(["drawText", this.yAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2])
		} else {
			if (this.yAxis2Show && !this.scatterPlotMatrix) {
				this.addToRender(["drawText", this.yAxis2Title, b, f, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2])
			}
		}
		d = this.marginLeft + this.offsetX + this.left - (this.margin * 2);
		b = this.marginLeft + this.offsetX + this.left + this.x + this.margin + this.margin;
		if (this.yAxisTransform && this.yAxisTransform.match(/log/) && !this.yAxisTransformTicks) {
			this.yAxisDecs = parseInt(Math.abs(this.yAxisMin))
		}
		for (var c = 0; c < this.yAxisValuesRaw.length; c++) {
			var h = this.yAxisValuesRaw[c];
			if (h >= this.yAxisMin && h <= this.yAxisMax) {
				var g = this.yAxisTransform && !this.yAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.yAxisTransform, h, true), "yAxis") : this.isGraphTime == "y" ? dateFormat(new Date(this.yAxisMin + h), this.timeFormat) : this.formatAxisValue(h, "yAxis");
				f = (this.marginTop + this.offsetY + this.top + this.y) - ((h - this.yAxisMin) * this.yAxisUnit);
				if (this.yAxisShow) {
					this.addToRender(["drawText", g, d, f, this.axisTickFont, this.axisTickColor, "right", "middle"])
				}
				if (this.yAxis2Show) {
					this.addToRender(["drawText", g, b, f, this.axisTickFont, this.axisTickColor, "left", "middle"])
				}
			}
		}
		d = this.marginLeft + this.offsetX + this.left + (this.x / 2);
		f = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + this.getFontPt(this.axisTickFont) + this.margin + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
		if (this.xAxisShow && !this.scatterPlotMatrix) {
			this.addToRender(["drawText", this.xAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "middle"])
		}
		f = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + (this.getFontPt(this.axisTickFont) / 2);
		var e = this.marginTop + this.offsetY + this.top - (this.margin + this.margin + (this.getFontPt(this.axisTickFont) / 2));
		if (!this.scatterPlotMatrixType.match(/complete/)) {
			e -= this.getFontPt(this.axisTitleFont) + this.margin + this.margin
		}
		if (this.xAxisTransform && this.xAxisTransform.match(/log/) && !this.xAxisTransformTicks) {
			this.xAxisDecs = parseInt(Math.abs(this.xAxisMin))
		}
		for (var c = 0; c < this.xAxisValuesRaw.length; c++) {
			var h = this.xAxisValuesRaw[c];
			if (h >= this.xAxisMin && h <= this.xAxisMax) {
				var g;
				if (this.isCreateHistogram) {
					g = this.formatAxisValue((h - this.xAxisMin) + this.isCreateHistogram[0], "xAxis")
				} else {
					g = this.xAxisTransform && !this.xAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.xAxisTransform, h, true), "xAxis") : this.isGraphTime == "x" ? dateFormat(new Date(this.xAxisMin + h), this.timeFormat) : this.formatAxisValue(h, "xAxis")
				}
				d = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
				if (this.xAxisShow) {
					this.addToRender(["drawText", g, d, f, this.axisTickFont, this.axisTickColor, "center", "middle"])
				}
				if (this.xAxisS2Show) {
					this.addToRender(["drawText", g, d, e, this.axisTickFont, this.axisTickColor, "center", "middle"])
				}
			}
		}
		if (this.graphType == "ScatterBubble2D") {
			if (this.zAxisShow) {
				d = this.marginLeft + this.offsetX + this.left + this.x + this.margin;
				f = this.marginTop + this.offsetY + this.top + (this.y / 2);
				this.addToRender(["drawText", this.zAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "bottom", Math.PI / 2])
			}
		}
		if (this.plotBox) {
			this.addToRender(["disableGradientTransparencyShadow"]);
			this.addToRender(["drawShape", "rectangle", this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), this.x, this.y, this.plotBoxColor, this.plotBoxColor, "open", false, this.outlineWidth]);
			this.addToRender(["enableGradientTransparencyShadow"])
		}
	};
	this.draw2DDataPoints = function() {
		if (this.motionBy && this.motionTrails) {
			this.draw2DDataPointsTrail()
		} else {
			this.draw2DDataPointsNotrail()
		}
	};
	this.draw2DDataPointsTrail = function() {
		var f = this.motionObject.varIndicesMotion.length;
		var d = f == 1 ? [0.5] : f == 2 ? [0.25, 0.5] : [0.1, 0.25, 0.5];
		var e = this.cloneObject(this.varIndices);
		var b = this.cloneObject(this.smpIndices);
		for (var c = 0; c < f; c++) {
			this.transparency = d[c];
			this.varIndices = this.motionObject.varIndicesMotion[c];
			this.smpIndices = this.motionObject.smpIndicesMotion[c];
			this.draw2DDataPointsNotrail()
		}
		this.transparency = null;
		this.varIndices = e;
		this.smpIndices = b;
		this.draw2DDataPointsNotrail()
	};
	this.setHistogram = function(p, o, c, q, e) {
		if (!this[p + "AxisHistogram"]) {
			this[p + "AxisHistogram"] = {
				data: [],
				vars: [],
				smps: [],
				cntx: [],
				hist: [],
				kde: [],
				stats: []
			};
			var k = this.getAxisDecimals(q);
			for (var g = 0; g <= o; g++) {
				var n = (c + (q * g)).toFixed(k);
				var h = (c + (q * (g + 1))).toFixed(k);
				this[p + "AxisHistogram"].vars.push("Bin" + (g + 1) + " (" + n + " to " + h + ")");
				this[p + "AxisHistogram"].data[g] = [];
				this[p + "AxisHistogram"].data[g][0] = q * (g + 1);
				this[p + "AxisHistogram"].hist[g] = [];
				for (var f = 0; f < e; f++) {
					this[p + "AxisHistogram"].hist[g][f] = []
				}
			}
			this[p + "AxisHistogram"].smps.push("Bin");
			this[p + "AxisHistogram"].min = c;
			this[p + "AxisHistogram"].size = q;
			this[p + "AxisHistogram"].decs = k;
			this[p + "AxisHistogram"].len = e
		}
	};
	this.setKde = function(b) {
		this.functionCaller = "setKde";
		var e = this.marginLeft + this.offsetX + this.left;
		var o = this.marginTop + this.offsetY + this.top + this.y;
		var h = this.data;
		if (h.y.kde && h.y.stats && this.showHistogramDensity) {
			var f = h.y.kde[0];
			var p = h.y.stats[0];
			var c = [];
			var n = [];
			for (var g = 0; g < f.length; g++) {
				var m = f[g][0];
				var i = f[g][1] * p[0];
				c.push(e + ((m - f[0][0]) * this.xAxisUnit));
				n.push(o - ((i - this.yAxisMin) * this.yAxisUnit))
			}
			this.addToRender(["drawLine", "spline", c, n, false, false, this.foreground, 1, false, false, false, true])
		}
	};
	this.draw2DDataPointsNotrail = function() {
		this.functionCaller = "draw2DDataPointsNotrail";
		var E, m, B, f;
		var ar, n, H, g, az, I, aB, s;
		var ag, D, M, o, ap, r, aB, s;
		var Q, V, R, q;
		var aE = [];
		var aA = [];
		var T = this;
		var X = this.marginLeft + this.offsetX + this.left;
		var P = this.marginTop + this.offsetY + this.top + this.y;
		if (this.type2D == "KM") {
			return
		} else {
			if (this.isHistogram) {
				this.histogramBarWidth = (this.isCreateHistogram[1] * this.xAxisUnit) - 3;
				var N = this.histogramStagger ? Math.floor(this.histogramBarWidth) : Math.floor(this.histogramBarWidth / (this.isCreateHistogram[4].length));
				for (var S = 0; S < this.isCreateHistogram[4].length; S++) {
					var ab = this.isCreateHistogram[4][S];
					var F = this.varIndices.length == 1 || !this.histogramStagger ? this.colors[ab % this.colors.length] : this.addColorTransparency(this.colors[ab % this.colors.length], 0.7);
					for (var Z = 0; Z < this.varIndices.length; Z++) {
						var v = this.varIndices[Z];
						var L = this.getDataAtPos(v, 0);
						var K = this.getDataAtPos(v, ab + 1);
						if (this.histogramStagger) {
							E = Math.floor((this.marginLeft + this.offsetX + this.left) + (L * this.xAxisUnit) - this.histogramBarWidth)
						} else {
							E = Math.floor((this.marginLeft + this.offsetX + this.left) + (L * this.xAxisUnit) + (N * ab) - this.histogramBarWidth)
						}
						B = E + N;
						m = P - ((K - this.yAxisMin) * this.yAxisUnit);
						f = P - m;
						if (this.isVisibleSelectedDataPoint(v, ab + 1) && K > 0 && f > 0.5) {
							this.functionCaller = "draw2DDataPointsNotrail";
							if (this.selectDataMode == "area" && this.isInSelectedDataPoints(v, ab)) {
								this.drawSelectedBackground(v, ab, "rectangle", B - (N / 2), m + (f / 2), N - 5, f - 5);
								if (N > 6 && f > 6) {
									this.addToRender(["drawShape", "rectangle", E + 3 + ((N - 6) / 2), m + 3 + ((f - 6) / 2), N - 6, f - 6, F, false, p], [v, ab + 1], false, null, false, [E + 3 + ((N - 6) / 2), P, N - 6, 0])
								}
							} else {
								this.addToRender(["drawShape", "rectangle", E + (N / 2), m + (f / 2), N, f, F], [v, ab + 1], false, null, false, [E + (N / 2), P, N, 0])
							}
							this.drawSelectedBackgroundLabel(v, ab + 1, E, m)
						}
					}
					this.setKde(F)
				}
			} else {
				var u = this.type2D == "XYZ" ? 1 : Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
				var N = this.histogramBarWidth;
				var G = this.meta;
				if (!G.vals.histograms) {
					G.vals.histograms = {}
				}
				for (var ab = 0; ab < u; ab++) {
					this.resetStagingDrawingBuffer();
					var aD = this.type2D == "Y" || this.type2D == "XYZ" ? this.xAxisIndices[this.xAxisCurrent] : this.xAxisIndices[ab];
					var at = this.type2D == "X" || this.type2D == "XYZ" ? this.yAxisIndices[this.yAxisCurrent] : this.yAxisIndices[ab];
					var aj = (this.graphType == "ScatterBubble2D" && !this.sizeBy && this.zAxisIndices.length > 0) || this.type2D == "XYZ" ? this.zAxisIndices[this.zAxisCurrent] : false;
					var ah = this.isHistogram ? aD : aD + ":" + at;
					var d = [];
					var c = [];
					var av = [];
					var au = [];
					var ac = [];
					var aa = [];
					var aF = {};
					for (var Z = 0; Z < this.varIndices.length; Z++) {
						if ((this.xAxisTransform == "percentile" && ((this.type2D.match(/Y|Z/) && Z == 0) || (this.type2D == "X"))) || (this.xAxisHistogramShow && !G.vals.histograms.xAxisHistogram)) {
							ar = this.type2D == "XYZ" || this.xAxisTransform != "percentile" ? this.getAxisDataBySample(this.xAxisIndices) : this.getAxisDataBySample(aD);
							n = this.range(ar);
							g = n[0];
							H = n[1];
							if (this.xAxisHistogramShow && Z == 0) {
								if ((this.type2D == "X" || this.type2D == "XY") && this.xAxisTransform == "percentile") {
									ar = this.getAxisDataBySample(this.xAxisIndices);
									n = this.range(ar)
								}
								az = this.histogramBins ? this.pretty((n[1] - n[0]) / this.histogramBins) : this.freedmanDiaconis(ar);
								aB = this.getHistogramBin(n[0], az);
								s = this.getHistogramBin(az + n[1], az);
								I = this.histogramBins ? this.histogramBins : (s - aB) / az;
								this.setHistogram("x", I, aB, az, this.xAxisIndices.length);
								for (var Y = 0; Y <= I; Y++) {
									d[Y] = 0
								}
								this.xAxisHistogram.smps.push(aD);
								this.xAxisHistogram.cntx.push([aD, at])
							}
						}
						if ((this.yAxisTransform == "percentile" && ((this.type2D.match(/X|Z/) && Z == 0) || (this.type2D == "Y"))) || (this.yAxisHistogramShow && !G.vals.histograms.yAxisHistogram)) {
							ag = this.type2D == "XYZ" || this.yAxisTransform != "percentile" ? this.getAxisDataBySample(this.yAxisIndices) : this.getAxisDataBySample(at);
							D = this.range(ag);
							o = D[0];
							M = D[1];
							if (this.yAxisHistogramShow && Z == 0) {
								if ((this.type2D == "Y" || this.type2D == "XY") || this.yAxisTransform == "percentile") {
									ag = this.getAxisDataBySample(this.yAxisIndices);
									D = this.range(ag)
								}
								ap = this.histogramBins ? this.pretty((D[1] - D[0]) / this.histogramBins) : this.freedmanDiaconis(ag);
								yBinMin = this.getHistogramBin(D[0], ap);
								yBinMax = this.getHistogramBin(ap + D[1], ap);
								r = this.histogramBins ? this.histogramBins : (yBinMax - yBinMin) / ap;
								this.setHistogram("y", r, yBinMin, ap, this.yAxisIndices.length);
								for (var Y = 0; Y <= r; Y++) {
									c[Y] = 0
								}
								this.yAxisHistogram.smps.push(at);
								this.yAxisHistogram.cntx.push([aD, at])
							}
						}
						if (aj !== false && Z == 0) {
							Q = this.type2D == "XYZ" ? this.getAxisDataBySample(this.zAxisIndices, "z") : this.getAxisDataBySample(aj, "z");
							V = this.range(Q);
							q = V[0];
							R = V[1]
						}
						var v = this.varIndices[Z];
						var L = this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(v, aD, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue) : this.getDataAtPos(v, aD, false, this.xAxisTransform, g, H);
						var K = this.yAxisTransform && this.yAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(v, at, false, this.yAxisTransform, this.yAxisTransformFloorValue, this.yAxisTransformCeilValue) : this.getDataAtPos(v, at, false, this.yAxisTransform, o, M);
						var J = aj !== false ? this.getDataAtPos(v, aj, false, this.zAxisTransform, this.zAxisTransformFloorValue, this.zAxisTransformCeilValue) : false;
						var aG = this.getDataAtPos(v, aD, "stdev");
						var aw = this.getDataAtPos(v, at, "stdev");
						var F = this.colorBy ? this.getPropertyValue(v, null, "colorBy") : this.colors[ab % this.colors.length];
						var ax = F;
						var ay = this.shapeBy ? this.getPropertyValue(v, null, "shapeBy") : this.shapes[0];
						var O = this.sizeBy ? parseInt(this.getPropertyValue(v, null, "sizeBy")) : aj !== false ? this.sizes[Math.floor(this.percentile(q, R, J) / 10) + 1] : this.scatterPointSize;
						var p = this.patternBy ? this.getPropertyValue(v, null, "patternBy") : this.getPropertyValue(ab, null, "patternBy");
						var ad = this.scatterType && this.scatterType.match(/image/i) ? this.images[Z] : false;
						var aC = ad ? "image" : ay;
						var ai = this.isVisibleSelectedDataPoint(v, ah);
						var W = this.isInSelectedDataPoints(v, ah);
						var C = this.selectDataMode == "transparency" && this.isSelectDataPoints && !W;
						var ao = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.data.z[this.ellipseBy][v] : this.ellipseBy && this.ellipseBy == "variable" ? "variable" : false;
						if (this.varIndices.length < this.scatterOutlineThreshold) {
							var e = this.isColorTransparency(F);
							if (e != null) {
								ax = this.addColorTransparency(this.foreground, e, true)
							} else {
								ax = this.transparency ? this.addColorTransparency(this.foreground, this.transparency) : this.foreground
							}
						}
						if (this.xAxisHistogramShow && (this.type2D != "Y" || (this.type2D == "Y" && ab == 0)) && !G.vals.histograms.xAxisHistogram) {
							if (L != null && L != "" && !isNaN(L)) {
								var ae = Math.max(Math.min(Math.floor((L - aB) / az), I), 0);
								av.push(L);
								if (!isNaN(ae)) {
									d[ae]++;
									this.xAxisHistogram.hist[ae][ab].push(v)
								}
							}
						}
						if (this.yAxisHistogramShow && (this.type2D != "X" || (this.type2D == "X" && ab == 0)) && !G.vals.histograms.yAxisHistogram) {
							if (K != null && K != "" && !isNaN(K)) {
								var ae = Math.max(Math.min(Math.floor((K - yBinMin) / ap), r), 0);
								au.push(K);
								if (!isNaN(ae)) {
									c[ae]++;
									this.yAxisHistogram.hist[ae][ab].push(v)
								}
							}
						}
						E = X + ((L - this.xAxisMin) * this.xAxisUnit);
						m = P - ((K - this.yAxisMin) * this.yAxisUnit);
						F = C ? this.addColorTransparency(F, 0.1) : F;
						ax = C ? this.addColorTransparency(ax, 0.1) : ax;
						if (this.ellipseBy && ao) {
							if (!aF.hasOwnProperty(ao)) {
								aF[ao] = [
									[],
									[]
								]
							}
							aF[ao][0].push(L);
							aF[ao][1].push(K)
						}
						if (this.scatterType && this.scatterType == "bar" && this.type2D != "XYZ") {
							f = (this.marginTop + this.offsetY + this.top + this.y) - m;
							if (ai && K > 0) {
								if (this.selectDataMode == "area" && W) {
									this.drawSelectedBackground(v, ah, "rectangle", E, m + (f / 2), (N * 2) - 5, f - 5, false, true);
									this.addToRender(["drawShape", "rectangle", (E + 2.5 - N) + (((N * 2) - 5) / 2), (m + 2.5) + ((f - 5) / 2), (N * 2) - 5, f - 5, F, false, p], [v, aD, at])
								} else {
									this.addToRender(["drawShape", "rectangle", E, m + (f / 2), N * 2, f, F, false, pa3t], [v, aD, at])
								}
								this.drawSelectedBackgroundLabel(v, ah, E, m)
							}
						} else {
							if (ai) {
								if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
									this.addKeyStagingDrawingBuffer(Z, E, m, O, O);
									this.addDataStagingDrawingBuffer(Z, "drawSelectedBackground", [v, ah, ay, E, m, O, O, false, true]);
									if (aG && !isNaN(aG)) {
										B = (aG / 2) * this.xAxisUnit;
										this.addDataStagingDrawingBuffer(Z, "drawLine", ["error", E, m, E + B, m, F, this.margin]);
										this.addDataStagingDrawingBuffer(Z, "drawLine", ["error", E, m, E - B, m, F, this.margin])
									}
									if (aw && !isNaN(aw)) {
										f = (aw / 2) * this.yAxisUnit;
										this.addDataStagingDrawingBuffer(Z, "drawLine", ["error", E, m, E, m + f, F, -this.margin]);
										this.addDataStagingDrawingBuffer(Z, "drawLine", ["error", E, m, E, m - f, F, -this.margin])
									}
									this.addDataStagingDrawingBuffer(Z, "drawShape", [aC, E, m, O, O, F, ax, p, false, false, false, false, false, false, ad], [v, aD, at, aj]);
									this.addDataStagingDrawingBuffer(Z, "drawSelectedBackgroundLabel", [v, ah, E, m])
								}
								if (this.scatterType && this.scatterType.match(/line|functio/i) && Z < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[Z + 1], ah)) {
									v = this.varIndices[Z + 1];
									L = this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(v, aD, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue) : this.getDataAtPos(v, aD, false, this.xAxisTransform, g, H);
									K = this.yAxisTransform && this.yAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(v, at, false, this.yAxisTransform, this.yAxisTransformFloorValue, this.yAxisTransformCeilValue) : this.getDataAtPos(v, at, false, this.yAxisTransform, o, M);
									B = X + ((L - this.xAxisMin) * this.xAxisUnit);
									f = P - ((K - this.yAxisMin) * this.yAxisUnit);
									if (this.scatterType == "lineStep") {
										this.addToRender(["drawLine", "line", E, m, B, m, F]);
										this.addToRender(["drawLine", "line", B, m, B, f, F])
									} else {
										if (this.lineType == "spline") {
											aE.push(E);
											aA.push(m)
										} else {
											this.addToRender(["drawLine", "line", E, m, B, f, F])
										}
									}
								}
							}
						}
					}
					var U = this.xAxisMin <= 0 && this.xAxisMax >= 0 ? X + (-this.xAxisMin * this.xAxisUnit) : X;
					var A = this.yAxisMin <= 0 && this.yAxisMax >= 0 ? P - (-this.yAxisMin * this.yAxisUnit) : P;
					this.drawDataStagingDrawingBuffer([U, A]);
					if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
						aE.push(B);
						aA.push(f);
						this.addToRender(["drawLine", "spline", aE, aA, false, false, F]);
						aE = [];
						aA = []
					}
					if (this.xAxisHistogramShow && !G.vals.histograms.xAxisHistogram) {
						for (var Z = 0; Z <= I; Z++) {
							ac.push(d[Z]);
							this.xAxisHistogram.data[Z][ab + 1] = d[Z]
						}
					}
					if (this.yAxisHistogramShow && !G.vals.histograms.yAxisHistogram) {
						for (var Z = 0; Z <= r; Z++) {
							aa.push(c[Z]);
							this.yAxisHistogram.data[Z][ab + 1] = c[Z]
						}
					}
					if (this.showLoessFit) {
						var L = this.getAxisDataBySample(aD);
						var K = this.getAxisDataBySample(at);
						var h = this.loess([L, K], false, [aD, at]);
						var aE = [];
						var aA = [];
						if (X) {
							for (var Z = 0; Z < this.loessDrawOptimizer; Z++) {
								aE.push(X + ((h[0][Z] - this.xAxisMin) * this.xAxisUnit));
								aA.push(P - ((h[1][Z] - this.yAxisMin) * this.yAxisUnit))
							}
							for (var Z = this.loessDrawOptimizer; Z < h[0].length - 1; Z++) {
								if (this.parseInt(h[0][Z]) == this.parseInt(h[0][Z - this.loessDrawOptimizer]) && this.parseInt(h[1][Z]) == this.parseInt(h[1][Z - this.loessDrawOptimizer])) {
									continue
								} else {
									aE.push(X + ((h[0][Z] - this.xAxisMin) * this.xAxisUnit));
									aA.push(P - ((h[1][Z] - this.yAxisMin) * this.yAxisUnit))
								}
							}
							aE.push(X + ((h[0][h[0].length - 1] - this.xAxisMin) * this.xAxisUnit));
							aA.push(P - ((h[1][h[0].length - 1] - this.yAxisMin) * this.yAxisUnit));
							this.addToRender(["drawLine", "spline", aE, aA, false, false, this.loessColor, 2], false, false, null, false, [aE[0], aA[0]])
						}
					}
					if (this.ellipseBy) {
						var af = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.meta.data.z[this.ellipseBy] : false;
						for (var ao in aF) {
							var an = this.errorEllipse(aF[ao][0], aF[ao][1]);
							var F = af ? af.colors[af.order[ao]] : this.colors[ab % this.colors.length];
							var al = X + ((an.cx - this.xAxisMin) * this.xAxisUnit);
							var ak = P - ((an.cy - this.yAxisMin) * this.yAxisUnit);
							var am = 2 * an.rx * this.xAxisUnit;
							var aq = 2 * an.ry * this.yAxisUnit;
							this.addToRender(["drawShape", "oval", al, ak, am, aq, false, F, "open", an.rot])
						}
					}
				}
				if (this.xAxisHistogramShow && !G.vals.histograms.xAxisHistogram) {
					n = this.range(ac);
					this.xAxisHistogram.axis = this[this.axisAlgorithm](n[0], n[1], 3, this.axisWilkinsonLoose);
					this.xAxisHistogram.axisMin = Math.min(n[0], this.xAxisHistogram.axis[0]);
					this.xAxisHistogram.axisMax = Math.max(n[1], this.xAxisHistogram.axis[this.xAxisHistogram.axis.length - 1]);
					this.xAxisHistogram.axisUnit = this.xAxisHistogramHeight / (this.xAxisHistogram.axisMax - this.xAxisHistogram.axisMin);
					if (!G.vals.histograms.xAxisHistogram) {
						G.vals.histograms.xAxisHistogram = this.xAxisHistogram
					}
				}
				if (this.yAxisHistogramShow && !G.vals.histograms.yAxisHistogram) {
					D = this.range(aa);
					this.yAxisHistogram.axis = this[this.axisAlgorithm](D[0], D[1], 3, this.axisWilkinsonLoose);
					this.yAxisHistogram.axisMin = Math.min(D[0], this.yAxisHistogram.axis[0]);
					this.yAxisHistogram.axisMax = Math.max(D[1], this.yAxisHistogram.axis[this.yAxisHistogram.axis.length - 1]);
					this.yAxisHistogram.axisUnit = this.yAxisHistogramHeight / (this.yAxisHistogram.axisMax - this.yAxisHistogram.axisMin);
					if (!G.vals.histograms.yAxisHistogram) {
						G.vals.histograms.yAxisHistogram = this.yAxisHistogram
					}
				}
				if (this.decorations && this.decorations.marker) {
					this.drawMarkers()
				}
			}
		}
	};
	this.draw2DContour = function() {
		this.functionCaller = "draw2DContour";
		var d, q, c, p;
		var g = this.marginLeft + this.offsetX + this.left;
		var r = this.marginTop + this.offsetY + this.top + this.y;
		if (this.isContour) {
			var o = this.data.y.contour.list;
			var s = this.getColorBrew(this.colorSpectrum, 0, o[0].level, this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var b = this.data.y.contour.xs;
			var h = this.data.y.contour.ys;
			if (this.contourType == "overlay") {
				for (var n = 0; n < o.length; n++) {
					d = g + (o[n][0].x * this.xAxisRange / b * this.xAxisUnit);
					q = r - (o[n][0].y * this.yAxisRange / h * this.yAxisUnit);
					for (var k = 1; k < o[n].length; k++) {
						c = g + (o[n][k].x * this.xAxisRange / b * this.xAxisUnit);
						p = r - (o[n][k].y * this.yAxisRange / h * this.yAxisUnit);
						this.addToRender(["drawLine", "line", d, q, c, p, this.foreground, false, false, false, false, true]);
						d = c;
						q = p
					}
				}
			} else {
				if (this.contourType == "color") {
					this.addToRender(["drawShape", "rectangle", g + (this.x / 2), r - (this.y / 2), this.x, this.y, this.getColorForValue(s, 0)]);
					for (var n = o.length - 1; n >= 0; n--) {
						var f = [];
						var m = [];
						var e = this.getColorForValue(s, o[n].level);
						for (var k = 0; k < o[n].length; k++) {
							f.push(g + (o[n][k].x * this.xAxisRange / b * this.xAxisUnit));
							m.push(r - (o[n][k].y * this.yAxisRange / h * this.yAxisUnit))
						}
						if (o[n][0].x != o[n][o[n].length - 1].x || o[n][0].y != o[n][o[n].length - 1].y) {
							if (o[n][0].x == 0 || o[n][0].x == b) {
								f.push(g + (o[n][0].x * this.xAxisRange / b * this.xAxisUnit));
								m.push(r - (o[n][o[n].length - 1].y * this.yAxisRange / h * this.yAxisUnit))
							} else {
								if (o[n][o[n].length - 1].x == 0 || o[n][o[n].length - 1].x == b) {
									f.push(g + (o[n][o[n].length - 1].x * this.xAxisRange / b * this.xAxisUnit));
									m.push(r - (o[n][0].y * this.yAxisRange / h * this.yAxisUnit))
								}
							}
						}
						this.addToRender(["drawShape", "path", f, m, false, false, e, e, "closed", false, false, true])
					}
				}
			}
		}
	};
	this.draw2DHistograms = function() {
		this.functionCaller = "draw2DHistograms";
		var I, f;
		var z = ["x", "y"];
		this.addToRender(["disableGradientTransparencyShadow"]);
		for (var F = 0; F < z.length; F++) {
			if (this[z[F] + "AxisHistogramShow"]) {
				var C = z[F] == "x" ? this.marginLeft + this.offsetX + this.left : this.marginLeft + this.offsetX + this.left + this.x + (this.margin * 2);
				var v = z[F] == "x" ? (this.marginTop + this.offsetY + this.top) - (this.margin * 2) : this.marginTop + this.offsetY + this.top + this.y;
				var A = z[F] == "x" ? [C, v - this.xAxisHistogramHeight, this.x, this.xAxisHistogramHeight] : [C, v - this.y, this.yAxisHistogramHeight, this.y];
				if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
					this.drawImage(CanvasXpress.cacheImages[this.getFileName(this.backgroundImage)], A[0], A[1], A[2], A[3])
				} else {
					if (this.backgroundType == "solid") {} else {
						if (this.backgroundType == "window" || this.backgroundType == "windowSolidGradient") {
							this.addToRender(["drawShape", "rectangle", A[0] + (A[2] / 2), A[1] + (A[3] / 2), A[2], A[3], this.backgroundWindow, this.backgroundWindow])
						} else {
							var H = this.getLinearGradient(A[0], A[1], A[2], A[3], this.backgroundGradient1Color, this.backgroundGradient2Color);
							this.addToRender(["drawShape", "rectangle", A[0] + (A[2] / 2), A[1] + (A[3] / 2), A[2], A[3], H, this.foreground])
						}
					}
				}
				if (z[F] == "x") {
					this.set2DWireFrameX(v - this.xAxisHistogramHeight, v, true);
					for (var E = 0; E < this.xAxisHistogram.axis.length; E++) {
						f = v - (this.xAxisHistogram.axis[E] * this.xAxisHistogram.axisUnit);
						this.addToRender(["drawLine", "line", C, f, C + this.x + this.margin, f, this.xAxisTickColor, false, "butt"]);
						this.addToRender(["drawText", this.xAxisHistogram.axis[E], C + this.x + this.margin + 1, f, this.axisTickFont, this.axisTickColor, "left", "middle"])
					}
				} else {
					this.set2DWireFrameY(C, C + this.xAxisHistogramHeight, true);
					for (var E = 0; E < this.yAxisHistogram.axis.length; E++) {
						I = C + (this.yAxisHistogram.axis[E] * this.yAxisHistogram.axisUnit);
						this.addToRender(["drawLine", "line", I, v - this.y, I, v + this.margin, this.xAxisTickColor, false, "butt"]);
						this.addToRender(["drawText", this.xAxisHistogram.axis[E], I, v + this.margin + 1, this.axisTickFont, this.axisTickColor, "left", "middle", Math.PI / 2])
					}
				}
				if (this.plotBox) {
					this.addToRender(["drawShape", "rectangle", A[0] + (A[2] / 2), A[1] + (A[3] / 2), A[2], A[3], false, this.plotBoxColor, "open"])
				}
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"]);
		for (var F = 0; F < z.length; F++) {
			if (this[z[F] + "AxisHistogramShow"]) {
				var G = z[F] == "x" ? this.meta.vals.histograms.xAxisHistogram : this.meta.vals.histograms.yAxisHistogram;
				var C = z[F] == "x" ? this.marginLeft + this.offsetX + this.left : this.marginLeft + this.offsetX + this.left + this.x + (this.margin * 2);
				var v = z[F] == "x" ? (this.marginTop + this.offsetY + this.top) - (this.margin * 2) : this.marginTop + this.offsetY + this.top + this.y;
				var K = z[F] == "x" ? Math.floor(G.size * this.xAxisUnit) : Math.floor(G.size * this.yAxisUnit);
				var s = this.histogramStagger ? Math.floor(K) : Math.floor(K / G.len);
				var J = z[F] == "x" ? [C, v - this.xAxisHistogramHeight, this.x + 1, this.xAxisHistogramHeight + 1] : [C, v - this.y, this.yAxisHistogramHeight + 1, this.y + 1];
				this.addToRender(["setClipArea", J]);
				for (var E = 0; E < G.vars.length; E++) {
					if (this.histogramStagger) {
						var d = [];
						var m = [];
						for (var D = 0; D < G.len; D++) {
							d.push(G.data[E][D + 1]);
							m.push(D)
						}
						m.sort(function(g, c) {
							return d[c] - d[g]
						})
					}
					for (var D = 0; D < G.len; D++) {
						var e = this.histogramStagger ? m[D] : D;
						var n = G.len == 1 || !this.histogramStagger ? this.colors[e % this.colors.length] : this.addColorTransparency(this.colors[e % this.colors.length], 0.7);
						var u = this.getPropertyValue(D, false, "patternBy");
						var q = G.data[E][0];
						var p = G.data[E][e + 1];
						var B = this[z[F] + "AxisMin"] - G.min;
						if (!p) {
							continue
						}
						if (z[F] == "x") {
							I = this.histogramStagger ? Math.floor(C + ((q - B) * this.xAxisUnit) - K) : Math.floor(C + ((q - B) * this.xAxisUnit) + (s * e) - K);
							f = p * this.xAxisHistogram.axisUnit;
							this.addToRender(["drawShape", "rectangle", I + ((s - 2.5) / 2), v - (f / 2), s - 2.5, f, n, false, u], [z[F] + "AxisHistogram-" + E + "-" + (e + 1) + "-" + D])
						} else {
							I = p * this.yAxisHistogram.axisUnit;
							f = this.histogramStagger ? Math.floor(v - ((q - B) * this.yAxisUnit)) : Math.floor(v - ((q - B) * this.yAxisUnit) + (s * e));
							this.addToRender(["drawShape", "rectangle", C + (I / 2), f + ((s - 2.5) / 2), I, s - 2.5, n, false, u], [z[F] + "AxisHistogram-" + E + "-" + (e + 1) + "-" + D])
						}
					}
				}
				this.addToRender(["resetClipArea"])
			}
		}
	};
	this.set2DprivateParams = function() {
		this.set2DType();
		this.set2DFont()
	};
	this.isValidKaplanMeier = function() {
		if (this.decorations && this.decorations.kaplanMeier) {
			return true
		} else {
			return false
		}
	};
	this.draw2DXYPlot = function() {
		this.addToRender(["setClipArea", this.setClipBoundaries()]);
		this.drawDecorationData();
		this.draw2DContour();
		this.draw2DDataPoints();
		this.addToRender(["resetClipArea"]);
		this.draw2DHistograms()
	};
	this.draw2DPlot = function() {
		if (this.xAxis && this.yAxis) {
			this.validatePropertyValues()
		}
		this.set2DprivateParams();
		this.set2DXYDimensions();
		if (this.xAxis && this.yAxis) {
			this.drawPlotWindow();
			this.set2DWireFrame();
			this.set2DLayout();
			this.draw2DXYPlot();
			this.drawLegend();
			this.drawTitle()
		}
	};
	this.initializeScatter2D = function() {
		if (this.layoutValid && (this.scatterPlotMatrix || this.isDOE)) {
			this.drawLayoutCompartments(this.draw2DPlot)
		} else {
			if (!this.scatterPlotMatrix) {
				this.unsetScatterPlotMatrix()
			}
			this.draw2DPlot()
		}
	};
	if (!a) {
		this.initializeScatter2D()
	}
};
CanvasXpress.prototype.Scatter3D = function(a) {
	this.set3DText = function() {
		this.setAxisFont(false, this.x)
	};
	this.set3DXYDimensions = function() {
		var e = this.width - (this.marginLeft + this.marginRight);
		var c = this.height - (this.marginTop + this.marginBottom);
		if (this.showLegend) {
			this.setLegends();
			if (!this.legendInside && this.legendLayout.length > 0) {
				if (this.legendPosition == "right") {
					e -= this.legendWidth
				}
				if (this.legendPosition == "bottom") {
					c -= this.legendHeight
				}
			}
		}
		var b = Math.min(e, c);
		var d = 0;
		if (e > c) {
			d = e - c;
			this.left = d / 2;
			this.right = d / 2;
			this.top = 0;
			this.bottom = 0;
			this.funcX = d / 2;
			this.funcY = 0
		} else {
			d = c - e;
			this.left = 0;
			this.right = 0;
			this.top = d / 2;
			this.bottom = d / 2;
			this.funcX = 0;
			this.funcY = d / 2
		}
		this.x = b;
		this.y = b;
		this.setScatterPointSize()
	};
	this.draw3DLayout = function(j, b, o, k, c, p, g, d) {
		this.functionCaller = "draw3DLayout";
		var f, r, e, q, n;
		var h = this.marginLeft + this.left + this.offsetX;
		var s = this.marginTop + this.top + this.offsetY;
		this.addToRender(["disableGradientTransparencyShadow"]);
		for (var m = 0; m < j.length; m++) {
			n = this.get3DTransfrom(j[m], b[m], o[m]);
			f = n[0] + h;
			r = n[1] + s;
			n = this.get3DTransfrom(k[m], c[m], p[m]);
			e = n[0] + h;
			q = n[1] + s;
			if (d == "dotted") {
				this.addToRender(["drawLine", "dottedLine", f, r, e, q, g[m], false, "butt"])
			} else {
				this.addToRender(["drawLine", "line", f, r, e, q, g[m], false, "butt"])
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"])
	};
	this.draw3DBar = function(q, o, n, v, R, T) {
		this.functionCaller = "draw3DBar";
		var J = this.marginLeft + this.left + this.offsetX;
		var E = this.marginTop + this.top + this.offsetY;
		var k = J + (this.x / 2);
		var g = E + (this.y / 2);
		var N = this.yAxisMin < 0 ? 0 : this.yAxisMin;
		var O = [
			[
				[q - v, o, n - v],
				[q + v, o, n - v],
				[q + v, N, n - v],
				[q - v, N, n - v]
			],
			[
				[q + v, o, n - v],
				[q + v, o, n + v],
				[q + v, N, n + v],
				[q + v, N, n - v]
			],
			[
				[q - v, o, n + v],
				[q + v, o, n + v],
				[q + v, N, n + v],
				[q - v, N, n + v]
			],
			[
				[q - v, o, n - v],
				[q - v, o, n + v],
				[q - v, N, n + v],
				[q - v, N, n - v]
			],
			[
				[q - v, o, n - v],
				[q + v, o, n - v],
				[q + v, o, n + v],
				[q - v, o, n + v]
			]
		];
		var Q = [];
		var S = [];
		var P = [];
		var I = [];
		for (var M = 0; M < O.length; M++) {
			Q[M] = [];
			for (var L = 0; L < O[M].length; L++) {
				var G = this.xAxisMin < 0 ? 0 : this.xAxisMin;
				var D = this.yAxisMin < 0 ? 0 : this.yAxisMin;
				var C = this.zAxisMin < 0 ? 0 : this.zAxisMin;
				var A = ((O[M][L][0] - G) * this.xAxisUnit) - this.xAxisOffset;
				var u = this.yAxisOffset - ((O[M][L][1] - D) * this.yAxisUnit);
				var p = ((O[M][L][2] - C) * this.zAxisUnit) - this.zAxisOffset;
				Q[M].push(this.get3DTransfrom(A, u, p))
			}
			I.push(M);
			P.push(this.euclidianDistance([(Q[M][0][0] + Q[M][2][0]) / 2, (Q[M][0][1] + Q[M][2][1]) / 2, (Q[M][0][2] + Q[M][2][2]) / 2], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
		}
		I.sort(function(d, c) {
			return P[c] - P[d]
		});
		var H;
		for (var B = 1; B < Q.length; B++) {
			var M = I[B];
			var F = B < 3 ? this.darkenLightenColor(R, -B * 15) : R;
			var m = [];
			var K = [];
			for (var L = 0; L < Q[M].length; L++) {
				m.push(Q[M][L][0] + J);
				K.push(Q[M][L][1] + E)
			}
			H = this.addToRender(["drawShape", "polygon", m, K, false, false, F, this.foreground, "closed"], T)
		}
	};
	this.set3DXLayout = function() {
		this.functionCaller = "set3DXLayout";
		var z = [],
			d = [],
			n = [],
			w = [],
			c = [],
			k = [],
			e = [];
		var v, m, p, b, A, r, j, h;
		var f = this.lenX / 15;
		var q = (15 * -f) + f;
		var g = this.xAxisTitle ? this.xAxisTitle : this.is3DPlot && this.xAxis.length == 0 ? "Samples" : this.xAxisIndex ? this.data.y.smps[this.xAxisIndex] : this.xAxis[0];
		var u = this.marginLeft + this.left + this.offsetX;
		var o = this.marginTop + this.top + this.offsetY;
		if (this.show3DGrid) {
			p = q;
			v = 0;
			m = 0;
			while (p < this.lenX) {
				if ((v + 1) % 3) {
					if (this.xAxisType == "continuous") {
						z[m] = p;
						d[m] = -this.lenY;
						n[m] = this.lenZ;
						w[m] = p;
						c[m] = this.lenY;
						k[m] = this.lenZ;
						e.push(this.xAxisTickColor);
						m++
					}
					z[m] = -this.lenX;
					d[m] = p * this.lenY / this.lenX;
					n[m] = this.lenZ;
					w[m] = this.lenX;
					c[m] = p * this.lenY / this.lenX;
					k[m] = this.lenZ;
					e.push(this.xAxisTickColor);
					m++
				}
				p += f;
				v++
			}
			this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle);
			z = [], d = [], n = [], w = [], c = [], k = [], e = [];
			p = q;
			v = 0;
			m = 0;
			A = this.xAxisIncr;
			while (p < this.lenX) {
				if (!((v + 1) % 3)) {
					if (this.xAxisType == "continuous") {
						z[m] = p;
						d[m] = -this.lenY;
						n[m] = this.lenZ;
						w[m] = p;
						c[m] = this.lenY;
						k[m] = this.lenZ;
						e.push(this.foreground);
						m++
					}
					z[m] = -this.lenX;
					d[m] = p * this.lenY / this.lenX;
					n[m] = this.lenZ;
					w[m] = this.lenX;
					c[m] = p * this.lenY / this.lenX;
					k[m] = this.lenZ;
					e.push(this.foreground);
					b = this.get3DTransfrom(p, this.lenY, -this.lenZ);
					j = b[0] + u;
					h = b[1] + o;
					r = this.xAxisTime ? dateFormat(new Date(this.xAxisMin + A), this.timeFormat) : this.formatAxisValue(this.xAxisMin + A, "xAxis");
					A += this.xAxisIncr;
					if (this.xAxisShow && this.xAxisType == "continuous") {
						this.addToRender(["drawText", r, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2])
					}
					m++
				}
				p += f;
				v++
			}
			this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
		}
		if (this.xAxisShow && !this.is3DPlot) {
			this.draw3DAxisTitle(q - (f * 2), this.lenX + f, this.lenY + (f * 4), this.lenY + (f * 4), -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "x")
		}
		z = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
		d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
		n = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		w = [-this.lenX, this.lenX, this.lenX, this.lenX];
		c = [this.lenY, -this.lenY, this.lenY, this.lenY];
		k = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		e = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
	};
	this.set3DYLayout = function() {
		this.functionCaller = "set3DYLayout";
		var A = [],
			d = [],
			n = [],
			z = [],
			c = [],
			k = [],
			e = [];
		var w, m, q, b, B, u, j, h;
		var f = this.lenY / 15;
		var r = (15 * -f) + f;
		var g = this.yAxisTitle ? this.yAxisTitle : this.is3DPlot && this.yAxis.length == 0 ? "Value" : this.yAxisIndex ? this.data.y.smps[this.yAxisIndex] : this.yAxis[0];
		var v = this.marginLeft + this.left + this.offsetX;
		var o = this.marginTop + this.top + this.offsetY;
		var p = [];
		if (this.show3DGrid) {
			q = r;
			w = 0;
			m = 0;
			while (q < this.lenY) {
				if ((w + 1) % 3) {
					if (this.zAxisType == "continuous") {
						A[m] = -this.lenX;
						d[m] = -this.lenY;
						n[m] = q * this.lenZ / this.lenY;
						z[m] = -this.lenX;
						c[m] = this.lenY;
						k[m] = q * this.lenZ / this.lenY;
						e.push(this.yAxisTickColor);
						m++
					}
					A[m] = -this.lenX;
					d[m] = q;
					n[m] = -this.lenZ;
					z[m] = -this.lenX;
					c[m] = q;
					k[m] = this.lenZ;
					e.push(this.yAxisTickColor);
					m++
				}
				q += f;
				w++
			}
			this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle);
			A = [], d = [], n = [], z = [], c = [], k = [], e = [];
			q = r;
			w = 0;
			m = 0;
			B = this.yAxisIncr * 9;
			while (q < this.lenY) {
				if (!((w + 1) % 3)) {
					if (this.zAxisType == "continuous") {
						A[m] = -this.lenX;
						d[m] = -this.lenY;
						n[m] = q * this.lenZ / this.lenY;
						z[m] = -this.lenX;
						c[m] = this.lenY;
						k[m] = q * this.lenZ / this.lenY;
						e.push(this.foreground);
						m++
					}
					A[m] = -this.lenX;
					d[m] = q;
					n[m] = -this.lenZ;
					z[m] = -this.lenX;
					c[m] = q;
					k[m] = this.lenZ;
					e.push(this.foreground);
					b = this.get3DTransfrom(-this.lenX, q, -this.lenZ);
					j = b[0] + v;
					h = b[1] + o;
					u = this.formatAxisValue(this.yAxisMin + B, "yAxis");
					B -= this.yAxisIncr;
					if (this.yAxisShow) {
						if (this.yRotate >= 45 && this.xRotate >= 45) {
							this.addToRender(["drawText", u, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2])
						} else {
							this.addToRender(["drawText", u, j - 5, h, this.axisTickFont, this.axisTickColor, "right"])
						}
					}
					m++
				}
				q += f;
				w++
			}
			this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle)
		}
		if (this.yAxisShow) {
			this.draw3DAxisTitle(-this.lenX - (f * 4), -this.lenX - (f * 4), r - (f * 2), this.lenY + f, -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "y")
		}
		A = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
		d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
		n = [-this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		z = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
		c = [this.lenY, -this.lenY, this.lenY, this.lenY];
		k = [-this.lenZ, -this.lenZ, this.lenZ, -this.lenZ];
		e = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle)
	};
	this.set3DZLayout = function() {
		this.functionCaller = "set3DZLayout";
		var n = this;
		var J = [],
			d = [],
			w = [],
			I = [],
			c = [],
			q = [],
			h = [];
		var G, r, A, v, b, L, E, p, o;
		var k, f, g, e, C, B, D, j;
		var m = this.zAxisTitle ? this.zAxisTitle : this.is3DPlot && this.zAxis.length == 0 ? "Variables" : this.zAxisIndex ? this.data.y.smps[this.zAxisIndex] : this.zAxis[0];
		var F = this.marginLeft + this.left + this.offsetX;
		var z = this.marginTop + this.top + this.offsetY;
		var H = function(u) {
			var t = u / n.varLabelInterval;
			if (parseInt(t) == parseFloat(t)) {
				var s = n.get3DTransfrom(n.lenX, n.lenY, A - (k / 2));
				var l = s[0] + F;
				var N = s[1] + z;
				var M = n.zAxis.length == 0 ? n.data.y.vars[n.varIndices[u]] : e[u];
				if (n.xRotate >= 45) {
					if (n.yRotate >= 45) {
						n.addToRender(["drawText", M, l + 5, N, n.axisTickFont, n.axisTickColor, "left"])
					} else {
						n.addToRender(["drawText", M, l, N + 5, n.axisTickFont, n.axisTickColor, "right", false, -Math.PI / 2])
					}
				} else {
					n.addToRender(["drawText", M, l + 5, N, n.axisTickFont, n.axisTickColor, "left"])
				}
			}
		};
		var K = function(N, t) {
			var M = N / n.smpLabelInterval;
			if (parseInt(M) == parseFloat(M)) {
				var s = n.get3DTransfrom((t * n.lenX / n.lenZ) - ((f / 2) * n.x3DRatio), n.lenY, -n.lenZ);
				var l = s[0] + F;
				var P = s[1] + z;
				var O = n.xAxis.length == 0 ? n.isGroupedData && n.scatterType == "dot" ? n.data.w.smps[n.grpIndices[N]] : n.data.y.smps[n.smpIndices[N]] : g[N];
				n.addToRender(["drawText", O, l, P + 5, n.axisTickFont, n.axisTickColor, "right", false, -Math.PI / 2])
			}
		};
		if (this.is3DPlot) {
			if (this.zAxis.length > 0) {
				if (this.zAxisType == "continuous") {
					k = this.lenZ / 15;
					C = (15 * -k) + k
				} else {
					e = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					k = this.lenZ / (e.length * 0.5);
					C = ((e.length * 0.5) * -k) + k
				}
			} else {
				k = this.lenZ / (this.varIndices.length * 0.5);
				C = ((this.varIndices.length * 0.5) * -k) + k
			}
			if (this.xAxis.length > 0) {
				if (this.xAxisType == "continuous") {
					f = this.lenX / 15;
					B = (15 * -f) + f
				} else {
					g = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					f = this.lenX / (g.length * 0.5);
					B = ((g.length * 0.5) * -f) + f
				}
			} else {
				if (this.isGroupedData && this.scatterType == "dot") {
					f = this.lenZ / (this.grpIndices.length * 0.5);
					B = ((this.grpIndices.length * 0.5) * -f) + f
				} else {
					f = this.lenZ / (this.smpIndices.length * 0.5);
					B = ((this.smpIndices.length * 0.5) * -f) + f
				}
			}
		} else {
			k = this.lenZ / 15;
			f = false;
			C = (15 * -k) + k;
			B = false
		}
		if (this.show3DGrid) {
			if (this.zAxisType == "continuous") {
				J = [], d = [], w = [], I = [], c = [], q = [], h = [];
				A = C;
				G = 0;
				r = 0;
				while (A < this.lenZ) {
					if ((G + 1) % 3) {
						J[r] = -this.lenX;
						d[r] = this.lenY;
						w[r] = A;
						I[r] = this.lenX;
						c[r] = this.lenY;
						q[r] = A;
						h.push(this.zAxisTickColor);
						r++
					}
					A += k;
					G++
				}
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
			}
			if (this.xAxisType == "continuous") {
				J = [], d = [], w = [], I = [], c = [], q = [], h = [];
				A = B || C;
				G = 0;
				r = 0;
				while (A < this.lenZ) {
					if ((G + 1) % 3) {
						J[r] = A * this.lenX / this.lenZ;
						d[r] = this.lenY;
						w[r] = -this.lenZ;
						I[r] = A * this.lenX / this.lenZ;
						c[r] = this.lenY;
						q[r] = this.lenZ;
						h.push(this.zAxisTickColor);
						r++
					}
					A += f || k;
					G++
				}
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
			}
			if (this.zAxisType == "continuous") {
				J = [], d = [], w = [], I = [], c = [], q = [], h = [];
				A = C;
				G = 0;
				r = 0;
				L = this.zAxisIncr;
				while (A < this.lenZ) {
					if (!((G + 1) % 3)) {
						J[r] = -this.lenX;
						d[r] = this.lenY;
						w[r] = A;
						I[r] = this.lenX;
						c[r] = this.lenY;
						q[r] = A;
						h.push(this.foreground);
						r++
					}
					A += k;
					G++
				}
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
			}
			if (this.xAxisType == "continuous" || this.zAxisType == "continuous") {
				J = [], d = [], w = [], I = [], c = [], q = [], h = [];
				if (this.xAxisType == "continuous") {
					A = B || C
				} else {
					A = C
				}
				G = 0;
				r = 0;
				L = this.zAxisIncr;
				while (A < this.lenZ) {
					if (!((G + 1) % 3)) {
						J[r] = A * this.lenX / this.lenZ;
						d[r] = this.lenY;
						w[r] = -this.lenZ;
						I[r] = A * this.lenX / this.lenZ;
						c[r] = this.lenY;
						q[r] = this.lenZ;
						h.push(this.foreground);
						r++;
						b = this.get3DTransfrom(this.lenX, this.lenY, A);
						p = b[0] + F;
						o = b[1] + z;
						E = this.zAxisTime ? dateFormat(new Date(this.zAxisMin + L), this.timeFormat) : this.formatAxisValue(this.zAxisMin + L, "zAxis");
						L += this.zAxisIncr;
						if (this.zAxisShow && this.zAxisType == "continuous") {
							if (this.xRotate >= 45) {
								if (this.yRotate >= 45) {
									this.addToRender(["drawText", E, p + 5, o, this.axisTickFont, this.axisTickColor, "left"])
								} else {
									this.addToRender(["drawText", E, p, o + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2])
								}
							} else {
								this.addToRender(["drawText", E, p + 5, o, this.axisTickFont, this.axisTickColor, "left"])
							}
						}
					}
					if (this.xAxisType == "continuous") {
						A += f || k
					} else {
						A += k
					}
					G++
				}
				if (this.xAxisType == "continuous") {
					this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
				}
			}
			if (this.zAxisType == "categorical") {
				A = C;
				G = 0;
				r = 0;
				while (A < this.lenZ) {
					J[r] = -this.lenX;
					d[r] = this.lenY;
					w[r] = A;
					I[r] = this.lenX;
					c[r] = this.lenY;
					q[r] = A;
					h.push(this.zAxisTickColor);
					H(G);
					r++;
					G++;
					A += k
				}
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle);
				H(G)
			}
			if (this.xAxisType == "categorical") {
				G = 0;
				v = B;
				while (v < this.lenZ) {
					J[r] = v * this.lenX / this.lenZ;
					d[r] = this.lenY;
					w[r] = -this.lenZ;
					I[r] = v * this.lenX / this.lenZ;
					c[r] = this.lenY;
					q[r] = this.lenZ;
					h.push(this.zAxisTickColor);
					K(G, v);
					r++;
					G++;
					v += f
				}
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle);
				K(G, v)
			}
		}
		if (this.zAxisShow && !this.is3DPlot) {
			this.draw3DAxisTitle(this.lenX + (k * 6), this.lenX + (k * 6), this.lenY + (k * 6), this.lenY + (k * 6), C - (k * 2), this.lenZ + k, m, "z")
		}
		J = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
		d = [this.lenY, this.lenY, this.lenY, this.lenY];
		w = [-this.lenZ, this.lenZ, -this.lenZ, -this.lenZ];
		I = [-this.lenX, this.lenX, this.lenX, this.lenX];
		c = [this.lenY, this.lenY, this.lenY, this.lenY];
		q = [this.lenZ, this.lenZ, this.lenZ, -this.lenZ];
		h = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
	};
	this.draw3DAxisTitle = function(v, u, e, d, k, j, n, c) {
		this.functionCaller = "draw3DAxisTitle";
		var p = this.measureText(n);
		var r = p / 2;
		var w = n.split("");
		var h = (v + u) / 2;
		var g = (e + d) / 2;
		var f = (k + j) / 2;
		var q = this.marginLeft + this.left + this.offsetX;
		var m = this.marginTop + this.top + this.offsetY;
		var o = this.xRotate >= 45 || this.yRotate >= 45 ? 4 : 0;
		if (this.xRotate >= 45 || this.yRotate >= 45) {
			p += w.length * 4;
			r = p / 2
		}
		if (c == "x") {
			h -= r;
			for (var s = 0; s < w.length; s++) {
				var b = this.get3DTransfrom(h, g, f);
				this.addToRender(["drawText", w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "top"]);
				h += this.measureText(w[s]) + o
			}
		} else {
			if (c == "y") {
				g += r;
				for (var s = 0; s < w.length; s++) {
					var b = this.get3DTransfrom(h, g, f);
					this.addToRender(["drawText", w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom", -Math.PI / 2]);
					g -= this.measureText(w[s]) + o
				}
			} else {
				if (c == "z") {
					f -= r;
					for (var s = 0; s < w.length; s++) {
						var b = this.get3DTransfrom(h, g, f);
						this.addToRender(["drawText", w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom"]);
						f += this.measureText(w[s]) + o
					}
				}
			}
		}
	};
	this.set3DLayout = function(c) {
		if (c) {
			this.layoutSet = {
				x: false,
				y: false,
				z: false
			}
		}
		for (var g = 0; g < this.layoutOrder.ord.length; g++) {
			var d = this.layoutOrder.ord[g];
			var h = c && this.layoutOrder[d];
			var f = !c && !this.layoutOrder[d];
			var e = c && this.layoutOrder[d + "1"];
			if (!this.layoutSet[d]) {
				if (h || f || (!h && !f && e)) {
					this["set3D" + d.toUpperCase() + "Layout"]();
					this.layoutSet[d] = true
				}
			}
		}
		if (!c) {
			delete(this.layoutSet)
		}
	};
	this.set3DAxes = function() {
		var f = ["x", "y", "z"];
		this.setMin = null;
		this.setMax = null;
		if (this.is3DPlot) {
			if (this.yAxis.length == 0) {
				if (this.xAxisTitle) {
					var c = this.yAxisTitle;
					this.yAxisTitle = this.xAxisTitle;
					this.xAxisTitle = c
				}
				this.yAxisMin = this.xAxisMin;
				this.yAxisMax = this.xAxisMax;
				this.yAxisIncr = this.getAxisIncrements(this.yAxisMin, this.yAxisMax, 10, this.yAxisExact);
				this.yAxisDecs = this.getAxisDecimals(this.yAxisIncr);
				this.yAxisRange = this.xAxisRange
			} else {
				var g = this.smpIndices;
				this.yAxisIndex = this.getSampleIndices([this.yAxis[0]]);
				this.setSamplesVisible([this.yAxisIndex]);
				this.setRangeData();
				this.yAxisMin = this.setMinY != null ? this.setMinY : this.minData;
				this.yAxisMax = this.setMaxY != null ? this.setMaxY : this.maxData;
				this.yAxisIncr = this.getAxisIncrements(this.yAxisMin, this.yAxisMax, 10, this.yAxisExact);
				this.yAxisDecs = this.getAxisDecimals(this.yAxisIncr);
				if (!this.yAxisExact) {
					this.yAxisMin = this.getAxisMin(this.yAxisMin, this.yAxisIncr);
					this.yAxisMax = this.yAxisMin + (this.yAxisIncr * 10)
				}
				this.yAxisRange = this.yAxisMax - this.yAxisMin;
				this.yAxisUnit = this.lenY * 2 / this.yAxisRange;
				this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisRange / 2)) * this.yAxisUnit);
				this.AxisType = "continuous";
				this.setSamplesVisible(g)
			}
			this.yAxisUnit = this.lenY * 2 / (this.yAxisIncr * 10);
			this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisIncr * 10 / 2)) * this.yAxisUnit);
			this.yAxisType = "continuous";
			if (this.xAxis.length > 0) {
				if (this.data.z && this.data.z.hasOwnProperty(this.xAxis[0]) && !this.isNumeric(this.data.z[this.xAxis[0]])) {
					var e = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					this.xAxisMin = 0;
					this.xAxisMax = 10;
					this.xAxisIncr = 10 / e.length;
					this.xAxisDecs = 0;
					this.xAxisRange = this.xAxisMax - this.xAxisMin;
					this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
					this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
					this.xAxisType = "categorical"
				} else {
					if (this.getSampleIndices(this.xAxis[0]) >= 0) {
						var g = this.smpIndices;
						this.xAxisIndex = this.getSampleIndices([this.xAxis[0]]);
						this.setSamplesVisible([this.xAxisIndex]);
						this.setRangeData();
						this.xAxisMin = this.setMinX != null ? this.setMinX : this.minData;
						this.xAxisMax = this.setMaxX != null ? this.setMaxX : this.maxData;
						this.xAxisIncr = this.getAxisIncrements(this.xAxisMin, this.xAxisMax, 10, this.xAxisExact);
						this.xAxisDecs = this.getAxisDecimals(this.xAxisIncr);
						if (!this.xAxisExact) {
							this.xAxisMin = this.getAxisMin(this.xAxisMin, this.xAxisIncr);
							this.xAxisMax = this.xAxisMin + (this.xAxisIncr * 10)
						}
						this.xAxisRange = this.xAxisMax - this.xAxisMin;
						this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
						this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
						this.xAxisType = "continuous";
						this.setSamplesVisible(g)
					}
				}
			} else {
				this.xAxisMin = 0;
				this.xAxisMax = 10;
				this.xAxisIncr = this.isGroupedData ? 10 / this.grpIndices.length : 10 / this.smpIndices.length;
				this.xAxisDecs = 0;
				this.xAxisRange = this.xAxisMax - this.xAxisMin;
				this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
				this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
				this.xAxisType = "categorical"
			}
			if (this.zAxis.length > 0) {
				if (this.data.z && this.data.z.hasOwnProperty(this.zAxis[0]) && !this.isNumeric(this.data.z[this.zAxis[0]])) {
					var e = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					this.zAxisMin = 0;
					this.zAxisMax = 10;
					this.zAxisIncr = 10 / e.length;
					this.zAxisDecs = 0;
					this.zAxisRange = this.zAxisMax - this.zAxisMin;
					this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
					this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
					this.zAxisType = "categorical"
				} else {
					if (this.getSampleIndices(this.zAxis[0]) >= 0) {
						var g = this.smpIndices;
						this.zAxisIndex = this.getSampleIndices([this.zAxis[0]]);
						this.setSamplesVisible([this.zAxisIndex]);
						this.setRangeData();
						this.zAxisMin = this.setMinZ != null ? this.setMinZ : this.minData;
						this.zAxisMax = this.setMaxZ != null ? this.setMaxZ : this.maxData;
						this.zAxisIncr = this.getAxisIncrements(this.zAxisMin, this.zAxisMax, 10, this.zAxisExact);
						this.zAxisDecs = this.getAxisDecimals(this.zAxisIncr);
						if (!this.zAxisExact) {
							this.zAxisMin = this.getAxisMin(this.zAxisMin, this.zAxisIncr);
							this.zAxisMax = this.zAxisMin + (this.zAxisIncr * 10)
						}
						this.zAxisRange = this.zAxisMax - this.zAxisMin;
						this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
						this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
						this.zAxisType = "continuous";
						this.setSamplesVisible(g)
					}
				}
			} else {
				this.zAxisMin = 0;
				this.zAxisMax = 10;
				this.zAxisIncr = 10 / this.varIndices.length;
				this.zAxisDecs = 0;
				this.zAxisRange = this.zAxisMax - this.zAxisMin;
				this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
				this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
				this.zAxisType = "categorical"
			}
		} else {
			for (var b = 0; b < f.length; b++) {
				var g = this.smpIndices;
				var d = f[b].toUpperCase();
				this[f[b] + "AxisIndex"] = this.getSampleIndices(this[f[b] + "Axis"])[0];
				this.setSamplesVisible([this[f[b] + "AxisIndex"]]);
				this.setRangeData();
				if (this.minData == this.maxData) {
					this.maxData += 0.5
				}
				this[f[b] + "AxisMin"] = this["setMin" + d] != null ? this["setMin" + d] : this.minData;
				this[f[b] + "AxisMax"] = this["setMax" + d] != null ? this["setMax" + d] : this.maxData;
				this[f[b] + "AxisIncr"] = this.getAxisIncrements(this[f[b] + "AxisMin"], this[f[b] + "AxisMax"], 10, this[f[b] + "AxisExact"]);
				this[f[b] + "AxisDecs"] = this.getAxisDecimals(this[f[b] + "AxisIncr"]);
				if (!this[f[b] + "AxisExact"]) {
					this[f[b] + "AxisMin"] = this.getAxisMin(this[f[b] + "AxisMin"], this[f[b] + "AxisIncr"]);
					this[f[b] + "AxisMax"] = this[f[b] + "AxisMin"] + (this[f[b] + "AxisIncr"] * 10)
				}
				this[f[b] + "AxisRange"] = this[f[b] + "AxisMax"] - this[f[b] + "AxisMin"];
				this[f[b] + "AxisUnit"] = this["len" + d] * 2 / this[f[b] + "AxisRange"];
				this[f[b] + "AxisOffset"] = Math.min(this["len" + d], (this[f[b] + "AxisMin"] + (this[f[b] + "AxisRange"] / 2)) * this[f[b] + "AxisUnit"]);
				this[f[b] + "AxisType"] = "continuous";
				this[f[b] + "AxisTime"] = this.isGraphTime == f[b] ? true : false;
				this.setSamplesVisible(g)
			}
		}
		this.set3DCenter()
	};
	this.set3DCenter = function() {
		var r = this.xAxisMin < 0 ? 0 : this.xAxisMin;
		var q = this.yAxisMin < 0 ? 0 : this.yAxisMin;
		var o = this.zAxisMin < 0 ? 0 : this.zAxisMin;
		var m = ((((this.xAxisMin + this.xAxisMax) / 2) - r) * this.xAxisUnit) - this.xAxisOffset;
		var l = this.yAxisOffset - ((((this.yAxisMin + this.yAxisMax) / 2) - q) * this.yAxisUnit);
		var k = ((((this.zAxisMin + this.zAxisMax) / 2) - o) * this.zAxisUnit) - this.zAxisOffset;
		this.zero3DPoint = this.get3DTransfrom(m, l, k);
		var A = this.get3DTransfrom(((this.xAxisMin - r) * this.xAxisUnit) - this.xAxisOffset, l, k);
		var w = this.get3DTransfrom(((this.xAxisMax - r) * this.xAxisUnit) - this.xAxisOffset, l, k);
		var f = this.get3DTransfrom(m, this.yAxisOffset - ((this.yAxisMin - q) * this.yAxisUnit), k);
		var e = this.get3DTransfrom(m, this.yAxisOffset - ((this.yAxisMax - q) * this.yAxisUnit), k);
		var p = this.get3DTransfrom(m, l, ((this.zAxisMax - o) * this.zAxisUnit) - this.zAxisOffset);
		var n = this.get3DTransfrom(m, l, ((this.zAxisMin - o) * this.zAxisUnit) - this.zAxisOffset);
		var u = this.euclidianDistance([A[0], A[1], A[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var t = this.euclidianDistance([w[0], w[1], w[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var c = this.euclidianDistance([f[0], f[1], f[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var b = this.euclidianDistance([e[0], e[1], e[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var j = this.euclidianDistance([p[0], p[1], p[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var h = this.euclidianDistance([n[0], n[1], n[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var s = this.euclidianDistance([this.zero3DPoint[0], this.zero3DPoint[1], this.zero3DPoint[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var B = [Math.min(u, t), Math.min(c, b), Math.min(j, h)];
		var C = {
			0: "x",
			1: "y",
			2: "z"
		};
		var g = [0, 1, 2];
		g = g.sort(function(x, i) {
			return B[x] - B[i]
		});
		var d = [];
		for (var v = 0; v < g.length; v++) {
			d.push(C[g[v]])
		}
		this.layoutOrder = {
			x0: j,
			x1: h,
			y0: u,
			y1: t,
			z0: c,
			z1: b,
			md: s,
			x: j >= h,
			y: u >= t,
			z: c >= b,
			x1: Math.min(j, h) > s,
			y1: Math.min(u, t) > s,
			z1: Math.min(c, b) > s,
			ord: d
		}
	};
	this.is3DVisibleDataPoint = function(b, d, c) {
		if (b >= this.xAxisMin && b <= this.xAxisMax) {
			if (d >= this.yAxisMin && d <= this.yAxisMax) {
				if (c >= this.zAxisMin && c <= this.zAxisMax) {
					return true
				}
			}
		}
		return false
	};
	this.draw3DDataPoints = function() {
		this.functionCaller = "draw3DDataPoints";
		var Z = this.marginLeft + this.left + this.offsetX;
		var Q = this.marginTop + this.top + this.offsetY;
		var aq = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
		var aN = {
			data: {},
			ellp: {},
			sphr: {}
		};
		var aK = [];
		var G = [];
		var aJ = [];
		var D = [];
		var b = [];
		var K = [];
		var ar = [];
		var F = [];
		var aC = [];
		var f = 0;
		this.connectByData = {};
		if (this.is3DPlot) {
			if (this.xAxis.length > 0 && this.yAxis.length > 0 && this.zAxis.length > 0) {
				var aD, aL, at;
				var ae = {};
				var ac = {};
				var aB = this.getSampleIndices(this.yAxis[0]);
				if (this.data.z && this.data.z.hasOwnProperty(this.xAxis[0]) && !this.isNumeric(this.data.z[this.xAxis[0]])) {
					aD = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					for (var ad = 0; ad < aD.length; ad++) {
						ae[aD[ad]] = ad
					}
					aL = false
				} else {
					aL = this.getSampleIndices(this.xAxis[0])
				}
				if (this.data.z && this.data.z.hasOwnProperty(this.zAxis[0]) && !this.isNumeric(this.data.z[this.zAxis[0]])) {
					aD = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					for (var ad = 0; ad < aD.length; ad++) {
						ac[aD[ad]] = ad
					}
					at = false
				} else {
					at = this.getSampleIndices(this.zAxis[0])
				}
				S = 0;
				for (var ad = 0; ad < this.varIndices.length; ad++) {
					var U = this.varIndices[ad];
					var O = aL === false ? (ae[this.data.z[this.xAxis[0]][U]] * this.xAxisIncr) + (this.xAxisIncr / 2) : this.getDataAtPos(U, aL);
					var N = this.getDataAtPos(U, aB);
					var M = at === false ? (ac[this.data.z[this.zAxis[0]][U]] * this.zAxisIncr) + (this.zAxisIncr / 2) : this.getDataAtPos(U, at);
					var aw = this.xAxisMin < 0 ? 0 : this.xAxisMin;
					var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
					var au = this.zAxisMin < 0 ? 0 : this.zAxisMin;
					var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
					var B = this.yAxisOffset - ((N - av) * this.yAxisUnit);
					var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
					ar.push(true);
					aK.push([O, N, M]);
					var aM = this.get3DTransfrom(C, B, A);
					G.push(aM);
					aJ.push(aM[2]);
					K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
					aC.push([U, aB]);
					b.push(S++)
				}
			} else {
				if (this.isGroupedData && this.scatterType == "dot") {
					this.isGroupedData = false;
					var S = 0;
					for (var ad = 0; ad < this.varIndices.length; ad++) {
						var U = this.varIndices[ad];
						for (var ab = 0; ab < this.grpIndices.length; ab++) {
							for (var aa = 0; aa < this.data.w.grps[this.grpIndices[ab]].length; aa++) {
								var H = this.data.w.grps[this.grpIndices[ab]][aa];
								var O = (ab * this.xAxisIncr) + (this.xAxisIncr / 2);
								var N = this.getDataAtPos(U, H);
								var M = (ad * this.zAxisIncr) + (this.zAxisIncr / 2);
								var aw = 0;
								var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
								var au = 0;
								var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
								var B = this.yAxisOffset - ((N - av) * this.yAxisUnit);
								var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
								ar.push(true);
								aK.push([O, N, M]);
								var aM = this.get3DTransfrom(C, B, A);
								G.push(aM);
								aJ.push(aM[2]);
								K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
								aC.push([U, this.grpIndices[ab]]);
								b.push(S++)
							}
						}
					}
					this.isGroupedData = true
				} else {
					var S = 0;
					for (var ad = 0; ad < this.varIndices.length; ad++) {
						var U = this.varIndices[ad];
						for (var ab = 0; ab < this.smpIndices.length; ab++) {
							var H = this.smpIndices[ab];
							var O = (ab * this.xAxisIncr) + (this.xAxisIncr / 2);
							var N = this.getDataAtPos(U, H);
							var M = (ad * this.zAxisIncr) + (this.zAxisIncr / 2);
							var aw = 0;
							var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
							var au = 0;
							var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
							var B = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((N - av) * this.yAxisUnit);
							var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
							ar.push(true);
							aK.push([O, N, M]);
							var aM = this.get3DTransfrom(C, B, A);
							G.push(aM);
							aJ.push(aM[2]);
							K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
							aC.push([U, H]);
							b.push(S++)
						}
					}
				}
			}
		} else {
			for (var ad = 0; ad < this.varIndices.length; ad++) {
				var U = this.varIndices[ad];
				var O = this.getDataAtPos(U, this.xAxisIndex);
				var N = this.getDataAtPos(U, this.yAxisIndex);
				var M = this.getDataAtPos(U, this.zAxisIndex);
				var aw = this.xAxisMin < 0 ? 0 : this.xAxisMin;
				var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
				var au = this.zAxisMin < 0 ? 0 : this.zAxisMin;
				var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
				var B = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((N - av) * this.yAxisUnit);
				var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
				var e = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.data.z[this.ellipseBy][U] : this.ellipseBy && this.ellipseBy == "variable" ? "variable" : false;
				ar.push(this.is3DVisibleDataPoint(O, N, M));
				aK.push([O, N, M]);
				var aM = this.get3DTransfrom(C, B, A);
				G.push(aM);
				aJ.push(aM[2]);
				if (this.scatterType != "function") {
					b.push(ad);
					K.push(this.euclidianDistance([G[ad][0], G[ad][1], G[ad][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
				}
				if (this.ellipseBy && e) {
					if (!aN.data.hasOwnProperty(e)) {
						aN.data[e] = [
							[],
							[],
							[]
						]
					}
					aN.data[e][0].push(O);
					aN.data[e][1].push(N);
					aN.data[e][2].push(M)
				}
			}
			if (this.ellipseBy) {
				var am = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.meta.data.z[this.ellipseBy] : false;
				var ad = this.varIndices.length;
				for (var e in aN.data) {
					aN.ellp[e] = this.errorEllipse(aN.data[e][0], aN.data[e][1], aN.data[e][2]);
					var ay = aN.ellp[e];
					aN.sphr[e] = this.sphere(ay.cx, ay.cy, ay.cz, ay.rx[0], ay.ry[0], ay.rz[0], ay.rot[0], ay.rot[1], ay.rot[2]);
					for (var ab = 0; ab < aN.sphr[e].length; ab++) {
						C = ((aN.sphr[e][ab][0] - aw) * this.xAxisUnit) - this.xAxisOffset;
						B = this.yAxisOffset - ((aN.sphr[e][ab][1] - av) * this.yAxisUnit);
						A = ((aN.sphr[e][ab][2] - au) * this.zAxisUnit) - this.zAxisOffset;
						aM = this.get3DTransfrom(C, B, A);
						G.push(aM);
						aJ.push(aM[2]);
						b.push(ad + ab);
						K.push(this.euclidianDistance([G[ad + ab][0], G[ad + ab][1], G[ad + ab][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
					}
					ad += aN.sphr[e].length
				}
			}
		}
		var aG = this.range(aJ);
		if (this.scatterType && this.scatterType == "function") {
			var Y = Math.sqrt(G.length);
			var U = 0;
			var h = [];
			var aE = this.colorBy ? this.meta.data.y.range[this.colorBy] : false;
			var X = this.colorBy ? this.getColorBrew(this.colorSpectrum, aE.min, aE.max, this.colorSpectrumZeroValue, this.colorSpectrumBreaks) : false;
			for (var ad = 1; ad < Y; ad++) {
				for (var ab = 0; ab < Y - 1; ab++) {
					var ak = ((ad - 1) * Y) + ab;
					var ap = (ad * Y) + ab;
					var aj = ((ad - 1) * Y) + ab + 1;
					var al = (ad * Y) + ab + 1;
					var aF = [G[ak][0] + this.funcX, G[ap][0] + this.funcX, G[al][0] + this.funcX, G[aj][0] + this.funcX];
					var az = [G[ak][1] + this.funcY, G[ap][1] + this.funcY, G[al][1] + this.funcY, G[aj][1] + this.funcY];
					var an = [G[ak][2], G[ap][2], G[al][2], G[aj][2]];
					var L = this.colorBy ? this.getColorForValue(X, this.mean([aK[ak][1], aK[ap][1], aK[al][1], aK[aj][1]])) : false;
					b.push(U++);
					K.push(this.euclidianDistance([this.mean(aF), this.mean(az), this.mean(an)], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
					h.push([aF, az, L])
				}
			}
			b.sort(function(g, c) {
				return K[c] - K[g]
			});
			for (var U = 0; U < h.length; U++) {
				var ad = b[U];
				if (ar[ad]) {
					var ai = [ad, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
					if (this.colorBy) {
						this.addToRender(["drawShape", "polygon", h[ad][0], h[ad][1], false, false, h[ad][2], h[ad][2], "closed"], ai)
					} else {
						this.addToRender(["drawShape", "polygon", h[ad][0], h[ad][1], false, false, false, this.foreground, "open"], ai)
					}
				}
			}
		} else {
			if (this.meta.system.browser == "Firefox") {
				b = this.radixSort(b)
			} else {
				b.sort(function(g, c) {
					return K[c] - K[g]
				})
			}
			var ao = this.is3DPlot ? this.scatterPointSize / (80 * this.bar3DInverseWeight) : this.scatterPointSize / (8 * this.bar3DInverseWeight);
			for (var U = 0; U < G.length; U++) {
				var ad = b[U];
				if (this.ellipseBy && ad >= this.varIndices.length) {
					var aH = 350;
					var aA = 25;
					var P = ad - this.varIndices.length;
					var ax = ad + 1;
					var ah = ad + aA;
					var aI = P % aA;
					var d = parseInt(P / aH);
					var m = (aH * d) + (aH / 2);
					var E = m - 24;
					if (!aI && ad + 1 < G.length) {
						this.addToRender(["drawLine", "line", Z + G[ad][0], Q + G[ad][1], Z + G[ad + 1][0], Q + G[ad + 1][1], this.colors[d % this.colors.length]])
					} else {
						if (parseInt(P / aA) == parseInt((P - 1) / aA) && parseInt(P / aH) == parseInt((P + 1) / aH) && ax < G.length) {
							this.addToRender(["drawLine", "line", Z + G[ad][0], Q + G[ad][1], Z + G[ax][0], Q + G[ax][1], this.colors[d % this.colors.length]]);
							if (parseInt(P / aH) == parseInt((P + aA) / aH) && ah < G.length) {
								if (P < E || P > m) {
									this.addToRender(["drawLine", "line", Z + G[ad][0], Q + G[ad][1], Z + G[ah][0], Q + G[ah][1], this.colors[d % this.colors.length]])
								}
							}
						}
					}
				} else {
					var P = this.is3DPlot ? aC[ad][0] : ad;
					var ag = this.colorBy ? this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "colorBy") : this.is3DPlot ? this.colors[P % this.colors.length] : this.colors[0];
					var V = this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "shapeBy");
					var R = this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "sizeBy");
					var S = this.patternBy ? this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "patternBy") : this.patterns[0];
					var af = this.scatterType && this.scatterType.match(/image/i) ? this.images[ad] : false;
					var ai = this.is3DPlot ? [aC[ad][0], aC[ad][1]] : [this.varIndices[ad], this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
					if (ar[ad] && this.isVisibleSelectedDataPoint(ad, aq)) {
						if (this.scatterType && this.scatterType.match(/bar/)) {
							var R = this.isInSelectedDataPoints(ad, aq) ? this.selectedBackgroundColor : ag;
							this.draw3DBar(aK[ad][0], aK[ad][1], aK[ad][2], ao, R, ai)
						} else {
							if (this.scatterType && this.scatterType.match(/dot/)) {
								var T = af ? "image" : V;
								var O = Z + G[ad][0];
								var N = Q + G[ad][1];
								var W = G.length > this.scatterOutlineThreshold ? ag : this.foreground;
								var M = Math.floor(this.percentile(aG[0], aG[1], G[ad][2]));
								this.drawSelectedBackground(ai[1], aq, V, O, N, R, R);
								this.addToRender(["drawShape", T, O, N, R, R, ag, W, S, false, false, false, false, false, false, af], ai);
								this.drawSelectedBackgroundLabel(ai[1], aq, O, N)
							} else {
								var T = af ? "image" : V;
								var O = Z + G[ad][0];
								var N = Q + G[ad][1];
								var W = G.length > this.scatterOutlineThreshold ? ag : this.foreground;
								var M = Math.floor(this.percentile(aG[0], aG[1], G[ad][2]));
								this.drawSelectedBackground(ad, aq, V, O, N, R, R);
								this.addToRender(["drawShape", T, O, N, R, R, ag, W, S, false, false, false, false, false, false, af], ai);
								this.drawSelectedBackgroundLabel(this.varIndices[ad], aq, O, N);
								if (this.scatterType && this.scatterType.match(/line/)) {
									D[ad] = [G[ad][0], G[ad][1]]
								} else {
									if (this.connectBy) {
										if (!this.connectByData[this.data.z[this.connectBy][ad]]) {
											this.connectByData[this.data.z[this.connectBy][ad]] = []
										}
										this.connectByData[this.data.z[this.connectBy][ad]].push([G[ad][0], G[ad][1]])
									}
								}
							}
						}
					}
				}
			}
			if (this.scatterType && this.scatterType.match(/line/) && D.length > 0) {
				for (var ad = 0; ad < D.length - 1; ad++) {
					if (ar[ad] && this.isVisibleSelectedDataPoint(ad, aq) && ar[ad + 1] && this.isVisibleSelectedDataPoint(ad + 1, aq)) {
						var J = Z + D[ad][0];
						var w = Q + D[ad][1];
						var I = Z + D[ad + 1][0];
						var u = Q + D[ad + 1][1];
						this.addToRender(["drawLine", "line", J, w, I, u, this.colors[0]])
					}
				}
			} else {
				if (this.connectBy) {
					for (U in this.connectByData) {
						if (this.connectByData[U].length > 1) {
							for (var ad = 0; ad < this.connectByData[U].length - 1; ad++) {
								var J = Z + this.connectByData[U][ad][0];
								var w = Q + this.connectByData[U][ad][1];
								var I = Z + this.connectByData[U][ad + 1][0];
								var u = Q + this.connectByData[U][ad + 1][1];
								this.addToRender(["drawLine", "line", J, w, I, u, this.connectByColor, this.connectByWidth])
							}
						}
					}
				}
			}
			if (this.decorations && this.decorations.marker) {
				this.drawMarkers()
			}
		}
	};
	this.set3DprivateParams = function() {
		this.set3DText();
		this.set3DParams()
	};
	this.draw3DPlot = function() {
		this.validatePropertyValues();
		this.set3DXYDimensions();
		this.set3DprivateParams();
		this.set3DRotation();
		this.set3DAxes();
		this.set3DLayout(true);
		this.draw3DDataPoints();
		this.set3DLayout();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializeScatter3D = function() {
		if (this.layoutValid) {
			this.drawLayoutCompartments(this.draw3DPlot)
		} else {
			this.draw3DPlot()
		}
	};
	if (!a) {
		this.initializeScatter3D()
	}
};
CanvasXpress.prototype.oneDPlot = function(a) {
	this.get1DLeft = function() {
		return this.marginLeft + this.offsetX + this.left
	};
	this.get1DTop = function() {
		return this.marginTop + this.offsetY + this.top
	};
	this.get1DIndices = function() {
		return this.isGroupedData ? this.grpIndices : this.smpIndices
	};
	this.get1DSamples = function() {
		return this.isGroupedData ? this.data.w.smps : this.data.y.smps
	};
	this.get1DLabels = function() {
		return this.isGroupedData ? this.data.w.smps : false
	};
	this.get1DCompBlockMax = function() {
		if (this.graphType == "BarLine" || this.graphType == "DotLine") {
			return this.getVariablesVisibleByAxis("xAxis").length
		} else {
			if (this.graphType.match(/Stacked|Line|Area|ParallelCoordinates/)) {
				return 1
			} else {
				return this.plotByVariable ? this.get1DIndices().length : this.varIndices.length
			}
		}
	};
	this.setVariableBlock = function() {
		this.variableBlock = this.varIndices.length
	};
	this.setRowColBlocks = function() {
		this.setVariableBlock();
		var b = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		var e = ["Area", "AreaLine", "Heatmap", "Line", "ParallelCoordinates", "Sankey", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Tree"];
		var d = 0;
		var f = 0;
		if (this.isInArray(this.graphType, e)) {
			d = b;
			f = this.graphType == "Heatmap" ? this.varIndices.length : 1
		} else {
			if (this.graphType == "BarLine" || this.graphType == "DotLine") {
				d = Math.max(this.xAxis.length, this.xAxis2.length) * b;
				f = 1
			} else {
				if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
					d = 1;
					f = 1
				} else {
					d = this.varIndices.length * b;
					f = 1
				}
			}
		}
		this.rowBlocks = d;
		this.colBlocks = f
	};
	this.set1DFont = function() {
		if (this.autoScaleFont) {
			var f = 1 - this.percentAspectRatioPlotArea;
			var b = this.width * f;
			var g = this.height * f;
			var c = this.getAxisDescription();
			var e = this.getAxisDescription(true);
			this.setAxisFont(c.length > e.length ? c : e, this.graphOrientation == "vertical" ? g : b);
			this.setPropertyFontSize(b, "varTitleFont");
			this.setPropertyFontSize(b, "varLabelFont");
			this.setPropertyFontSize(this.graphOrientation == "vertical" ? b : g, "smpTitleFont");
			this.setPropertyFontSize(this.graphOrientation == "vertical" ? b : g, "smpLabelFont")
		}
	};
	this.setOverlays = function(u) {
		var r = this;
		var c = {};
		var l = this[u + "Overlays"];
		var e = this[u + "OverlayProperties"];
		var f = u == "smp" ? this.data.x : this.data.z;
		var t = (u == "var") || (u == "smp" && this.graphOrientation == "vertical") ? ["Bottom", "Top"] : ["Left", "Right"];
		var s = function() {
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && f.hasOwnProperty(l[j])) {
					if (!e[l[j]]) {
						e[l[j]] = {}
					}
					if (!e[l[j]]["type"]) {
						e[l[j]]["type"] = "Default"
					}
					if (!e[l[j]]["color"]) {
						e[l[j]]["color"] = r.colors[j]
					}
					if (!e[l[j]]["spectrum"]) {
						e[l[j]]["spectrum"] = r.colorSpectrum
					}
					if (!e[l[j]]["position"]) {
						if (r.graphType == "Heatmap" || r.graphOrientation == "horizontal") {
							e[l[j]]["position"] = u == "smp" ? "left" : "bottom"
						} else {
							e[l[j]]["position"] = "bottom"
						}
					} else {
						if ((u == "var") || (u == "smp" && r.graphOrientation == "vertical")) {
							if (!e[l[j]]["position"].match(/top|bottom/)) {
								e[l[j]]["position"] = e[l[j]]["position"] == "rigth" ? "top" : "bottom"
							}
						} else {
							if (!e[l[j]]["position"].match(/left|right/)) {
								e[l[j]]["position"] = e[l[j]]["position"] == "top" ? "right" : "left"
							}
						}
					}
				}
			}
		};
		var o = function() {
			var k = [];
			var m = [];
			for (var j = 0; j < l.length; j++) {
				if (l[j] == "-") {
					m.push(j)
				}
			}
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && e[l[j]]["position"].match(/left|bottom/)) {
					k.push(l[j])
				}
			}
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && e[l[j]]["position"].match(/right|top/)) {
					k.push(l[j])
				}
			}
			for (var j = 0; j < m.length; j++) {
				k.splice(m[j], 0, "-")
			}
			l = k;
			r[u + "Overlays"] = l
		};
		if (this.isDOE) {} else {
			s();
			o()
		}
		this[u + "OverlaysStrLength"] = 0;
		for (var n = 0; n < t.length; n++) {
			var b = t[n].toLowerCase();
			var q = false;
			this[u + "OverlaysThickness" + t[n]] = 0;
			if (this.showOverlays && l.length > 0) {
				if (u == "smp") {
					if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
						continue
					}
				} else {
					if (u == "var") {
						if (this.graphType != "Heatmap") {
							continue
						}
					} else {
						continue
					}
				}
				for (var h = 0; h < l.length; h++) {
					if (l[h] == "-") {
						if (h > 0 && q == b) {
							this[u + "OverlaysThickness" + t[n]] += this.margin
						}
					} else {
						if (!c.hasOwnProperty(l[h])) {
							q = e[l[h]]["position"];
							if (q == b) {
								var d = this.getOverlaysForTypePosition(u, e[l[h]]["type"], b, l[h]);
								this[u + "OverlaysThickness" + t[n]] += e[l[h]]["thickness"] || this.overlaysThickness;
								for (var g = 0; g < d.length; g++) {
									this[u + "OverlaysStrLength"] = Math.max(this[u + "OverlaysStrLength"], this.measureText(d[g], this.overlayFont) + this.margin);
									c[d[g]] = true
								}
							}
						}
					}
				}
				if (this[u + "OverlaysThickness" + t[n]] > 0) {
					this[u + "OverlaysThickness" + t[n]] += this.margin
				}
			}
		}
	};
	this.getOverlaysForTypePosition = function(h, e, k, f) {
		var b = [];
		var l = h == "smp" ? this.smpOverlayProperties : this.varOverlayProperties;
		var g = h == "smp" ? this.smpOverlays : this.varOverlays;
		for (var j = 0; j < g.length; j++) {
			var d = g[j];
			if (d != "-" && l.hasOwnProperty(d)) {
				var m = l[d]["type"];
				var c = l[d]["position"];
				if (k.match(/left|bottom/) && !c.match(/left|bottom/)) {
					continue
				} else {
					if (k.match(/top|right/) && !c.match(/top|right/)) {
						continue
					}
				}
				if (e.match(/Area|AreaLine/) && m.match(/Area|AreaLine/)) {
					b.push(d)
				} else {
					if (e.match(/Bar|BarLine/) && m.match(/Bar|BarLine/)) {
						b.push(d)
					} else {
						if (e.match(/Dotplot|DotLine/) && m.match(/Dotplot|DotLine/)) {
							b.push(d)
						} else {
							if (e == "Line" && m == "Line") {
								b.push(d)
							} else {
								if (e.match(/Heatmap|Default|Text/)) {
									return [f]
								} else {
									if (e == "Pie" && m == "Pie") {
										b.push(d)
									} else {
										if (e == "Treemap" && m == "Treemap") {
											b.push(d)
										} else {
											if ((e == "StackedPercent" || e == "StackedPercentLine") && (m == "StackedPercent" || m == "StackedPercentLine")) {
												b.push(d)
											} else {
												if ((e == "Stacked" || e == "StackedLine") && (m == "Stacked" || m == "StackedLine")) {
													b.push(d)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return b
	};
	this.getVariableTitleHeight = function() {
		if (this.varTitle && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			return this.varTitleFontSize + this.margin
		} else {
			return 0
		}
	};
	this.getVariableLabelLength = function() {
		if (this.showVariableNames && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			if (this.varLabelRotate && Math.abs(this.varLabelRotate) == 90) {
				return this.varLabelFontSize + this.margin
			} else {
				return this.measureText(this.shortenText(this.meta.data.y.maxVarStr, this.maxVarStringLen), this.varLabelFont) + this.margin
			}
		} else {
			return 0
		}
	};
	this.getVariableLabelDescLength = function() {
		if (this.showVariableNames && this.varLabelDescription && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			var b = this.meta.data.z[this.varLabelDescription];
			if (b.maxLevChr > this.maxVarStringLen) {
				return this.measureText(b.maxLevStr.substring(0, this.maxVarStringLen), this.varLabelFont)
			} else {
				return this.measureText(b.maxLevStr, this.varLabelFont)
			}
		} else {
			return 0
		}
	};
	this.getSampleTitleHeight = function() {
		if (this.smpTitle && this.graphType != "Treemap" && this.graphType != "TagCloud" && this.graphType != "Sankey" && this.graphType != "Tree") {
			return this.smpTitleFontSize + this.margin
		} else {
			return 0
		}
	};
	this.getSampleLabelLength = function() {
		if (this.showSampleNames && this.graphType != "Treemap" && this.graphType != "TagCloud" && this.graphType != "Sankey") {
			if (this.smpLabelRotate && Math.abs(this.smpLabelRotate) == 90) {
				return this.smpLabelFontSize + this.margin
			} else {
				var b;
				if (this.layoutValid && !this.layoutAdjust) {
					b = this.isGroupedData && this.meta.data.g ? this.getMaxText(this.meta.data.g.smps) : this.meta.data.y.maxSmpStr
				} else {
					if (this.isGraphTime) {
						b = this.getMaxText(this.timeValues)
					} else {
						b = this.isGroupedData ? this.meta.data.w.maxSmpStr : this.meta.data.y.maxSmpStr
					}
				}
				if (b.length > this.maxSmpStringLen) {
					b = this.measureText(b.substring(0, this.maxSmpStringLen), this.smpLabelFont) + (this.margin * 2)
				} else {
					b = this.measureText(b, this.smpLabelFont) + (this.margin * 2)
				}
				b = this.smpLabelRotate ? b * (Math.cos(this.radians(this.smpLabelRotate))) : b;
				return b
			}
		} else {
			return 0
		}
	};
	this.getSampleLabelDescLength = function() {
		if (this.showSampleNames && this.smpLabelDescription && this.graphType != "Treemap" && this.graphType != "TagCloud" && this.graphType != "Sankey" && this.graphType != "Tree") {
			var b = this.meta.data.x[this.smpLabelDescription];
			if (b.maxLevChr > this.maxSmpStringLen) {
				return this.measureText(b.maxLevStr.substring(0, this.maxSmpStringLen), this.smpLabelFont)
			} else {
				return this.measureText(b.maxLevStr, this.smpLabelFont)
			}
		} else {
			return 0
		}
	};
	this.getAxisTitleTickLength = function(m) {
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return 0
		} else {
			if (this.graphOrientation == "vertical") {
				var f, k, e, c;
				if (((this.xAxisTransform && this.xAxisTransform.match(/log|exp/)) || (this.isTransformedData && this.isTransformedData.match(/log|exp/))) && !this.xAxisTransformTicks) {
					var j = this.xAxisValues;
					var h = this.xAxis2Values;
					var l = [];
					for (var d = 0; d < j.length; d++) {
						var b = j[d];
						l.push(this.formatNumber(this.transformValue(this.xAxisTransform || this.isTransformedData, b, true)))
					}
					e = this.getMaxText(l);
					var g = [];
					for (var d = 0; d < h.length; d++) {
						var b = h[d];
						g.push(this.transformValue(this.xAxis2Transform || this.isTransformedData, b, true))
					}
					c = this.getMaxText(g)
				} else {
					e = this.xAxisMaxStrLength;
					c = this.xAxis2MaxStrLength
				}
				if (this.graphType == "ParallelCoordinates") {
					if (this.smpLabelRotate) {
						if (this.smpLabelRotate == 90) {
							f = Math.max(this.parallelCoordinates[0].len, this.parallelCoordinates[0].lenSmp / 2)
						} else {
							f = Math.max(this.parallelCoordinates[0].len, this.parallelCoordinates[0].lenSmp * (Math.sin(this.radians(this.smpLabelRotate))))
						}
					} else {
						f = this.parallelCoordinates[0].len
					}
				} else {
					if (this.graphType == "Candlestick") {
						if (this.showVolume) {
							f = Math.max(this.measureText(e, this.axisTickFont), this.measureText(c, this.axisTickFont))
						} else {
							if (this.summaryType == "candle") {
								f = this.measureText(e, this.axisTickFont)
							} else {
								f = this.measureText(c, this.axisTickFont)
							}
						}
					} else {
						if (this.graphType == "BarLine" || this.graphType == "DotLine") {
							f = m ? this.measureText(c, this.axisTickFont) : this.measureText(e, this.axisTickFont)
						} else {
							f = this.measureText(e, this.axisTickFont)
						}
					}
				}
				k = m ? this.getAxisDescription(true) : this.getAxisDescription();
				k = k != "" && !this.layoutValid ? this.axisTitleFontSize : 0;
				if (m) {
					if (this.graphType == "ParallelCoordinates") {
						if (this.smpLabelRotate && this.smpLabelRotate == 90) {
							return this.parallelCoordinates[this.parallelCoordinates.length - 1].lenSmp
						} else {
							return 0
						}
					} else {
						return this.xAxis2Show ? k + f + (this.margin * 4) : 0
					}
				} else {
					if (this.graphType == "ParallelCoordinates") {
						return k + f + (this.margin * 4)
					} else {
						return this.xAxisShow ? k + f + (this.margin * 4) : 0
					}
				}
			} else {
				k = m ? this.getAxisDescription(true) : this.getAxisDescription();
				k = k != "" && !this.layoutValid ? this.axisTitleFontSize : 0;
				if (m) {
					return this.xAxis2Show ? k + this.axisTickFontSize + (this.margin * 4) : 0
				} else {
					return this.xAxisShow ? k + this.axisTickFontSize + (this.margin * 4) : 0
				}
			}
		}
	};
	this.getHeatmapIndicatorWidth = function() {
		if (this.showHeatmapIndicator) {
			var b = this.getDefaultMetaDataObject();
			var c = this.xAxisTitle ? this.measureText(this.xAxisTitle, this.legendFont) : 0;
			if (this.heatmapIndicatorPosition == "right") {
				return Math.max(c, this.heatmapIndicatorHeight + (this.margin * 2) + b.maxLevLen)
			} else {
				return Math.max(c, this.heatmapIndicatorWidth + b.maxLevLen)
			}
		} else {
			return 0
		}
	};
	this.getHeatmapIndicatorHeight = function(b) {
		if (this.showHeatmapIndicator) {
			var c = (this.margin * 2) + this.legendFontSize;
			if (b && this.isMultidimensionalData && this.heatmapIndicatorPosition == "bottom") {
				return this.legendInside ? 0 : this.heatmapIndicatorHeight + (this.xAxisTitle ? (this.margin * 2) : 0) + c
			} else {
				return this.heatmapIndicatorHeight + (this.margin * 2) + c
			}
		} else {
			return 0
		}
	};
	this.getLegendHeight = function() {
		var c = 0;
		var b = this.showLegend && this.legendPosition == "bottom" && !this.legendInside;
		var d = (this.showVarOverlaysLegend || this.showSmpOverlaysLegend) && this.overlaysLegendPosition.match(/bottom/i);
		if (this.graphType == "Heatmap" && !this.isMultidimensionalData && !(this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)) {
			if (b) {
				c += this.legendHeight
			}
			if (d) {
				c += this.legendOverlaysHeight
			}
		} else {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap|Stacked|ParallelCoordinates|Line|Sankey|Tree/))) {
				if (b) {
					c += this.legendHeight
				}
				if (d) {
					c += this.legendOverlaysHeight
				}
			} else {
				if (this.graphType == "Treemap") {} else {
					if (b) {
						c += this.legendVariableHeight + this.margin
					}
					if (d) {
						c += this.legendOverlaysHeight
					}
				}
			}
		}
		return c
	};
	this.getLegendWidth = function() {
		var c = 0;
		var b = this.showLegend && this.legendPosition == "right" && !this.legendInside;
		var d = (this.showVarOverlaysLegend || this.showSmpOverlaysLegend) && this.overlaysLegendPosition.match(/right/i);
		if (this.graphType == "Heatmap" && !this.isMultidimensionalData && !(this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)) {
			if (b) {
				c += this.legendWidth
			}
			if (d) {
				c += this.legendOverlaysWidth
			}
		} else {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap|Stacked|ParallelCoordinates|Line|Sankey|Tree/))) {
				if (b) {
					c += this.legendWidth
				}
				if (d) {
					c += this.legendOverlaysWidth
				}
			} else {
				if (this.graphType == "Treemap") {} else {
					if (b) {
						c += this.legendVariableWidth + this.margin
					}
					if (d) {
						c += this.legendOverlaysWidth
					}
				}
			}
		}
		return c
	};
	this.getVarTreeHeight = function() {
		var b = 0;
		if (this.graphType == "Heatmap" && this.showVarDendrogram && this.varDendrogram) {
			b = this.dendrogramHeight + this.margin
		}
		return b
	};
	this.getSmpTreeWidthHeight = function() {
		var b = 0;
		if (this.showSmpDendrogram && this.smpDendrogram && !this.isGroupedData && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			b = this.dendrogramHeight + this.margin
		}
		return b
	};
	this.getOverlaysTickLabelsLength = function() {
		var d = 0;
		if (this.smpOverlays.length > 0) {
			var b = this.meta.data.x;
			var c = [];
			for (var f = 0; f < this.smpOverlays.length; f++) {
				var h = this.smpOverlays[f];
				if (h != "-") {
					var g = this.smpOverlayProperties[h].position;
					var e = this.smpOverlayProperties[h].type;
					if (g.match(/left|right/i) && !e.match(/text|default|increase|decrease/i)) {
						c.push(b[h].min);
						c.push(b[h].max)
					}
				}
			}
			d = this.measureText(this.getMaxText(c), this.overlayFont)
		}
		return d ? d + (this.margin * 2) : 0
	};
	this.getTreeRootLabelLength = function() {
		return this.measureText(this.hierarchy[0], this.smpLabelFont)
	};
	this.set1DXYDimensionsLeft = function() {
		var b = 0;
		if (this.graphOrientation == "vertical") {
			b = this.layoutValid && !this.layoutAdjust && !this.isShowDOEData ? this.margin * (this.layoutCollapse ? 0 : 1) : this.margin + this.getAxisTitleTickLength()
		} else {
			b = this.margin + this.getSampleTitleHeight() + (this.graphType == "Tree" ? this.treeNodeSize + this.getTreeRootLabelLength() : this.getSampleLabelLength()) + this.smpOverlaysThicknessLeft;
			if (this.smpDendrogramPosition != "right") {
				b += this.getSmpTreeWidthHeight()
			}
		}
		this.left = b
	};
	this.set1DXYDimensionsRight = function() {
		var b = 0;
		if (this.graphOrientation == "vertical") {
			b = this.layoutValid && !this.layoutAdjust && !this.isShowDOEData ? this.margin * (this.layoutCollapse ? 0 : 1) : this.margin + this.getAxisTitleTickLength(true)
		} else {
			b = this.margin + this.smpOverlaysThicknessRight + (this.graphType == "Tree" ? this.getSampleLabelLength() + this.treeNodeSize : 0);
			if (this.smpDendrogramPosition == "right") {
				b += this.getSmpTreeWidthHeight() + this.margin
			}
			if (this.layoutValid && this.layoutCollapse) {
				b -= this.margin
			}
		}
		b += this.getLegendWidth();
		if (this.graphType == "Heatmap") {
			var e = this.getSampleLabelDescLength();
			var c = 0;
			if (this.showOverlays) {
				c = this.varOverlaysStrLength
			}
			c = Math.max(e, c);
			e = this.margin + this.smpOverlaysThicknessRight;
			if (this.smpDendrogramPosition == "right") {
				e = this.getSmpTreeWidthHeight()
			}
			if (c > e) {
				b += c - e
			}
			if (this.heatmapIndicatorPosition == "right") {
				b += this.getHeatmapIndicatorWidth()
			}
		}
		this.right = b
	};
	this.set1DXYDimensionsTop = function() {
		var g = this.getOverlaysTickLabelsLength();
		var c = this.margin + this.getTitleSubtitleHeight();
		if (this.layoutValid) {
			c += ((this.getFontHeight() + (this.margin * 2)) * (this.segregateVariablesBy.length + this.segregateSamplesBy.length)) - this.margin
		}
		if (this.graphOrientation == "vertical") {
			c += this.smpOverlaysThicknessTop;
			if (this.smpDendrogramPosition != "bottom") {
				c += this.getSmpTreeWidthHeight()
			}
			c += this.graphType == "Tree" ? this.smpLabelFontSize + this.treeNodeSize : 0
		} else {
			if (this.graphType == "Heatmap") {
				var b = 0;
				var e = this.layoutValid ? this.margin : this.getHeatmapIndicatorHeight();
				var f = e;
				b += this.varOverlaysThicknessTop;
				if (this.varDendrogramPosition != "bottom") {
					b += this.getVarTreeHeight()
				}
				if (this.varTitleLabelOverlayPosition != "bottom") {
					b += this.getVariableTitleHeight();
					b += this.getVariableLabelLength()
				} else {
					b += this.getVariableLabelDescLength()
				}
				if (!this.isOncoprint) {
					if (this.heatmapIndicatorPosition == "right") {} else {
						if (this.heatmapIndicatorPosition == "top") {
							b += e
						} else {
							if (this.heatmapIndicatorPosition == "topLeft") {
								if (this.left > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									f = e - b;
									b = Math.max(b, e)
								} else {
									this.heatmapIndicatorY = b;
									b += e
								}
							} else {
								if (this.right > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									f = e - b;
									b = Math.max(b, e)
								} else {
									b += e
								}
							}
						}
					}
				}
				c += b;
				this.heatmapIndicatorY = c + this.margin - f
			} else {
				c += this.getAxisTitleTickLength()
			}
		}
		this.top = Math.max(c, g)
	};
	this.set1DXYDimensionsBottom = function() {
		var c = this.margin;
		if (this.graphOrientation == "vertical") {
			c += this.getSampleTitleHeight() + this.getSampleLabelLength() + this.smpOverlaysThicknessBottom;
			c += this.graphType == "Tree" ? this.getSampleLabelLength() : 0;
			if (this.smpDendrogramPosition == "bottom") {
				c += this.getSmpTreeWidthHeight()
			}
			c += this.getLegendHeight();
			if (this.layoutValid && this.layoutCollapse) {
				c -= this.margin
			}
		} else {
			if (this.graphType == "Heatmap") {
				c += this.varOverlaysThicknessBottom;
				if (this.varTitleLabelOverlayPosition == "bottom") {
					c += this.getVariableLabelLength();
					c += this.getVariableTitleHeight()
				} else {
					c += Math.max(this.getVariableLabelDescLength(), this.smpOverlaysStrLength)
				}
				if (this.varDendrogramPosition == "bottom") {
					c += this.getVarTreeHeight()
				}
				if (this.isOncoprint) {
					c += this.legendOncoprintHeight
				}
				if (!this.legendInside && this.legendPosition == "bottom") {
					c += this.legendHeight
				}
				if (this.overlaysLegendPosition.match(/bottom/i)) {
					c += this.legendOverlaysHeight
				}
			} else {
				c += this.getAxisTitleTickLength(true) + this.getLegendHeight();
				if (this.layoutValid && this.layoutCollapse) {
					c -= this.margin
				}
			}
		}
		this.bottom = c
	};
	this.adjustLegendFontSize = function() {
		var b = this.meta.config.orig;
		if (!b.legendFontSize && this.adjustAspectRatio) {
			b.legendFontSize = this.legendFontSize
		}
		if (this.legendFontSize > 3) {
			this.legendFontSize -= 2
		}
	};
	this.adjustSmpFontSize = function() {
		if (this.adjustAspectRatio) {
			var c = this.meta.config.orig;
			this.smpLabelFontSize = parseInt(this.smpLabelFontSize * 0.8);
			var b = Math.min(Math.max(parseInt(this.smpLabelFontSize * this.smpLabelScaleFontFactor), this.minTextSize), this.maxTextSize);
			if (this.smpLabelFontSize < this.minTextSize) {
				if (this.graphType == "Heatmap") {
					if (this.rowBlockSize && b > this.rowBlockSize) {
						if (!c.showSampleNames) {
							c.showSampleNames = this.showSampleNames;
							this.showSampleNames = false
						}
					}
				} else {
					if (!c.showSampleNames) {
						c.showSampleNames = this.showSampleNames;
						this.showSampleNames = false
					}
				}
			}
			this.smpLabelFont = this.smpLabelFontStyle + " " + b + "px " + this.fontName
		}
	};
	this.adjustVarFontSize = function() {
		if (this.adjustAspectRatio) {
			var b = this.meta.config.orig;
			this.varLabelFontSize = parseInt(this.varLabelFontSize * 0.8);
			if (this.varLabelFontSize < this.minTextSize) {
				if (!b.showVariableNames) {
					b.showVariableNames = this.showVariableNames;
					this.showVariableNames = false
				}
			}
			this.varLabelFont = this.varLabelFontStyle + " " + Math.min(Math.max(parseInt(this.varLabelFontSize * this.varLabelScaleFontFactor), this.minTextSize), this.maxTextSize) + "px " + this.fontName
		}
	};
	this.adjust1DYDimension = function() {
		var b = this.layoutComb ? this.layoutHeight * this.percentAspectRatioPlotArea : this.height * this.percentAspectRatioPlotArea;
		var c = this.meta.config.orig;
		while (this.adjustAspectRatioYTries <= this.adjustAspectRatioMax && this.y < b) {
			this.adjustLegendFontSize();
			this.setLegends();
			this.adjustVarFontSize();
			if (this.graphType != "Heatmap") {
				this.adjustSmpFontSize()
			}
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
			if (this.adjustAspectRatioYTries == this.adjustAspectRatioMax && this.y < b) {
				if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
					c.showLegend = this.showLegend;
					this.showLegend = false;
					this.set1DFont()
				}
				if (this.varLabelDescription) {
					c.varLabelDescription = this.varLabelDescription;
					this.varLabelDescription = false;
					this.set1DFont()
				}
				this.set1DXYDimensionsTop();
				this.set1DXYDimensionsBottom();
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
				}
			}
			this.adjustAspectRatioYTries++
		}
	};
	this.adjust1DXDimension = function() {
		var b = this.layoutComb ? this.layoutWidth * this.percentAspectRatioPlotArea : this.width * this.percentAspectRatioPlotArea;
		var c = this.meta.config.orig;
		while (this.adjustAspectRatioXTries <= this.adjustAspectRatioMax && this.x < b) {
			this.adjustLegendFontSize();
			this.setLegends();
			if (this.graphType != "Heatmap") {
				this.adjustVarFontSize()
			}
			this.adjustSmpFontSize();
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
			if (this.adjustAspectRatioXTries == this.adjustAspectRatioMax && this.x < b) {
				if (this.showLegend && this.legendPosition != "bottom" && !this.legendInside) {
					c.showLegend = this.showLegend;
					this.showLegend = false;
					this.set1DFont()
				}
				if (this.smpLabelDescription) {
					c.smpLabelDescription = this.smpLabelDescription;
					this.smpLabelDescription = false;
					this.set1DFont()
				}
				this.set1DXYDimensionsLeft();
				this.set1DXYDimensionsRight();
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < b) {
					this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
				}
			}
			this.adjustAspectRatioXTries++
		}
	};
	this.set1DXYDimensions = function() {
		var c = this.layoutComb ? this.layoutWidth * this.percentAspectRatioPlotArea : this.width * this.percentAspectRatioPlotArea;
		var b = this.layoutComb ? this.layoutHeight * this.percentAspectRatioPlotArea : this.height * this.percentAspectRatioPlotArea;
		if (this.isGraphTime) {
			if (!this.showVolume || (this.layoutComb && this.layoutCurrent == 0)) {
				this.setTimeAxis()
			}
		}
		this.setLegends();
		this.setRowColBlocks();
		this.set1DFont();
		if (this.graphOrientation == "vertical") {
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			if (this.adjustAspectRatio) {
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.adjust1DYDimension()
				}
			}
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			if (this.adjustAspectRatio) {
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < c) {
					this.adjust1DXDimension()
				}
			}
		} else {
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			if (this.adjustAspectRatio) {
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < c) {
					this.adjust1DXDimension()
				}
			}
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			if (this.adjustAspectRatio) {
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.adjust1DYDimension()
				}
			}
		}
	};
	this.set1DPrivateParamsOncoprint = function() {
		var i = this.adjustAspectRatio ? this.x / this.varIndices.length : 10;
		var f = i * 3;
		var b = i * this.colBlocks;
		var g = f * this.rowBlocks;
		var d = this.marginLeft + this.left + b + this.right + this.marginRight;
		var e = this.marginTop + this.top + g + this.bottom + this.marginBottom;
		if (e <= this.height) {
			this.colBlockSize = i;
			this.rowBlockSize = f;
			this.blockSeparation = this.rowBlockSize
		} else {
			this.rowBlockSize = this.y / this.rowBlocks;
			this.blockSeparation = this.rowBlockSize;
			this.colBlockSize = this.rowBlockSize / 3
		}
		this.y = this.rowBlockSize * this.rowBlocks;
		this.x = this.colBlockSize * this.colBlocks;
		d = this.marginLeft + ((this.left + this.x + this.right) * this.layoutCols) + this.marginRight;
		e = this.marginTop + ((this.top + this.y + this.bottom) * this.layoutRows) + this.marginBottom;
		this.width = Math.max(d, this.width);
		this.height = Math.max(e, this.height);
		this.resizeCanvas()
	};
	this.set1DPrivateParamsManual = function() {
		var b = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		this.rowBlockSize = this.widthFactor * (this.scaleTextToSize(this.rowBlocks) + this.scaleTextConstantAdd);
		if (this.graphType == "Heatmap") {
			if (this.colBlocks < 20) {
				this.colBlockSize = this.scaleTextToSize(this.colBlocks) + (this.scaleTextConstantAdd * 4)
			} else {
				this.colBlockSize = (parseInt(1 / Math.sqrt(this.colBlocks) * this.scaleTextConstantMult)) + 1
			}
			this.colBlockSize *= this.widthFactor;
			this.blockSeparation = this.rowBlockSize / 2;
			this.y = this.rowBlockSize * this.rowBlocks;
			this.x = this.colBlockSize * this.colBlocks
		} else {
			this.blockSeparation = this.rowBlockSize * this.sampleSeparationFactor;
			if (this.graphOrientation == "vertical") {
				if (this.graphType.match(/Area|ParallelCoordinates/)) {
					this.x = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (b - 1))
				} else {
					if (this.plotByVariable) {
						this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.variableBlock) + this.blockSeparation
					} else {
						this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * b) + this.blockSeparation
					}
				}
				this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
			} else {
				if (this.graphType.match(/Area|ParallelCoordinates/)) {
					this.y = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (b - 1))
				} else {
					if (this.plotByVariable) {
						this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.varIndices.length) + this.blockSeparation
					} else {
						this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * b) + this.blockSeparation
					}
				}
				this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
			}
			this.colBlockSize = 1
		}
		this.width = this.marginLeft + ((this.left + this.x + this.right) * this.layoutCols) + this.marginRight;
		this.height = this.marginTop + ((this.top + this.y + this.bottom) * this.layoutRows) + this.marginBottom;
		this.resizeCanvas()
	};
	this.set1DPrivateParamsAuto = function() {
		var d = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		if (this.graphType == "Heatmap") {
			this.rowBlockSize = this.y / this.rowBlocks;
			this.blockSeparation = this.rowBlockSize;
			this.colBlockSize = this.x / this.varIndices.length
		} else {
			if (this.graphType.match(/Area|ParallelCoordinates/)) {
				this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + d - 2) : this.y / (this.rowBlocks + d - 2)
			} else {
				if (this.plotByVariable) {
					this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + this.varIndices.length) : this.y / (this.rowBlocks + this.varIndices.length)
				} else {
					this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + d) : this.y / (this.rowBlocks + d)
				}
			}
			var c = this.widthFactor + this.sampleSeparationFactor;
			var b = this.graphType.match(/Stacked/) ? 1 : this.varIndices.length;
			if (this.widthFactor > this.sampleSeparationFactor) {
				this.blockSeparation = this.rowBlockSize * (this.sampleSeparationFactor / c);
				this.rowBlockSize *= 1 + (this.widthFactor / (c * b))
			} else {
				if (this.sampleSeparationFactor > this.widthFactor) {
					this.blockSeparation = this.rowBlockSize * (1 + (this.sampleSeparationFactor / c));
					this.rowBlockSize -= ((this.blockSeparation - this.rowBlockSize) / b)
				} else {
					this.blockSeparation = this.rowBlockSize
				}
			}
			this.colBlockSize = 1
		}
	};
	this.set1DPrivateParams = function() {
		var b = 100;
		if (this.isOncoprint) {
			this.set1DPrivateParamsOncoprint()
		} else {
			if (!this.adjustAspectRatio) {
				this.set1DPrivateParamsManual()
			} else {
				this.set1DPrivateParamsAuto()
			}
		}
		this.rowBlockSize = Math.max(1, Math.floor(this.rowBlockSize * b)) / b;
		this.colBlockSize = Math.max(1, Math.floor(this.colBlockSize * b)) / b;
		this.blockSeparation = Math.floor(this.blockSeparation * b) / b
	};
	this.get1DMinFloorValue = function() {
		if (this.xAxisTransform && this.xAxisTransform == "floor") {
			return this.xAxisTransformFloorValue
		} else {
			return this.minData
		}
	};
	this.get1DMaxCeilValue = function() {
		if (this.xAxisTransform && this.xAxisTransform == "ceil") {
			return this.xAxisTransformCeilValue
		} else {
			return this.maxData
		}
	};
	this.getTreemapOverlay = function(i, j, c, f, b, e) {
		var g = [];
		for (var d in i) {
			g.push({
				area: i[d],
				index: -1,
				label: d,
				color: j.type == "Numeric" ? this.getColorForValue(j.colorBrew, i[d]) : j.colors[j.order[d]]
			})
		}
		return this.processTreemap(g, {
			width: c,
			height: f,
			left: b,
			top: e
		})
	};
	this.getTreemapVariable = function(f, h) {
		var l = this;
		var n = function(z, r, v, u) {
			if (z.length > 1) {
				if (r + 1 < l.treemapBy.length) {
					r++;
					b = l.getSampleLevelsByAnnotation(l.treemapBy[r], z);
					for (var w = 0; w < b.length; w++) {
						p = w;
						var A = l.getSamplesByAnnotationLevel(l.treemapBy[r], b[p], z);
						var s = n(A, r, v, []);
						v += s[1];
						u.push({
							area: v,
							index: -1,
							label: b[p],
							outline: 2,
							children: s[0]
						})
					}
				} else {
					for (var w = 0; w < z.length; w++) {
						var x = z[w];
						var t = l.getDataAtPos(f, x, "sum", l.xAxisTransform, l.get1DMinFloorValue(), l.get1DMaxCeilValue());
						var y = l.data.y.smps[x];
						v += t;
						u.push({
							area: t,
							color: l.getPropertyValue(f, x, "colorBy"),
							pattern: l.getPropertyValue(f, x, "patternBy"),
							label: y,
							index: [f, x]
						})
					}
				}
			} else {
				var x = z[0];
				var t = l.getDataAtPos(f, x, "sum", l.xAxisTransform, l.get1DMinFloorValue(), l.get1DMaxCeilValue());
				v = t;
				u.push({
					area: t,
					color: l.getPropertyValue(f, x, "colorBy"),
					pattern: l.getPropertyValue(f, x, "patternBy"),
					label: l.data.y.smps[x],
					index: [f, x]
				})
			}
			return [u, v]
		};
		var j = [];
		var c, p, b;
		this.isGroupedData = false;
		var q = this.groupingFactors;
		this.groupingFactors = [];
		var m = this.getSampleLevelsByAnnotation(this.treemapBy[0], h);
		var e = 0;
		for (var g = 0; g < m.length; g++) {
			c = 0;
			p = g;
			var k = l.getSamplesByAnnotationLevel(l.treemapBy[c], m[p], h);
			var d = n(k, c, e, []);
			j.push({
				area: d[1],
				index: -1,
				label: l.treemapBy[c] + ":" + m[g],
				children: d[0]
			})
		}
		this.isGroupedData = true;
		this.groupingFactors = q;
		return j
	};
	this.getTreemap = function() {
		var m = this;
		var r = function() {
			var j = [];
			if (s) {
				for (var n = 0; n < m.data.w.grps[p].length; n++) {
					var k = m.data.w.grps[p][n];
					var t = m.getDataAtPos(f, k);
					j.push({
						area: t,
						label: m.data.y.smps[k],
						color: m.colorBy ? m.getPropertyValue(f, k, "colorBy") : m.colors[k % m.colors.length],
						index: [f, k]
					})
				}
			} else {
				for (var n = 0; n < m.smpIndices.length; n++) {
					var k = m.smpIndices[n];
					var t = m.getDataAtPos(f, k);
					j.push({
						area: t,
						label: m.data.y.smps[k],
						color: m.colorBy ? m.getPropertyValue(f, k, "colorBy") : m.colors[k % m.colors.length],
						index: [f, k]
					})
				}
			}
			return j
		};
		var l = [];
		var o = [];
		var f, p;
		var s = this.isGroupedData && this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		this.isGroupedData = false;
		for (var h = 0; h < this.varIndices.length; h++) {
			f = this.varIndices[h];
			if (s) {
				for (var e = 0; e < this.data.w.grps.length; e++) {
					var q = 0;
					for (var c = 0; c < this.data.w.grps[e].length; c++) {
						var g = this.data.w.grps[e][c];
						q += this.getDataAtPos(f, g)
					}
					o.push(q)
				}
			} else {
				var q = 0;
				for (var e = 0; e < this.smpIndices.length; e++) {
					var g = this.smpIndices[h];
					q += this.getDataAtPos(f, g)
				}
				o.push(q)
			}
		}
		for (var h = 0; h < this.varIndices.length; h++) {
			f = this.varIndices[h];
			if (s) {
				var b = 0;
				for (var e = 0; e < this.data.w.grps.length; e++) {
					p = e;
					l.push({
						area: o[b++],
						title: this.varIndices.length > 1 ? this.data.y.vars[f] + ":" + this.data.w.smps[e] : this.data.w.smps[e],
						index: -1,
						children: r()
					})
				}
			} else {
				l.push({
					area: o[h],
					title: this.data.y.vars[f],
					index: -1,
					children: r()
				})
			}
		}
		if (s) {
			this.isGroupedData = true
		}
		if (this.isDOE) {
			return this.processTreemap(l, {
				width: this.x - 20,
				height: this.y - 20,
				left: 10,
				top: 10
			})
		} else {
			return this.processTreemap(l, {
				width: this.x,
				height: this.y,
				left: 0,
				top: 0
			})
		}
	};
	this.set1DXAxis = function() {
		if (this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		} else {
			if (this.graphType == "ParallelCoordinates") {
				var d = this.graphOrientation == "vertical" ? this.y - 0.5 : this.x - 0.5;
				var f = this.get1DIndices();
				for (var c = 0; c < f.length; c++) {
					var b = this.parallelCoordinates[c];
					b.units = d / (b.max - b.min)
				}
			} else {
				var d = this.graphOrientation == "vertical" ? "y" : "x";
				var e = ["BarLine", "DotLine", "AreaLine", "StackedLine", "StackedPercentLine"];
				this.setAxisUnits("xAxis", d);
				if (this.isInArray(this.graphType, e) || (this.graphType == "Candlestick" && this.showVolume)) {
					this.setAxisUnits("xAxis2", d)
				}
			}
		}
	};
	this.draw1DWireFrame = function() {
		this.functionCaller = "draw1DWireFrame";
		var E, h, D, g, C, f, B, c, u, k, p, A, y, d;
		var m = this.get1DIndices();
		var F = this.xAxisTickStyle == "dotted" || this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
		var v = this.guides == "dotted" ? "dottedLine" : "line";
		var q = !this.adjustAspectRatio ? this.rowBlockSize * 0.3 : 0;
		var w = this.get1DLeft();
		var s = this.get1DTop();
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		}
		this.addToRender(["disableGradientTransparencyShadow"]);
		if (this.graphType == "Heatmap") {
			if (this.guides && this.isMultidimensionalData && !this.isGraphTime) {
				E = w;
				D = w + this.x;
				h = s + (this.blockSeparation / 2);
				g = s + this.y;
				for (var z = 0; z < m.length; z++) {
					var o = z / this.smpLabelInterval;
					if (parseInt(o) == parseFloat(o)) {
						this.addToRender(["drawLine", v, E, h, D, h, this.guidesColor, this.guidesWidth, "butt"], false, false, null, false, g)
					}
					h += this.rowBlockSize
				}
				E = w + (this.colBlockSize / 2);
				h = s;
				g = s + this.y;
				for (var z = 0; z < this.varIndices.length; z++) {
					var o = z / this.varLabelInterval;
					if (parseInt(o) == parseFloat(o)) {
						this.addToRender(["drawLine", v, E, h, E, g, this.guidesColor, this.guidesWidth, "butt"], false, false, null, false, w)
					}
					E += this.colBlockSize
				}
			}
		} else {
			if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
				var e = this.getVariablesVisibleByAxis("xAxis");
				A = e.length
			} else {
				if (this.graphType.match(/Stacked|Line|Area|ParallelCoordinates/)) {
					A = 1
				} else {
					A = this.varIndices.length
				}
			}
			p = A * this.rowBlockSize;
			y = (this.blockSeparation + p) / 2;
			if (this.graphOrientation == "vertical") {
				if (this.graphType == "ParallelCoordinates") {
					E = w;
					D = w;
					h = s;
					g = this.y;
					for (var z = 0; z < m.length; z++) {
						this.addToRender(["drawLine", "line", E, h, E, h + g, this.xAxisTickColor]);
						var b = this.parallelCoordinates[z];
						this.addToRender(["drawLine", "line", E - this.margin, h, E, h, this.xAxisTickColor]);
						this.addToRender(["drawLine", "line", E - this.margin, h + g, E, h + g, this.xAxisTickColor]);
						for (var x = 0; x < b.vals.length; x++) {
							f = h + g - ((b.vals[x] - b.min) * b.units);
							this.addToRender(["drawLine", "line", E - this.margin, f, E, f, this.xAxisTickColor]);
							this.addToRender(["drawText", b.vals[x], E - (this.margin * 2), f, this.axisTickFont, this.axisTickColor, "right", "middle"])
						}
						E += this.blockSeparation + p
					}
				} else {
					if (this.isGraphTime) {
						var n = this.x / m.length;
						var r = this.graphType.match(/Area/) ? 0 : w + ((this.blockSeparation + p) / 2);
						h = s;
						g = s + this.y;
						for (var z = 0; z < this.timeValueIndices.length; z++) {
							E = (this.timeValueIndices[z] * n) + r;
							if (this.guides) {
								this.addToRender(["drawLine", v, E, h, E, g, this.guidesColor, this.guidesWidth, "butt"], false, false, null, false, g)
							}
						}
					} else {
						if (!this.plotByVariable) {
							E = this.graphType.match(/Area/) ? w : w + this.blockSeparation + p;
							D = w;
							C = w + this.blockSeparation + p;
							h = s;
							g = this.y;
							for (var z = 0; z < m.length; z++) {
								if (this.blockContrast) {
									k = z % 2 ? this.evenColor : this.oddColor;
									this.addToRender(["drawShape", "rectangle", D + (C / 2), h + (g / 2), C, g, k, k]);
									D = C;
									C = D + this.blockSeparation + p
								}
								if (this.guides) {
									if (this.graphType.match(/Area/) && (z == 0 || z == m.length - 1)) {
										E += this.blockSeparation + p;
										continue
									}
									this.addToRender(["drawLine", v, E - y, h, E - y, h + g, this.guidesColor, this.guidesWidth, "butt"])
								}
								E += this.blockSeparation + p
							}
						}
					}
					d = this.xAxisMin < 0 ? s + this.y - ((0 - this.xAxisMin) * this.xAxisUnit) : s + this.y;
					if (this.xAxisMinorTicks && this.summaryType != "volume") {
						for (var z = 0; z < this.xAxisMinorValues.length; z++) {
							var G = this.xAxisMinorValues[z];
							if (G >= this.xAxisMin && G <= this.xAxisMax) {
								h = this.get1DTop() + this.y - ((G - this.xAxisMin) * this.xAxisUnit);
								this.addToRender(["drawLine", F, w, h, w + this.x, h, this.xAxisTickColor, this.outlineWidth / 3, "butt"], false, false, null, false, d)
							}
						}
					}
					E = this.get1DLeft() - (this.margin * 2);
					D = w;
					C = w + this.x;
					for (var z = 0; z < this.xAxisValuesRaw.length; z++) {
						var G = this.xAxisValuesRaw[z];
						if (G >= this.xAxisMin && G <= this.xAxisMax) {
							h = this.get1DTop() + this.y - ((G - this.xAxisMin) * this.xAxisUnit);
							if (this.xAxisMajorTicks) {
								this.addToRender(["drawLine", F, D, h, C, h, this.xAxisTickColor, false, "butt"], false, false, null, false, d)
							}
							if (this.xAxisShow || this.xAxisShowLayout) {
								this.addToRender(["drawLine", F, D - this.margin, h, D, h, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
							}
							if (this.xAxis2Show || this.xAxis2ShowLayout) {
								this.addToRender(["drawLine", F, C, h, C + this.margin, h, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
							}
						}
					}
				}
			} else {
				if (this.graphType == "ParallelCoordinates") {
					E = w;
					D = this.x;
					h = s;
					g = s;
					f = s + this.blockSeparation + p;
					for (var z = 0; z < m.length; z++) {
						this.addToRender(["drawLine", "line", E, h, w + D, h, this.xAxisTickColor]);
						var b = this.parallelCoordinates[z];
						this.addToRender(["drawLine", "line", E, h - this.margin, E, h, this.xAxisTickColor]);
						this.addToRender(["drawLine", "line", w + D, h - this.margin, w + D, h, this.xAxisTickColor]);
						for (var x = 0; x < b.vals.length; x++) {
							C = E + ((b.vals[x] - b.min) * b.units);
							this.addToRender(["drawLine", "line", C, h - this.margin, C, h, this.xAxisColor]);
							this.addToRender(["drawText", b.vals[x], C, h - (this.margin * 2), this.axisTickFont, this.axisTickColor, "center", "bottom"])
						}
						h += this.blockSeparation + p
					}
				} else {
					if (this.isGraphTime) {
						var n = this.y / m.length;
						var r = this.graphType.match(/Area/) ? 0 : s + ((this.blockSeparation + p) / 2);
						E = w;
						D = this.x;
						for (var z = 0; z < this.timeValueIndices.length; z++) {
							h = (this.timeValueIndices[z] * n) + r;
							if (this.guides) {
								this.addToRender(["drawLine", v, E, h, D, h, this.guidesColor, this.guidesWidth, "butt"], false, false, null, false, w)
							}
						}
					} else {
						if (!this.plotByVariable) {
							E = w;
							D = this.x;
							h = this.graphType.match(/Area/) ? s : s + this.blockSeparation + p;
							g = s;
							f = s + this.blockSeparation + p;
							for (var z = 0; z < m.length; z++) {
								if (this.blockContrast) {
									c = z == 0 || z == m.length - 1 ? (this.blockSeparation * 1.5) + p : this.blockSeparation + p;
									k = z % 2 ? this.evenColor : this.oddColor;
									this.addToRender(["drawShape", "rectangle", E + (D / 2), g + (c / 2), D, c, k, k]);
									g = f;
									f = g + this.blockSeparation + p
								}
								if (this.guides) {
									if (this.graphType.match(/Area/) && (z == 0 || z == m.length - 1)) {
										h += this.blockSeparation + p;
										continue
									}
									this.addToRender(["drawLine", v, E, h - y, w + D, h - y, this.guidesColor, this.guidesWidth, "butt"])
								}
								h += this.blockSeparation + p
							}
						}
					}
				}
				d = this.xAxisMin < 0 ? w + this.x - ((0 - this.xAxisMin) * this.xAxisUnit) : w;
				if (this.xAxisMinorTicks && this.summaryType != "volume") {
					for (var z = 0; z < this.xAxisMinorValues.length; z++) {
						var G = this.xAxisMinorValues[z];
						if (G >= this.xAxisMin && G <= this.xAxisMax) {
							E = this.graphInverted ? w + this.x - ((G - this.xAxisMin) * this.xAxisUnit) : w + ((G - this.xAxisMin) * this.xAxisUnit);
							this.addToRender(["drawLine", F, E, s, E, s + this.y, this.xAxisTickColor, this.outlineWidth / 3, "butt"], false, false, null, false, d)
						}
					}
				}
				h = this.get1DTop() - ((this.margin * 2) + (this.axisTickFontSize / 2));
				g = s;
				f = s + this.y;
				u = (this.segregateVariablesBy.length + this.segregateSamplesBy.length) * (this.getFontHeight() + (this.margin * 2));
				c = g - (u + this.margin);
				for (var z = 0; z < this.xAxisValuesRaw.length; z++) {
					var G = this.xAxisValuesRaw[z];
					if (G >= this.xAxisMin && G <= this.xAxisMax) {
						E = this.graphInverted ? w + this.x - ((G - this.xAxisMin) * this.xAxisUnit) : w + ((G - this.xAxisMin) * this.xAxisUnit);
						if (this.xAxisMajorTicks) {
							this.addToRender(["drawLine", F, E, g, E, f, this.xAxisTickColor, false, "butt"], false, false, null, false, w)
						}
						if (this.xAxisShow || this.xAxisShowLayout) {
							if (this.layoutValid) {
								if (this.layoutAdjust) {
									this.addToRender(["drawLine", F, E, g - this.margin, E, g, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
								} else {
									this.addToRender(["drawLine", F, E, c, E, c + this.margin, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
								}
							} else {
								this.addToRender(["drawLine", F, E, g - this.margin, E, g, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
							}
						}
						if (this.xAxis2Show || this.xAxis2ShowLayout) {
							this.addToRender(["drawLine", F, E, f, E, f + this.margin, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt"], false, false, null, false, d)
						}
					}
				}
			}
		}
		this.addToRender(["enableGradientTransparencyShadow"])
	};
	this.drawDendrograms = function() {
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		} else {
			if (!this.isGroupedData) {
				if (this.showSmpDendrogram) {
					this.drawDendrogram("smpDendrogram")
				}
				if (this.graphType == "Heatmap" && this.showVarDendrogram) {
					this.drawDendrogram("varDendrogram")
				}
			}
		}
	};
	this.getDendrogramClipArea = function(d) {
		var b = this.get1DLeft();
		var c = this.get1DTop();
		if (d == "varDendrogram") {
			if (this.varDendrogramPosition == "bottom") {
				return [b, c + this.y, b + this.x + 1, c + this.y + this.bottom]
			} else {
				return [b, this.marginTop + this.offsetY, b + this.x + 1, c]
			}
		} else {
			if (this.graphOrientation == "vertical") {
				if (this.smpDendrogramPosition == "bottom") {
					return [b, c + this.y, b + this.x + 1, c + this.y + this.bottom]
				} else {
					return [b, this.marginTop + this.offsetY, b + this.x + 1, c]
				}
			} else {
				if (this.smpDendrogramPosition == "right") {
					return [b + this.x, c, b + this.x + this.right, c + this.y + 1]
				} else {
					return [this.marginLeft + this.offsetX, c, b, c + this.y + 1]
				}
			}
		}
	};
	this.getDendrogramBlockSize = function(c) {
		if (this.graphType != "Heatmap") {
			var b;
			if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
				var c = this.getVariablesVisibleByAxis("xAxis");
				b = c.length
			} else {
				if (this.graphType.match(/Stacked|Line|Area/)) {
					b = 1
				} else {
					b = this.varIndices.length
				}
			}
			return (b * this.rowBlockSize) + this.blockSeparation
		} else {
			return c == "varDendrogram" ? this.colBlockSize : this.rowBlockSize
		}
	};
	this.getDendrogramTopOffset = function(f) {
		var e = this.get1DTop();
		var c = f == "varDendrogram" ? "showVarDendrogram" : "showSmpDendrogram";
		var g = 0;
		var d = this.getDendrogramBlockSize(f);
		var b = this.getDendrogramInverse(f);
		if (this[c] && this[f]) {
			if (f == "varDendrogram") {
				if (this.varDendrogramPosition == "bottom") {
					g = e + this.y + this.bottom - (this.dendrogramHeight + this.margin);
					if (this.varTitleLabelOverlayPosition == "bottom") {
						g -= this.getVariableTitleHeight()
					}
					if (this.isOncoprint) {
						g -= this.legendOncoprintHeight
					}
					if (!this.legendInside && this.legendPosition == "bottom") {
						g -= this.legendHeight
					}
					g = b < 0 ? g + this.dendrogramHeight : g
				} else {
					if (this.varTitleLabelOverlayPosition != "bottom") {
						g = e - (this.varOverlaysThicknessTop + this.getVariableLabelLength() + this.getVarTreeHeight())
					} else {
						g = e - (this.margin + this.varOverlaysThicknessTop + this.getVarTreeHeight() + this.getVariableLabelDescLength())
					}
				}
			} else {
				if (this.graphOrientation == "vertical") {
					if (this.smpDendrogramPosition == "bottom") {
						g = e + this.y + this.bottom - (this.getSampleTitleHeight() + this.getLegendHeight() + this.getSmpTreeWidthHeight())
					} else {
						g = e - (this.getSmpTreeWidthHeight() + this.smpOverlaysThicknessTop)
					}
					g = b < 0 ? g + this.dendrogramHeight : g
				} else {
					g = this.graphType.match(/Area/) ? e : e + (d / 2);
					if (this.smpIndicesStart > -1) {
						g -= d * this.smpIndicesStart
					}
				}
			}
		}
		return g
	};
	this.getDendrogramLeftOffset = function(f) {
		var d = this.get1DLeft();
		var c = f == "varDendrogram" ? "showVarDendrogram" : "showSmpDendrogram";
		var g = 0;
		var e = this.getDendrogramBlockSize(f);
		var b = this.getDendrogramInverse(f);
		if (this[c] && this[f]) {
			if (f == "varDendrogram") {
				g = d + (e / 2);
				if (this.varIndicesStart > -1) {
					g -= e * this.varIndicesStart
				}
			} else {
				if (this.graphOrientation == "vertical") {
					g = this.graphType.match(/Area/) ? d : d + (e / 2);
					if (this.smpIndicesStart > -1) {
						g -= e * this.smpIndicesStart
					}
				} else {
					if (this.smpDendrogramPosition == "right") {
						g = d + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin;
						g = b < 0 ? g + this.dendrogramHeight : g
					} else {
						g = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight()
					}
				}
			}
		}
		return g
	};
	this.getDendrogramInverse = function(b) {
		if (b == "varDendrogram") {
			return this.varDendrogramPosition == "top" ? 1 : -1
		} else {
			if (this.graphOrientation == "vertical") {
				if (!this.smpDendrogramPosition.match(/top|bottom/)) {
					this.smpDendrogramPosition = "top"
				}
				return this.smpDendrogramPosition == "top" ? 1 : -1
			} else {
				if (!this.smpDendrogramPosition.match(/left|right/)) {
					this.smpDendrogramPosition = "left"
				}
				return this.smpDendrogramPosition == "left" ? 1 : -1
			}
		}
	};
	this.drawDendrogram = function(g) {
		this.functionCaller = "drawDendrogram";
		if (this.graphType != "TagCloud" && this.graphType != "Sankey" && this.graphType != "Tree" && this[g]) {
			var j = this;
			var k = this[g];
			var o = this.getDendrogramBlockSize(g);
			var e = this.getDendrogramInverse(g);
			var n = this.getDendrogramClipArea(g);
			var s = this.getDendrogramTopOffset(g);
			var i = this.getDendrogramLeftOffset(g);
			var q = k.useHeight ? this.dendrogramHeight / k.height : this.dendrogramHeight / k.max;
			var m = g == "varDendrogram" || this.graphOrientation == "vertical" ? false : true;
			var f = 0;
			var p = function(d) {
				if (d.children) {
					for (var b = 0; b < d.children.length; b++) {
						p(d.children[b]);
						if (d.children[b].children) {
							d.children[b].color = d.children[b].children[0].color
						}
					}
				} else {
					if (g == "varDendrogram") {
						d.color = j.getDendrogramColor(d.name)
					} else {
						d.color = j.getDendrogramColor(false, d.name)
					}
				}
				if (d.mid != null) {
					var c;
					if (k.useHeight) {
						c = d.height ? q * (k.height - d.height) * e : j.dendrogramHeight * e
					} else {
						c = q * d.depth * e
					}
					if (m) {
						d.x = i + c;
						d.y = s + (o * d.mid)
					} else {
						d.x = i + (o * d.mid);
						d.y = s + c
					}
				}
			};
			var h = function(d) {
				if (d.children) {
					var c = d.x;
					var y = d.y;
					var u = d.color;
					for (var t = 0; t < d.children.length; t++) {
						var b = d.children[t].x;
						var w = d.children[t].y;
						var r = d.children[t].color;
						var x;
						if (j.graphOrientation == "vertical" || g == "varDendrogram") {
							x = j.addToRender(["drawLine", "line", c, y, b, y, r, false, "butt", false, false, true, n], [g + ":" + f++ + ":" + d.nodeId], false, null, false, [c, s, b, s]);
							j.addToRender(["drawLine", "line", b, y, b, w, r, false, "butt", false, false, true, n], [g + ":" + f++ + ":" + d.nodeId], false, x, false, [b, s, b, s])
						} else {
							x = j.addToRender(["drawLine", "line", c, y, c, w, r, false, "butt", false, false, true, n], [g + ":" + f++ + ":" + d.nodeId], false, null, false, [i, y, i, w]);
							j.addToRender(["drawLine", "line", c, w, b, w, r, false, "butt", false, false, true, n], [g + ":" + f++ + ":" + d.nodeId], false, null, false, [i, w, i, w])
						}
						h(d.children[t])
					}
					if (d.nodeId != null && d.children.length > 1) {
						var v = d.name ? d.name : "";
						var l = k.useHeight ? d.height : d.depth;
						j.addToRender(["drawShape", "circle", d.x, d.y, j.margin * 2, j.margin * 2, "rgba(0,0,0,0)", "rgba(0,0,0,0)"], [d.nodeId + "-" + l + "-" + g + "-" + v])
					}
				}
			};
			this.addToRender(["disableGradientTransparencyShadow"]);
			p(k);
			h(k);
			this.addToRender(["enableGradientTransparencyShadow"])
		}
	};
	this.draw1DYLayout = function() {
		this.smpInfo = [];
		this.varInfo = [];
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		} else {
			if (this.smpTitle) {
				this.draw1DYLayoutSampleTitle()
			}
			if (this.graphType == "Heatmap") {
				this.draw1DYLayoutHeatmap();
				if (this.varTitle) {
					this.draw1DYLayoutVariableTitle()
				}
			} else {
				this.draw1DYLayoutNoHeatmap()
			}
		}
	};
	this.draw1DYLayoutSampleTitle = function() {
		this.functionCaller = "draw1DYLayoutSampleTitle";
		var d, e;
		var b = this.get1DLeft() + this.margin;
		var c = this.get1DTop();
		if (this.graphOrientation == "vertical") {
			d = b + (this.x / 2);
			if (this.segregateVariablesBy.length > 0) {
				e = (c + this.y + this.bottom + this.getSampleLabelLength() + (this.margin * 2)) - (this.margin + (this.smpTitleFontSize / 2))
			} else {
				e = (c + this.y + this.bottom) - (this.margin + (this.smpTitleFontSize / 2))
			}
			e -= this.getLegendHeight();
			this.addToRender(["drawText", this.smpTitle, d, e, this.smpTitleFont, this.smpTitleFontColor, "center", "middle"])
		} else {
			if (this.segregateVariablesBy.length > 1) {
				d = this.marginLeft + this.getFontHeight() + (this.margin * 2) + (this.smpTitleFontSize / 2)
			} else {
				if (this.segregateVariablesBy.length > 0) {
					d = this.marginLeft + (this.margin * (this.segregateSamplesBy.length > 0 ? 5 : 0)) + (this.smpTitleFontSize / 2)
				} else {
					d = this.marginLeft + this.offsetX + (this.smpTitleFontSize / 2)
				}
			}
			e = c + (this.y / 2);
			this.addToRender(["drawText", this.smpTitle, d, e, this.smpTitleFont, this.smpTitleFontColor, "center", "middle", -Math.PI / 2])
		}
	};
	this.draw1DYLayoutVariableTitle = function() {
		this.functionCaller = "draw1DYLayoutVariableTitle";
		var d, e;
		var b = this.get1DLeft() + this.margin;
		var c = this.get1DTop();
		d = b + (this.x / 2);
		if (this.varTitleLabelOverlayPosition != "bottom") {
			e = this.offsetY + (this.margin * 2) + this.top;
			e -= this.getVariableLabelLength();
			e -= this.varOverlaysThicknessTop;
			if (this.varDendrogramPosition == "top") {
				e -= this.getVarTreeHeight()
			}
		} else {
			e = c + this.y + this.bottom
		}
		this.addToRender(["drawText", this.varTitle, d, e, this.varTitleFont, this.varTitleFontColor, "center", "bottom"])
	};
	this.draw1DYLayoutHeatmap = function() {
		this.functionCaller = "draw1DYLayoutHeatmap";
		var A, d, z, c;
		var u = this.get1DLeft() + this.margin;
		var q = this.get1DTop();
		var g = this.get1DIndices();
		var r = this.get1DSamples();
		var B = this.get1DLabels();
		var n = !this.adjustAspectRatio ? this.rowBlockSize * 0.3 : 0;
		if (this.showSampleNames) {
			var w = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
			if (this.isGraphTime) {
				var k = this.y / g.length;
				var v = k / 2;
				var o = q + v;
				A = u - (this.margin * 2);
				z = u + this.x + this.margin;
				c = q + this.y;
				for (var x = 0; x < this.timeValueIndices.length; x++) {
					d = (this.timeValueIndices[x] * k) + o + n;
					this.smpInfo[x] = d;
					if (this.smpLabelRotate) {
						this.addToRender(["drawText", this.timeValues[x], A - this.margin, d + n, this.smpLabelFont, f, w, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + x])
					} else {
						this.addToRender(["drawText", this.timeValues[x], A, d + n, this.smpLabelFont, f, "right", "middle"], ["Smp-" + x])
					}
					if (this.smpLabelDescription) {
						var m = this.shortenText(this.data.x[this.smpLabelDescription][g[x]], this.maxSmpStringLen);
						this.addToRender(["drawText", m, z, d + n, this.smpLabelFont, f, "right", "middle"])
					}
				}
			} else {
				A = u;
				z = u + this.x + this.margin;
				d = q + (this.blockSeparation / 2);
				c = q + this.y;
				var h = this.smpOverlaysThicknessLeft;
				for (var x = 0; x < g.length; x++) {
					var j = x / this.smpLabelInterval;
					if (parseInt(j) == parseFloat(j)) {
						var p = g[x];
						var m = this.shortenText(B ? B[p] : r[p], this.maxSmpStringLen);
						var y = (this.margin * 2) + h;
						var f = this.getSmpColor(r[p]);
						this.smpInfo[x] = d;
						if (this.smpLabelRotate) {
							this.addToRender(["drawText", m, A - (y + this.margin), d + n, this.smpLabelFont, f, w, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + p])
						} else {
							this.addToRender(["drawText", m, A - y, d + n, this.smpLabelFont, f, "right", "middle"], ["Smp-" + p])
						}
						if (this.smpLabelDescription) {
							var m = this.shortenText(this.data.x[this.smpLabelDescription][p], this.maxSmpStringLen);
							this.addToRender(["drawText", m, z, d + n, this.smpLabelFont, f, "left", "middle"])
						}
					}
					d += this.rowBlockSize
				}
			}
		}
		if (this.showVariableNames) {
			var v = this.colBlockSize / 2;
			var e = Math.abs(this.varLabelRotate) == 90 ? "center" : this.varTitleLabelOverlayPosition != "bottom" ? "left" : "right";
			var C = this.varTitleLabelOverlayPosition != "bottom" ? "left" : "right";
			var b = this.varTitleLabelOverlayPosition != "bottom" ? "right" : "left";
			u = (u - this.margin);
			d = this.varTitleLabelOverlayPosition != "bottom" ? q - (this.margin + this.varOverlaysThicknessTop) : d = q + this.y + this.margin;
			if (this.varTitleLabelOverlayPosition != "top" && this.varOverlays.length > 0 && this.showOverlays && this.graphType == "Heatmap") {
				d += this.varOverlaysThicknessBottom
			}
			c = this.varTitleLabelOverlayPosition != "bottom" ? q + this.y + this.margin : q - this.margin;
			for (var x = 0; x < this.varIndices.length; x++) {
				A = (u + (x * this.colBlockSize) + v);
				var j = x / this.varLabelInterval;
				if (parseInt(j) == parseFloat(j)) {
					var p = this.varIndices[x];
					var s = this.shortenText(this.data.y.vars[p], this.maxVarStringLen);
					var f = this.getVarColor(this.data.y.vars[p]);
					this.varInfo[x] = A;
					if (this.varLabelRotate) {
						this.addToRender(["drawText", s, A, d, this.varLabelFont, f, e, "middle", -Math.PI / 2 + (this.varLabelRotate * Math.PI / 180)], ["Var-" + p])
					} else {
						this.addToRender(["drawText", s, A, d, this.varLabelFont, f, C, "middle", -Math.PI / 2], ["Var-" + p])
					}
					if (this.varLabelDescription) {
						var s = this.shortenText(this.data.z[this.varLabelDescription][p], this.maxVarStringLen);
						this.addToRender(["drawText", s, A, c, this.varLabelFont, f, b, "middle", -Math.PI / 2])
					}
				}
			}
		}
	};
	this.draw1DYLayoutNoHeatmap = function() {
		this.functionCaller = "draw1DYLayoutNoHeatmap";
		var A, d, y, c, x, b;
		var r = this.get1DLeft() + this.margin;
		var p = this.get1DTop();
		var f = this.get1DIndices();
		var q = this.get1DSamples();
		var B = this.get1DLabels();
		if (this.showSampleNames) {
			var m = this.get1DCompBlockMax() * this.rowBlockSize;
			if (this.graphOrientation == "vertical") {
				var v = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
				if (this.isGraphTime) {
					var h = this.plotByVariable ? this.x / this.varIndices.length : this.x / f.length;
					var u = this.plotByVariable ? this.rowBlockSize / 2 : h / 2;
					var n = this.graphType.match(/Area/) ? 0 : r + ((this.blockSeparation + m) / 2);
					d = p + this.y + this.smpOverlaysThicknessBottom + (this.margin * 2);
					if (this.plotByVariable) {
						A = n + u;
						for (var w = 0; w < this.varIndices.length; w++) {
							for (var s = 0; s < this.timeValueIndices.length; s++) {
								this.smpInfo[s] = A;
								if (this.smpLabelRotate) {
									this.addToRender(["drawText", this.timeValues[s], A, d + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + s])
								} else {
									this.addToRender(["drawText", this.timeValues[s], A, d, this.smpLabelFont, e, "right", "middle", -Math.PI / 2], ["Smp-" + s])
								}
								A += this.rowBlockSize
							}
							A += this.blockSeparation
						}
					} else {
						for (var w = 0; w < this.timeValueIndices.length; w++) {
							A = (this.timeValueIndices[w] * h) + n;
							this.smpInfo[w] = A;
							if (this.smpLabelRotate) {
								this.addToRender(["drawText", this.timeValues[w], A, d + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + w])
							} else {
								this.addToRender(["drawText", this.timeValues[w], A, d, this.smpLabelFont, e, "right", "middle", -Math.PI / 2], ["Smp-" + w])
							}
						}
					}
				} else {
					A = this.plotByVariable ? r + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area|ParallelCoordinates/) ? r : r + ((this.blockSeparation + m) / 2);
					d = p;
					c = p + this.y;
					b = c + this.smpOverlaysThicknessBottom + this.margin;
					if (this.plotByVariable) {
						for (var w = 0; w < this.varIndices.length; w++) {
							for (var s = 0; s < f.length; s++) {
								var g = s / this.smpLabelInterval;
								if (parseInt(g) == parseFloat(g)) {
									var z = f[s];
									var k = this.shortenText(q[z], this.maxSmpStringLen);
									var e = this.getSmpColor(q[z]);
									this.smpInfo[s] = A;
									if (this.smpLabelRotate) {
										if (this.smpLabelRotate == 90) {
											this.addToRender(["drawText", k, A, b + this.margin + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + z])
										} else {
											this.addToRender(["drawText", k, A, b + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + z])
										}
									} else {
										this.addToRender(["drawText", k, A - this.margin, b, this.smpLabelFont, e, "right", "middle", -Math.PI / 2], ["Smp-" + z])
									}
								}
								A += this.rowBlockSize
							}
							A += this.blockSeparation
						}
					} else {
						var C;
						for (var w = 0; w < f.length; w++) {
							var g = w / this.smpLabelInterval;
							if (parseInt(g) == parseFloat(g)) {
								this.smpInfo[w] = A;
								if (w > 0 && this.parseInt(this.smpInfo[w]) < this.parseInt(this.smpInfo[C] + this.smpLabelFontSize)) {
									A += this.blockSeparation + m;
									continue
								}
								var o = f[w];
								var k = this.shortenText(B ? B[o] : q[o], this.maxSmpStringLen);
								var e = this.getSmpColor(q[o]);
								if (this.smpLabelRotate) {
									if (this.smpLabelRotate == 90) {
										this.addToRender(["drawText", k, A, b + this.margin + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + o])
									} else {
										this.addToRender(["drawText", k, A, b + this.margin, this.smpLabelFont, e, v, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)], ["Smp-" + o])
									}
								} else {
									this.addToRender(["drawText", k, A - this.margin, b, this.smpLabelFont, e, "right", "middle", -Math.PI / 2], ["Smp-" + o])
								}
								C = w
							}
							A += this.blockSeparation + m
						}
					}
				}
			} else {
				var v = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
				if (this.isGraphTime) {
					var h = this.plotByVariable ? this.y / this.varIndices.length : this.y / f.length;
					var u = this.plotByVariable ? this.rowBlockSize / 2 : h / 2;
					var n = this.graphType.match(/Area/) ? 0 : p + ((this.blockSeparation + m) / 2);
					A = r - (this.margin * 2);
					if (this.plotByVariable) {
						d = n + u;
						for (var w = 0; w < this.varIndices.length; w++) {
							for (var s = 0; s < this.timeValueIndices.length; s++) {
								this.smpInfo[s] = d;
								if (this.smpLabelRotate) {
									this.addToRender(["drawText", this.timeValues[s], A - this.margin, d, this.smpLabelFont, e, v, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + s])
								} else {
									this.addToRender(["drawText", this.timeValues[s], A, d, this.smpLabelFont, e, "right", "middle"], ["Smp-" + s])
								}
								d += this.rowBlockSize
							}
							d += this.blockSeparation
						}
					} else {
						for (var w = 0; w < this.timeValueIndices.length; w++) {
							d = (this.timeValueIndices[w] * h) + n;
							this.smpInfo[w] = d;
							if (this.smpLabelRotate) {
								this.addToRender(["drawText", this.timeValues[w], A - this.margin, d, this.smpLabelFont, e, v, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + w])
							} else {
								this.addToRender(["drawText", this.timeValues[w], A, d, this.smpLabelFont, e, "right", "middle"], ["Smp-" + w])
							}
						}
					}
				} else {
					d = this.plotByVariable ? p + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area|ParallelCoordinates/) ? p : p + ((this.blockSeparation + m) / 2);
					A = r;
					y = r + this.x;
					x = A - (this.smpOverlaysThicknessLeft + (this.margin * 2));
					if (this.plotByVariable) {
						for (var w = 0; w < this.varIndices.length; w++) {
							for (var s = 0; s < f.length; s++) {
								var g = s / this.smpLabelInterval;
								if (parseInt(g) == parseFloat(g)) {
									var z = f[s];
									var k = this.shortenText(q[z], this.maxSmpStringLen);
									var e = this.getSmpColor(q[z]);
									this.smpInfo[s] = d;
									if (this.smpLabelRotate) {
										this.addToRender(["drawText", k, x - this.margin, d, this.smpLabelFont, e, v, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + o])
									} else {
										this.addToRender(["drawText", k, x, d, this.smpLabelFont, e, "right", "middle"], ["Smp-" + o])
									}
								}
								d += this.rowBlockSize
							}
							d += this.blockSeparation
						}
					} else {
						var C;
						for (var w = 0; w < f.length; w++) {
							var g = w / this.smpLabelInterval;
							if (parseInt(g) == parseFloat(g)) {
								this.smpInfo[w] = d;
								if (w > 0 && this.parseInt(this.smpInfo[w]) < this.parseInt(this.smpInfo[C] + this.smpLabelFontSize)) {
									d += this.blockSeparation + m;
									continue
								}
								var o = f[w];
								var k = this.shortenText(B ? B[o] : q[o], this.maxSmpStringLen);
								var e = this.getSmpColor(q[o]);
								if (this.smpLabelRotate) {
									this.addToRender(["drawText", k, x - this.margin, d, this.smpLabelFont, e, v, "middle", this.smpLabelRotate * Math.PI / 180], ["Smp-" + o])
								} else {
									this.addToRender(["drawText", k, x, d, this.smpLabelFont, e, "right", "middle"], ["Smp-" + o])
								}
								C = w
							}
							d += this.blockSeparation + m
						}
					}
				}
			}
		}
	};
	this.draw1DOverlaysDataPoints = function(D, G, N, af, ag, b, J, g, u, Z, ab, T, Q, B, x) {
		this.functionCaller = "draw1DOverlaysDataPoints";
		var Y, E, ak, H, w, I, e, am;
		var O = ab;
		var K = T;
		var A = [];
		var C = [];
		var ac = [];
		var M = {};
		var aa = 0;
		for (var ae = 0; ae < J.length; ae++) {
			M[J[ae]] = aa;
			aa++
		}
		if (Z == "vertical") {
			this.addToRender(["setClipArea", [ab, T - g, this.x, g]])
		} else {
			this.addToRender(["setClipArea", [ab, T, g, this.y]])
		}
		if (ag != "Pie") {
			if (!B) {
				B = [];
				var r = [];
				if (ag.match(/Stacked/)) {
					var m = false;
					for (var ad = 0; ad < af.length; ad++) {
						var f = 0;
						var S = 0;
						for (var ae = 0; ae < G.length; ae++) {
							var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
							if (b[G[ae]]["type"].match(/Line/)) {
								A.push(L)
							} else {
								if (L > 0) {
									f += L
								} else {
									if (L < 0) {
										m = true;
										S += L
									}
								}
							}
						}
						B.push(f);
						r.push(S)
					}
					if (ag.match(/StackedPercent/)) {
						B = m ? [-100, 100] : [0, 100]
					} else {
						if (m) {
							B = B.concat(r)
						} else {
							B.push(0)
						}
						if (A.length > 0) {
							Y = this.range(A);
							am = Y[1]
						}
					}
				} else {
					for (var ae = 0; ae < G.length; ae++) {
						for (var ad = 0; ad < af.length; ad++) {
							var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
							B.push(L)
						}
					}
				}
			}
			if (ag != "Treemap") {
				Y = this.range(B);
				if (am > Y[1]) {
					Y[1] = am
				}
				E = this[this.axisAlgorithm](Y[0], Y[1], 3, this.axisWilkinsonLoose);
				ak = Math.min(Y[0], E[0]);
				H = Math.max(Y[1], E[E.length - 1]);
				w = (g - 2) / (H - ak);
				I = ak < 0 ? Math.abs(ak) * w : 0;
				if (x) {
					e = u / x
				} else {
					aa = 0;
					for (var ae = 0; ae < G.length; ae++) {
						if (b[G[ae]]["type"] != "Line") {
							if (b[G[ae]]["type"] == ag) {
								aa++
							}
						} else {
							aa++
						}
					}
					e = u / aa
				}
			}
		}
		switch (ag) {
			case "Area":
			case "AreaLine":
				var ai = [];
				var aj = [];
				var X = [];
				var al = [];
				for (var ae = 0; ae < G.length; ae++) {
					if (b[G[ae]]["type"].match(/Line/)) {
						C.push(G[ae]);
						continue
					}
					var R = [];
					for (var ad = 0; ad < af.length; ad++) {
						var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
						R.push(L)
					}
					ai.push(R);
					aj.push(b[G[ae]]["color"]);
					X.push("closed");
					al.push([this.capitalize(D) + "Ovr-" + M[G[ae]]])
				}
				if (Z == "vertical") {
					this.drawAreaPlot(ai, ab + (u / 2), T, this.x - u, g, u, false, false, w, ak, H, Z, false, aj, X, al, false, Q)
				} else {
					if (this.graphType == "Area") {
						this.drawAreaPlot(ai, ab, T, g, (af.length - 1) * u, u, false, false, w, ak, H, Z, false, aj, X, al, false, Q)
					} else {
						this.drawAreaPlot(ai, ab, T + (u / 2), g, (af.length - 1) * u, u, false, false, w, ak, H, Z, false, aj, X, al, false, Q)
					}
				}
				if (C.length > 0) {
					this.draw1DOverlaysDataPoints(D, C, N, af, "Line", b, J, g, u, Z, O, K, Q, B, C.length)
				}
				break;
			case "Bar":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Line":
				var o = this.jitter;
				this.jitter = false;
				for (var ae = 0; ae < G.length; ae++) {
					if (b[G[ae]]["type"].match(/BarLine|DotLine/) && ag != "Line") {
						C.push(G[ae]);
						continue
					}
					var ai = [];
					var aj = [];
					var V = [];
					var al = [];
					var U = [];
					var X = [];
					if (ag == "Dotplot") {
						for (var ad = 0; ad < af.length; ad++) {
							var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
							ai.push([L]);
							aj.push([b[G[ae]]["color"]]);
							V.push([false]);
							al.push([
								[this.capitalize(D) + "Ovr-" + af[ad] + "-" + M[G[ae]]]
							]);
							U.push([this.margin]);
							X.push(["circle"])
						}
					} else {
						for (var ad = 0; ad < af.length; ad++) {
							var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
							ai.push(L);
							aj.push(b[G[ae]]["color"]);
							V.push(false);
							al.push([this.capitalize(D) + "Ovr-" + af[ad] + "-" + M[G[ae]]])
						}
					}
					if (ag == "Bar") {
						if (Z == "vertical") {
							this.drawBarPlot(ai, false, ab, T - I, e, u, w, I, ak, Z, aj, V, al, false, false, Q)
						} else {
							this.drawBarPlot(ai, false, ab, T, e, u, w, I, ak, Z, aj, V, al, false, false, Q)
						}
					} else {
						if (ag == "Line") {
							if (Z == "vertical") {
								this.drawLinePlot(ai, false, ab + (u / 2), T, e, u, w, ak, Z, aj[0], V, false, al, false, false, Q, G[ae])
							} else {
								this.drawLinePlot(ai, false, ab, T + (u / 2), e, u, w, ak, Z, aj[0], V, false, al, false, false, Q, G[ae])
							}
						} else {
							if (ag == "Dotplot") {
								var W = this.graphType;
								this.graphType = "Dotplot";
								if (Z == "vertical") {
									this.drawDotPlot(ai, false, ab + (u / 2), T, e, u, w, ak, U, Z, aj, V, X, al, false, false, Q, G[ae])
								} else {
									this.drawDotPlot(ai, false, ab, T + (u / 2), e, u, w, ak, U, Z, aj, V, X, al, false, false, Q, G[ae])
								}
								this.graphType = W
							}
						}
					}
					if (Z == "vertical" && ag != "Line") {
						ab += e
					} else {
						if (Z == "horizontal" && ag != "Line") {
							T += e
						}
					}
				}
				if (C.length > 0) {
					this.draw1DOverlaysDataPoints(D, C, N, af, "Line", b, J, g, u, Z, O, K, Q, B, C.length)
				}
				this.jitter = o;
				break;
			case "Pie":
				this.showPieValues = false;
				for (var ad = 0; ad < af.length; ad++) {
					this.pieColors = [];
					var ai = [];
					var al = [];
					for (var ae = 0; ae < G.length; ae++) {
						var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", G[ae]);
						this.pieColors.push(b[G[ae]]["color"]);
						ai.push(L);
						al.push([this.capitalize(D) + "Ovr-" + af[ad] + "-" + M[G[ae]]])
					}
					var X = this.setPieData(ai);
					if (Z == "vertical") {
						this.drawPie(X, ab + (u / 2), T - (g / 2), Math.min((g / 2), (u / 2)) - 2, al, false);
						ab += u
					} else {
						if (Z == "horizontal") {
							this.drawPie(X, ab + (g / 2), T + (u / 2), Math.min((g / 2), (u / 2)) - 2, al, false);
							T += u
						}
					}
				}
				break;
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
				for (var ae = 0; ae < G.length; ae++) {
					if (b[G[ae]]["type"].match(/Line/)) {
						C.push(G[ae])
					} else {
						ac.push(G[ae])
					}
				}
				for (var ad = 0; ad < af.length; ad++) {
					var ai = [];
					var aj = [];
					var al = [];
					var X = [];
					var f = 0;
					var S = 0;
					for (var ae = 0; ae < ac.length; ae++) {
						var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", ac[ae]);
						if (L > 0) {
							f += L
						} else {
							S += L
						}
					}
					for (var ae = 0; ae < ac.length; ae++) {
						var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", ac[ae]);
						ai.push(L);
						aj.push(b[ac[ae]]["color"]);
						X.push(false);
						al.push([this.capitalize(D) + "Ovr-" + af[ad] + "-" + M[G[ae]]])
					}
					this.drawStackedPlot(ai, ab, T, u, false, ag.match(/Percent/) ? true : false, [f, S], w, ak < 0 ? -ak * w : 0, Z, aj, X, al, false, Q);
					if (Z == "vertical") {
						ab += u
					} else {
						if (Z == "horizontal") {
							T += u
						}
					}
				}
				if (C.length > 0) {
					if (ag.match(/Percent/)) {
						var F = {};
						for (var ae = 0; ae < C.length; ae++) {
							var L = this.getMetadataValue(af[ad], D == "smp" ? "x" : "z", C[ae]);
							F[C[ae]] = [];
							Y = this.range(N[C[ae]]);
							for (var ad = 0; ad < af.length; ad++) {
								F[C[ae]][af[ad]] = this.percentile(Y[0], Y[1], L)
							}
						}
						this.draw1DOverlaysDataPoints(D, C, F, af, "Line", b, J, g, u, Z, O, K, Q, B, C.length)
					} else {
						this.draw1DOverlaysDataPoints(D, C, N, af, "Line", b, J, g, u, Z, O, K, Q, B, C.length)
					}
				}
				break;
			case "Treemap":
				var F = {};
				var h = this.meta.data[D == "smp" ? "x" : "z"][G[0]];
				if (h.type == "String") {
					for (var ae = 0; ae < B.length; ae++) {
						if (F.hasOwnProperty(B[ae])) {
							F[B[ae]]++
						} else {
							F[B[ae]] = 1
						}
					}
				} else {
					var v = this.isGroupedData ? this.data.w : this.data.y;
					for (var ae = 0; ae < af.length; ae++) {
						F[v.smps[af[ae]]] = B[ae]
					}
				}
				var k;
				if (Z == "vertical") {
					k = this.getTreemapOverlay(F, h, this.x, g, ab, T - g);
					this.drawTreemap(k, 0, 0)
				} else {
					if (Z == "horizontal") {
						k = this.getTreemapOverlay(F, h, g, this.y, ab, T);
						this.drawTreemap(k, 0, 0)
					}
				}
				break
		}
		this.addToRender(["resetClipArea"]);
		if (ag != "Pie" && ag != "Treemap") {
			this.disableGradientTransparencyShadow();
			if (Z == "vertical" && !x) {
				var P = O - (this.margin * 1.5);
				for (var ae = 0; ae < E.length; ae++) {
					var y = ((E[ae] - ak) * w);
					var ah = K - y;
					this.addToRender(["drawLine", "line", O - this.margin, ah, O, ah, this.xAxisTickColor]);
					this.addToRender(["drawText", E[ae].toString(), P, ah, this.overlayFont, this.overlayFontColor, "right", "middle"])
				}
				this.addToRender(["drawShape", "rectangle", O + (this.x / 2), K - (g / 2), this.x, g, false, this.xAxisTickColor, "open", false, this.outlineWidth])
			} else {
				if (Z == "horizontal" && !x) {
					var ah = K - (this.margin * 1.5);
					for (var ae = 0; ae < E.length; ae++) {
						var y = ((E[ae] - ak) * w);
						var P = Q ? O + Q - y : O + y;
						this.addToRender(["drawLine", "line", P, K - this.margin, P, K, this.xAxisTickColor]);
						this.addToRender(["drawText", E[ae].toString(), P, ah, this.overlayFont, this.overlayFontColor, Q ? "left" : "right", "middle", Q ? -Math.PI / 2 : Math.PI / 2])
					}
					this.addToRender(["drawShape", "rectangle", O + (g / 2), K + (this.y / 2), g, this.y, false, this.xAxisTickColor, "open", false, this.outlineWidth])
				}
			}
			this.enableGradientTransparencyShadow()
		}
	};
	this.getOverlayClipArea = function(d) {
		var b = this.get1DLeft();
		var c = this.get1DTop();
		switch (d) {
			case "top":
				return [b, this.marginTop + this.offsetY, b + this.x + 1, c];
			case "bottom":
				return [b, c + this.y, b + this.x + 1, c + this.y + this.bottom];
			case "right":
				return [b + this.x, c, b + this.x + this.right, c + this.y + 1];
			case "left":
				return [this.marginLeft + this.offsetX, c, b, c + this.y + 1];
			default:
				return false
		}
	};
	this.isDrawOverlayNames = function() {
		if (!this.layoutValid) {
			return true
		} else {
			if (this.layoutValid && this.data.l && this.data.l.weight && this.layoutCurrent == this.data.l.weight.length - 1) {
				return true
			} else {
				if (this.layoutValid && !this.layoutTopology) {
					return this.layoutAxis == 1
				} else {
					if (this.graphOrientation == "vertical") {
						return (this.layoutCurrent + 1) % this.layoutRows
					} else {
						if (this.graphOrientation == "horizontal") {
							return (this.layoutCurrent + 1) % this.layoutCols
						} else {
							return false
						}
					}
				}
			}
		}
	};
	this.draw1DOverlays = function() {
		this.functionCaller = "draw1DOverlays";
		var v, c, u, V, r, U, Q, y, z, R, J, E, f;
		var w = {};
		var C = {};
		var L = this.get1DLeft();
		var H = this.get1DTop();
		var e = this.get1DIndices();
		var K = this.meta.data;
		this.smpOverlayInfo = {};
		this.varOverlayInfo = {};
		var G = this;
		var D = function(j, i) {
			if (j.type == "Numeric") {
				return G.getColorForValue(j.colorBrew, i)
			} else {
				if (j.colors) {
					return j.colors[j.order[i]]
				} else {
					if (j.colorBy) {
						return j.colorBy[i]
					}
				}
			}
		};
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		}
		if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
			z = this.getVariablesVisibleByAxis("xAxis").length
		} else {
			if (this.graphType.match(/Stacked|Line|Area|Heatmap/)) {
				z = 1
			} else {
				z = this.plotByVariable ? e.length : this.variableBlock
			}
		}
		if (this.showOverlays) {
			if (this.smpOverlays.length > 0) {
				J = 0;
				for (var N = 0; N < this.smpOverlays.length; N++) {
					C[this.smpOverlays[N]] = J;
					J++
				}
				Q = z * this.rowBlockSize;
				R = this.isGroupedData ? this.data.w.factors : this.data.x;
				if (this.graphOrientation == "vertical") {
					c = H + this.y + this.margin;
					for (var N = 0; N < this.smpOverlays.length; N++) {
						var A = this.smpOverlays[N];
						if (A != "-") {
							f = this.getOverlayClipArea(this.smpOverlayProperties[A]["position"]);
							if (this.smpOverlayProperties[A]["position"] == "top" && !E) {
								c = H - this.smpOverlaysThicknessTop;
								E = true
							}
							v = this.graphType.match(/Area/) ? L - ((Q + this.blockSeparation) / 2) : L;
							u = Q + this.blockSeparation;
							r = 0;
							V = this.smpOverlayProperties[A]["thickness"] || this.overlaysThickness;
							if (!this.smpOverlayProperties[A]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
								if (w.hasOwnProperty(A)) {
									continue
								}
								var O = this.smpOverlayProperties[A]["type"];
								var F = this.smpOverlayProperties[A]["position"];
								var x = this.getOverlaysForTypePosition("smp", O, F);
								var b = [];
								for (var M = 0; M < x.length; M++) {
									b.unshift(x[M])
								}
								this.draw1DOverlaysDataPoints("smp", x, R, e, O, this.smpOverlayProperties, this.smpOverlays, V, u, "vertical", v, c + V);
								if (this.isDrawOverlayNames()) {
									v = this.graphType.match(/Area/) ? (L + this.x + this.margin) + ((Q + this.blockSeparation) / 2) : L + this.x + this.margin;
									U = V / (x.length + 1);
									for (var M = 0; M < x.length; M++) {
										var I = b[M];
										w[I] = true;
										this.smpOverlayInfo[I] = c + (U * (M + 1));
										this.addToRender(["drawText", I, v, c + (U * (M + 1)), this.overlayFont, this.smpOverlayProperties[I]["color"], "left", "middle", false, this.measureText(this.shortenText(A, this.maxOverlayStringLen), this.overlayFont)], ["SmpOverlay-" + C[I]])
									}
								}
							} else {
								var O = this.smpOverlayProperties[A]["type"];
								for (var M = 0; M < e.length; M++) {
									var B = R[A][e[M]];
									var g = B != null ? D(K.x[A], B) : this.missingDataColor;
									var P = false;
									if (M < e.length - 1) {
										P = R[A][e[M + 1]]
									}
									if (B === P) {
										r += u;
										continue
									}
									if (O != "Text") {
										var q = v;
										var p = v + u + r;
										var T = c;
										var S = c + V;
										if (O == "Increase") {
											this.addToRender(["drawShape", "path", [q, p, p, q],
												[S, T, S, S], false, false, this.colors[2], false, false, false, false, true, f
											], ["SmpOvr-" + e[M] + "-" + N])
										} else {
											if (O == "Decrease") {
												this.addToRender(["drawShape", "path", [q, p, q, q],
													[T, S, S, T], false, false, this.colors[2], false, false, false, false, true, f
												], ["SmpOvr-" + e[M] + "-" + N])
											} else {
												this.addToRender(["drawShape", "rectangle", v + ((u + r) / 2), c + (V / 2), u + r, V, g, false, false, false, false, true, f], ["SmpOvr-" + e[M] + "-" + N])
											}
										}
									}
									if (this.showLevelOverlays || O == "Text") {
										if ((u + r) > V) {
											this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, u + r), v + ((u + r) / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, (u + r) - 2])
										} else {
											this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, V), v + ((u + r) / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, V - 2])
										}
									}
									v += u + r;
									r = 0
								}
								if (this.isDrawOverlayNames()) {
									v = this.graphType.match(/Area/) ? (L + this.x + this.margin) + ((Q + this.blockSeparation) / 2) : L + this.x + this.margin;
									this.smpOverlayInfo[A] = c + (V / 2);
									this.addToRender(["drawText", A, v, c + (V / 2), this.overlayFont, this.overlayFontColor, "left", "middle", false, this.measureText(this.shortenText(A, this.maxOverlayStringLen), this.overlayFont)], ["SmpOverlay-" + N])
								}
							}
							c += V
						} else {
							if (A == "-") {
								c += this.margin
							}
						}
					}
				} else {
					v = L - this.smpOverlaysThicknessLeft;
					for (var N = 0; N < this.smpOverlays.length; N++) {
						var A = this.smpOverlays[N];
						if (A != "-") {
							f = this.getOverlayClipArea(this.smpOverlayProperties[A]["position"]);
							if (this.smpOverlayProperties[A]["position"] == "right" && !E) {
								v = L + this.x + this.margin;
								E = true
							}
							u = this.smpOverlayProperties[A]["thickness"] || this.overlaysThickness;
							c = this.graphType.match(/Area/) ? H - ((Q + this.blockSeparation) / 2) : H;
							V = this.graphType != "Heatmap" ? Q + this.blockSeparation : Q;
							U = 0;
							if (!this.smpOverlayProperties[A]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
								if (w.hasOwnProperty(A)) {
									continue
								}
								var O = this.smpOverlayProperties[A]["type"];
								var F = this.smpOverlayProperties[A]["position"];
								var x = this.getOverlaysForTypePosition("smp", O, F);
								var b = [];
								for (var M = 0; M < x.length; M++) {
									b.unshift(x[M])
								}
								this.draw1DOverlaysDataPoints("smp", x, R, e, O, this.smpOverlayProperties, this.smpOverlays, u, V, "horizontal", v, c, F == "left" ? u : false);
								if (this.isDrawOverlayNames()) {
									c = this.graphType.match(/Area/) ? (H + this.y + this.margin) + ((Q + this.blockSeparation) / 2) : H + this.y + this.margin;
									r = u / (x.length + 1);
									for (var M = 0; M < x.length; M++) {
										var I = b[M];
										w[I] = true;
										this.smpOverlayInfo[I] = v + (r * (M + 1));
										this.addToRender(["drawText", I, v + (r * (M + 1)), c, this.overlayFont, this.smpOverlayProperties[I]["color"], F == "left" ? "right" : "left", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2], ["SmpOverlay-" + C[I]])
									}
								}
							} else {
								var O = this.smpOverlayProperties[A]["type"];
								var F = this.smpOverlayProperties[A]["position"];
								for (var M = 0; M < e.length; M++) {
									var B = R[A][e[M]];
									var g = B != null ? D(K.x[A], B) : this.missingDataColor;
									var P = false;
									if (M < e.length - 1) {
										P = R[A][e[M + 1]]
									}
									if (B === P) {
										U += V;
										continue
									}
									if (O != "Text") {
										var q = v;
										var p = v + u;
										var T = c;
										var S = c + V + U;
										if (O == "Increase") {
											this.addToRender(["drawShape", "path", [p, p, q, p],
												[T, S, S, T], false, false, g, false, false, false, false, true, f
											], ["SmpOvr-" + e[M] + "-" + N])
										} else {
											if (O == "Decrease") {
												this.addToRender(["drawShape", "path", [q, p, p, q],
													[T, T, S, T], false, false, g, false, false, false, false, true, f
												], ["SmpOvr-" + e[M] + "-" + N])
											} else {
												this.addToRender(["drawShape", "rectangle", v + (u / 2), c + ((V + U) / 2), u, V + U, g, false, false, false, false, true, f], ["SmpOvr-" + e[M] + "-" + N])
											}
										}
									}
									if (this.graphType == "Heatmap" && this.heatmapSmpSeparateBy && this.heatmapSmpSeparateBy == A) {
										var T = c + V + U;
										var d = T - (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
										var k = T + (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
										if (k < H + this.y) {
											this.addToRender(["drawShape", "rectangle", L - 1 + ((this.x + 1) / 2), d + (this.heatmapSeparatorWidth / 2), this.x + 1, this.heatmapSeparatorWidth, this.background, this.background])
										}
									}
									if (this.showLevelOverlays || O == "Text") {
										if ((V + U) > u) {
											this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, (V + U)), v + (u / 2), c + ((V + U) / 2), this.overlayFont, this.overlayFontColor, "center", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2, (V + U) - 2])
										} else {
											this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, u), v + (u / 2), c + ((V + U) / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, u - 2])
										}
									}
									c += V + U;
									U = 0
								}
								if (this.isDrawOverlayNames()) {
									c = this.graphType.match(/Area/) ? (H + this.y + this.margin) + ((Q + this.blockSeparation) / 2) : H + this.y + this.margin;
									this.smpOverlayInfo[A] = v + (u / 2);
									this.addToRender(["drawText", A, v + (u / 2), c, this.overlayFont, this.overlayFontColor, F == "left" ? "right" : "left", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2], ["SmpOverlay-" + N])
								}
							}
							v += u
						} else {
							if (A == "-") {
								v += this.margin
							}
						}
					}
				}
			}
			w = {};
			E = false;
			if (this.varOverlays.length > 0 && this.graphType == "Heatmap") {
				J = 0;
				for (var N = 0; N < this.varOverlays.length; N++) {
					C[this.varOverlays[N]] = J;
					J++
				}
				c = this.varTitleLabelOverlayPosition != "bottom" ? H - this.varOverlaysThicknessTop : H + this.y + this.margin;
				for (var N = 0; N < this.varOverlays.length; N++) {
					var A = this.varOverlays[N];
					if (A != "-") {
						f = this.getOverlayClipArea(this.varOverlayProperties[A]["position"]);
						if (this.varOverlayProperties[A]["position"] == "top" && !E) {
							c = H - this.varOverlaysThicknessTop;
							E = true
						}
						v = L + (this.colBlockSize / 2);
						u = 0;
						V = this.varOverlayProperties[A]["thickness"] || this.overlaysThickness;
						if (!this.varOverlayProperties[A]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
							if (w.hasOwnProperty(A)) {
								continue
							}
							var O = this.varOverlayProperties[A]["type"];
							var F = this.varOverlayProperties[A]["position"];
							var x = this.getOverlaysForTypePosition("var", O, F);
							var b = [];
							for (var M = 0; M < x.length; M++) {
								b.unshift(x[M])
							}
							this.draw1DOverlaysDataPoints("var", x, this.data.z, this.varIndices, O, this.varOverlayProperties, this.varOverlays, V, this.colBlockSize, "vertical", v - (this.colBlockSize / 2), c + V);
							v = L + this.x + this.margin;
							U = V / (x.length + 1);
							for (var M = 0; M < x.length; M++) {
								var I = b[M];
								w[I] = true;
								this.varOverlayInfo[I] = c + (U * (M + 1));
								this.addToRender(["drawText", I, v, c + (U * (M + 1)), this.overlayFont, this.varOverlayProperties[I]["color"], "left", "middle", false, this.measureText(this.shortenText(A, this.maxOverlayStringLen), this.overlayFont)], ["VarOverlay-" + C[I]])
							}
						} else {
							var O = this.varOverlayProperties[A]["type"];
							for (var M = 0; M < this.varIndices.length; M++) {
								var B = this.data.z[A][this.varIndices[M]];
								var g = B != null ? D(K.z[A], B) : this.missingDataColor;
								var P = M < this.varIndices.length - 1 ? this.data.z[A][this.varIndices[M + 1]] : false;
								if (B == P) {
									u += this.colBlockSize;
									continue
								}
								if (O != "Text") {
									var q = v - (this.colBlockSize / 2);
									var p = q + this.colBlockSize + u;
									var T = c;
									var S = c + V;
									if (O == "Increase") {
										this.addToRender(["drawShape", "path", [q, p, p, q],
											[S, T, S, S], false, false, g, false, false, false, false, true, f
										], ["VarOvr-" + this.varIndices[M] + "-" + N])
									} else {
										if (O == "Decrease") {
											this.addToRender(["drawShape", "path", [q, p, q, q],
												[T, S, S, T], false, false, g, false, false, false, false, true, f
											], ["VarOvr-" + this.varIndices[M] + "-" + N])
										} else {
											this.addToRender(["drawShape", "rectangle", (v - (this.colBlockSize / 2)) + ((this.colBlockSize + u) / 2), c + (V / 2), this.colBlockSize + u, V, g, false, false, false, false, true, f], ["VarOvr-" + this.varIndices[M] + "-" + N])
										}
									}
								}
								if (this.graphType == "Heatmap" && this.heatmapVarSeparateBy && this.heatmapVarSeparateBy == A) {
									var q = (v - (this.colBlockSize / 2)) + this.colBlockSize + u;
									var s = q - (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
									var h = q + (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
									if (h < L + this.x) {
										this.addToRender(["drawShape", "rectangle", s + (this.heatmapSeparatorWidth / 2), (H - 1) + ((this.y + 1) / 2), this.heatmapSeparatorWidth, this.y + 1, this.background, this.background])
									}
								}
								if (this.showLevelOverlays || O == "Text") {
									if (this.colBlockSize + u > V) {
										this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, this.colBlockSize + u), v + (u / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, (this.colBlockSize + u) - 2])
									} else {
										this.addToRender(["drawText", this.shortenText(B, this.overlayFontSize, V), v + (u / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, V - 2])
									}
								}
								v += this.colBlockSize + u;
								u = 0
							}
							v = L + this.x + this.margin;
							this.varOverlayInfo[A] = c + (V / 2);
							this.addToRender(["drawText", A, v, c + (V / 2), this.overlayFont, this.overlayFontColor, "left", "middle", false, this.measureText(this.shortenText(A, this.maxOverlayStringLen), this.overlayFont)], ["VarOverlay-" + N])
						}
						c += V
					} else {
						if (A == "-") {
							c += this.margin
						}
					}
				}
			}
		}
	};
	this.getAxisDescription = function(e) {
		var d;
		var b = {
			standardDeviation: "Std Dev.",
			standardErrorMean: "Std Error of Mean",
			confidenceInterval95: "95% CI"
		};
		var c = this.graphType != "Boxplot" && !this.graphType.match(/stacked/i) && this.graphType != "Treemap";
		if (e) {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.xAxis2Values.length > 0) {
				d = this.xAxis2Title ? this.xAxis2Title + " (Lines)" : "(Lines)";
				if (this.showErrorBars && this.isGroupedData && c) {
					if (d != "") {
						d = d + "; Error bars are the " + b[this.errorBarsType]
					} else {
						d = "Error bars are the " + b[this.errorBarsType]
					}
				}
			} else {
				d = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxis2Title ? this.xAxis2Title : ""
			}
		} else {
			d = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : "";
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.xAxisValues.length > 0) {
				if (this.graphType.match(/BarLine|StackedLine|StackedPercentLine/)) {
					d = d + " (Bars)"
				} else {
					if (this.graphType.match(/DotLine/)) {
						d = d + " (Dots)"
					} else {
						if (this.graphType == "AreaLine") {
							d = d + " (Area)"
						}
					}
				}
			}
			if (this.showErrorBars && (this.isGroupedData || (this.layoutValid && this.data.l && this.data.l.group && c)) && c) {
				if (d != "") {
					d = d + "; Error bars are the " + b[this.errorBarsType]
				} else {
					d = "Error bars are the " + b[this.errorBarsType]
				}
			}
		}
		return this.transformType ? this.transformType + " " + d : d
	};
	this.draw1DXLayout = function() {
		this.functionCaller = "draw1DXLayout";
		var s, g, o, p, w, m, u, c, d, b;
		var n = this.get1DLeft();
		var f = this.get1DTop();
		var k = this.layoutComb ? 0 : 0;
		var v = this.layoutComb ? 1 : 0;
		var e = this;
		var j = function(h) {
			if (e.xAxisTransform && e.xAxisTransform.match(/log|exp/) && !e.xAxisTransformTicks) {
				return e.formatAxisValue(e.transformValue(e.xAxisTransform, h, true), "xAxis")
			} else {
				if (e.isTransformedData && e.isTransformedData.match(/log|exp/) && !e.xAxisTransformTicks) {
					return e.formatAxisValue(e.transformValue(e.isTransformedData, h, true), "xAxis")
				} else {
					return e.formatAxisValue(w, "xAxis")
				}
			}
		};
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "ParallelCoordinates" || this.graphType == "Sankey" || this.graphType == "Tree") {
			return
		}
		if (!this.layoutValid) {
			this.layoutAxis = 3
		}
		if (this.graphType == "Heatmap") {
			var r = this.getHeatmapIndicatorHeight();
			if (this.showHeatmapIndicator) {
				if (this.layoutValid) {
					u = (this.width / 2) - (this.heatmapIndicatorWidth / 2);
					c = this.height - this.layoutBottom
				} else {
					if (this.heatmapIndicatorPosition == "right") {
						this.heatmapIndicatorY = f;
						u = this.width - (this.marginRight + this.getHeatmapIndicatorWidth())
					} else {
						if (this.heatmapIndicatorPosition == "top") {
							u = (n + (this.x / 2)) - (this.heatmapIndicatorWidth / 2)
						} else {
							if (this.heatmapIndicatorPosition == "topLeft") {
								if (this.left > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									u = n - (this.heatmapIndicatorWidth + (this.margin * 2))
								} else {
									u = this.marginLeft + this.offsetX + (this.margin * 6)
								}
							} else {
								if (this.right > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									u = n + this.x + (this.margin * 2)
								} else {
									u = this.width - (this.marginRight + (this.heatmapIndicatorWidth + (this.margin * 6)))
								}
							}
						}
					}
					c = this.heatmapIndicatorY
				}
				if (!this.layoutValid && this.heatmapIndicatorPosition != "right") {
					if (this.varDendrogramPosition == "top") {
						c -= this.getVarTreeHeight()
					}
					c -= this.varOverlaysThicknessTop;
					if (this.varTitleLabelOverlayPosition != "bottom") {
						c -= this.getVariableTitleHeight();
						c -= this.getVariableLabelLength()
					} else {
						c -= this.getVariableLabelDescLength()
					}
					c += this.margin
				}
				if (!this.isOncoprint) {
					this.drawColorIndicator(u, c, this.getDefaultMetaDataObject(), this.xAxisTitle ? this.xAxisTitle : false, true)
				}
			}
		} else {
			if ((this.xAxisTransform && this.xAxisTransform.match(/log/) && !this.xAxisTransformTicks) || (this.isTransformedData && this.isTransformedData.match(/log|exp/) && !this.xAxisTransformTicks)) {
				this.xAxisDecs = parseInt(Math.abs(this.xAxisMin))
			}
			if (this.graphOrientation == "vertical") {
				b = this.xAxisMin < 0 ? f + this.y - ((0 - this.xAxisMin) * this.xAxisUnit) : f + this.y;
				if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
					if (!this.layoutValid) {
						u = n + (this.axisTitleFontSize / 2) - this.getAxisTitleTickLength();
						c = f + (this.y / 2);
						s = this.getAxisDescription();
						this.addToRender(["drawText", s, u, c, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2])
					}
					p = "right";
					g = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2ValuesRaw : this.xAxisValuesRaw;
					u = n - (this.margin * 2);
					for (var q = k; q < g.length - v; q++) {
						w = this.xAxisValuesRaw[q];
						if (w >= this.xAxisMin && w <= this.xAxisMax) {
							m = j(w);
							c = this.graphType == "Candlestick" && this.summaryType == "volume" ? f + this.y - ((w - this.xAxis2Min) * this.xAxis2Unit) : f + this.y - ((w - this.xAxisMin) * this.xAxisUnit);
							this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "right", "middle"], false, false, null, false, b)
						}
					}
				}
				if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
					p = "left";
					u = n + this.x + (this.margin * 2);
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.xAxis2Values.length > 0) {
						b = this.xAxis2Min < 0 ? f + this.y - ((0 - this.xAxis2Min) * this.xAxis2Unit) : f + this.y;
						for (var q = k; q < this.xAxis2Values.length - v; q++) {
							w = this.xAxis2ValuesRaw[q];
							if (w >= this.xAxis2Min && w <= this.xAxis2Max) {
								m = j(w);
								c = f + this.y - ((w - this.xAxis2Min) * this.xAxis2Unit);
								this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "left", "middle"], false, false, null, false, b)
							}
						}
					} else {
						b = this.xAxisMin < 0 ? f + this.y - ((0 - this.xAxisMin) * this.xAxisUnit) : f + this.y;
						g = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2ValuesRaw : this.xAxisValuesRaw;
						for (var q = k; q < g.length - v; q++) {
							w = g[q];
							if (w >= this.xAxisMin && w <= this.xAxisMax) {
								m = j(w);
								c = this.graphType == "Candlestick" && this.summaryType == "volume" ? f + this.y - ((w - this.xAxis2Min) * this.xAxis2Unit) : f + this.y - ((w - this.xAxisMin) * this.xAxisUnit);
								this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "left", "middle"], false, false, null, false, b)
							}
						}
					}
					if (!this.layoutValid) {
						u = n + this.x + this.getAxisTitleTickLength(true) - (this.axisTitleFontSize / 2);
						c = f + (this.y / 2);
						s = this.getAxisDescription(true);
						this.addToRender(["drawText", s, u, c, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2])
					}
				}
			} else {
				b = this.xAxisMin < 0 ? n + this.x - ((0 - this.xAxisMin) * this.xAxisUnit) : n;
				if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
					if (!this.layoutValid) {
						u = n + (this.x / 2);
						c = f - ((this.margin * 4) + this.axisTickFontSize + (this.axisTitleFontSize / 2));
						s = this.getAxisDescription();
						this.addToRender(["drawText", s, u, c, this.axisTitleFont, this.axisTitleColor, "center", "middle"])
					}
					g = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2ValuesRaw : this.xAxisValuesRaw;
					c = f - ((this.margin * 2) + (this.axisTickFontSize / 2));
					if (this.layoutValid && !this.layoutAdjust) {
						c -= (this.segregateVariablesBy.length + this.segregateSamplesBy.length) * (this.getFontHeight() + (this.margin * 2))
					}
					for (var q = k; q < g.length - v; q++) {
						w = g[q];
						if (w >= this.xAxisMin && w <= this.xAxisMax) {
							m = j(w);
							if (this.invertGraph) {
								u = this.graphType == "Candlestick" && this.summaryType == "volume" ? n + this.x - ((w - this.xAxis2Min) * this.xAxis2Unit) : n + this.x - ((w - this.xAxisMin) * this.xAxisUnit)
							} else {
								u = this.graphType == "Candlestick" && this.summaryType == "volume" ? n + ((w - this.xAxis2Min) * this.xAxis2Unit) : n + ((w - this.xAxisMin) * this.xAxisUnit)
							}
							this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "center", "middle"], false, false, null, false, b)
						}
					}
				}
				if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
					c = f + this.y + (this.margin * 2) + (this.axisTickFontSize / 2);
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.xAxis2Values.length > 0) {
						b = this.xAxis2Min < 0 ? n + this.x - ((0 - this.xAxis2Min) * this.xAxis2Unit) : n;
						for (var q = k; q < this.xAxis2Values.length - v; q++) {
							w = this.xAxis2ValuesRaw[q];
							if (w >= this.xAxis2Min && w <= this.xAxis2Max) {
								m = j(w);
								if (this.invertGraph) {
									u = n + this.x - ((w - this.xAxis2Min) * this.xAxis2Unit)
								} else {
									u = n + ((w - this.xAxis2Min) * this.xAxis2Unit)
								}
								this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "center", "middle"], false, false, null, false, b)
							}
						}
					} else {
						b = this.xAxisMin < 0 ? n + this.x - ((0 - this.xAxisMin) * this.xAxisUnit) : n;
						g = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2ValuesRaw : this.xAxisValuesRaw;
						for (var q = k; q < g.length - v; q++) {
							w = g[q];
							if (w >= this.xAxisMin && w <= this.xAxisMax) {
								m = j(w);
								if (this.invertGraph) {
									u = this.graphType == "Candlestick" && this.summaryType == "volume" ? n + this.x - ((w - this.xAxis2Min) * this.xAxis2Unit) : n + this.x - ((w - this.xAxisMin) * this.xAxisUnit)
								} else {
									u = this.graphType == "Candlestick" && this.summaryType == "volume" ? n + ((w - this.xAxis2Min) * this.xAxis2Unit) : n + ((w - this.xAxisMin) * this.xAxisUnit)
								}
								this.addToRender(["drawText", m, u, c, this.axisTickFont, this.axisTickColor, "center", "middle"], false, false, null, false, b)
							}
						}
					}
					if (!this.layoutValid) {
						u = n + (this.x / 2);
						c = f + this.y + (this.margin * 3) + this.axisTickFontSize + (this.axisTitleFontSize / 2);
						s = this.getAxisDescription(true);
						this.addToRender(["drawText", s, u, c, this.axisTitleFont, this.axisTitleColor, "center", "middle"])
					}
				}
			}
			if (this.plotBox) {
				this.disableGradientTransparencyShadow();
				this.addToRender(["drawShape", "rectangle", n + (this.x / 2), f + (this.y / 2), this.x, this.y, this.plotBoxColor, this.plotBoxColor, "open", false, this.outlineWidth]);
				this.enableGradientTransparencyShadow()
			}
		}
	};
	this.draw1DDataPoints = function() {
		if (this.smpIndices && this.smpIndices.length < 1) {
			return
		}
		if (!this.currentErrorBarsType) {
			this.currentErrorBarsType = this.errorBarsType
		}
		if (this.currentErrorBarsType != this.errorBarsType && this.isGroupedData) {
			this.regroupSamples();
			this.currentErrorBarsType = this.errorBarsType
		}
		if (this.graphType != "Tree") {
			this.addToRender(["setClipArea", this.setClipBoundaries()])
		}
		switch (this.graphType) {
			case "Bar":
				this.draw1DBarDataPoints(this.varIndices, "xAxis");
				if (this.barType == "lollipop") {
					this.draw1DDotplotDataPoints()
				}
				break;
			case "Line":
			case "ParallelCoordinates":
				this.draw1DLineDataPoints(this.varIndices, "xAxis");
				break;
			case "BarLine":
				this.draw1DBarDataPoints(this.xAxisVarIndices, "xAxis");
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Stacked":
			case "StackedPercent":
				this.draw1DStackedDataPoints();
				break;
			case "StackedLine":
			case "StackedPercentLine":
				this.draw1DStackedDataPoints();
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Area":
				this.draw1DAreaDataPoints(this.varIndices, "xAxis");
				break;
			case "AreaLine":
				this.draw1DAreaDataPoints(this.xAxisVarIndices, "xAxis");
				this.draw1DAreaDataPoints(this.xAxis2VarIndices, "xAxis2", true);
				break;
			case "Boxplot":
				if (this.showBoxplotOriginalData) {
					this.draw1DBoxplotDataPoints(true, true);
					this.draw1DDotplotDataPoints(true, true)
				} else {
					if (this.showViolinBoxplot) {
						this.draw1DDotplotDataPoints(true, true);
						this.draw1DBoxplotDataPoints(true, true)
					} else {
						this.draw1DBoxplotDataPoints()
					}
				}
				break;
			case "Candlestick":
				this.draw1DCandlestickDataPoints();
				break;
			case "Dotplot":
				this.draw1DDotplotDataPoints();
				break;
			case "DotLine":
				this.draw1DDotplotDataPoints();
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Heatmap":
				if (this.isContour) {
					if (this.contourType == "overlay") {
						this.draw1DHeatmapDataPoints()
					}
					this.draw1DContour()
				} else {
					this.draw1DHeatmapDataPoints()
				}
				break;
			case "Treemap":
				this.draw1DTreemapDataPoints();
				break;
			case "TagCloud":
				this.draw1DTagCloudDataPoints();
				break;
			case "Sankey":
				this.draw1DSankeyDataPoints();
				break;
			case "Tree":
				this.draw1DTreeDataPoints();
				break
		}
		if (this.graphType != "Tree") {
			this.addToRender(["resetClipArea"])
		}
		return true
	};
	this.draw1DBarDataPoints = function(B, A) {
		var f = this.get1DIndices();
		var D = f.length;
		var w = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
		var h = this.get1DLeft();
		var C = this.get1DTop();
		var g = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * B.length);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			h += this.blockSeparation / 2;
			C = (C + this.y) - w
		} else {
			h += w;
			C += this.blockSeparation / 2
		}
		for (var o = 0; o < B.length; o++) {
			var r = [];
			var q = [];
			var u = [];
			var y = [];
			var b = [];
			for (var k = 0; k < D; k++) {
				u.push(this.getPropertyValue(B[o], f[k], "colorBy"));
				b.push(this.getPropertyValue(B[o], f[k], "patternBy"));
				r.push(this.getDataAtPos(B[o], f[k], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
				if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
					q.push(this.getDataAtPos(B[o], f[k], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
				}
				y.push([B[o], f[k]])
			}
			this.drawBarPlot(r, q, h, C, this.rowBlockSize, g, this[A + "Unit"], w, this[A + "Min"], this.graphOrientation, u, b, y, false, false, this.invertGraph ? this.x - w : false);
			if (this.graphOrientation == "vertical") {
				h = this.plotByVariable ? h + (this.blockSeparation + (this.rowBlockSize * D)) : h + this.rowBlockSize
			} else {
				C = this.plotByVariable ? C + (this.blockSeparation + (this.rowBlockSize * D)) : C + this.rowBlockSize
			}
		}
	};
	this.draw1DLineDataPoints = function(g, f) {
		var A = this.get1DIndices();
		var k = A.length;
		var C = this.get1DLeft();
		var h = this.get1DTop();
		var u = this.graphType == "BarLine" || this.graphType == "DotLine" ? true : false;
		var z = u ? this.blockSeparation + (this.xAxisVarIndices.length * this.rowBlockSize) : this.blockSeparation + this.rowBlockSize;
		var B = this.graphType == "ParallelCoordinates" ? 0 : ((this.blockSeparation + this.rowBlockSize) / 2);
		var I = this.colorBy ? this.getSampleIndices(this.colorBy) : false;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			C += B;
			h += this.y
		} else {
			h += B
		}
		for (var E = 0; E < g.length; E++) {
			var G = [];
			var F = [];
			var H = this.colorBy ? this.getPropertyValue(g[E], I, "colorBy") : this.coordinateLineColor ? this.colors[E % this.colors.length] : this.getVariableColor(this.data.y.vars[g[E]]);
			var y = this.graphType == "DotLine" ? false : this.lineDecoration == "symbol" ? this.shapes[E % this.shapes.length] : "sphere";
			var w = [];
			var J = [];
			for (var D = 0; D < k; D++) {
				G.push(this.getDataAtPos(g[E], A[D], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
				if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
					F.push(this.getDataAtPos(g[E], A[D], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					w.push(this.getPropertyValue(g[E], A[D], "patternBy"))
				}
				J.push([g[E], A[D]])
			}
			this.drawLinePlot(G, F, C, h, this.rowBlockSize / 2, z, this.graphType == "ParallelCoordinates" ? this.parallelCoordinates : this[f + "Unit"], this[f + "Min"], this.graphOrientation, H, w, y, J, false, false, this.invertGraph ? this.x : false, this.data.y.vars[g[E]]);
			if (u && this.xAxisVarIndices.length == this.xAxis2VarIndices.length) {
				if (this.graphOrientation == "vertical") {
					C += this.rowBlockSize
				} else {
					h += this.rowBlockSize
				}
			}
		}
	};
	this.draw1DStackedDataPoints = function() {
		var A = this.get1DIndices();
		var r = A.length;
		var C = this.get1DLeft();
		var o = this.get1DTop();
		var B = this.blockSeparation + this.rowBlockSize;
		var k = this.graphType.match(/Line/) ? this.xAxisVarIndices : this.varIndices;
		var h = this.graphType == "StackedPercentLine" ? this.xAxisVarIndices : false;
		var y = this.graphType.match(/Percent/) ? true : false;
		var e = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
		var u = this.invertGraph ? this.x : false;
		var b = this.graphOrientation == "vertical" ? this.get1DTop() + this.y : this.get1DLeft();
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData("sum")
		}
		if (this.graphOrientation == "vertical") {
			C += this.blockSeparation / 2;
			o += this.y
		} else {
			o += this.blockSeparation / 2
		}
		for (var F = 0; F < r; F++) {
			var G = this.sum(this.getDataForSmpGrpAtIndex(A[F], h), false, false, true);
			var D = this.sum(this.getDataForSmpGrpAtIndex(A[F], h), false, false, false, true);
			var I = [];
			var J = [];
			var x = [];
			var K = [];
			var H = [];
			if (this.isGroupedData && this.treemapBy.length > 0) {
				for (var E = 0; E < k.length; E++) {
					I.push(this.getDataAtPos(k[E], A[F], "sum", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					H.push(this.getTreemapVariable(k[E], this.data.w.grps[A[F]]))
				}
			} else {
				H = false;
				for (var E = 0; E < k.length; E++) {
					I.push(this.getDataAtPos(k[E], A[F], "sum", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					J.push(this.getPropertyValue(k[E], A[F], "colorBy"));
					x.push(this.getPropertyValue(k[E], A[F], "patternBy"));
					K.push([k[E], A[F]])
				}
			}
			this.drawStackedPlot(I, C, o, this.rowBlockSize, H, y, [G, D], this.xAxisUnit, e, this.graphOrientation, J, x, K, false, u, b);
			if (this.graphOrientation == "vertical") {
				C += B
			} else {
				o += B
			}
		}
	};
	this.draw1DAreaDataPoints = function(h, g, G) {
		var b = this;
		var B = this.get1DIndices();
		var r = B.length;
		var D = this.get1DLeft();
		var k = this.get1DTop();
		var C = this.rowBlockSize + this.blockSeparation;
		var H = [];
		var I = [];
		var w = [];
		var J = [];
		var y = [];
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			k += this.y
		}
		if (this.areaType != "stacked" && this.areaType != "percent") {
			var A = [];
			var K = [];
			for (var F = 0; F < h.length; F++) {
				A[F] = b.getDataAtPos(h[F], B[0], false, b.xAxisTransform, b.get1DMinFloorValue(), b.get1DMaxCeilValue());
				K[F] = F
			}
			h.sort(function(d, c) {
				return A[d] - A[c]
			})
		}
		for (var E = 0; E < r; E++) {
			y.push(0)
		}
		for (var F = 0; F < h.length; F++) {
			var e = [];
			var u = g == "xAxis" || this.coordinateLineColor ? this.colors[h[F] % this.colors.length] : this.getVariableColor(this.data.y.vars[h[F]]);
			for (var E = 0; E < r; E++) {
				e.push(this.getDataAtPos(h[F], B[E], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
				y[E] += e[E]
			}
			H.push(e);
			I.push(u);
			w.push("closed");
			J.push([h[F]])
		}
		this.drawAreaPlot(H, D, k, this.x, this.y, C, this.areaType, y, this[g + "Unit"], this[g + "Min"], this[g + "Max"], this.graphOrientation, G, I, w, J, false, this.invertGraph ? this.x : false, B);
		if (this.areaType != "stacked" && this.areaType != "percent") {
			h.sort(function(d, c) {
				return K[d] - K[c]
			})
		}
	};
	this.draw1DBoxplotDataPoints = function(g, F) {
		var A = this.get1DIndices();
		var h = A.length;
		var e = this.varIndices;
		var C = this.get1DLeft();
		var f = this.get1DTop();
		var B = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * e.length);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			C += this.blockSeparation / 2;
			if (this.showViolinBoxplot && this.isRawData) {
				C += this.rowBlockSize / 3
			}
			f += this.y
		} else {
			f += this.blockSeparation / 2;
			if (this.showViolinBoxplot && this.isRawData) {
				f += this.rowBlockSize / 3
			}
		}
		if (!this.isRawData) {
			g = false
		}
		for (var G = 0; G < e.length; G++) {
			var H = [];
			var I = [];
			var w = [];
			var x = [];
			var J = [];
			for (var E = 0; E < h; E++) {
				var u = ["iqr1", "iqr3", "qtl1", "qtl3", "median", "out", "mean"];
				var b = [];
				var y = this.getGroupColor(e[G], A[E]);
				for (var D = 0; D < u.length; D++) {
					b.push(this.getDataAtPos(e[G], A[E], u[D], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
				}
				if (F && this.isRawData) {
					b[5] = false
				}
				H.push(b);
				I.push(g ? this.foreground : y);
				x.push(g ? "open" : this.getPropertyValue(e[G], A[E], "patternBy"));
				J.push(F ? [e[G], A[E], "box"] : [e[G], A[E]]);
				w.push(y)
			}
			if (this.showViolinBoxplot && this.isRawData) {
				this.drawBoxPlot(H, C, f, this.rowBlockSize / 3, B, this.xAxisUnit, this.xAxisMin, this.graphOrientation, I, x, J, w)
			} else {
				this.drawBoxPlot(H, C, f, this.rowBlockSize, B, this.xAxisUnit, this.xAxisMin, this.graphOrientation, I, x, J, w)
			}
			if (this.graphOrientation == "vertical") {
				C = this.plotByVariable ? C + (this.blockSeparation + (this.rowBlockSize * h)) : C + this.rowBlockSize
			} else {
				f = this.plotByVariable ? f + (this.blockSeparation + (this.rowBlockSize * h)) : f + this.rowBlockSize
			}
		}
	};
	this.draw1DCandlestickDataPoints = function() {
		var B = this.get1DIndices();
		var w = B.length;
		var g = this.varIndices;
		var D = this.get1DLeft();
		var q = this.get1DTop();
		var C = this.blockSeparation + (this.rowBlockSize * g.length);
		var A = this.summaryType == "candle" ? true : false;
		var o = A ? this.xAxisUnit : this.xAxis2Unit;
		var f = A ? this.xAxisMin : this.xAxis2Min;
		var H = this.rowBlockSize / 2;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			D += this.blockSeparation / 2;
			q += this.y
		} else {
			q += this.blockSeparation / 2
		}
		for (var G = 0; G < g.length; G++) {
			var I = [];
			var J = this.colors[G % this.colors.length];
			var L = [];
			for (var F = 0; F < w; F++) {
				var y = A ? ["open", "close", "high", "low"] : ["volume"];
				var e = [];
				for (var E = 0; E < y.length; E++) {
					e.push(this.getDataAtPos(g[G], B[F], y[E], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
				}
				I.push(e);
				L.push([g[G], B[F]])
			}
			this.drawCandlestickPlot(I, D, q, this.rowBlockSize, C, o, f, A, this.graphOrientation, J, L);
			if (this.stockIndicators.length > 0) {
				for (var F = 0; F < this.stockIndicators.length; F++) {
					var K = this.getTechnicalIndicatorColor(this.stockIndicators[F]);
					var I = [];
					for (var E = 0; E < w; E++) {
						I.push(this.getDataAtPos(g[G], B[E], this.stockIndicators[F], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
					}
					if (this.graphOrientation == "vertical") {
						this.drawLinePlot(I, [], D + H, q, this.rowBlockSize, C, o, f, this.graphOrientation, K, false, false, false, false, false, false, this.stockIndicators[F])
					} else {
						this.drawLinePlot(I, [], D, q + H, this.rowBlockSize, C, o, f, this.graphOrientation, K, false, false, false, false, false, false, this.stockIndicators[F])
					}
				}
			}
			if (this.graphOrientation == "vertical") {
				D += this.rowBlockSize
			} else {
				q += this.rowBlockSize
			}
		}
	};
	this.setConnectData = function(g, h) {
		if (this.connectBy && this.data.x && this.data.x.hasOwnProperty(this.connectBy)) {
			this.connectByDataVar = [];
			this.connectByData = {};
			var c, f;
			var e = 0;
			for (var d = 0; d < g.length; d++) {
				if (this.isGroupedData) {
					for (var b = 0; b < this.data.w.grps[g[d]].length; b++) {
						f = this.data.w.grps[g[d]][b];
						c = this.data.x[this.connectBy][f];
						if (!this.connectByData.hasOwnProperty(c)) {
							this.connectByData[c] = []
						}
						this.connectByData[c].push(e);
						e++
					}
				} else {
					f = g[d];
					c = this.data.x[this.connectBy][f];
					if (!this.connectByData.hasOwnProperty(c)) {
						this.connectByData[c] = []
					}
					this.connectByData[c].push(d)
				}
			}
		} else {
			if (this.connectBy && this.data.z && this.data.z.hasOwnProperty(this.connectBy)) {
				this.connectByDataVar = [];
				this.connectByData = {};
				var c, f;
				var e = 0;
				for (var d = 0; d < h.length; d++) {
					f = h[d];
					c = this.data.z[this.connectBy][f];
					if (!this.connectByData.hasOwnProperty(c)) {
						this.connectByData[c] = []
					}
					this.connectByData[c].push(d)
				}
			}
		}
	};
	this.draw1DDotplotDataPoints = function(P, B) {
		var O = this.get1DIndices();
		var I = O.length;
		var F = this.graphType == "DotLine" ? this.xAxisVarIndices : this.varIndices;
		var R = this.get1DLeft();
		var H = this.get1DTop();
		var ab = this.dotplotType == "stacked" ? ((this.blockSeparation + this.rowBlockSize) / 2) + this.blockSeparation : ((this.blockSeparation + this.rowBlockSize) / 2);
		var Q = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * F.length);
		var q = this.graphType.match(/Bar/) && this.barType == "lollipop" && !this.isGroupedData ? true : false;
		var M = this.jitter;
		this.setConnectData(O, this.varIndices);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (q) {
			this.jitter = false
		}
		if (this.graphOrientation == "vertical") {
			R += ab;
			H += this.y
		} else {
			H += ab
		}
		for (var U = 0; U < F.length; U++) {
			var Z = [];
			var Y = [];
			var aa = [];
			var V = [];
			var L = [];
			var X = [];
			var ac = [];
			var W = 0;
			var N;
			for (var T = 0; T < I; T++) {
				if (this.isGroupedData) {
					var A = [];
					var C = [];
					var D = [];
					var K = [];
					var E = [];
					var G = [];
					var J = this.isTransformedData || (this.showBoxplotOriginalData && this.data.y.trans) ? this.data.y.trans : this.data.y.data;
					this.isGroupedData = false;
					for (var S = 0; S < this.data.w.grps[O[T]].length; S++) {
						N = this.getPropertyValue(F[U], this.data.w.grps[O[T]][S], "colorBy");
						A.push(J[F[U]][this.data.w.grps[O[T]][S]]);
						E.push(this.getPropertyValue(F[U], this.data.w.grps[O[T]][S], "shapeBy"));
						C.push(this.getPropertyValue(F[U], this.data.w.grps[O[T]][S], "sizeBy"));
						D.push(P ? this.addColorTransparency(N, this.boxplotDataPointTransparency) : N);
						K.push(this.getPropertyValue(F[U], this.data.w.grps[O[T]][S], "patternBy"));
						G.push([F[U], O[T], this.data.w.grps[O[T]][S]]);
						W++
					}
					this.isGroupedData = true;
					if (this.data.w.hasOwnProperty("stdev")) {
						Y.push([this.getDataAtPos(F[U], O[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()), this.getDataAtPos(F[U], O[T], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())])
					}
					Z.push(A);
					L.push(E);
					X.push(C);
					aa.push(D);
					V.push(K);
					ac.push(G)
				} else {
					N = this.getPropertyValue(F[U], O[T], "colorBy");
					Z.push([this.getDataAtPos(F[U], O[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())]);
					if (this.data.y.hasOwnProperty("stdev")) {
						Y.push([this.getDataAtPos(F[U], O[T], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())])
					}
					L.push([this.getPropertyValue(F[U], O[T], "shapeBy")]);
					X.push([q ? this.rowBlockSize * this.barLollipopFactor : this.getPropertyValue(F[U], O[T], "sizeBy")]);
					aa.push([P ? this.addColorTransparency(N, this.boxplotDataPointTransparency) : N]);
					V.push([this.getPropertyValue(F[U], O[T], "patternBy")]);
					ac.push([
						[F[U], O[T]]
					])
				}
			}
			if (this.plotByVariable) {
				this.drawDotPlot(Z, Y, R, H, this.rowBlockSize, Q, this.xAxisUnit, this.xAxisMin, X, this.graphOrientation, aa, V, L, (q ? false : ac), false, false, this.invertGraph ? this.x : false, this.data.y.vars[F[U]], U == F.length - 1)
			} else {
				this.drawDotPlot(Z, Y, R, H, this.blockSeparation, Q, this.xAxisUnit, this.xAxisMin, X, this.graphOrientation, aa, V, L, (q ? false : ac), false, false, this.invertGraph ? this.x : false, this.data.y.vars[F[U]], U == F.length - 1)
			}
			if (this.graphOrientation == "vertical") {
				if (this.dotplotType != "stacked") {
					R = this.plotByVariable ? R + (this.blockSeparation + (this.rowBlockSize * I)) : R + this.rowBlockSize
				}
			} else {
				if (this.dotplotType != "stacked") {
					H = this.plotByVariable ? H + (this.blockSeparation + (this.rowBlockSize * I)) : H + this.rowBlockSize
				}
			}
		}
		this.jitter = M
	};
	this.draw1DHeatmapDataPoints = function() {
		this.functionCaller = "draw1DHeatmapDataPoints";
		var P = this.get1DIndices();
		var V = this.isGroupedData ? this.data.w : this.data.y;
		var K = P.length;
		var R = this.get1DLeft();
		var J = this.get1DTop();
		var W = this.colBlockSize < 4 || this.rowBlockSize < 4 || !this.heatmapCellBox ? true : false;
		var Q = Math.max(Math.min(this.colBlockSize, this.rowBlockSize) - 10, 3);
		var S = this.dataSizes && this.dataSizes.length > 0 ? Q / this.max(this.dataSizes) : 1;
		var L = this.outlineWidth;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.isMultidimensionalData || this.isOncoprint) {
			if (this.isOncoprint) {
				var g = "rgb(220,220,220)";
				var r = "rgb(255,0,0)";
				var F = "rgb(0,153,0)";
				var b = "rgb(0,0,255)";
				var A = this.colBlockSize * 0.8;
				var ab = this.rowBlockSize * 0.9;
				var h = this.rowBlockSize * 0.3;
				for (var U = 0; U < this.varIndices.length; U++) {
					for (var T = 0; T < K; T++) {
						var E = R + (U * this.colBlockSize) + (this.colBlockSize / 2);
						var C = J + (T * this.rowBlockSize) + (this.rowBlockSize / 2);
						var B = C + h;
						var H = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
						var Q = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue(), true);
						var M = this.getPropertyValue(this.varIndices[U], P[T], "patternByData");
						var Y = !isNaN(H) ? this.getColorForValue(false, H) : this.missingDataColor;
						var N = this.getPropertyValue(this.varIndices[U], P[T], "outlineByData");
						var I = this.getPropertyValue(this.varIndices[U], P[T], "shapeByData");
						var G = this.getPropertyValue(this.varIndices[U], P[T], "sizeByData");
						this.addToRender(["drawShape", "rect", E, C, A, ab, g, g, M], [this.varIndices[U], P[T]], false, null, false, [this.left, C, 0, ab]);
						if (H >= this.oncoprintAmplification) {
							this.addToRender(["drawShape", "rect", E, C, A, ab, r, r, M], false, false, null, false, [this.left, C, 0, ab])
						} else {
							if (H <= this.oncoprintDeletion) {
								this.addToRender(["drawShape", "rect", E, C, A, ab, b, b, M], false, false, null, false, [this.left, C, 0, ab])
							}
						}
						if (Q && ((isNaN(Q) && !Q.toString().match(/^no$|^-$|^neg$/i)) || Q > 0)) {
							this.addToRender(["drawShape", "rect", E, C, A, A, F, F, M], false, false, null, false, [this.left, C, 0, ab]);
							if (this.oncoprintCode) {
								this.addToRender(["drawText", Q, E, C, this.varLabelFont, this.varLabelFontColor, "center", "middle"], false, false, null, false, [this.left, C, 0, ab])
							}
						}
						if (this.isMultidimensionalData) {
							var O = G ? this.percentile(this.sizes[0], this.sizes[this.sizes.length - 1], G) / 10 : 1;
							if (O == 0) {
								O = 1
							}
							if (I) {
								N = N ? N : this.foreground;
								this.addToRender(["drawShape", I, E, B, A * O, h * O, N, N, M], false, false, null, false, this.left)
							} else {
								if (N) {
									this.addToRender(["drawShape", "circle", E, B, A * O, h * O, N, N, M], false, false, null, false, this.left)
								}
							}
						}
					}
				}
			} else {
				for (var U = 0; U < this.varIndices.length; U++) {
					for (var T = 0; T < K; T++) {
						var E = R + (U * this.colBlockSize) + (this.colBlockSize / 2);
						var C = J + (T * this.rowBlockSize) + (this.rowBlockSize / 2);
						var H = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
						var Y = !isNaN(H) ? this.getColorForValue(false, H) : this.missingDataColor;
						N = this.outlineBy ? this.getPropertyValue(this.varIndices[U], P[T], "outlineByData") : Y;
						var I = this.getPropertyValue(this.varIndices[U], P[T], "shapeByData");
						var G = this.getPropertyValue(this.varIndices[U], P[T], "sizeByData");
						var M = this.getPropertyValue(this.varIndices[U], P[T], "patternByData");
						this.addToRender(["drawShape", I, E, C, G, G, Y, N, M], [this.varIndices[U], P[T]], false, null, false, this.left);
						if (this.showDataValues) {
							this.addToRender(["drawText", this.correctPrecisionBug(H), (E + (this.colBlockSize / 2)) - 2, (C + (this.rowBlockSize / 2)) - 2, this.overlayFont, this.foreground, "right", "bottom"], false, false, null, false, this.left)
						}
					}
				}
			}
			this.outlineWidth = L
		} else {
			var I = 0;
			for (var U = 0; U < K; U++) {
				var X = [];
				var aa = [];
				var M = [];
				for (var T = 0; T < this.varIndices.length; T++) {
					X.push(this.getDataAtPos(this.varIndices[T], P[U], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					aa.push([this.varIndices[T], P[U]]);
					if (this.patternBy) {
						M.push(this.getPropertyValue(this.varIndices[T], P[U], "patternBy"))
					} else {
						M.push("solid")
					}
				}
				if (U > 0 && U < K - 1) {
					if (I >= 0.5) {
						this.drawHeatmap(X, R, J, this.colBlockSize, this.rowBlockSize, W, aa, false, M, this.meta.def.colorBrew);
						if (this.heatmapCellBox) {
							this.addToRender(["drawLine", "line", R - 1, J, R + this.x + 1, J, this.heatmapCellBoxColor, this.heatmapCellBoxWidth], false, false, null, true)
						}
						I = 0
					}
				} else {
					this.drawHeatmap(X, R, J, this.colBlockSize, this.rowBlockSize, W, aa, false, M, this.meta.def.colorBrew);
					if (U > 0) {
						if (this.heatmapCellBox) {
							this.addToRender(["drawLine", "line", R - 1, J, R + this.x + 1, J, this.heatmapCellBoxColor, this.heatmapCellBoxWidth], false, false, null, true)
						}
					}
				}
				J += this.rowBlockSize;
				I += this.rowBlockSize
			}
			if (!W) {
				R = this.get1DLeft();
				J = this.get1DTop();
				this.addToRender(["drawLine", "line", R - 1, J - 1, R - 1, J + this.y + 1, this.heatmapCellBoxColor, this.heatmapCellBoxWidth], false, false, null, true);
				for (var U = 0; U <= this.varIndices.length; U++) {
					this.addToRender(["drawLine", "line", R, J - 1, R, J + this.y + 1, this.heatmapCellBoxColor, this.heatmapCellBoxWidth], false, false, null, true);
					R += this.colBlockSize
				}
				R = this.get1DLeft()
			}
			if (this.highlightSmp.length > 0 || this.highlightVar.length > 0) {
				J = this.get1DTop();
				R = this.get1DLeft();
				var ac = this.getObjectArray(this.highlightVar);
				var Z = this.getObjectArray(this.highlightSmp);
				var G = this.heatmapCellBoxWidth + this.heatmapCellBoxHighlightWidth;
				var D = G / 2;
				if (this.highlightSmp.length == 0) {
					for (var U = 0; U < this.varIndices.length; U++) {
						if (ac.hasOwnProperty(V.vars[this.varIndices[U]])) {
							this.addToRender(["drawShape", "rectangle", (R + D) + ((this.colBlockSize - G) / 2), (J + D) + ((this.y - G) / 2), this.colBlockSize - G, this.y - G, false, this.heatmapCellBoxColorHighlight, "open", false, G], false, false, null, true)
						}
						R += this.colBlockSize
					}
				} else {
					if (this.highlightVar.length == 0) {
						for (var U = 0; U < K; U++) {
							if (Z.hasOwnProperty(V.smps[P[U]])) {
								this.addToRender(["drawShape", "rectangle", (R + D) + ((this.x - G) / 2), (J + D) + ((this.rowBlockSize - G) / 2), this.x - G, this.rowBlockSize - G, false, this.heatmapCellBoxColorHighlight, "open", false, G], false, false, null, true)
							}
							J += this.rowBlockSize
						}
					} else {
						for (var U = 0; U < K; U++) {
							R = this.get1DLeft();
							for (var T = 0; T <= this.varIndices.length; T++) {
								if (Z.hasOwnProperty(V.smps[P[U]]) && ac.hasOwnProperty(V.vars[this.varIndices[T]])) {
									this.addToRender(["drawShape", "rectangle", (R + D) + ((this.colBlockSize - G) / 2), (J + D) + ((this.rowBlockSize - G) / 2), this.colBlockSize - G, this.rowBlockSize - G, false, this.heatmapCellBoxColorHighlight, "open", false, G], false, false, null, true)
								}
								R += this.colBlockSize
							}
							J += this.rowBlockSize
						}
					}
				}
			}
		}
	};
	this.draw1DTreemapDataPoints = function() {
		var c = this.get1DLeft();
		var d = this.get1DTop();
		var b = this.getTreemap();
		this.drawTreemap(b, c, d)
	};
	this.draw1DTagCloudDataPoints = function(h) {
		var g = this.randomSeed;
		this.setTagCloud(h);
		var k = this.varIndices[0];
		for (var e = 0; e < this.smpIndices.length; e++) {
			var b = this.smpIndices[e];
			var j = this.getDataAtPos(k, b);
			var l = this.colorBy ? this.getPropertyValue(k, b, "colorBy") : this.foreground;
			if (!this.drawCloudTag(this.data.y.smps[b], j, l, [k, b])) {
				this.resizeCanvas();
				this.meta.render = {
					objects: [],
					groups: {},
					types: {},
					order: [],
					map: {},
					origin: [],
					transition: false
				};
				if (this.pseudoRandom) {
					this.randomSeed = g
				}
				this.draw1DTagCloudDataPoints(0.9);
				break
			}
		}
		if (this.pseudoRandom) {
			this.randomSeed = g
		}
	};
	this.draw1DContour = function() {
		this.functionCaller = "draw1DContour";
		var w, e, v, d;
		if (this.isContour) {
			var g = this.data.y.contour.list;
			var y = this.getColorBrew(this.colorSpectrum, 0, g[0].level, this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var b = this.varIndices.length - 1;
			var n = this.smpIndices.length - 1;
			var p = (this.x - this.colBlockSize) / b;
			var o = (this.y - this.rowBlockSize) / n;
			var m = this.varIndices[0] * p;
			var k = this.smpIndices[0] * o;
			var r = (this.get1DLeft() + (this.colBlockSize / 2)) - m;
			var h = (this.get1DTop() + (this.rowBlockSize / 2)) - k;
			var x = 10;
			if (this.contourType == "overlay") {
				for (var u = 0; u < g.length; u++) {
					w = r + (g[u][0].x * p);
					e = h + (g[u][0].y * o);
					for (var s = 1; s < g[u].length; s++) {
						v = r + (g[u][s].x * p);
						d = h + (g[u][s].y * o);
						this.addToRender(["drawLine", "line", w, e, v, d, this.foreground, false, false, false, false, true]);
						w = v;
						e = d
					}
				}
			} else {
				if (this.contourType == "color") {
					this.addToRender(["drawShape", "rectangle", r + ((this.x - this.colBlockSize) / 2), h + ((this.y - this.rowBlockSize) / 2), this.x - this.colBlockSize, this.y - this.rowBlockSize, this.getColorForValue(y, 0)]);
					for (var u = g.length - 1; u >= 0; u--) {
						var c = [];
						var q = [];
						var f = this.getColorForValue(y, g[u].level);
						for (var s = 0; s < g[u].length; s++) {
							c.push(r + (g[u][s].x * p));
							q.push(h + (g[u][s].y * o))
						}
						if (g[u][0].x != g[u][g[u].length - 1].x || g[u][0].y != g[u][g[u].length - 1].y) {
							if (g[u][0].x == 0 || g[u][0].x == b) {
								c.push(r + (g[u][0].x * p));
								q.push(h + (g[u][g[u].length - 1].y * o))
							} else {
								if (g[u][g[u].length - 1].x == 0 || g[u][g[u].length - 1].x == b) {
									c.push(r + (g[u][g[u].length - 1].x * p));
									q.push(h + (g[u][0].y * o))
								}
							}
						}
						this.addToRender(["drawShape", "path", c, q, false, false, f, f, "closed", false, false, true])
					}
				}
			}
		}
	};
	this.draw1DSankeyDataPoints = function() {
		if (!this.moveSankey) {
			this.setSankey()
		}
		var b = this.get1DLeft();
		var n = this.get1DTop();
		var p = this.data.sankey;
		var k = p.links[0].target.x - p.links[0].source.x;
		for (var h = 0; h < p.nodes.length; h++) {
			var f = p.nodes[h];
			f.plotX = f.x + b;
			f.plotY = f.y + n;
			f.color = this.addColorTransparency(this.colors[h % this.colors.length], 0.75);
			f.tooltip = ["Sankey:" + f.name + ":" + h]
		}
		for (var h = 0; h < p.links.length; h++) {
			var m = p.links[h];
			var o = (m.dy / 2);
			m.plotX = [];
			m.plotY = [];
			m.tooltip = [this.hierarchyVarIndex, m.id];
			for (var e = 0; e < 4; e++) {
				m.plotX.push(m.bezier[0][e] + b);
				m.plotY.push(m.bezier[1][e] + n - o)
			}
			if (this.colorBy) {
				m.color = this.addColorTransparency(this.getPropertyValue(this.hierarchyVarIndex, m.id, "colorBy"), 0.75)
			} else {
				if (this.sankeyCoordinateColor) {
					var g = this.addColorTransparency(m.source.color, 0.75);
					var c = this.addColorTransparency(m.target.color, 0.75);
					m.color = this.getLinearGradient(0, 0, k, 0, g, c);
					m.colors = [g, c]
				} else {
					m.color = this.sankeyColor
				}
			}
		}
		this.drawSankey(p)
	};
	this.draw1DTreeDataPoints = function() {
		this.setTree();
		if (this.data.tree && this.data.tree.plot) {
			var b = this.data.tree.plot;
			var d = this.get1DLeft();
			var j = this.get1DTop();
			var f = this;
			var c = this.data.tree.plot.leaves().length;
			var e = this.treeInverted ? -1 : 1;
			var i = function(m) {
				var k = m.x / 180 * Math.PI;
				var l = m.y;
				m.y = e * l * Math.sin(k) + (f.x / 2);
				m.x = e * l * Math.cos(k) + (f.y / 2)
			};
			var h = function(m) {
				var l = m.descendants();
				for (var k = 0; k < l.length; k++) {
					if (!l[k]._children) {
						delete(l[k].data.color);
						delete(l[k].data.shape);
						delete(l[k].data.size);
						delete(l[k].data.pattern)
					}
				}
			};
			var g = function(q) {
				if (q.children) {
					for (var l = 0; l < q.children.length; l++) {
						g(q.children[l])
					}
				}
				if (f.treeCircular) {
					i(q)
				}
				if (f.graphOrientation == "vertical" && !f.treeCircular) {
					q.y0 = f.treeInverted ? (b.size[1] - q.y) + j : q.y + j;
					q.x0 = f.treeInverted ? (b.size[0] - q.x) + d : q.x + d
				} else {
					if (f.graphOrientation == "horizontal" && !f.treeCircular) {
						q.y0 = f.treeInverted ? (b.size[1] - q.y) + d : q.y + d;
						q.x0 = f.treeInverted ? (b.size[0] - q.x) + j : q.x + j
					} else {
						q.y0 = q.y + d;
						q.x0 = q.x + j
					}
				}
				if (!f.colorBy) {
					q.data.color = f.background
				} else {
					if (f.colorBy && !q.data.color) {
						q.data.color = q.data.idx != null ? f.getPropertyValue(false, q.data.idx, "colorBy") : f.background
					}
				}
				if (!f.shapeBy) {
					q.data.shape = "sphere"
				} else {
					if (f.shapeBy && !q.data.shape) {
						q.data.shape = q.data.idx != null ? f.getPropertyValue(false, q.data.idx, "shapeBy") : "sphere"
					}
				}
				if (!f.sizeBy) {
					q.data.size = f.treeNodeSize
				} else {
					if (f.sizeBy && !q.data.size) {
						q.data.size = q.data.idx != null ? f.getPropertyValue(false, q.data.idx, "sizeBy") : f.treeNodeSize
					}
				}
				if (!f.patternBy) {
					q.data.pattern = "solid"
				} else {
					if (f.patternBy && !q.data.pattern) {
						q.data.pattern = q.data.idx != null ? f.getPropertyValue(false, q.data.idx, "patternBy") : "solid"
					}
				}
				q.data.tooltip = "Tree:" + q.data.name + " (" + q.leaves().length + ")";
				if (q.parent) {
					var o = [];
					var k = [];
					var p = [];
					var m = [];
					for (var l = 0; l < q.parent.children.length; l++) {
						o.push(q.parent.children[l].data.color);
						k.push(q.parent.children[l].data.size);
						p.push(q.parent.children[l].data.shas);
						m.push(q.parent.children[l].data.pats)
					}
					q.parent.data.color = f.combineColors(o);
					q.parent.data.size = f.mean(k);
					if (f.isUnique(p)) {
						q.parent.data.shape = p[0]
					}
					if (f.isUnique(m)) {
						q.parent.data.pattern = m[0]
					}
				}
			};
			h(this.data.tree.plot);
			g(this.data.tree.plot);
			this.drawTree(f.graphOrientation)
		}
	};
	this.checkOrientation = function() {
		if (this.graphType == "Heatmap") {
			this.graphOrientation = "horizontal"
		} else {
			if (this.graphType == "Sankey") {
				this.graphOrientation = "vertical"
			}
		}
	};
	this.checkClustering = function() {
		if (this.samplesClustered) {
			this.clusterSamples(false, true)
		}
		if (this.variablesClustered) {
			this.clusterVariables(false, true)
		}
		if (this.samplesKmeaned) {
			this.kmeansSamples(false, true)
		}
		if (this.variablesKmeaned) {
			this.kmeansVariables(false, true)
		}
	};
	this.checkSamplesGrouping = function() {
		if (this.groupingFactors.length > 0 && !this.isGroupedData) {
			if (this.layoutComb && this.data.l && this.data.l.group && this.isSameObject(this.data.l.group.sort(), this.groupingFactors.sort())) {} else {
				this.groupSamples(this.getGroupingFactors(true), false, false, true, true)
			}
		}
	};
	this.checkDataTransform = function() {
		if (this.transformedData && this.transformType && !this.isTransformedData) {
			this.transform(this.transformType, this.transformAxis, false, true);
			if (this.graphType != "Candlestick" || (this.graphType == "Candlestick" && !this.showVolume)) {
				this.initAxes();
				this.setColorBrew(true)
			}
		}
	};
	this.checkSegregation = function() {
		if (this.graphType != "Candlestick" && !this.isDOE) {
			this.validateSegregation();
			if (this.data.l) {
				if (this.segregateSamplesBy.length == 0) {} else {
					if (!this.data.l.smps) {
						this.segregateSamples(this.segregateSamplesBy, true)
					}
				}
				if (this.segregateVariablesBy.length == 0) {} else {
					if (!this.data.l.vars) {
						this.segregateVariables(this.segregateVariablesBy, true)
					}
				}
			} else {
				if (this.segregateSamplesBy.length > 0 && this.segregateVariablesBy.length > 0) {
					this.segregateSamplesVariables(true)
				} else {
					if (this.segregateSamplesBy.length > 0) {
						this.segregateSamples(this.segregateSamplesBy, true)
					} else {
						if (this.segregateVariablesBy.length > 0) {
							this.segregateVariables(this.segregateVariablesBy, true)
						}
					}
				}
			}
		}
	};
	this.checkMultidimensional = function() {
		var d = this.graphType == "Heatmap" ? ["outline", "shape", "size", "pattern"] : ["color", "outline", "shape", "size", "pattern"];
		for (var c = 0; c < d.length; c++) {
			var b = d[c] + "ByData";
			if (this[b] && this.data.y[this[b]] && this.isArray(this.data.y[this[b]])) {
				this.isMultidimensionalData = true
			}
		}
	};
	this.checkTreemap = function() {
		if (this.graphType == "Treemap") {
			this.showVarDendrogram = true
		}
	};
	this.checkOncoprint = function() {
		if (this.isOncoprint) {
			if (!this.data.y.hasOwnProperty(this.isOncoprint)) {
				this.isOncoprint = false
			} else {
				this.summarizeOncoprint()
			}
		}
	};
	this.validate1DPropertyDefaults = function() {
		this.checkOrientation();
		this.checkSamplesGrouping();
		this.checkDataTransform();
		this.checkClustering();
		this.checkSegregation();
		this.checkMultidimensional();
		this.checkTreemap();
		this.checkOncoprint()
	};
	this.setOverlaysDendrogramVariable = function() {
		if (this.isDOE) {
			this.showOverlays = false;
			this.showVarDendrogram = false;
			this.showSmpDendrogram = false;
			this.smpTitle = false
		} else {
			if (this.plotByVariable) {
				if (this.graphType.match(/^Bar$|Boxplot|Dotplot/)) {
					this.showOverlays = false;
					this.showVarDendrogram = false;
					this.showSmpDendrogram = false
				} else {
					this.plotByVariable = false
				}
			}
		}
	};
	this.set1DAttributes = function() {
		this.setDendrograms();
		this.setOverlayFont()
	};
	this.set1DOverlays = function() {
		this.validateOverlays();
		this.setOverlays("var");
		this.setOverlays("smp")
	};
	this.draw1DLayout = function() {
		this.drawDendrograms();
		this.draw1DXLayout();
		this.draw1DYLayout()
	};
	this.draw1DData = function() {
		this.drawPlotWindow();
		this.draw1DWireFrame();
		this.draw1DDataPoints();
		this.draw1DLayout();
		this.draw1DOverlays();
		this.drawDecorationData();
		this.drawLegend();
		this.drawTitle()
	};
	this.draw1DPlot = function() {
		this.checkOrientation();
		this.validatePropertyValues();
		this.setOverlaysDendrogramVariable();
		this.set1DAttributes();
		this.set1DOverlays();
		this.set1DXYDimensions();
		this.set1DPrivateParams();
		this.set1DXAxis();
		this.draw1DData()
	};
	this.restoreOriginalSettings = function() {
		var e = this.meta.config.orig;
		var c = ["varLabelScaleFontFactor", "showVariableNames", "showSampleNames", "varLabelDescription", "smpLabelScaleFontFactor", "smpLabelDescription", "insideLegend", "legendFontSize", "showLegend", "legendPosition"];
		for (var b = 0; b < c.length; b++) {
			var d = c[b];
			if (e[d]) {
				this[d] = e[d];
				delete(e[d])
			}
		}
		this.adjustAspectRatioXTries = 0;
		this.adjustAspectRatioYTries = 0
	};
	this.initialize1DPlot = function() {
		this.validate1DPropertyDefaults();
		if (this.layoutValid) {
			this.drawLayoutCompartments(this.draw1DPlot)
		} else {
			this.draw1DPlot()
		}
		this.restoreOriginalSettings();
		this.resetInitialFontSize()
	};
	if (!a) {
		this.initialize1DPlot()
	}
};
CanvasXpress.prototype.Network = function(a) {
	this.findXYCoordinates = function(d) {
		var b = this.adjustedCoordinates(d);
		var f = {};
		f.x = (b.x / this.scaleFactor || 1) - this.offsetX;
		f.y = (b.y / this.scaleFactor || 1) - this.offsetY;
		return f
	};
	this.addNode = function(e, d) {
		if (e) {
			if (!e.id) {
				var b = 0;
				var f = "id" + b;
				while (this.nodes.hasOwnProperty(f)) {
					b++;
					f = "id" + b
				}
				e.id = f
			}
			if (!e.color) {
				e.color = this.colors[0]
			}
			if (!e.shape) {
				e.shape = this.shapes[0]
			}
			if (!e.size) {
				e.size = 1
			}
			if (d) {
				var c = this.findXYCoordinates(d);
				e.x = c.x;
				e.y = c.y
			}
			this.data.nodeIndices[e.id] = this.data.nodes.length;
			this.data.nodes.push(e);
			this.nodes[e.id] = e;
			return e
		}
	};
	this.getNodeConfigurableProperties = function(b) {
		var d = this.getObjectArray(this.nodeConfigurableProperties);
		if (b) {
			for (var c in this.data.nodes[b]) {
				d[c] = true
			}
		}
		return this.getKeys(d)
	};
	this.getEdgeConfigurableProperties = function(c) {
		var d = this.getObjectArray(this.edgeConfigurableProperties);
		if (c) {
			for (var b in this.data.edges[c]) {
				d[b] = true
			}
		}
		return this.getKeys(d)
	};
	this.removeNode = function(e, l) {
		if (e && e.id) {
			var b = l ? this.getObjectArray(this.findChildrenNodeIndices(e.id)) : false;
			var h = [];
			var d = 0;
			if (this.nodeParentHood[e.id] && this.nodeParentHood[e.id].children) {
				for (var k = 0; k < this.nodeParentHood[e.id].children.length; k++) {
					var m = this.nodeParentHood[e.id].children[k];
					if (this.data.nodeIndices[m] && this.data.nodes[this.data.nodeIndices[m]]) {
						delete(this.data.nodes[this.data.nodeIndices[m]].parentNode)
					}
				}
			}
			this.data.nodeIndices = {};
			for (var k = 0; k < this.data.nodes.length; k++) {
				if (this.data.nodes[k].id != e.id) {
					if (b && b.hasOwnProperty(k)) {
						var g = this.edgesForNode(this.data.edges, this.data.nodes[k].id);
						for (var f = 0; f < g.length; f++) {
							this.removeEdge(g[f])
						}
					} else {
						h.push(this.data.nodes[k]);
						this.data.nodeIndices[this.data.nodes[k].id] = d;
						d++
					}
				} else {
					var g = this.edgesForNode(this.data.edges, e.id);
					for (var f = 0; f < g.length; f++) {
						this.removeEdge(g[f])
					}
				}
			}
			this.data.nodes = h
		}
	};
	this.addEdge = function(b) {
		if (b && b.id1 && b.id2) {
			if (!b.color) {
				b.color = this.colors[0]
			}
			if (!b.width) {
				b.width = 1
			}
			if (!b.type) {
				b.type = "line"
			}
			this.data.edges.push(b)
		}
	};
	this.removeEdge = function(d) {
		if (d && d.id1 && d.id2) {
			var c = [];
			for (var b = 0; b < this.data.edges.length; b++) {
				if (this.data.edges[b].id1 != d.id1 || this.data.edges[b].id2 != d.id2) {
					c.push(this.data.edges[b])
				}
			}
			this.data.edges = c
		}
	};
	this.getAllObjectAttributes = function(d) {
		var e = [];
		if (this.data[d]) {
			for (var c = 0; c < this.data[d].length; c++) {
				for (var b in this.data[d][c]) {
					if (e.hasOwnProperty(b)) {
						e[b]++
					} else {
						e[b] = 1
					}
				}
			}
		}
		return e
	};
	this.setAllObjectAttributes = function(b, o, t, k) {
		if (this.data[b]) {
			var e = this.meta.data[b];
			var g = this.getAllObjectAttributeValues(b, t);
			if (g) {
				if (this.isNumeric(g)) {
					e[t] = {
						type: "Numeric"
					};
					var h = this.range(g);
					if (o == "color") {
						var r = this.getColorBrew(this.colorSpectrum, h[0], h[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
						this.networkColorBrew = r;
						for (var p = 0; p < this.data[b].length; p++) {
							if (this.data[b][p].hasOwnProperty(t)) {
								var u = this.data[b][p][t];
								var c = this.getColorForValue(r, u);
								this.data[b][p][o] = c
							} else {
								this.data[b][p][o] = this.missingDataColor
							}
						}
					} else {
						if (o == "size") {
							for (var p = 0; p < this.data[b].length; p++) {
								if (this.data[b][p].hasOwnProperty(t)) {
									var u = this.data[b][p][t];
									var n = this.percentile(h[0], h[1], u);
									var q = parseInt(n * 25 / 10);
									if (k) {
										this.data[b][p]["decorationSize"] = 1 + (q / 25)
									} else {
										this.data[b][p][o] = 1 + (q / 100)
									}
								} else {
									if (k) {
										this.data[b][p]["decorationSize"] = 0.1
									} else {
										this.data[b][p][o] = 0.1
									}
								}
							}
						} else {
							if (o == "shape") {
								if (b == "nodes") {
									var j = "square";
									for (var p = 0; p < this.data[b].length; p++) {
										if (this.data[b][p].hasOwnProperty(t)) {
											var u = this.data[b][p][t];
											var n = this.percentile(h[0], h[1], u);
											var m = parseInt(n / 10);
											if (m > 0) {
												m--
											}
											this.data[b][p][o] = "pie" + m
										} else {
											this.data[b][p][o] = j
										}
									}
								} else {
									if (b == "edges") {
										for (var p = 0; p < this.data[b].length; p++) {
											if (this.data[b][p].hasOwnProperty(t)) {
												var u = this.data[b][p][t];
												var n = this.percentile(h[0], h[1], u);
												var m = parseInt(n / 10);
												if (m > 0) {
													m--
												}
												this.data[b][p]["type"] = this.lines[m]
											} else {
												this.data[b][p]["type"] = this.lines[10]
											}
										}
									}
								}
							}
						}
					}
				} else {
					e[t] = {
						type: "String"
					};
					var d = 0;
					var s = 0;
					var f = 0.1;
					var l = {
						color: {},
						shape: {},
						size: {}
					};
					for (var p = 0; p < g.length; p++) {
						if (!l.color.hasOwnProperty(g[p])) {
							l.color[g[p]] = this.colors[d % this.colors.length];
							d++
						}
						if (b == "nodes") {
							if (!l.shape.hasOwnProperty(g[p])) {
								l.shape[g[p]] = this.shapes[s % this.shapes.length];
								s++
							}
						} else {
							if (!l.shape.hasOwnProperty(g[p])) {
								l.lines[g[p]] = this.lines[s % this.lines.length];
								s++
							}
						}
						if (!l.size.hasOwnProperty(g[p])) {
							l.size[g[p]] = f;
							f += 0.1
						}
					}
					for (var p = 0; p < this.data[b].length; p++) {
						if (this.data[b][p].hasOwnProperty(t)) {
							var u = this.data[b][p][t];
							this.data[b][p][o] = l[o][u]
						}
					}
				}
			}
		}
	};
	this.getAllObjectAttributeValues = function(d, b) {
		var e = [];
		if (this.data[d]) {
			for (var c = 0; c < this.data[d].length; c++) {
				if (this.data[d][c].hasOwnProperty(b)) {
					e.push(this.data[d][c][b])
				}
			}
		}
		return e
	};
	this.modifyXYEdgeElbow = function(e, d, c, b) {
		var f = this.data.edges[e].elbows[d];
		f[0] -= c;
		f[1] -= b
	};
	this.getNodeWidth = function(b) {
		return (b.width ? b.width : b.size ? (this.nodeSize * b.size) : this.nodeSize)
	};
	this.getNodeHeight = function(b) {
		return (b.height ? b.height : b.size ? (this.nodeSize * b.size) : this.nodeSize)
	};
	this.modifyNodeSize = function(e, b, c) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		delete(d.size);
		d.width = b;
		d.height = c
	};
	this.modifyXYNode = function(g, d, b) {
		var f = this.data.nodes[this.data.nodeIndices[g]];
		if (!f.fixed) {
			f.x -= d;
			f.y -= b;
			if (f.labelX != null && f.labelY != null) {
				this.modifyXYNodeLab(g, d, b)
			}
			if (f.decorationsX != null && f.decorationsY != null) {
				this.modifyXYNodeDec(g, d, b)
			}
			if (this.networkLayoutType != "radial") {
				if (this.nodeParentHood[f.id] && this.nodeParentHood[f.id]["children"]) {
					for (var e = 0; e < this.nodeParentHood[f.id]["children"].length; e++) {
						var c = this.nodeParentHood[f.id]["children"][e];
						this.modifyXYNode(c, d, b)
					}
				}
			}
		}
	};
	this.modifyXYNodeLab = function(e, c, b) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		if (!d.fixed) {
			d.labelX = d.labelX != null ? d.labelX - c : d.labelXi - c;
			d.labelY = d.labelY != null ? d.labelY - b : d.labelYi - b
		}
	};
	this.modifyXYNodeDec = function(e, c, b) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		if (!d.fixed) {
			d.decorationsX = d.decorationsX != null ? d.decorationsX - c : d.decorationsXi - c;
			d.decorationsY = d.decorationsY != null ? d.decorationsY - b : d.decorationsYi - b
		}
	};
	this.getHiddenNodes = function() {
		var c = [];
		if (this.data.nodes) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (this.data.nodes[b].hide) {
					c.push(this.data.nodes[b])
				}
			}
		}
		return c
	};
	this.orderNodes = function(c) {
		for (var b in this.selectNode) {
			this[c](this.data.nodes[this.data.nodeIndices[b]])
		}
	};
	this.sendNodeToBack = function(d) {
		var c = [d];
		for (var b = 0; b < this.data.nodes.length; b++) {
			if (this.data.nodes[b].id != d.id) {
				c.push(this.data.nodes[b])
			}
		}
		this.data.nodes = c;
		this.setNodeIndices()
	};
	this.sendNodeBackward = function(e) {
		var d = [];
		var b = this.data.nodeIndices[e.id];
		if (b > 0) {
			for (var c = 0; c < b - 1; c++) {
				d.push(this.data.nodes[c])
			}
			d.push(this.data.nodes[b]);
			d.push(this.data.nodes[b - 1]);
			for (var c = b + 1; c < this.data.nodes.length; c++) {
				d.push(this.data.nodes[c])
			}
			this.data.nodes = d;
			this.setNodeIndices()
		}
	};
	this.bringNodeToFront = function(d) {
		var c = [];
		for (var b = 0; b < this.data.nodes.length; b++) {
			if (this.data.nodes[b].id != d.id) {
				c.push(this.data.nodes[b])
			}
		}
		c.push(d);
		this.data.nodes = c;
		this.setNodeIndices()
	};
	this.bringNodeForward = function(e) {
		var d = [];
		var b = this.data.nodeIndices[e.id];
		if (this.data.nodes.length - 1 > b) {
			for (var c = 0; c < b; c++) {
				d.push(this.data.nodes[c])
			}
			d.push(this.data.nodes[b + 1]);
			d.push(this.data.nodes[b]);
			for (var c = b + 2; c < this.data.nodes.length; c++) {
				d.push(this.data.nodes[c])
			}
			this.data.nodes = d;
			this.setNodeIndices()
		}
	};
	this.flashNode = function(j, e, b) {
		j = this.toArray(j);
		var q = (this.maxX - this.minX) / this.scaleFactor;
		var n = (this.maxY - this.minY) / this.scaleFactor;
		var d = 0.015;
		for (var k = 0; k < j.length; k++) {
			var c = j[k];
			var f = this.data.nodes[this.data.nodeIndices[c]];
			var p = f.width ? f.width : f.size ? f.size : this.nodeSize;
			var m = f.height ? f.height : f.size ? f.size : this.nodeSize;
			var l = (p < d * q ? d * q : p) * 1.35;
			var o = (m < d * n ? d * n : m) * 1.35;
			var g = this.adjustNetworkObjects(["circle", f.x, f.y, 1]);
			this.flash(g[1], g[2], l * this.scaleFactor, o * this.scaleFactor, e || this.nodeHighlightColor, b)
		}
	};
	this.highlightNodes = function(b) {
		this.functionCaller = "highlightNodes";
		if (this.isTransition()) {
			return
		}
		if (this.isArray(b)) {
			this.highlightNode = this.highlightNode.concat(b)
		} else {
			this.highlightNode.push(b)
		}
		this.draw()
	};
	this.unHighlightNodes = function(b) {
		this.functionCaller = "unHighlightNodes";
		if (this.isTransition()) {
			return
		}
		var e = [];
		b = this.toArray(b);
		for (var d = 0; d < this.highlightNode.length; d++) {
			var f = false;
			for (var c = 0; c < b.length; c++) {
				if (this.highlightNode[d] == b[c]) {
					f = true;
					break
				}
			}
			if (!f) {
				e.push(this.highlightNode[d])
			}
		}
		this.highlightNode = e;
		this.draw()
	};
	this.addToNetworkStack = function() {
		if (this.networkStack.length >= this.networkStackStates) {
			this.networkStack.shift()
		}
		this.networkStackIndex = this.networkStack.length;
		this.networkStack.push(this.cloneObject(this.data));
		if (this.userEvents.stackchange) {
			this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
		}
	};
	this.undoNetworkOp = function() {
		if (this.canNetworkUndoOp()) {
			this.networkStackIndex--;
			this.nodes = {};
			this.updateData(this.networkStack[this.networkStackIndex]);
			if (this.userEvents.stackchange) {
				this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
			}
		} else {
			if (this.debug) {
				alert("No data in Undo Stack")
			}
		}
	};
	this.canNetworkUndoOp = function() {
		return this.networkStackIndex > 0 ? true : false
	};
	this.redoNetworkOp = function() {
		if (this.canNetworkRedoOp()) {
			this.networkStackIndex++;
			this.nodes = {};
			this.updateData(this.networkStack[this.networkStackIndex]);
			if (this.userEvents.stackchange) {
				this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
			}
		} else {
			if (this.debug) {
				alert("No data in Redo Stack")
			}
		}
	};
	this.canNetworkRedoOp = function() {
		return this.networkStackIndex < this.networkStack.length - 1 ? true : false
	};
	this.clearNetworkStack = function() {
		this.stackNumber = false;
		this.networkStackIndex = 0;
		this.networkStack = [];
		if (this.userEvents.stackchange) {
			this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
		}
	};
	this.addLegend = function(b, e, d) {
		this.inititalizeNetworkLegend();
		if (b && e) {
			if (d && b == "text") {
				var c = this.findXYCoordinates(d);
				e.x = c.x;
				e.y = c.y
			}
			this.data.legend[b].push(e);
			return e
		}
	};
	this.deleteLegend = function(d, e) {
		if (d && e && e.id) {
			var c = [];
			for (var b = 0; b < this.data.legend[d].length; b++) {
				if (this.data.legend[d][b].id != e.id) {
					c.push(this.data.legend[d][b])
				}
			}
			this.data.legend[d] = c;
			delete(this.data.legend.ids[d][e.id])
		}
	};
	this.alignDistributeSelectedNodes = function(k, d, p) {
		this.functionCaller = "alignDistributeSelectedNodes";
		if (this.isTransition()) {
			return
		}
		var g, b, j, t, h;
		var l = this.getSelectedNodeCoordinates();
		if (l || d == 89 || d == 90) {
			if (k) {
				this.cancelEvent(k);
				this.stopEvent(k)
			}
			if (d == 84) {
				g = this.min(l.y);
				for (var h in this.selectNode) {
					var f = this.data.nodes[this.data.nodeIndices[h]];
					this.modifyXYNode(f.id, 0, f.y - g)
				}
			} else {
				if (d == 82) {
					g = this.max(l.x);
					for (var h in this.selectNode) {
						var f = this.data.nodes[this.data.nodeIndices[h]];
						this.modifyXYNode(f.id, f.x - g, 0)
					}
				} else {
					if (d == 66) {
						g = this.max(l.y);
						for (var h in this.selectNode) {
							var f = this.data.nodes[this.data.nodeIndices[h]];
							this.modifyXYNode(f.id, 0, f.y - g)
						}
					} else {
						if (d == 76) {
							g = this.min(l.x);
							for (var h in this.selectNode) {
								var f = this.data.nodes[this.data.nodeIndices[h]];
								this.modifyXYNode(f.id, f.x - g, 0)
							}
						} else {
							if (d == 86) {
								b = this.range(l.y);
								j = this.rank(l.y);
								t = (b[1] - b[0]) / (this.isSelectNodes - 1);
								g = b[0];
								for (var q = 0; q < j.length; q++) {
									h = l.i[j[q]];
									var f = this.data.nodes[this.data.nodeIndices[h]];
									this.modifyXYNode(f.id, 0, f.y - (g + (q * t)))
								}
							} else {
								if (d == 72) {
									b = this.range(l.x);
									j = this.rank(l.x);
									t = (b[1] - b[0]) / (this.isSelectNodes - 1);
									g = b[0];
									for (var q = 0; q < j.length; q++) {
										h = l.i[j[q]];
										var f = this.data.nodes[this.data.nodeIndices[h]];
										this.modifyXYNode(f.id, f.x - (g + (q * t)), 0)
									}
								} else {
									if (d == 90) {
										if (k.shiftKey || p) {
											if (this.canNetworkRedoOp()) {
												this.resetSelectedNodes();
												this.redoNetworkOp()
											}
										} else {
											if (this.canNetworkUndoOp()) {
												this.resetSelectedNodes();
												this.undoNetworkOp()
											}
										}
										return false
									}
								}
							}
						}
					}
				}
			}
			this.draw(false, false, false, true);
			this.addToNetworkStack()
		}
		return false
	};
	this.getSelectedNodeCoordinates = function() {
		var f = {
			x: [],
			y: [],
			i: []
		};
		var b = false;
		for (var d in this.selectNode) {
			var e = this.data.nodes[this.data.nodeIndices[d]];
			f.x.push(e.x);
			f.y.push(e.y);
			f.i.push(d);
			b = true
		}
		return b ? f : false
	};
	this.findNodesBy = function(h) {
		var b = [];
		var l = 0;
		for (var d in h) {
			h[d] = this.toArray(h[d]);
			l++
		}
		for (var k = 0; k < this.data.nodes.length; k++) {
			var e = this.data.nodes[k];
			var f = 0;
			for (var d in h) {
				var o = h[d];
				for (var g = 0; g < o.length; g++) {
					if (e[d] && e[d] == o[g]) {
						f++
					}
				}
			}
			if (f == l) {
				b.push(e)
			}
		}
		return b
	};
	this.setNetworkDimensions = function() {
		this.left = 0;
		this.top = this.getTitleSubtitleHeight();
		this.x = this.width;
		this.y = this.height - this.top
	};
	this.setNetworkPrivateParams = function(b) {
		if (this.data.nodes.length > 0) {
			this.layoutDone = false;
			this.left = 0;
			this.top = this.getTitleSubtitleHeight();
			this.x = this.width;
			this.y = this.height - this.top;
			if (this.networkLayoutType == "radial") {
				this.networkXCenter = this.x / 2;
				this.networkYCenter = this.y / 2
			} else {
				this.set3DParams();
				this.area = this.x * this.y;
				if (this.networkForceConstant != null && this.networkForceConstantOriginal != null) {
					this.networkForceConstantOriginal = this.networkForceConstant
				}
				if (this.temperature != null && this.temperatureOriginal != null) {
					this.temperatureOriginal = this.temperature
				}
				if (this.initialTemperature != null && this.initialTemperatureOriginal != null) {
					this.initialTemperatureOriginal = this.initialTemperature
				}
				this.networkForceConstant = this.networkForceConstant ? this.networkForceConstant : Math.sqrt(this.area / (b ? b.i.length : this.data.nodes.length));
				this.temperature = this.temperature ? this.temperature : (b ? b.i.length : this.data.nodes.length) + Math.floor(Math.sqrt(b ? b.e.length : this.data.edges.length));
				this.minimumTemperature = 1;
				this.initialTemperature = this.initialTemperature ? this.initialTemperature : this.temperature;
				this.iteration = 0;
				if (this.networkForceConstant < 0.001) {
					this.networkForceConstant = 0.001
				}
			}
			if (this.x <= 400 || this.y <= 400) {
				this.nodeFont = (this.nodeSize - 6) + "px " + this.fontName;
				this.showAnimationFont = this.nodeFont + "px " + this.fontName
			}
		} else {
			this.layoutDone = true
		}
	};
	this.networkContains = function(b, c) {
		return this.findNode(b, c) != null
	};
	this.findNode = function(c, e) {
		for (var d in c) {
			var b = c[d];
			if (e.call(b)) {
				return b
			}
		}
		return null
	};
	this.filterEdges = function(c, f) {
		var e = [];
		for (var d in c) {
			var b = c[d];
			if (f.call(b)) {
				e.push(b)
			}
		}
		return e
	};
	this.reduceNetwork = function(b, f, d) {
		var e = null;
		for (var c in b) {
			if (e == null) {
				if (d) {
					e = d.apply(d, [b[c]])
				} else {
					e = b[c]
				}
			} else {
				e = f.apply(b[c], [e, b[c]])
			}
		}
		return e
	};
	this.vectorDifference = function(e, d) {
		var c = e.x - d.x;
		var g = e.y - d.y;
		var f = e.z - d.z;
		if (c == 0) {
			c = 0.01 + this.random()
		}
		if (g == 0) {
			g = 0.01 + this.random()
		}
		if (this.is3DNetwork) {
			if (f == 0) {
				f = 0.01 + this.random()
			}
		}
		return {
			x: c,
			y: g,
			z: f
		}
	};
	this.vectorMagnitude = function(c) {
		var b;
		if (this.is3DNetwork) {
			b = Math.sqrt((c.x * c.x) + (c.y * c.y) + (c.z * c.z))
		} else {
			b = Math.sqrt((c.x * c.x) + (c.y * c.y))
		}
		return isNaN(b) ? 0 : b
	};
	this.normalizeGraph = function(j) {
		var h = [];
		var b = {};
		var k = this;
		for (var f in j.nodes) {
			if (!b.hasOwnProperty(j.nodes[f].id)) {
				var e = j.nodes[f];
				var d = [];
				b[e.id] = 1;
				if (!this.networkContains(d, function() {
						return k.networkContains(this.nodes, function() {
							return this.id = e.id
						})
					})) {
					var c = {};
					c.nodes = [];
					c.edges = [];
					this.addNodeToGraph(e, c, j);
					if (c.nodes.length > 0) {
						h.push(c)
					}
					for (var g = 0; g < c.nodes.length; g++) {
						b[c.nodes[g].id] = 1
					}
				}
			}
		}
		return h
	};
	this.addNodeToGraph = function(d, f, e) {
		if (this.findNodeForId(d.id, f) == null) {
			f.nodes.push(d);
			var b = this.edgesForNode(e.edges, d.id);
			for (edgeIndex in b) {
				var c = b[edgeIndex];
				f.edges.push(c);
				if (c.id1 == d.id) {
					this.addNodeToGraph(this.findNodeForId(c.id2, e), f, e)
				} else {
					this.addNodeToGraph(this.findNodeForId(c.id1, e), f, e)
				}
			}
		}
	};
	this.findNodeForId = function(c, b) {
		return this.findNode(b.nodes, function() {
			return c == this.id
		})
	};
	this.edgesForNode = function(b, c) {
		return this.filterEdges(b, function(d) {
			return (this.id1 == c || this.id2 == c)
		})
	};
	this.attractiveForce = function(b, c) {
		switch (this.attractiveForceFunction) {
			case "FruchtermanReingold":
				return (b * b) / c;
			case "Eades":
				return c * Math.log(b)
		}
	};
	this.repulsiveForce = function(b, c) {
		return (c * c) / b
	};
	this.storePositions = function() {
		var e = {};
		for (var c = 0; c < this.data.nodes.length; c++) {
			var d = this.data.nodes[c];
			if (!d.hide && !d.hiddenParent) {
				var b = {
					x: d.x,
					y: d.y,
					z: d.z
				};
				e[d.id] = b
			}
		}
		return e
	};
	this.calculateRepulsiveDisplacement = function(e) {
		var d = this;
		var b = function(l, s, h) {
			var r = h * h;
			for (var p = 0; p < s.length; p++) {
				var v = d.data.nodes[d.data.nodeIndices[s[p]]];
				var o = l[v.id];
				for (var n = 0; n < s.length; n++) {
					if (p != n) {
						var u = d.data.nodes[d.data.nodeIndices[s[n]]];
						var g = l[u.id];
						if (!v.hide && !v.hiddenParent && !u.hide && !u.hiddenParent) {
							var t = d.vectorDifference(v, u);
							var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(t) - (d.nodeSize * 2), d.networkNodeMinDistance) : d.vectorMagnitude(t);
							var q = r / f;
							if (!v.fixed) {
								o.x += (t.x / f) * q;
								o.y += (t.y / f) * q;
								o.z += (t.z / f) * q
							}
							if (!u.fixed && d.networkLayoutType == "organic") {
								g.x -= (t.x / f) * q;
								g.y -= (t.y / f) * q;
								g.z -= (t.z / f) * q
							}
						}
					}
				}
			}
		};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(e[c], this.subNetworks[c].nodes, this.subNetworks[c].networkForceConstant)
			}
		} else {
			b(e, this.getKeys(this.data.nodeIndices), this.networkForceConstant)
		}
	};
	this.calculateAttractiveDisplacement = function(e) {
		var d = this;
		var b = function(p, o, h) {
			for (var j = 0; j < o.length; j++) {
				var l = o[j];
				if (!d.nodes || !d.nodes[l.id1] || !d.nodes[l.id2]) {
					alert('Nodes "' + l.id1 + '" and/or "' + l.id2 + '" are missing!');
					return
				}
				if (d.nodes && !d.nodes[l.id1].hide && !d.nodes[l.id2].hide && !d.nodes[l.id1].hiddenParent && !d.nodes[l.id2].hiddenParent) {
					var n = d.vectorDifference(d.nodes[l.id1], d.nodes[l.id2]);
					var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(n) - (d.nodeSize * 2), d.networkNodeMinDistance) : Math.max(d.vectorMagnitude(n), d.networkNodeMinDistance);
					var g = d.attractiveForce(f, h);
					if (!d.nodes[l.id1].fixed) {
						p[l.id1].x -= (n.x / f) * g;
						p[l.id1].y -= (n.y / f) * g;
						p[l.id1].z -= (n.z / f) * g
					}
					if (!d.nodes[l.id2].fixed) {
						p[l.id2].x += (n.x / f) * g;
						p[l.id2].y += (n.y / f) * g;
						p[l.id2].z += (n.z / f) * g
					}
				}
			}
		};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(e[c], this.subNetworks[c].edges, this.subNetworks[c].networkForceConstant)
			}
		} else {
			b(e, this.data.edges, this.networkForceConstant)
		}
	};
	this.applyDisplacement = function(e) {
		var d = this;
		var c = function(j, g) {
			for (var k in j) {
				var h = d.nodes[k];
				if (!h.hide && !h.fixed) {
					var i = j[k];
					var f = Math.max(d.vectorMagnitude(i), 0.001);
					h.x += (i.x / f) * Math.min(g, Math.abs(i.x));
					h.y += (i.y / f) * Math.min(g, Math.abs(i.y));
					h.z += (i.z / f) * Math.min(g, Math.abs(i.z))
				}
			}
		};
		if (this.nodes) {
			if (this.subNetworks) {
				for (var b = 0; b < this.subNetworks.length; b++) {
					c(e[b], this.subNetworks[b].temperature)
				}
			} else {
				c(e, this.temperature)
			}
		}
	};
	this.isLayoutDone = function() {
		var f = this;
		var e = this.storePositions();
		var g = 0;
		var c = 0;
		var b = function(h, l) {
			var w = 0;
			var m = 0;
			var r = {
				x: Number.MAX_VALUE,
				y: Number.MAX_VALUE
			};
			var v = {
				x: Number.MAX_VALUE * -1,
				y: Number.MAX_VALUE * -1
			};
			for (var s = 0; s < h.length; s++) {
				var q = f.data.nodes[f.data.nodeIndices[h[s]]];
				if (!q.hide && !q.hiddenParent && !q.fixed) {
					var k = e[q.id];
					r.x = Math.min(r.x, k.x);
					r.y = Math.min(r.y, k.y);
					r.z = Math.min(r.z, k.z);
					v.x = Math.max(v.x, k.x);
					v.y = Math.max(v.y, k.y);
					v.z = Math.max(v.z, k.z);
					w += Math.abs(f.vectorMagnitude(f.vectorDifference(f.previousNodePositions[q.id], k)));
					m++
				}
			}
			var u = w / m;
			var t = Math.abs(f.vectorMagnitude(f.vectorDifference(r, v)));
			var j = Math.abs(f.vectorMagnitude({
				x: l.x,
				y: l.y,
				z: parseInt((l.x + l.y) / 2)
			}));
			l.minimumTemperature = t / j;
			l.layoutDone = u < l.minimumTemperature;
			if (l.layoutDone) {
				c++
			}
			if (l.initialProgress == null && l.temperature <= l.minimumTemperature) {
				l.initialProgress = u - (l.minimumTemperature / 2)
			}
			if (l.initialProgress != null) {
				l.layoutProgress = Math.max(l.layoutProgress, 1 - ((u - (l.minimumTemperature / 2)) / l.initialProgress))
			}
			g += l.layoutProgress
		};
		if (this.subNetworks) {
			for (var d = 0; d < this.subNetworks.length; d++) {
				b(this.subNetworks[d].nodes, this.subNetworks[d])
			}
			this.layoutProgress = g / this.subNetworks.length;
			this.layoutDone = c == this.subNetworks.length ? true : false
		} else {
			b(this.getKeys(this.data.nodeIndices), this)
		}
		this.previousNodePositions = e
	};
	this.setInitialForceDirectedLayout = function() {
		var d = this;
		var b = function(j, e, h) {
			for (var f = 0; f < j.length; f++) {
				var g = d.data.nodes[d.data.nodeIndices[j[f]]];
				if (!g.hide && !g.hiddenParent) {
					g.x = Math.floor(d.random() * e);
					g.y = Math.floor(d.random() * h);
					g.z = d.is3DNetwork ? Math.floor(d.random() * parseInt((e + h) / 2)) : 0
				}
			}
		};
		this.layoutProgress = 0;
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(this.subNetworks[c].nodes, this.subNetworks[c].x, this.subNetworks[c].y)
			}
		} else {
			b(this.getKeys(this.data.nodeIndices), this.x, this.y)
		}
		this.previousNodePositions = this.storePositions()
	};
	this.setInitialNodeDisplacement = function() {
		var d = this.subNetworks ? [] : {};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				d[c] = {};
				for (var b = 0; b < this.subNetworks[c].nodes.length; b++) {
					d[c][this.subNetworks[c].nodes[b]] = {
						x: 0,
						y: 0,
						z: 0
					}
				}
			}
		} else {
			for (var c = 0; c < this.data.nodes.length; c++) {
				if (!this.data.nodes[c].hide && !this.data.nodes[c].hiddenParent) {
					d[this.data.nodes[c].id] = {
						x: 0,
						y: 0,
						z: 0
					}
				}
			}
		}
		return d
	};
	this.updateForceDirectedLayout = function(d) {
		var f = new Date().getTime();
		var c = f;
		if (this.data.edges.length > 1) {
			if (!this.layoutDone) {
				while (c - f < d) {
					var e = this.setInitialNodeDisplacement();
					this.calculateRepulsiveDisplacement(e);
					this.calculateAttractiveDisplacement(e);
					this.applyDisplacement(e);
					if (this.subNetworks) {
						for (var b = 0; b < this.subNetworks.length; b++) {
							this.subNetworks[b].temperature = Math.max(this.subNetworks[b].temperature - (this.subNetworks[b].initialTemperature / 100), this.subNetworks[b].minimumTemperature)
						}
					} else {
						this.temperature = Math.max(this.temperature - (this.initialTemperature / 100), this.minimumTemperature)
					}
					this.isLayoutDone();
					this.iteration++;
					c = new Date().getTime()
				}
			}
		} else {
			this.layoutDone = true
		}
		return this.layoutDone
	};
	this.translateScaleNetworkCanvas = function(b) {
		if (b) {
			this.translateCanvas(-this.offsetX, -this.offsetY);
			this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor)
		} else {
			this.scaleCanvas(this.scaleFactor, this.scaleFactor);
			this.translateCanvas(this.offsetX, this.offsetY)
		}
	};
	this.renderNetwork = function() {
		this.resizeCanvas();
		this.setNetworkRotation();
		if (!this.layoutDone && !this.showAnimation) {
			this.drawNetworkProgressBar(true);
			return
		}
		if (this.data.nodes.length > 0) {
			if (this.layoutDone) {
				this.setXYNodePrecision()
			}
			this.setNetworkMinMaxRangeXY();
			this.setNetworkScaleFactor();
			if (this.scaleFactor) {
				if (this.showAnimation) {
					if (this.preScaleNetwork) {
						this.centerNetwork();
						this.drawNetworkNodes(true);
						if (this.networkNodesOnTop) {
							this.drawNetworkEdges();
							this.drawNetworkNodes()
						} else {
							this.drawNetworkNodes();
							this.drawNetworkEdges()
						}
						this.drawNetworkCommunitiesConvexHulls();
						if (this.layoutDone) {
							this.drawNetworkLegend()
						}
					} else {
						this.addToRender(["translateScaleNetworkCanvas", false]);
						this.drawNetworkNodes(true);
						if (this.networkNodesOnTop) {
							this.drawNetworkEdges();
							this.drawNetworkNodes()
						} else {
							this.drawNetworkNodes();
							this.drawNetworkEdges()
						}
						this.drawNetworkCommunitiesConvexHulls();
						if (this.layoutDone) {
							this.drawNetworkDecorations();
							this.drawNetworkLegend()
						}
						this.addToRender(["translateScaleNetworkCanvas", true])
					}
					this.drawCitation();
					this.drawNetworkColorIndicator();
					this.drawTitle();
					this.drawCanvasBox(true)
				} else {
					this.drawCitation();
					this.drawNetworkColorIndicator();
					this.drawTitle();
					this.drawCanvasBox(true);
					if (this.preScaleNetwork) {
						this.centerNetwork()
					} else {
						this.addToRender(["translateScaleNetworkCanvas", false])
					}
					if (this.networkNodesOnTop) {
						this.drawNetworkEdges();
						this.drawNetworkNodes()
					} else {
						this.drawNetworkNodes();
						this.drawNetworkEdges()
					}
					this.drawNetworkCommunitiesConvexHulls();
					if (this.layoutDone) {
						this.drawNetworkDecorations();
						this.drawNetworkLegend()
					}
				}
			}
			this.drawNetworkProgressBar()
		}
		this.render()
	};
	this.reRootRadialNetwork = function(f) {
		this.functionCaller = "reRootRadialNetwork";
		if (this.isTransition()) {
			return
		}
		var e = this.data.nodes[f].id;
		this.networkCurrentAngle = this.getAngle(this.finalRadialNodePositions[e].x, this.finalRadialNodePositions[e].y, this.finalRadialNodePositions[this.networkRoot].x, this.finalRadialNodePositions[this.networkRoot].y, 0) + 180;
		this.orderRadialNetwork = {};
		var c = this.data.nodeIndices[e];
		var d = 0;
		for (var b = c; b < this.data.nodes.length; b++) {
			this.orderRadialNetwork[this.data.nodes[b].id] = d;
			d++
		}
		for (var b = 0; b < c; b++) {
			this.orderRadialNetwork[this.data.nodes[b].id] = d;
			d++
		}
		this.networkXCenter = this.finalRadialNodePositions[e].x;
		this.networkYCenter = this.finalRadialNodePositions[e].y;
		this.networkRoot = e;
		this.layoutDone = false;
		this.draw()
	};
	this.renderRadialLayout = function() {
		this.functionCaller = "renderRadialLayout";
		this.scaleCanvas(this.scaleFactor, this.scaleFactor);
		this.translateCanvas(this.offsetX, this.offsetY);
		var b = this.data.nodes[this.data.nodeIndices[this.networkRoot]];
		for (var c = 1; c < this.networkDepth; c++) {
			this.addToRender(["drawShape", "circle", b.x, b.y, c * this.networkLevelSize * 2, c * this.networkLevelSize * 2, this.background, this.infoAreaColor, "open"])
		}
	};
	this.centerNetwork = function() {
		for (var b = 0; b < this.data.nodes.length; b++) {
			var c = this.data.nodes[b];
			if (!c.hide && !c.hiddenParent) {
				c.x = (this.offsetX + c.x) * this.scaleFactor;
				c.y = (this.offsetY + c.y) * this.scaleFactor
			}
		}
		this.scaleFactor = 0.9;
		this.offsetX = this.x * 0.05;
		this.offsetY = this.y * 0.05
	};
	this.setXYNodePrecision = function() {
		if (this.approximateNodePositions) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (c.x) {
					c.x = parseInt(c.x);
					this.nodes[c.id].x = c.x
				}
				if (c.y) {
					c.y = parseInt(c.y);
					this.nodes[c.id].y = c.y
				}
				if (c.z) {
					c.z = parseInt(c.z);
					this.nodes[c.id].z = c.z
				}
			}
		}
	};
	this.getLengthToNodeBoundary = function(d, j, c, i, f, e) {
		if (f) {
			var h = f.size ? f.size : 1;
			var b = e && f.height ? f.height : f.width ? f.width : this.nodeSize * h;
			var g = e && f.width ? f.width : f.height ? f.height : this.nodeSize * h;
			var k = this.clip("line", [d, j, c, i], [d - (b / 2), j - (g / 2), b + (d - (b / 2)), g + (j - (g / 2))]);
			return this.lineLength(k[0], k[1], k[2], k[3]) + (this.margin * 2)
		} else {
			return this.margin * 2
		}
	};
	this.drawNetworkEdges = function() {
		this.functionCaller = "drawNetworkEdges";
		if (this.nodes) {
			var b = {};
			var f = this.foreground;
			for (var u = 0; u < this.data.edges.length; u++) {
				var g = this.data.edges[u];
				var s = this.nodes[g.id1];
				var r = this.nodes[g.id2];
				var x = false;
				if (!s.hide && !s.hiddenParent && !r.hide && !r.hiddenParent && !g.anchor) {
					x = true
				} else {
					if (this.showHiddenChildEdges) {
						if (s.hide || s.hiddenParent || (s.parentNode && this.nodes[s.parentNode].hideChildren)) {
							s = this.findVisibleParentNode(g.id1);
							if (s) {
								x = true
							}
						}
						if (r.hide || r.hiddenParent || (r.parentNode && this.nodes[r.parentNode].hideChildren)) {
							r = this.findVisibleParentNode(g.id2);
							if (r) {
								x = true
							}
						}
					}
				}
				var z = s.id + ":" + r.id;
				if (x && !g.hide) {
					if (!b.hasOwnProperty(z)) {
						var c = this.selectNode.hasOwnProperty(s.id) && this.selectNode.hasOwnProperty(r.id) ? this.nodeHighlightColor : g.color ? g.color : f;
						var k = g.width ? g.width : this.edgeWidth;
						var h = g.cap ? g.cap : false;
						var d = g.exact ? g.exact : false;
						var n, l, w, v;
						if (this.is3DNetwork) {
							n = s.x3d;
							l = s.y3d;
							w = r.x3d;
							v = r.y3d
						} else {
							n = s.x;
							l = s.y;
							w = r.x;
							v = r.y
						}
						var m = g.type ? g.type : "line";
						var p = m.match(/curved/) ? true : false;
						var y = d ? 0 : g.elbows && g.elbows.length > 0 ? this.getLengthToNodeBoundary(n, l, g.elbows[0][0], g.elbows[0][1], s, p) : this.getLengthToNodeBoundary(n, l, w, v, s, p);
						var e = d ? 0 : g.elbows && g.elbows.length > 0 ? this.getLengthToNodeBoundary(w, v, g.elbows[g.elbows.length - 1][0], g.elbows[g.elbows.length - 1][1], r, p) : this.getLengthToNodeBoundary(w, v, n, l, r, p);
						if (this.layoutDone && !this.isAnimation) {
							this.addToRender(["drawLine", m, n, l, w, v, c, k / this.zoom, h, Math.max(0, y / this.zoom / 1.25), Math.max(0, e / this.zoom / 1.25), false, false, g.elbows], [u + this.data.nodes.length]);
							if (g.elbows) {
								var o = g.elbows;
								for (var t = 0; t < o.length; t++) {
									this.addToRender(["drawShape", "rectangle", o[t][0] + 2, o[t][1] + 2, 4, 4, false, this.foreground, "open"], [u + this.data.nodes.length, t], "-elbow")
								}
							}
						} else {
							this.addToRender(["drawLine", m, n, l, w, v, c, k / this.zoom, h, Math.max(0, y / this.zoom / 1.25), Math.max(0, e / this.zoom / 1.25), false, false, g.elbows])
						}
						b[z] = 1
					}
				}
			}
		}
	};
	this.drawNetworkSelectionNodePoint = function(C, q, p, s, D, v, o) {
		this.functionCaller = "drawNetworkSelectionNodePoint";
		var n, j, f, d, E, e, c, G, A, l, k, F, g, m, B;
		this.addToRender(["drawShape", "rect", q, p, s, D, this.nodeHighlightColor, this.foreground, "open", v, false, false, false, false, false, false, o]);
		if (v) {
			m = Math.cos(v);
			B = Math.sin(v);
			l = -(B * ((-D / 2) - 10));
			k = (m * ((-D / 2) - 10));
			F = -(B * (-D / 2));
			g = (m * (-D / 2));
			this.addToRender(["drawLine", "line", l + q, k + p, F + q, g + p, this.foreground]);
			n = [-(B * ((-D / 2) - 10)), (m * ((-D / 2) - 10))];
			j = [(m * (-s / 2)) - (B * (-D / 2)), (m * (-D / 2)) + (B * (-s / 2))];
			f = [-(B * (-D / 2)), (m * (-D / 2))];
			d = [(m * (s / 2)) - (B * (-D / 2)), (m * (-D / 2)) + (B * (s / 2))];
			E = [(m * (-s / 2)), (B * (-s / 2))];
			e = [(m * (-s / 2)) - (B * (D / 2)), (m * (D / 2)) + (B * (-s / 2))];
			c = [-(B * (D / 2)), (m * (D / 2))];
			G = [(m * (s / 2)) - (B * (D / 2)), (m * (D / 2)) + (B * (s / 2))];
			A = [(m * (s / 2)), (B * (s / 2))]
		} else {
			this.addToRender(["drawLine", "line", q, p - ((D / 2) + 10), q, p - (D / 2), this.foreground]);
			n = [q, p - ((D / 2) + 10)];
			j = [q - (s / 2), p - (D / 2)];
			f = [q, p - (D / 2)];
			d = [q + (s / 2), p - (D / 2)];
			E = [q - (s / 2), p];
			e = [q - (s / 2), p + (D / 2)];
			c = [q, p + (D / 2)];
			G = [q + (s / 2), p + (D / 2)];
			A = [q + (s / 2), p]
		}
		var b = [n, j, f, d, E, e, c, G, A];
		var u = ["-resizeROT", "-resizeTL", "-resizeTM", "-resizeTR", "-resizeML", "-resizeBL", "-resizeBM", "-resizeBR", "-resizeMR"];
		for (var t = 0; t < b.length; t++) {
			this.addToRender(["drawShape", "rect", b[t][0], b[t][1], this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", v, false, false, false, false, false, false, o], [C], u[t])
		}
	};
	this.drawNetworkNodeLabel = function(r, m, v, l, u, t) {
		this.functionCaller = "drawNetworkNodeLabel";
		var d, c, k, j;
		var e = this.labelNodePosition == "auto" ? "center" : this.labelNodePosition;
		var f = r.label ? r.label : r.name ? r.name : r.id;
		var s = this.getNodeColor(r.id, r.labelColor);
		var o = r.labelSize ? this.nodeFontSize * r.labelSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
		var n = this.nodeFontStyle + " " + Math.min(Math.max((parseInt(o / this.zoom * 1.25)), this.minTextSize), this.maxTextSize) + "px " + this.fontName;
		var q = this.measureText(f, n);
		var p = o;
		if (r.labelX != null && r.labelY != null) {
			d = r.labelX;
			c = r.labelY;
			this.addToRender(["drawText", f, r.labelX, r.labelY, n, s, "center", "middle"])
		} else {
			var g = this.isMultipleLines(f);
			var b = parseInt(o) + 4;
			if (g) {
				if (g % 2) {
					v += (parseInt(g / 2) * b) + (b / 2)
				} else {
					v = (v + parseInt(g / 2) * b)
				}
			}
			if (r.labelPosition) {
				e = r.labelPosition
			}
			switch (e) {
				case "top":
					d = m - (q / 2);
					c = v - ((u / 2) + this.margin + (p / 2));
					k = m;
					j = c;
					r.labelXi = m;
					r.labelYi = c;
					break;
				case "bottom":
					d = m - (q / 2);
					c = v + ((u / 2) + this.margin + (p / 2));
					k = m;
					j = c;
					r.labelXi = m;
					r.labelYi = c;
					break;
				case "right":
					d = m + ((l / 2) + this.margin + (q / 2));
					c = v - (p / 2);
					k = d;
					j = v;
					r.labelXi = d;
					r.labelYi = v;
					break;
				case "left":
					d = m - ((l / 2) + this.margin + (q / 2));
					c = v - (p / 2);
					k = d;
					j = v;
					r.labelXi = d;
					r.labelYi = v;
					break;
				case "center":
					k = m;
					j = v;
					r.labelXi = m;
					r.labelYi = v;
					break
			}
		}
		this.addToRender(["drawText", f, k, j, n, s, "center", "middle"], [t], "-lab")
	};
	this.drawNetworkNodes = function(t) {
		this.functionCaller = "drawNetworkNodes";
		var l = this.data.nodes.length / this.zoom < this.showNodeNameThreshold ? true : false;
		var g = this.foreground;
		var w = this.shapes[0];
		var c = 6001;
		var h = this.rangeX > this.rangeY ? "bottom" : "right";
		var b = this.autoHideOnDecorationsCenter && this.decorationsPosition == "center" && this.decorations.length > 0 ? true : false;
		for (var x = 0; x < this.data.nodes.length; x++) {
			var u = this.data.nodes[x];
			if (t) {
				if (!u.eventless) {
					continue
				}
			} else {
				if (u.eventless) {
					continue
				}
			}
			var j = this.overrideAnchorNodes ? false : u.anchor;
			if (!u.hide && !u.hiddenParent && !j) {
				var n = this.is3DNetwork ? u.x3d : u.x;
				var A = this.is3DNetwork ? u.y3d : u.y;
				var q = u.shape ? u.shape : w;
				var y = u.outline ? u.outline : this.foreground;
				var z = u.size ? u.size : 1;
				var m = u.width ? u.width / this.zoom : this.nodeSize * z / this.zoom;
				var s = u.height ? u.height / this.zoom : this.nodeSize * z / this.zoom;
				var v = this.selectNode.hasOwnProperty(u.id) ? true : false;
				var f = v ? this.nodeHighlightColor : this.colorNodeBy ? u.color : u.communityColor && this.isCoordinateNodeColorsNetworkConvexHull ? u.communityColor : u.gradient && u.color1 && u.color2 && u.color3 ? this.getRadialGradient(n, A, Math.max(m, s) / 2, u.color1, u.color2, u.color3) : u.color ? u.color : g;
				var o = u.pattern ? u.pattern : "closed";
				var k = u.rotate ? u.rotate * Math.PI / 180 : false;
				var r = u.outlineWidth ? u.outlineWidth : false;
				var e = u.imagePath ? u.imagePath : false;
				var d = u.zIndex ? u.zIndex : e ? c : false;
				var p = u.eventless ? false : true;
				if (this.layoutDone && !this.isAnimation) {
					if (p || this.overrideEventlessNodes) {
						this.addToRender(["drawShape", q, n, A, m, s, f, y, o, k, r, false, false, false, false, e, d], [x])
					} else {
						this.addToRender(["drawShape", q, n, A, m, s, f, y, o, k, r, false, false, false, false, e, d])
					}
					if (v && !u.fixed) {
						this.drawNetworkSelectionNodePoint(x, n, A, m, s, k, r)
					} else {
						if (v && u.fixed) {
							this.drawNetworkSelectionNodePoint(u, n, A, m, s, k, r)
						}
					}
					if (l && !u.hideLabel) {
						if (p || this.overrideEventlessNodes) {
							this.drawNetworkNodeLabel(u, n, A, m, s, x)
						}
					}
				} else {
					this.addToRender(["drawShape", q, n, A, m, s, f, y, o, k, r, false, false, false, false, e, d])
				}
				c++
			}
		}
	};
	this.drawNetworkCommunitiesConvexHulls = function() {
		var k, b, q, o, g, m, l;
		if (this.isNetworkConvexHull) {
			for (var f = 0; f < this.networkCommunities; f++) {
				if (this.networkConvexHulls[f]["nodes"]) {
					var d = [];
					var p = [];
					k = this.addColorTransparency(this.colors[f % this.colors.length], 0.2);
					var g = this.getHull(this.networkConvexHulls[f]["nodes"]);
					this.networkConvexHulls[f]["convexHull"] = g[0];
					for (var e = 0; e < g[0].length; e++) {
						d.push(g[0][e][0]);
						p.push(g[0][e][1])
					}
					this.addToRender(["drawShape", "hull", d, p, g[2] - g[1], g[4] - g[3], k])
				}
			}
		} else {
			if (this.isNetworkCommunities) {
				this.setNetworkCommunities();
				this.drawNetworkCommunitiesConvexHulls()
			}
		}
	};
	this.drawNetworkDecorations = function() {
		this.functionCaller = "drawNetworkDecorations";
		if (this.showDecorations && this.decorations.length > 0) {
			var g = this;
			var x = function() {
				var p = {};
				for (var E = 0; E < g.data.nodes.length; E++) {
					var F = g.data.nodes[E];
					if (!F.hide && !F.hiddenParent && !e) {
						for (var z = 0; z < g.decorations.length; z++) {
							var G = g.decorations[z];
							if (F[G] || (F.decorations && F.decorations[G])) {
								p[E] = true
							}
						}
					}
				}
				return g.getKeys(p).sort(function(j, i) {
					return j - i
				})
			};
			var r = function(z) {
				var G = {
					vals: {}
				};
				for (var F = 0; F < z.length; F++) {
					var H = g.data.nodes[z[F]];
					for (var E = 0; E < g.decorations.length; E++) {
						var J = g.decorations[E];
						var I = H[J] ? H[J] : H.decorations ? H.decorations[J] : false;
						if (g.isObject(I)) {
							G.type = "m";
							for (var p in I) {
								G.vals[p] = true
							}
						} else {
							G.type = "s"
						}
					}
				}
				return G
			};
			var h = function(z, p, M) {
				var K = g.getKeys(p.vals);
				var H = {
					vals: [],
					area: [],
					cols: [],
					col2: [],
					patt: [],
					shpe: [],
					shp2: []
				};
				if (p.type == "m") {
					if (g.decorationsType == "heatmap") {
						for (var I = 0; I < K.length; I++) {
							H.vals[I] = [];
							H.area[I] = [];
							H.patt[I] = []
						}
					} else {
						for (var I = 0; I < g.decorations.length; I++) {
							H.vals[I] = [];
							H.area[I] = [];
							H.patt[I] = [];
							H.cols[I] = []
						}
					}
				}
				for (var I = 0; I < g.decorations.length; I++) {
					var E = g.decorations[I];
					var J = g.decorationsProperties[E] && g.decorationsProperties[E].color ? g.decorationsProperties[E].color : g.decorationsColors[I];
					var O = g.decorationsProperties[E] && g.decorationsProperties[E].shape ? g.decorationsProperties[E].shape : "circle";
					if (p.type == "m") {
						for (var G = 0; G < K.length; G++) {
							var N = z[E] ? z[E][K[G]] : z.decorations && z.decorations[E] ? z.decorations[E][K[G]] : "NA";
							var F = g.decorationsProperties[K[G]] && g.decorationsProperties[K[G]].color ? g.decorationsProperties[K[G]].color : g.decorationsColors[g.decorations.length + G];
							var L = g.decorationsProperties[K[G]] && g.decorationsProperties[K[G]].shape ? g.decorationsProperties[K[G]].shape : "square";
							if (g.decorationsType == "heatmap") {
								H.vals[G].push(N);
								H.area[G].push([M + "-" + I + "-" + K[G]]);
								H.patt[G].push("closed");
								if (I == 0) {
									H.cols.push(F);
									H.shpe.push(L)
								}
							} else {
								if (g.decorationsType.match(/stacked/)) {
									H.vals[I].push(N);
									H.area[I].push([M + "-" + I + "-" + K[G]]);
									H.cols[I].push(F);
									H.patt[I].push("closed")
								}
							}
						}
						H.col2.push(J);
						if (g.decorationsType == "heatmap") {
							H.shp2.push(O)
						} else {
							H.shpe.push(O)
						}
					} else {
						if (!H.vals[0]) {
							H.vals[0] = []
						}
						var N = z[E] ? z[E] : z.decorations && z.decorations[E] ? z.decorations[E] : "NA";
						var J = g.decorationsProperties[E] && g.decorationsProperties[E].color ? g.decorationsProperties[E].color : g.decorationsColors[I];
						var O = g.decorationsProperties[E] && g.decorationsProperties[E].shape ? g.decorationsProperties[E].shape : "circle";
						if (N == "NA") {
							continue
						}
						H.vals[0].push(N);
						H.area.push([M + "-" + I]);
						H.cols.push(J);
						H.patt.push("closed");
						H.shpe.push(O)
					}
				}
				return H
			};
			var o = x();
			var m = r(o);
			var w = this.decorations.length * this.decorationsWidth / 2;
			var f = this.decorationsWidth * 0.7;
			var d = this.decorationsHeight / 2;
			var A = this.getColorBrew(this.colorSpectrum, this.decorationsRange[0], this.decorationsRange[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			for (var t = 0; t < o.length; t++) {
				var q = this.data.nodes[o[t]];
				var C = h(q, m, o[t]);
				var e = this.overrideAnchorNodes ? false : q.anchor;
				if (!q.hide && !q.hiddenParent && !e) {
					var l = this.is3DNetwork ? q.x3d : q.x;
					var u = this.is3DNetwork ? q.y3d : q.y;
					var D = q.size ? this.nodeSize * q.size : this.nodeSize;
					var b = D / 2;
					var v, c;
					if (q.decorationsX != null && q.decorationsY != null) {
						v = q.decorationsX;
						c = q.decorationsY
					} else {
						switch (this.decorationsPosition) {
							case "top":
								v = this.decorationsType == "pie" ? l : l - w;
								if (this.decorationsType == "pie") {
									c = u - (b + d + this.decorationsWidth)
								} else {
									c = u - (b + this.decorationsHeight + this.decorationsWidth)
								}
								break;
							case "bottom":
								v = this.decorationsType == "pie" ? l : l - w;
								c = u + (b + this.decorationsWidth);
								c = this.decorationsType == "pie" ? c + d : c;
								break;
							case "right":
								v = l + b + this.decorationsWidth;
								c = this.decorationsType == "pie" ? u : u - d;
								v = this.decorationsType == "pie" ? v + d : v;
								break;
							case "left":
								if (this.decorationsType == "pie") {
									v = l - (b + (this.decorationsHeight / 2) + this.decorationsWidth)
								} else {
									v = l - (b + (this.decorationsWidth * (this.decorations.length + 1)))
								}
								c = this.decorationsType == "pie" ? u : u - d;
								break;
							case "center":
								v = this.decorationsType == "pie" ? l : l - w;
								c = this.decorationsType == "pie" ? u : u - d;
								break
						}
						q.decorationsXi = v;
						q.decorationsYi = c
					}
					if (this.decorationsType == "bar") {
						var k = this.decorationsRange[0] < 0 ? Math.abs(this.decorationsRange[0]) * this.decorationsUnits : 0;
						this.drawBarPlot(C.vals[0], [], v, c + this.decorationsHeight - k, this.decorationsWidth, this.decorationsWidth, this.decorationsUnits, k, this.decorationsRange[0], "vertical", C.cols, C.patt, C.area, "-dec")
					} else {
						if (this.decorationsType.match(/stacked/)) {
							var n = this.decorationsType.match(/percent/) ? true : false;
							c += this.decorationsHeight;
							if (this.decorationsPosition == "top") {
								c -= this.decorationsWidth
							}
							for (var s = 0; s < this.decorations.length; s++) {
								this.drawStackedPlot(C.vals[s], v, c, this.decorationsWidth, false, n, [this.sum(C.vals[s], false, false, true), this.sum(C.vals[s], false, false, false, true)], this.decorationsUnits, 0, "vertical", C.cols[s], C.patt[s], C.area[s], "-dec");
								this.addToRender(["drawShape", C.shpe[s], v + this.decorationsWidth / 2, c + this.decorationsWidth, f, f, C.col2[s], this.foreground, "closed"]);
								v += this.decorationsWidth
							}
						} else {
							if (this.decorationsType == "heatmap") {
								if (m.type == "m") {
									var B = this.decorationsHeight / C.vals.length;
									switch (this.decorationsPosition) {
										case "top":
											c -= this.decorationsWidth;
											break;
										case "bottom":
											break;
										case "right":
											v += this.decorationsWidth;
											break;
										case "left":
											break;
										case "center":
											break
									}
									for (var s = 0; s < C.vals.length; s++) {
										this.drawHeatmap(C.vals[s], v, c, this.decorationsWidth, B, false, C.area[s], "-dec", C.patt[s], A);
										this.addToRender(["drawShape", C.shpe[s], v - this.decorationsWidth, c + (B / 2), f, f, C.cols[s], this.foreground, "closed"]);
										c += B
									}
									for (var s = 0; s < this.decorations.length; s++) {
										this.addToRender(["drawShape", C.shp2[s], v + this.decorationsWidth / 2, c + this.decorationsWidth, f, f, C.col2[s], this.foreground, "closed"]);
										v += this.decorationsWidth
									}
								} else {
									if (this.decorationsPosition == "top") {
										c -= this.decorationsWidth
									}
									this.drawHeatmap(C.vals[0], v, c, this.decorationsWidth, this.decorationsHeight, false, C.area, "-dec", C.patt, A);
									for (var s = 0; s < this.decorations.length; s++) {
										this.addToRender(["drawShape", C.shpe[s], v + this.decorationsWidth / 2, c + this.decorationsHeight + this.decorationsWidth, f, f, C.cols[s], this.foreground, "closed"]);
										v += this.decorationsWidth
									}
								}
							} else {
								var y = this.colors;
								this.colors = C.cols;
								this.drawPie(this.setPieData(C.vals[0], false, C.cols), v, c, this.sizeDecorationBy && q.decorationSize ? q.decorationSize : d, C.area, "-dec");
								this.colors = y
							}
						}
					}
				}
			}
		}
	};
	this.getLegendId = function(c, d) {
		if (c) {
			if (!d) {
				var b = 0;
				d = c + "LegendId" + b;
				if (this.data.legend.ids.hasOwnProperty(c)) {
					while (this.data.legend.ids[c].hasOwnProperty(d)) {
						b++;
						d = c + "LegendId" + b
					}
				} else {
					this.data.legend.ids[c] = {}
				}
			}
			this.data.legend.ids[c][d] = true;
			return d
		}
	};
	this.findNetworkXYRange = function(c) {
		var b = Number.MAX_VALUE;
		var h = Number.MAX_VALUE * -1;
		var j = Number.MAX_VALUE;
		var g = Number.MAX_VALUE * -1;
		if (!c) {
			c = this.getKeys(this.data.nodeIndices)
		}
		if (c && c.length > 0) {
			if (this.is3DNetwork && this.layoutDone && this.scaleFactor) {
				for (var e = 0; e < c.length; e++) {
					var f = this.data.nodes[this.data.nodeIndices[c[e]]];
					var d = this.overrideAnchorNodes ? false : f.anchor;
					if (!f.hide && !f.hiddenParent && !d) {
						b = Math.min(b, f.x3d);
						h = Math.max(h, f.x3d);
						j = Math.min(j, f.y3d);
						g = Math.max(g, f.y3d)
					}
				}
			} else {
				for (var e = 0; e < c.length; e++) {
					var f = this.data.nodes[this.data.nodeIndices[c[e]]];
					var d = this.overrideAnchorNodes ? false : f.anchor;
					if (!f.hide && !f.hiddenParent && !d) {
						b = Math.min(b, f.x);
						h = Math.max(h, f.x);
						j = Math.min(j, f.y);
						g = Math.max(g, f.y)
					}
				}
			}
		}
		return ({
			minX: b,
			maxX: h,
			minY: j,
			maxY: g
		})
	};
	this.inititalizeNetworkLegend = function() {
		if (!this.data.legend) {
			this.data.legend = {}
		}
		if (!this.data.legend.pos) {
			this.data.legend.pos = {}
		}
		if (!this.data.legend.pos.nodes) {
			this.data.legend.pos.nodes = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.pos.edges) {
			this.data.legend.pos.edges = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.pos.decorations) {
			this.data.legend.pos.decorations = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.ids) {
			this.data.legend.ids = {
				nodes: {},
				edges: {},
				text: {},
				decorations: {}
			}
		}
	};
	this.drawNetworkLegend = function() {
		if (this.showLegend) {
			this.inititalizeNetworkLegend();
			var b = this.findNetworkXYRange();
			this.curLegendX = b.minX;
			this.curLegendY = b.minY;
			if (this.showNetworkNodesLegend) {
				this.drawNetworkLegendNodes()
			}
			if (this.showNetworkEdgesLegend) {
				this.drawNetworkLegendEdges()
			}
			if (this.showNetworkTextLegend) {
				this.drawNetworkLegendText()
			}
			if (this.showNetworkDecorationsLegend) {
				this.drawNetworkLegendDecorations()
			}
		}
	};
	this.drawNetworkColorIndicator = function() {
		if (this.colorNodeBy && this.meta.data.nodes[this.colorNodeBy].type == "Numeric") {
			if (this.legendPosition = ~/top/) {
				this.drawColorIndicator(this.width - (this.heatmapIndicatorWidth + 10 + (this.margin * 2)), (this.margin * 2), this.networkColorBrew, this.colorNodeBy, true)
			} else {
				this.drawColorIndicator((this.margin * 2), this.height - (this.heatmapIndicatorWidth + 20 + (this.margin * 2)), this.networkColorBrew, this.colorNodeBy)
			}
		}
	};
	this.drawNetworkLegendNodes = function() {
		this.functionCaller = "drawNetworkLegendNodes";
		if (this.data.legend.nodes && this.data.legend.nodes.length > 0) {
			var g = this.data.legend.pos.nodes.x != null && !isNaN(this.data.legend.pos.nodes.x) ? this.data.legend.pos.nodes.x : this.curLegendX;
			var e = this.data.legend.pos.nodes.y != null && !isNaN(this.data.legend.pos.nodes.y) ? this.data.legend.pos.nodes.y : this.curLegendY;
			this.data.legend.pos.nodes.x = parseInt(g);
			this.data.legend.pos.nodes.y = parseInt(e);
			var x = 0;
			var w = 0;
			var l = 0;
			for (var y = 0; y < this.data.legend.nodes.length; y++) {
				var t = this.data.legend.nodes[y];
				var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
				var m = t.width ? t.width : q;
				var s = t.height ? t.height : q;
				var C = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				w = Math.max(w, m);
				l = Math.max(l, Math.max(s, C + this.margin))
			}
			l /= 2;
			for (var y = 0; y < this.data.legend.nodes.length; y++) {
				var t = this.data.legend.nodes[y];
				t.id = this.getLegendId("nodes", t.id);
				var v = t.color || this.nodeFontColor;
				var z = t.outline ? t.outline : this.foreground;
				var b = t.shape || this.shapes[0];
				var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
				var m = t.width ? t.width : q;
				var s = t.height ? t.height : q;
				var n = t.pattern ? t.pattern : "closed";
				var k = t.rotate ? t.rotate * Math.PI / 180 : false;
				var u = t.outlineWidth ? t.outlineWidth : false;
				var h = t.imagePath ? t.imagePath : false;
				var c = t.zIndex ? t.zIndex : false;
				var j = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var p = this.nodeFontStyle + " " + (parseInt(j)) + "px " + this.fontName;
				var o = t.text ? t.text : "";
				var r = this.measureText(o, p);
				q = parseFloat(sprintf("%.1f", q));
				x = Math.max(x, (this.margin * 3) + (w * 1.5) + r);
				e += l;
				this.addToRender(["drawShape", b, g + w - this.margin, this.margin + e + l, m, s, v, z, n, k, u, false, false, false, false, h, c]);
				this.addToRender(["drawText", o, this.margin + g + (w * 1.5), this.margin + e + l, p, this.nodeFontColor, "left", "middle"]);
				e += l
			}
			e += this.margin + l;
			var B = this.data.legend.pos.nodes.x;
			var f = this.data.legend.pos.nodes.y + (l * 0.5);
			var A = x;
			var d = e - this.data.legend.pos.nodes.y;
			this.drawLegendBackgroundBox(B, f, A, d, true, "-legend-Nodes");
			this.curLegendX = g;
			this.curLegendY = e
		}
	};
	this.drawNetworkLegendEdges = function() {
		this.functionCaller = "drawNetworkLegendEdges";
		if (this.data.legend.edges && this.data.legend.edges.length > 0) {
			var e = this.data.legend.pos.edges.x != null && !isNaN(this.data.legend.pos.edges.x) ? this.data.legend.pos.edges.x : this.curLegendX;
			var c = this.data.legend.pos.edges.y != null && !isNaN(this.data.legend.pos.edges.y) ? this.data.legend.pos.edges.y : this.curLegendY;
			this.data.legend.pos.edges.x = parseInt(e);
			this.data.legend.pos.edges.y = parseInt(c);
			var p = 0;
			var h = 0;
			for (var q = 0; q < this.data.legend.edges.length; q++) {
				var f = this.data.legend.edges[q];
				f.id = this.getLegendId("edges", f.id);
				var o = f.color || this.nodeFontColor;
				var j = f.type || "line";
				var n = f.width || 1;
				var m = f.size ? f.size * this.nodeFontSize : this.nodeFontSize;
				var g = f.font ? f.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var l = this.nodeFontStyle + " " + (parseInt(g)) + "px " + this.fontName;
				var k = f.text || "";
				var r = this.measureText(k, l);
				m = parseFloat(sprintf("%.1f", m));
				p = Math.max(p, (this.margin * 3) + m + r);
				h = g / 2;
				c += h;
				this.addToRender(["drawLine", j, this.margin + e, this.margin + c + h, e + m, this.margin + c + h, o, n * this.edgeWidth, false, 0, 0]);
				this.addToRender(["drawText", k, (this.margin * 2) + e + m, this.margin + c + h, l, this.nodeFontColor, "left", "middle"]);
				c += g
			}
			c += this.margin + h;
			var t = this.data.legend.pos.edges.x;
			var d = this.data.legend.pos.edges.y;
			var s = p;
			var b = c - this.data.legend.pos.edges.y;
			this.drawLegendBackgroundBox(t, d, s, b, true, "-legend-Edges");
			this.curLegendX = e;
			this.curLegendY = c
		}
	};
	this.drawNetworkLegendText = function() {
		this.functionCaller = "drawNetworkLegendText";
		if (this.data.legend.text && this.data.legend.text.length > 0) {
			var p = 0;
			for (var k = 0; k < this.data.legend.text.length; k++) {
				var l = this.data.legend.text[k];
				l.id = this.getLegendId("text", l.id);
				var j = l.x != null && !isNaN(l.x) ? l.x : this.curLegendX;
				var f = l.y != null && !isNaN(l.y) ? l.y : this.curLegendY;
				l.x = parseInt(j);
				l.y = parseInt(f);
				if (l.boxed) {
					this.legendBox = true
				}
				var g = l.margin || this.margin;
				var m = this.setNetworkLegendMargins(g);
				var h = l.color || this.nodeFontColor;
				var r = l.text || "";
				var o = l.font ? l.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var e = this.nodeFontStyle + " " + (parseInt(o)) + "px " + this.fontName;
				var d = this.measureText(r, e);
				p = o / 2;
				this.addToRender(["drawText", r, m[3] + j, m[0] + f + p, e, h, "left", "middle"]);
				var c = l.x;
				var q = l.y;
				var b = m[1] + m[3] + d;
				var n = m[0] + m[2] + o;
				this.drawLegendBackgroundBox(c, q, b, n, true, "-legend-Text" + k);
				f += m[0] + m[2] + o;
				this.curLegendX = j;
				this.curLegendY = f
			}
		}
	};
	this.drawNetworkLegendDecorations = function() {
		this.functionCaller = "drawNetworkLegendDecorations";
		if (this.data.legend.decorations && this.data.legend.decorations.length > 0) {
			var f = this.data.legend.pos.decorations.x != null && !isNaN(this.data.legend.pos.decorations.x) ? this.data.legend.pos.decorations.x : this.curLegendX;
			var d = this.data.legend.pos.decorations.y != null && !isNaN(this.data.legend.pos.decorations.y) ? this.data.legend.pos.decorations.y : this.curLegendY;
			this.data.legend.pos.decorations.x = parseInt(f);
			this.data.legend.pos.decorations.y = parseInt(d);
			var t = 0;
			var j = 0;
			for (var u = 0; u < this.data.legend.decorations.length; u++) {
				this.data.legend.decorations[u].id = this.getLegendId("decorations", this.data.legend.decorations[u].id);
				var s = this.data.legend.decorations[u].color || this.nodeFontColor;
				var v = this.data.legend.decorations[u].outline ? this.data.legend.decorations[u].outline : this.foreground;
				var b = this.data.legend.decorations[u].shape || this.shapes[0];
				var o = this.data.legend.decorations[u].size ? this.data.legend.decorations[u].size * this.nodeFontSize : this.nodeFontSize;
				var k = this.data.legend.decorations[u].width ? this.data.legend.decorations[u].width : o;
				var q = this.data.legend.decorations[u].height ? this.data.legend.decorations[u].height : o;
				var l = this.data.legend.decorations[u].pattern ? this.data.legend.decorations[u].pattern : "closed";
				var h = this.data.legend.decorations[u].rotate ? this.data.legend.decorations[u].rotate * Math.PI / 180 : false;
				var r = this.data.legend.decorations[u].outlineWidth ? this.data.legend.decorations[u].otlineWidth : false;
				var g = this.data.legend.decorations[u].font ? this.data.legend.decorations[u].font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var n = this.nodeFontStyle + " " + (parseInt(g)) + "px " + this.fontName;
				var m = this.data.legend.decorations[u].text ? this.data.legend.decorations[u].text : "";
				var p = this.measureText(m, n);
				o = parseFloat(sprintf("%.1f", o));
				t = Math.max(t, (this.margin * 3) + o + p);
				j = o / 2;
				d += j;
				this.addToRender(["drawShape", b, this.margin + f + j, this.margin + d + j, k, q, s, v, l, h, r]);
				this.addToRender(["drawText", m, (this.margin * 2) + f + o, this.margin + d + j, n, this.nodeFontColor, "left", "middle"]);
				d += o
			}
			d += this.margin + j;
			var x = this.data.legend.pos.decorations.x;
			var e = this.data.legend.pos.decorations.y;
			var w = t;
			var c = d - this.data.legend.pos.decorations.y;
			this.drawLegendBackgroundBox(x, e, w, c, true, "-legend-Decorations");
			this.curLegendX = f;
			this.curLegendY = d
		}
	};
	this.setNetworkLegendMargins = function(b) {
		if (isNaN(b)) {
			var c = b.split(/[,\s]+/);
			if (c.length > 3) {
				return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[3])]
			} else {
				if (c.length == 3) {
					return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[1])]
				} else {
					if (c.length == 2) {
						return [parseInt(c[0]), parseInt(c[1]), parseInt(c[0]), parseInt(c[1])]
					} else {
						return [parseInt(c[0]), parseInt(c[0]), parseInt(c[0]), parseInt(c[0])]
					}
				}
			}
		} else {
			return [parseInt(b), parseInt(b), parseInt(b), parseInt(b)]
		}
	};
	this.drawNetworkProgressBar = function(c) {
		this.functionCaller = "drawNetworkProgressBar";
		if (!this.layoutDone) {
			var b = (new Date().getTime() - this.preUpdateTime) / (this.layoutTime * 1000);
			b = Math.max(b, this.layoutProgress);
			if (c) {
				this.addToRender(["drawShape", "rectangle", (this.width / 2) + 5, (this.height / 2) + 2.5, 10, 5, this.foreground, this.foreground, "closed"]);
				this.addToRender(["drawText", "Calculating ...", (this.width / 2) - 50, (this.height / 2) + 10, this.showAnimationFont, this.showAnimationFontColor, "left", "top"])
			} else {
				this.addToRender(["drawShape", "rectangle", this.width - 105, this.height - 17.5, 10, 5, this.foreground, this.foreground, "closed"])
			}
		}
	};
	this.packSubNetworks = function() {
		var l = this;
		var q = function(u, t, s) {
			for (var v = 0; v < u.length; v++) {
				l.modifyXYNode(u[v], t, s)
			}
		};
		var c = function(i, u, s, t) {
			this.x = i;
			this.y = u;
			this.w = s;
			this.h = t
		};
		c.prototype.fits = function(i) {
			return i.w >= this.w && i.h >= this.h
		};
		c.prototype.sameSize = function(i) {
			return i.w == this.w && i.h == this.h
		};
		var e = function() {
			this.l = null;
			this.r = null;
			this.a = null;
			this.f = false
		};
		e.prototype.insert = function(i) {
			if (this.l != null) {
				return this.l.insert(i) || this.r.insert(i)
			}
			if (this.f) {
				return null
			}
			if (!i.fits(this.a)) {
				return null
			}
			if (i.sameSize(this.a)) {
				this.f = true;
				return this
			}
			this.l = new e();
			this.r = new e();
			var s = this.a.w - i.w;
			var u = this.a.h - i.h;
			var t = this.a;
			if (s > u) {
				this.l.a = new c(t.x, t.y, i.w, t.h);
				this.r.a = new c(t.x + i.w, t.y, t.w - i.w, t.h)
			} else {
				this.l.a = new c(t.x, t.y, t.w, i.h);
				this.r.a = new c(t.x, t.y + i.h, t.w, t.h - i.h)
			}
			return this.l.insert(i)
		};
		for (var k = 0; k < this.subNetworks.length; k++) {
			this.subNetworks[k].mnm = this.findNetworkXYRange(this.subNetworks[k].nodes);
			this.subNetworks[k].w = (this.subNetworks[k].mnm.maxX - this.subNetworks[k].mnm.minX);
			this.subNetworks[k].h = (this.subNetworks[k].mnm.maxY - this.subNetworks[k].mnm.minY);
			q(this.subNetworks[k].nodes, this.subNetworks[k].mnm.minX, this.subNetworks[k].mnm.minY)
		}
		var r = this.subNetworks[1];
		for (var k = 0; k < this.subNetworks.length; k++) {
			this.subNetworks[k].w += (r.w * 0.5);
			this.subNetworks[k].h += (r.h * 0.5)
		}
		var d = this.subNetworks[0];
		var b = d.nodes.length / this.data.nodes.length;
		var h = ((2 + b) * ((this.x / this.y) * d.w));
		var g = ((2 + b) * ((this.y / this.x) * d.h));
		var m = new e();
		var o, n;
		m.a = new c(0, 0, h, g);
		for (var k = 0; k < this.subNetworks.length; k++) {
			var f = this.subNetworks[k];
			var p = new c(0, 0, f.w, f.h);
			var j = m.insert(p);
			if (j) {
				q(this.subNetworks[k].nodes, -j.a.x, -j.a.y)
			}
		}
		this.scaleFactor *= 0.1
	};
	this.setNetworkMinMaxRangeXY = function() {
		if (!this.networkFreeze || (this.rangeX == null || this.rangeY == null)) {
			if (this.subNetworks && !this.isAnimation) {
				this.packSubNetworks();
				if (!this.isAnimation) {
					this.subNetworks = false
				}
			}
			this.minX = Number.MAX_VALUE;
			this.minY = Number.MAX_VALUE;
			this.maxX = 0;
			this.maxY = 0;
			if (this.is3DNetwork && this.layoutDone) {
				for (var c = 0; c < this.data.nodes.length; c++) {
					var e = this.data.nodes[c];
					var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					if (!e.hide) {
						this.minX = Math.min(this.minX, e.x3d - b / 2);
						this.minY = Math.min(this.minY, e.y3d - d / 2);
						this.maxX = Math.max(this.maxX, e.x3d + b / 2);
						this.maxY = Math.max(this.maxY, e.y3d + d / 2)
					}
				}
			} else {
				for (var c = 0; c < this.data.nodes.length; c++) {
					var e = this.data.nodes[c];
					var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					if (!e.hide) {
						this.minX = Math.min(this.minX, e.x - b / 2);
						this.minY = Math.min(this.minY, e.y - d / 2);
						this.maxX = Math.max(this.maxX, e.x + b / 2);
						this.maxY = Math.max(this.maxY, e.y + d / 2)
					}
				}
			}
			this.minX -= (this.nodeSize * 1.5);
			this.minY -= (this.nodeSize * 1.5);
			this.maxX += (this.nodeSize * 1.5);
			this.maxY += (this.nodeSize * 1.5);
			this.rangeX = this.maxX - this.minX;
			this.rangeY = this.maxY - this.minY
		}
	};
	this.setNetworkRotation = function() {
		if (this.is3DNetwork && this.layoutDone) {
			var k = [];
			var e = [];
			var p = [];
			this.set3DRotation();
			for (var f = 0; f < this.data.nodes.length; f++) {
				e.push(f);
				var c = this.data.nodes[f];
				var g = this.get3DTransfrom(c.x, c.y, c.z);
				c.x3d = g[0];
				c.y3d = g[1];
				c.z3d = g[2];
				k.push(Math.sqrt((c.x3d * c.x3d) + (c.y3d * c.y3d) + (c.z3d * c.z3d)))
			}
			e.sort(function(j, i) {
				return k[i] - k[j]
			});
			for (var o = 0; o < this.data.nodes.length; o++) {
				var f = e[o];
				var c = this.data.nodes[f];
				p.push(c)
			}
			this.data.nodes = p;
			this.setNodeIndices()
		} else {
			if (this.network2DRotate != 0) {
				if (this.network2DRotate >= Math.abs(360)) {
					this.network2DRotate = 0
				}
				var l = Math.PI * this.network2DRotate / 360;
				for (var f = 0; f < this.data.nodes.length; f++) {
					var c = this.data.nodes[f];
					if (c.x != null && c.y != null) {
						var n = c.x;
						var m = c.y;
						c.x = (n * Math.cos(l)) - (m * Math.sin(l));
						c.y = (m * Math.cos(l)) + (n * Math.sin(l))
					}
				}
				for (var f = 0; f < this.data.edges.length; f++) {
					var b = this.data.edges[f];
					if (b.elbows && b.elbows.length > 0) {
						for (var d = 0; d < b.elbows.length; d++) {
							var n = b.elbows[d][0];
							var m = b.elbows[d][1];
							b.elbows[d][0] = (n * Math.cos(l)) - (m * Math.sin(l));
							b.elbows[d][1] = (m * Math.cos(l)) + (n * Math.sin(l))
						}
					}
				}
				if (this.data.legend.pos.nodes.x && this.data.legend.pos.nodes.y) {
					var n = this.data.legend.pos.nodes.x;
					var m = this.data.legend.pos.nodes.y;
					this.data.legend.pos.nodes.x = (n * Math.cos(l)) - (m * Math.sin(l));
					this.data.legend.pos.nodes.y = (m * Math.cos(l)) + (n * Math.sin(l))
				}
				if (this.data.legend.pos.edges.x && this.data.legend.pos.edges.y) {
					var n = this.data.legend.pos.edges.x;
					var m = this.data.legend.pos.edges.y;
					this.data.legend.pos.edges.x = (n * Math.cos(l)) - (m * Math.sin(l));
					this.data.legend.pos.edges.y = (m * Math.cos(l)) + (n * Math.sin(l))
				}
				if (this.data.legend.text) {
					for (var f = 0; f < this.data.legend.text.length; f++) {
						var h = this.data.legend.text[f];
						var n = h.x;
						var m = h.y;
						h.x = (n * Math.cos(l)) - (m * Math.sin(l));
						h.y = (m * Math.cos(l)) + (n * Math.sin(l))
					}
				}
				this.network2DRotate = 0
			}
		}
	};
	this.setNetworkScaleFactor = function() {
		if (!this.networkFreeze || this.scaleFactor == null || isNaN(this.scaleFactor)) {
			this.scaleFactor = this.networkLayoutType == "radial" ? 0.3 : Math.min(this.x / (this.maxX - this.minX), this.y / (this.maxY - this.minY))
		}
		this.scaleFactor *= this.zoom;
		if (this.networkFreeze) {
			this.zoomGlobal *= this.zoom;
			this.zoom = 1
		}
		this.widthBounds = this.x / this.scaleFactor;
		this.heightBounds = this.y / this.scaleFactor;
		this.offsetX = ((this.widthBounds / 2) - ((this.minX + this.maxX) / 2)) + this.panningX + this.panningGlobalX;
		this.offsetY = ((this.heightBounds / 2) - ((this.minY + this.maxY) / 2)) + this.panningY + this.panningGlobalY
	};
	this.optimizeNetworkLayout = function(e) {
		if (this.data.nodes.length > 0) {
			this.isAnimation = true;
			this.setInitialForceDirectedLayout();
			this.preUpdateTime = new Date().getTime();
			this.networkUpdateTime = 0;
			var b = this.layoutTime * 1000;
			var c = this.maxIterations * (e ? e.i.length : this.data.nodes.length) * 10;
			var d = this;
			var f = e ? {
				minX: d.min(e.x),
				maxX: d.max(e.x),
				minY: d.min(e.y),
				maxY: d.max(e.y)
			} : false;
			var g = function() {
				this.update = function() {
					var j = function() {
						var n = {
							minX: Number.MAX_VALUE,
							maxX: -Number.MAX_VALUE,
							minY: Number.MAX_VALUE,
							maxY: -Number.MAX_VALUE
						};
						for (var m = 0; m < e.i.length; m++) {
							var o = d.data.nodes[d.data.nodeIndices[e.i[m]]];
							n.minX = Math.min(n.minX, o.x);
							n.maxX = Math.max(n.maxX, o.x);
							n.minY = Math.min(n.minY, o.y);
							n.maxY = Math.max(n.maxY, o.y)
						}
						var q = (n.maxX - n.minX) / (f.maxX - f.minX);
						var p = (n.maxY - n.minY) / (f.maxY - f.minY);
						var l = (n.minX / q) - f.minX;
						var k = (n.minY / p) - f.minY;
						for (var m = 0; m < e.i.length; m++) {
							var o = d.data.nodes[d.data.nodeIndices[e.i[m]]];
							o.x = (o.x / q) - l;
							o.y = (o.y / p) - k
						}
					};
					var i = new Date().getTime();
					if (e) {
						j()
					}
					if (d.updateForceDirectedLayout(30) || i - d.preUpdateTime > b || d.iteration > c) {
						d.layoutDone = true;
						clearInterval(h);
						d.isAnimation = false;
						d.iteration = 0;
						if (e) {
							j()
						}
					}
					d.renderNetwork()
				};
				var h = this.setInterval(this.update, 30)
			};
			g.call()
		}
	};
	this.recalculateLayoutSelectedNodes = function() {
		if (this.data.nodes.length > 0) {
			this.layoutDone = false;
			this.randomSeed = 8;
			this.networkForceConstant = 0;
			this.temperature = 0;
			this.initialTemperature = 0;
			var b = this.data.edges;
			var d = this.getSelectedNodeCoordinates();
			d.e = [];
			for (var c = 0; c < b.length; c++) {
				if (this.selectNode.hasOwnProperty(b[c].id1) && this.selectNode.hasOwnProperty(b[c].id2)) {
					d.e.push[b[c].id1, b[c].id2] = true
				}
			}
			this.showHideSelectedDataPoint(false, 1000, true);
			this.setNetworkPrivateParams(d);
			this.optimizeNetworkLayout(d)
		}
	};
	this.getPolar = function(c, b) {
		return {
			x: this.networkXCenter + c * Math.cos(b * Math.PI / 180),
			y: this.networkYCenter + c * Math.sin(b * Math.PI / 180)
		}
	};
	this.setNodePositions = function(b) {
		for (var d in b) {
			var c = this.data.nodes[this.data.nodeIndices[d]];
			c.x = b[d].x;
			c.y = b[d].y
		}
	};
	this.animateRadialNodePositions = function() {
		this.isAnimation = true;
		var f = this;
		var e = 15;
		var d = 0;
		var c = 0;
		for (var h in f.finalRadialNodePositions) {
			if (this.initialRadialNodePositions[h].r == 0) {
				this.initialRadialNodePositions[h].a = this.finalRadialNodePositions[h].a
			}
			if (this.finalRadialNodePositions[h].r == 0) {
				this.finalRadialNodePositions[h].a = this.initialRadialNodePositions[h].a
			}
			var b = (this.finalRadialNodePositions[h].a - this.initialRadialNodePositions[h].a);
			if (b < 0) {
				b += 360
			}
			if (b > 360) {
				b -= 360
			}
			if (b > 180) {
				b -= 360
			}
			this.finalRadialNodePositions[h].a = (this.initialRadialNodePositions[h].a + b)
		}
		var g = function() {
			this.update = function() {
				var k = {};
				var s = Math.atan((d / e) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
				var p = 1 - s;
				for (var m in f.finalRadialNodePositions) {
					var j = ((p * f.initialRadialNodePositions[m].a) + (s * f.finalRadialNodePositions[m].a));
					var l = ((p * f.initialRadialNodePositions[m].r) + (s * f.finalRadialNodePositions[m].r));
					var q = f.getPolar(l, j);
					k[m] = {
						x: q.x,
						y: q.y
					}
				}
				if (d >= e) {
					clearInterval(i);
					f.isAnimation = false;
					k = f.finalRadialNodePositions
				}
				d++;
				f.setNodePositions(k);
				f.renderNetwork();
				if (!f.isAnimation && f.networkLayoutType == "radial" && f.showNetworkRadialLayout) {
					f.renderRadialLayout()
				}
			};
			var i = this.setInterval(this.update, 50)
		};
		g.call()
	};
	this.setFinalRadialNodePositions = function(e, d) {
		if (!this.finalRadialNodePositions) {
			this.finalRadialNodePositions = {}
		}
		if (!this.nodeParentHood.drawn.hasOwnProperty(e)) {
			var m, o, g, n, b;
			var f = this.data.nodes[this.data.nodeIndices[e]];
			if (!f.hide && !f.hiddenParent) {
				if (this.nodeParentHood[e].children.length > 1 && !d) {
					var k = [];
					var j = this;
					if (this.orderRadialNetwork) {
						this.nodeParentHood[e].children.sort(function(i, c) {
							return j.orderRadialNetwork[i] - j.orderRadialNetwork[c]
						})
					}
					for (var h = 0; h < this.nodeParentHood[e].children.length; h++) {
						if (this.nodeParentHood[this.nodeParentHood[e].children[h]].level > this.nodeParentHood[e].level) {
							this.setFinalRadialNodePositions(this.nodeParentHood[e].children[h]);
							k.push(this.nodeParentHood[this.nodeParentHood[e].children[h]].angle)
						}
					}
					if (k.length > 0) {
						if (k.length == 1) {
							n = k[0]
						} else {
							if (k[0] > k[k.length - 1]) {
								n = ((k[0] + k[k.length - 1]) % 360) / 2
							} else {
								n = (k[0] + k[k.length - 1]) / 2
							}
						}
					} else {
						this.setFinalRadialNodePositions(e, true)
					}
				} else {
					n = this.networkCurrentAngle;
					this.networkCurrentAngle = (this.networkCurrentAngle + this.networkAngleStep)
				}
				g = (this.networkDepth - 1) - this.nodeParentHood[e].level;
				m = this.getPolar(this.networkRadialRadius, n);
				o = this.shortenLine(this.networkXCenter, this.networkYCenter, m.x, m.y, 0, this.networkLevelSize * g, "line");
				b = this.lineLength(this.networkXCenter, this.networkYCenter, o[2], o[3]);
				if (this.nodeParentHood[e].level == 0) {
					n = 0;
					b = 0
				}
				this.finalRadialNodePositions[f.id] = {
					x: o[2],
					y: o[3],
					r: b,
					a: n % 360
				};
				this.nodeParentHood.drawn[e] = true;
				this.nodeParentHood[e].angle = n
			}
		}
	};
	this.setInitialRadialNodePositions = function() {
		if (!this.initialRadialNodePositions) {
			this.initialRadialNodePositions = {};
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (!this.data.nodes[b].hide && !this.data.nodes[b].hiddenParent) {
					var c = this.data.nodes[b];
					this.initialRadialNodePositions[c.id] = {
						x: this.networkXCenter,
						y: this.networkYCenter,
						r: 0,
						a: 0
					}
				}
			}
		} else {
			this.initialRadialNodePositions = this.finalRadialNodePositions;
			this.finalRadialNodePositions = false
		}
	};
	this.setRadialNetwrorkLayout = function() {
		if (this.data.nodes.length > 0) {
			this.networkLevelSize = this.x * 4 / (this.networkDepth * 2);
			this.networkAngleStep = 360 / this.networkDivisions;
			this.networkCurrentAngle = this.networkCurrentAngle ? this.networkCurrentAngle : 0;
			this.networkRadialRadius = this.networkLevelSize * (this.networkDepth - 1);
			this.setInitialRadialNodePositions();
			this.setFinalRadialNodePositions(this.networkRoot);
			this.layoutDone = true;
			if (this.showAnimation) {
				this.animateRadialNodePositions()
			} else {
				this.setNodePositions(this.finalRadialNodePositions);
				this.renderNetwork()
			}
		}
	};
	this.unsetNetworkCommunities = function() {
		this.functionCaller = "unsetNetworkCommunities";
		if (this.isTransition()) {
			return
		}
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		this.isNetworkConvexHull = false;
		this.draw(false, false, false, true);
		this.removeMenus()
	};
	this.setNetworkCommunities = function(d) {
		this.functionCaller = "setNetworkCommunities";
		if (this.isTransition()) {
			return
		}
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		var e = [];
		for (var g = 0; g < this.data.nodes.length; g++) {
			e.push(this.data.nodes[g].id)
		}
		var b = 0;
		var h;
		if (this.calculateNetworkCommunities) {
			h = jLouvain().nodes(e).edges(this.data.edges)();
			for (var g = 0; g < this.data.nodes.length; g++) {
				var k = h[this.data.nodes[g].id];
				b = Math.max(b, k);
				this.data.nodes[g].community = k;
				this.data.nodes[g].communityColor = this.colors[this.data.nodes[g].community % this.colors.length]
			}
		} else {
			for (var g = 0; g < this.data.nodes.length; g++) {
				var k = this.data.nodes[g].community || 0;
				b = Math.max(b, k);
				this.data.nodes[g].communityColor = this.colors[this.data.nodes[g].community % this.colors.length]
			}
		}
		this.networkCommunities = b + 1;
		for (var g = 0; g < this.networkCommunities; g++) {
			var e = [];
			for (var f = 0; f < this.data.nodes.length; f++) {
				if (this.data.nodes[f].community == g) {
					e.push(f)
				}
			}
			this.networkConvexHulls[g] = {
				nodes: e,
				drawn: false
			}
		}
		this.isNetworkConvexHull = true;
		this.removeMenus();
		if (d) {
			this.draw(false, false, false, true)
		}
	};
	this.drawNetworkCommunities = function() {
		var b = this;
		var c = function() {
			this.update = function() {
				if (b.layoutDone) {
					b.setNetworkCommunities(true);
					clearInterval(d)
				}
			};
			var d = this.setInterval(this.update, 30)
		};
		c.call()
	};
	this.getHull = function(s) {
		var c = this;
		var b = function(m, l, i) {
			return (l[0] - m[0]) * (i[1] - m[1]) - (l[1] - m[1]) * (i[0] - m[0])
		};
		var d = function(p) {
			var m = p.size ? p.size : 1;
			var i = p.width ? p.width : c.nodeSize * m;
			var l = p.height ? p.height : c.nodeSize * m;
			return [p.x, p.y, i, l]
		};
		var v = [];
		var C, D;
		var A, B;
		var o = 0;
		for (var w = 0; w < s.length; w++) {
			var r = d(this.data.nodes[s[w]]);
			var f = r.x;
			var e = r.y;
			if (r[0] > C || !C) {
				C = r[0]
			}
			if (r[0] < D || !D) {
				D = r[0]
			}
			if (r[1] > A || !A) {
				A = r[1]
			}
			if (r[1] < B || !B) {
				B = r[1]
			}
			o = Math.max(o, Math.max(r[2], r[3]));
			v.push([r[0], r[1]])
		}
		var h = (D + C) / 2;
		var g = (B + A) / 2;
		if (v.length == 1) {
			var r = d(this.data.nodes[s[0]]);
			v.push([h - r[2], g]);
			v.push([h, g - r[3]]);
			v.push([h + r[2], g]);
			v.push([h, g + r[3]])
		} else {
			if (v.length == 2) {
				var r = d(this.data.nodes[s[0]]);
				var t = d(this.data.nodes[s[1]]);
				v.push([h - o, g]);
				v.push([h, g - o]);
				v.push([h + o, g]);
				v.push([h, g + o])
			}
		}
		v.sort(function(l, i) {
			return (l[0] - i[0]) || (l[1] - i[1])
		});
		var E = [0, 0];
		var F = [];
		var z = [];
		var w, u;
		for (w = 0, u = v.length; w < u; w++) {
			var k = v[w];
			var j = v[u - w - 1];
			while (F.length >= 2 && b(F[F.length - 2], F[F.length - 1], k) <= 0) {
				F.pop()
			}
			F.push(k);
			while (z.length >= 2 && b(z[z.length - 2], z[z.length - 1], j) <= 0) {
				z.pop()
			}
			z.push(j);
			E[0] += k[0];
			E[1] += k[1]
		}
		E[0] *= 1 / s.length;
		E[1] *= 1 / s.length;
		z.pop();
		F.pop();
		return [this.expandPolygon(F.concat(z), o * this.hullScale), D, C, B, A]
	};
	this.createRandomNetwork = function(u) {
		var m = {};
		var b = {};
		if (u) {
			m = this.createMesh()
		} else {
			m.nodes = [];
			var e = Math.floor(this.random() * this.randomNetworkNodes) + 1;
			for (var o = 0; o < e; o++) {
				var h = {};
				var s = Math.floor(this.random() * this.shapes.length);
				var f = Math.floor(this.random() * this.colors.length);
				h.id = "id" + o;
				h.shape = this.shapes[s];
				if (h.shape == "image") {
					h.imagePath = "cx"
				}
				h.color = this.colors[f];
				h.size = 1;
				m.nodes.push(h)
			}
			m.edges = [];
			if (this.lines.length == 0) {
				this.lines = this.setLineTypes()
			}
			for (var o = 0; o < m.nodes.length; o++) {
				var g = m.nodes[o];
				var l = [];
				for (var k = 0; k < Math.floor(this.random() * this.randomNetworkNodeEdgesMax) - 1; k++) {
					l.push(Math.floor(this.random() * e))
				}
				for (var k = 0; k < l.length; k++) {
					var d = m.nodes[l[k]];
					var r = o + ":" + l[k];
					var q = l[k] + ":" + o;
					if (g.id != d.id && !b.hasOwnProperty(r) && !b.hasOwnProperty(r)) {
						var c = {};
						var t = Math.floor(this.random() * this.lines.length);
						var f = Math.floor(this.random() * this.colors.length);
						c.id1 = g.id;
						c.id2 = d.id;
						c.width = 1;
						c.type = this.lines[t];
						c.color = this.colors[f];
						m.edges.push(c);
						b[r] = 1;
						b[q] = 1
					}
				}
			}
		}
		if (this.randomNetworkReduce) {
			var p = this.normalizeGraph(m);
			m = this.reduceNetwork(p, function(j, i) {
				if (j.nodes && i.nodes) {
					if (j.nodes.length >= i.nodes.length) {
						return j
					} else {
						return i
					}
				} else {
					if (j.nodes) {
						return j
					} else {
						if (i.nodes) {
							return i
						} else {
							return null
						}
					}
				}
			})
		}
		if (m.nodes.length < 5) {
			return this.createRandomNetwork(true)
		} else {
			var l = [];
			for (var o = 0; o < m.edges.length; o++) {
				if (m.edges[o].id1 && m.edges[o].id2) {
					l.push(m.edges[o])
				}
			}
			m.edges = l;
			this.resetObjectAttributes();
			return m
		}
	};
	this.createMesh = function() {
		var g = {};
		g.nodes = [];
		g.edges = [];
		var f = 7;
		var b = this;
		for (var i = 0; i < f * f; i++) {
			var d = {};
			var h = Math.floor(this.random() * this.shapes.length);
			var c = Math.floor(this.random() * this.colors.length);
			d.id = "id" + i;
			d.shape = this.shapes[h];
			d.color = this.colors[c];
			d.size = 1;
			g.nodes.push(d)
		}
		var e = function(n, m) {
			var l = {};
			var j = Math.floor(b.random() * b.lines.length);
			var k = Math.floor(b.random() * b.colors.length);
			l.id1 = g.nodes[n].id;
			l.id2 = g.nodes[m].id;
			l.width = 1;
			l.type = b.lines[j];
			l.color = b.colors[k];
			return l
		};
		for (var i = 0; i < g.nodes.length; i++) {
			if (Math.floor(this.random() * f) != 0) {
				if (i + 1 < g.nodes.length && (i + 1) % f != 0) {
					g.edges.push(e(i, i + 1))
				}
				if (i + f < g.nodes.length) {
					g.edges.push(e(i, i + f))
				}
			}
		}
		return g
	};
	this.setNodeChildren = function(g, c, h) {
		this.networkDepth = c > this.networkDepth ? c : this.networkDepth;
		var e = this.data.nodes[this.data.nodeIndices[g]];
		if (!e.hide && !e.hiddenParent) {
			var b = this.edgesForNode(this.data.edges, g);
			if (!this.nodeParentHood.hasOwnProperty(g)) {
				if (b.length == 1) {
					this.networkDivisions++
				}
				if (b.length > 0) {
					for (var d = 0; d < b.length; d++) {
						if (!this.nodeParentHood[g]) {
							this.nodeParentHood[g] = {};
							this.nodeParentHood[g].children = [];
							this.nodeParentHood[g].level = c;
							this.nodeParentHood[g].angle = 0;
							this.nodeParentHood[g].parent = h
						}
						this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
						if (b[d].id1 == g) {
							this.nodeParentHood[g].children.push(b[d].id2);
							this.setNodeChildren(b[d].id2, c + 1, g)
						} else {
							if (b[d].id2 == g) {
								this.nodeParentHood[g].children.push(b[d].id1);
								this.setNodeChildren(b[d].id1, c + 1, g)
							}
						}
					}
				}
			} else {
				this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
				for (var d = 0; d < this.nodeParentHood[g].children.length; d++) {
					var f = this.nodeParentHood[g].children[d];
					if (this.nodeParentHood[f]) {
						if ((c + 1) < this.nodeParentHood[f].level) {
							this.nodeParentHood[f].level = c + 1;
							this.nodeParentHood[f].parent = g
						}
					}
				}
			}
		}
	};
	this.setNodeParentHood = function() {
		this.nodeParentHood = {};
		if (this.networkLayoutType == "radial") {
			if (!this.networkRoot) {
				this.networkRoot = this.data.nodes[0].id
			}
			this.nodeParentHood.drawn = {};
			this.networkDepth = 0;
			this.networkDivisions = 0;
			this.setNodeChildren(this.networkRoot, 0, false)
		} else {
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (!this.data.nodes[b].hide) {
					if (this.data.nodes[b].parentNode || this.data.nodes[b].hideChildren) {
						if (this.data.nodes[b].parentNode && !this.nodeParentHood.hasOwnProperty(this.data.nodes[b].parentNode)) {
							this.nodeParentHood[this.data.nodes[b].parentNode] = {}
						}
						if (this.data.nodes[b].parentNode) {
							if (!this.nodeParentHood[this.data.nodes[b].parentNode].children) {
								this.nodeParentHood[this.data.nodes[b].parentNode].children = []
							}
							this.nodeParentHood[this.data.nodes[b].parentNode].children.push(this.data.nodes[b].id);
							if (this.data.nodes[this.data.nodeIndices[this.data.nodes[b].parentNode]].hideChildren) {
								this.data.nodes[b].hiddenParent = true
							}
						}
						if (this.data.nodes[b].hideChildren) {
							if (!this.nodeParentHood.hasOwnProperty(this.data.nodes[b].id)) {
								this.nodeParentHood[this.data.nodes[b].id] = {}
							}
							this.nodeParentHood[this.data.nodes[b].id].hideChildren = true
						}
					}
				}
			}
			for (var c in this.nodeParentHood) {
				if (this.data.nodes[this.data.nodeIndices[c]].hideChildren || this.isParentHidden(c)) {
					this.hideUnhideChildrenNodes(c, true)
				} else {
					if (this.nodeParentHood[c].children) {
						this.hideUnhideChildrenNodes(c, false)
					}
				}
			}
		}
	};
	this.isParentHidden = function(d) {
		var c = this.findParentNodes(d);
		if (c) {
			for (var b = 0; b < c.length; b++) {
				if (this.data.nodes[this.data.nodeIndices[c[b]]].hideChildren) {
					return true
				}
			}
		}
		return false
	};
	this.findParentNodes = function(d, b) {
		if (this.data.nodes[this.data.nodeIndices[d]].parentNode) {
			var c = this.data.nodes[this.data.nodeIndices[d]].parentNode;
			if (!b) {
				b = []
			}
			b.push(c);
			b = this.findParentNodes(c, b);
			return b
		} else {
			return b ? b.reverse() : false
		}
	};
	this.findChildrenNodeIndices = function(d, c) {
		if (!c) {
			c = []
		}
		if (this.networkLayoutType != "radial") {
			if (this.nodeParentHood[d] && this.nodeParentHood[d]["children"]) {
				for (var b = 0; b < this.nodeParentHood[d]["children"].length; b++) {
					c.push(this.data.nodeIndices[this.nodeParentHood[d]["children"][b]]);
					c = this.findChildrenNodeIndices(this.nodeParentHood[d]["children"][b], c)
				}
			}
		}
		return c.length > 0 ? c : false
	};
	this.hasChildren = function(b) {
		return this.nodeParentHood[b] && this.nodeParentHood[b].children
	};
	this.findVisibleParentNode = function(d) {
		var c = this.findParentNodes(d);
		if (c) {
			c.reverse();
			for (var b = 0; b < c.length; b++) {
				if (!this.nodes[c[b]].hide && !this.nodes[c[b]].hiddenParent) {
					return this.nodes[c[b]]
				}
			}
		}
		return false
	};
	this.collateNetworks = function() {
		if (this.data.nodes.length > 0) {
			var l = this.normalizeGraph({
				nodes: this.data.nodes,
				edges: this.data.edges
			});
			if (l.length > 1) {
				var b = [];
				for (var h = 0; h < l.length; h++) {
					b.push(h)
				}
				b.sort(function(j, i) {
					return l[i].nodes.length - l[j].nodes.length
				});
				this.subNetworks = [];
				for (var p = 0; p < l.length; p++) {
					var h = b[p];
					var d = [];
					var m = [];
					var g = l[h].nodes.length;
					var k = l[h].edges.length;
					var c = g / this.data.nodes.length;
					var o = c * (this.x * Math.log(l.length));
					var n = c * (this.y * Math.log(l.length));
					var e = o * n;
					for (var f = 0; f < l[h].nodes.length; f++) {
						d.push(l[h].nodes[f].id)
					}
					for (var f = 0; f < l[h].edges.length; f++) {
						if (typeof l[h].edges[f] != "function") {
							m.push(l[h].edges[f])
						}
					}
					this.subNetworks.push({
						nodes: d,
						edges: m,
						x: o,
						y: n,
						area: e,
						networkForceConstant: Math.sqrt(e / g),
						temperature: g + Math.floor(Math.sqrt(k)),
						minimumTemperature: 1,
						initialTemperature: g + Math.floor(Math.sqrt(k)),
						initialProgress: null,
						layoutProgress: 0,
						layoutDone: false
					})
				}
			}
		}
	};
	this.setObjectAttributes = function() {
		if (this.colorNodeBy) {
			this.setAllObjectAttributes("nodes", "color", this.colorNodeBy)
		}
		if (this.shapeNodeBy) {
			this.setAllObjectAttributes("nodes", "shape", this.shapeNodeBy)
		}
		if (this.sizeNodeBy) {
			this.setAllObjectAttributes("nodes", "size", this.sizeNodeBy)
		}
		if (this.sizeDecorationBy) {
			this.setAllObjectAttributes("nodes", "size", this.sizeDecorationBy, true)
		}
		if (this.colorEdgeBy) {
			this.setAllObjectAttributes("edges", "color", this.colorEdgeBy)
		}
		if (this.shapeEdgeBy) {
			this.setAllObjectAttributes("edges", "shape", this.shapeEdgeBy)
		}
		if (this.sizeEdgeBy) {
			this.setAllObjectAttributes("edges", "size", this.sizeEdgeBy)
		}
	};
	this.resetObjectAttributes = function() {
		this.colorNodeBy = false;
		this.shapeNodeBy = false;
		this.sizeNodeBy = false;
		this.sizeDecorationBy = false;
		this.colorEdgeBy = false;
		this.shapeEdgeBy = false;
		this.sizeEdgeBy = false
	};
	this.setDecorationsRangeUnits = function() {
		this.decorationsRange = [];
		var c = {};
		var d = {};
		if (this.showDecorations && this.decorations.length > 0) {
			var n = [];
			for (var l = 0; l < this.data.nodes.length; l++) {
				var f = this.data.nodes[l];
				for (var h = 0; h < this.decorations.length; h++) {
					if (f[this.decorations[h]] || (f.decorations && f.decorations[this.decorations[h]])) {
						var o = f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]];
						if (this.isObject(o)) {
							if (this.decorationsType == "stacked") {
								var q = 0;
								for (var g in o) {
									if (!isNaN(o[g])) {
										d[g] = true;
										q += o[g]
									}
								}
								n.push(q)
							} else {
								if (this.decorationsType == "stackedpercent") {
									for (var g in o) {
										if (!isNaN(o[g])) {
											d[g] = true
										}
									}
									n = [0, 100]
								} else {
									if (this.decorationsType == "heatmap") {
										for (var g in o) {
											if (!isNaN(o[g])) {
												d[g] = true;
												n.push(o[g])
											}
										}
									} else {
										alert("Ooops! canvasXpress does not support " + this.decorationsType + " for this multidimensional plotting");
										return
									}
								}
							}
						} else {
							if (!isNaN(f[this.decorations[h]]) || (f.decorations && !isNaN(f.decorations[this.decorations[h]]))) {
								n.push(f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]])
							}
						}
					}
				}
			}
			this.decorationsRange = this.range(n);
			if (this.decorationsType == "stacked") {
				this.decorationsRange[0] = 0
			}
			var b = this.decorationsRange[1] - this.decorationsRange[0];
			if (b == 0) {
				this.decorationsRange[1] = this.max(n) + 1
			}
			var m = this.decorationsType.match(/stacked/) ? this.decorationsRange[0] : this.decorationsRange[0] - (b * 0.05);
			if (m > 0) {
				this.decorationsRange[0] = m;
				b = this.decorationsRange[1] - this.decorationsRange[0]
			}
			this.decorationsUnits = this.decorationsHeight / b;
			if (!this.data.legend) {
				this.data.legend = {}
			}
			this.data.legend.decorations = [];
			for (var l = 0; l < this.decorations.length; l++) {
				if (this.decorationsColors[l]) {
					c[this.decorationsColors[l]] = true;
					this.data.legend.decorations.push({
						shape: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle",
						color: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.decorationsColors[l],
						text: this.decorations[l],
						size: 0.5,
						font: 0.5
					})
				} else {
					for (var h = 0; h < this.colors.length; h++) {
						if (!c.hasOwnProperty(this.colors[h])) {
							var e = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.colors[h];
							var p = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle";
							this.decorationsColors[l] = e;
							c[e] = true;
							this.data.legend.decorations.push({
								shape: p,
								color: e,
								text: this.decorations[l],
								size: 0.5,
								font: 0.5
							});
							break
						}
					}
				}
			}
			var l = this.decorations.length;
			for (var g in d) {
				if (this.decorationsColors[l]) {
					c[this.decorationsColors[l]] = true;
					this.data.legend.decorations.push({
						shape: this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square",
						color: this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.decorationsColors[l],
						text: g,
						size: 0.5,
						font: 0.5
					})
				} else {
					for (var h = 0; h < this.colors.length; h++) {
						if (!c.hasOwnProperty(this.colors[h])) {
							var e = this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.colors[h];
							var p = this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square";
							this.decorationsColors[l] = e;
							c[e] = true;
							this.data.legend.decorations.push({
								shape: p,
								color: e,
								text: g,
								size: 0.5,
								font: 0.5
							});
							break
						}
					}
				}
				l++
			}
		}
	};
	this.checkDecorations = function() {
		if (!this.decorations) {
			this.decorations = []
		}
	};
	this.checkCalculateLayout = function() {
		if (!this.calculateLayout) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (this.is3DNetwork) {
					if (c.x3d == null || c.y3d == null) {
						this.calculateLayout = true;
						return
					}
				} else {
					if (c.x == null || c.y == null) {
						this.calculateLayout = true;
						return
					}
				}
			}
		}
	};
	this.recalculateLayout = function() {
		this.calculateLayout = true;
		this.initializeNetwork()
	};
	this.validateXYNodeCoordinates = function() {
		for (var b = 0; b < this.data.nodes.length; b++) {
			var c = this.data.nodes[b];
			if (this.is3DNetwork) {
				if (c.x3d == null) {
					c.x3d = -1
				}
				if (c.y3d == null) {
					c.y3d = -1
				}
			} else {
				if (c.x == null) {
					c.x = -1
				}
				if (c.y == null) {
					c.y = -1
				}
			}
		}
	};
	this.drawNetworkPlot = function() {
		this.showAnimationFont = (this.showAnimationFontSize) + "px " + this.fontName;
		this.setNodeParentHood();
		this.setObjectAttributes();
		this.setDecorationsRangeUnits();
		if (this.calculateLayout) {
			this.collateNetworks();
			this.setNetworkPrivateParams();
			if (this.networkLayoutType == "radial") {
				this.setRadialNetwrorkLayout()
			} else {
				this.optimizeNetworkLayout()
			}
			this.calculateLayout = false
		} else {
			this.validateXYNodeCoordinates();
			this.layoutDone = true;
			if (this.networkLayoutType == "radial" && this.showAnimation) {
				this.setRadialNetwrorkLayout()
			} else {
				this.renderNetwork()
			}
		}
		if (this.networkFreezeOnLoad && this.layoutDone) {
			this.networkFreezeOnLoad = false;
			this.networkFreeze = true
		}
	};
	this.initializeNetwork = function() {
		this.checkCalculateLayout();
		this.setNetworkDimensions();
		if (!this.nodes && this.data.nodes) {
			this.setNodes()
		}
		this.drawNetworkPlot()
	};
	if (!a) {
		this.initializeNetwork()
	}
};
CanvasXpress.prototype.Genome = function() {
	this.setGenomeSubtracks = function() {
		this.subtracks = [];
		this.subtracksInfo = [];
		this.y = this.margin;
		var a = this.marginTop + this.top;
		var G = 0;
		var C = this.xAxisMin * this.xAxisUnit;
		var u = this.xAxisMax * this.xAxisUnit;
		for (var I = 0; I < this.data.tracks.length; I++) {
			var g, q, K, n;
			var f = [];
			var A = [];
			var F = 0;
			var w = this.data.tracks[I];
			var d = w.data;
			var b = w.type ? w.type : this.featureTypeDefault;
			var J = w.height ? w.height : this.featureHeightDefault;
			var B = w.subtracksMax || this.subtracksMaxDefault;
			var L = w.bumpSpace ? w.bumpSpace : 0;
			if (!w.hide) {
				if (w.name && !w.hideName) {
					this.y += this.trackNameFontSize + (this.margin * 2)
				}
				w.startY = this.marginTop + this.top + this.y;
				this.subtracks[I] = [];
				if (this.featureStaggered) {
					for (var E = 0; E < d.length; E++) {
						var c = d[E];
						var p = this.shortenText(c.label || c.name || c.id, this.maxFeatureStringLen);
						var y = c.hideName || w.hideFeatureNames ? 0 : this.measureText(p, this.featureNameFont) + (this.margin * 3);
						var M = c.data;
						if (!c.hide) {
							c.index = E;
							c.counter = G++;
							if (b == "box") {
								g = this.getGenomeBoxRange(M);
								q = g[0] * this.xAxisUnit;
								K = (g[1] + L) * this.xAxisUnit;
								if (c.showDir && this.xAxisUnit > 0.001) {
									if (c.dir == "right") {
										K += 11
									} else {
										q -= 11
									}
								}
								K = Math.max(q + y, K)
							} else {
								if (b == "sequence") {
									var x = this.setGenomeGaps(c.gaps, c.sequence.length, c.dir);
									if (c.offsetLeft && !c.offset) {
										c.offset = (c.offsetLeft - (c.sequence.length + x.total)) + 1
									}
									q = c.offset * this.xAxisUnit;
									K = q + ((c.sequence.length + x.total + L) * this.xAxisUnit);
									K = Math.max(q + y, K)
								} else {
									q = (c.offset + L) * this.xAxisUnit;
									K = w.autowidth && this.isArray(M) ? q + (M[0].length * this.xAxisUnit) : q + w.width ? w.width : this.featureWidthDefault;
									K = Math.max(q + y, K)
								}
							}
							n = q >= C && q <= u ? true : K >= C && K <= u ? true : q <= C && K >= u ? true : false;
							f.push([q, K, n, E])
						}
					}
					if (f.length > 0) {
						f.sort(function(h, e) {
							return h[0] - e[0]
						});
						for (var E = 0; E < f.length; E++) {
							if (f[E][2]) {
								n = false;
								for (var D = 0; D < A.length; D++) {
									K = Math.round(A[D][A[D].length - 1][1]);
									if (Math.round(f[E][0]) >= K) {
										A[D].push(f[E]);
										n = true;
										break
									}
								}
								if (!n) {
									A.push([f[E]])
								}
							}
						}
						for (var E = 0; E < A.length; E++) {
							if (E < B) {
								this.subtracks[I][E] = [];
								F += A[E].length;
								var H = 0;
								var t = 0;
								var o = 0;
								for (var D = 0; D < A[E].length; D++) {
									c = d[A[E][D][3]];
									this.subtracks[I][E].push(A[E][D][3]);
									this.subtracksInfo[c.counter] = {
										track: I,
										subtrack: E,
										index: c.index,
										name: c.label || c.name || c.id,
										start: a + this.y
									};
									if (b == "box") {
										H = Math.max(H, this.getBoxFeatureHeight(c));
										t = Math.max(t, c.translatesTop || 0);
										o = Math.max(o, c.translatesBottom || 0)
									} else {
										if (b == "sequence") {
											H = Math.max(H, this.getSequenceFeatureHeight(c))
										}
									}
								}
								if (!this.isNameInSubtrack(w, this.subtracks[I][E])) {
									this.y += this.featureNameFontSize + this.margin
								}
								this.y += J + this.margin;
								if (b == "box" || b == "sequence") {
									this.y += H
								}
								for (var D = 0; D < A[E].length; D++) {
									c = d[A[E][D][3]];
									this.subtracksInfo[c.counter].end = a + this.y;
									this.subtracksInfo[c.counter].maxHeight = H;
									this.subtracksInfo[c.counter].translateTop = t;
									this.subtracksInfo[c.counter].translateBottom = o
								}
							}
						}
					}
				} else {
					for (var E = 0; E < d.length; E++) {
						var c = d[E];
						if (!c.hide) {
							c.index = E;
							c.counter = G++;
							if (E < B) {
								F++;
								this.subtracks[I][E] = [E];
								this.subtracksInfo[c.counter] = {
									track: I,
									subtrack: E,
									index: c.index,
									name: c.label || c.name || c.id,
									start: a + this.y
								};
								this.y += J + this.margin;
								if (b == "box") {
									this.subtracksInfo[c.counter].maxHeight = this.getBoxFeatureHeight(c);
									this.subtracksInfo[c.counter].translateTop = c.translatesTop || 0;
									this.subtracksInfo[c.counter].translateBottom = c.translatesBottom || 0;
									this.y += this.subtracksInfo[c.counter].maxHeight
								} else {
									if (b == "sequence") {
										this.subtracksInfo[c.counter].maxHeight = this.getSequenceFeatureHeight(c);
										this.y += this.subtracksInfo[c.counter].maxHeight
									}
								}
								this.subtracksInfo[c.counter].end = a + this.y
							}
						}
					}
				}
				w.endY = this.y;
				w.displayedFeatures = F;
				w.totalFeatures = d.length;
				this.y += (this.margin * 2)
			}
		}
	};
	this.isNameInSubtrack = function(a, e) {
		for (var c = 0; c < e.length; c++) {
			var d = e[c];
			var b = a.data[d];
			if (!b.hideName && !a.hideFeatureNames) {
				return false
			}
		}
		return true
	};
	this.getGenomeRange = function(a) {
		var f = [];
		var d = [];
		for (var e = 0; e < a.length; e++) {
			if (a[e].range) {
				f.push(a[e].range[0]);
				d.push(a[e].range[1])
			} else {
				var h = [];
				var g = a[e].data;
				if (this.isArray(g[0])) {
					for (var c = 0; c < g.length; c++) {
						for (var b = 0; b < g[c].length; b++) {
							h = h.concat(g[c][b])
						}
					}
				} else {
					for (var c = 0; c < g.length; c++) {
						h = h.concat(g[c])
					}
				}
				a[e].range = this.range(h);
				f.push(a[e].range[0]);
				d.push(a[e].range[1])
			}
		}
		return this.range([this.min(f), this.max(d)])
	};
	this.getGenomeBoxRange = function(c) {
		if (c) {
			var a = [];
			for (var b = 0; b < c.length; b++) {
				a.push(c[b][0]);
				a.push(c[b][1])
			}
			a.sort(function(e, d) {
				return e - d
			});
			return [a[0], a[a.length - 1]]
		} else {
			return [0, 1]
		}
	};
	this.setGenomeGaps = function(e, a, b) {
		var d = 0;
		var f = {
			total: d
		};
		if (e && this.isArray(e) && e.length > 0) {
			for (var c = 0; c < e.length; c++) {
				var h = b == "left" ? a - e[c][0] : e[c][0];
				f[h] = e[c][1];
				d += e[c][1]
			}
			f.total = d
		}
		return f
	};
	this.getBoxFeatureHeight = function(b) {
		if (this.genomeResolution != "low" && (b.translate || b.sequence)) {
			if (b.dir == "left" && !b.sequenceRC) {
				b.sequenceRC = this.getReverseComplement(b.sequence)
			}
			if (b.cds && !b.translate) {
				var a = b.cds[0] % 3 || 3;
				b.translate = b.dir == "left" ? [a * -1] : [a]
			}
			if (b.translate && !b.translateRC && this.featureTranslateShow) {
				b.translateRC = this.translate(b.translate, b.dir == "left" ? b.sequenceRC : b.sequence)
			}
			if (b.translate && this.genomeResolution == "high") {
				return this.featureTranslateHeight * b.translate.length
			}
		}
		return 0
	};
	this.getSequenceFeatureHeight = function(b) {
		var c = 0;
		if (this.genomeResolution == "high") {
			if (b.trace && this.featureTracesShow) {
				c += this.featureTraceHeight
			}
			if (b.translate && this.featureTranslateShow) {
				for (var a = 0; a < b.translate.length; a++) {
					c += this.featureTranslateHeight
				}
			}
			if (b.quality && this.featureQualityShow) {
				c += this.featureQualityHeight
			}
			if (b.signalToNoise && this.featureSignalToNoiseShow) {
				c += this.featureSignalToNoiseHeight
			}
			if (b.coordinate && this.featureCoordinateShow) {
				c += this.featureCoordinateHeight
			}
		} else {
			if (this.genomeResolution == "medium") {
				if (b.trace && this.featureTracesShow) {
					c += this.featureTraceHeight
				}
			}
		}
		return c
	};
	this.getReverseComplement = function(d) {
		var b = d.split("");
		var a = [];
		for (var c = 0; c < b.length; c++) {
			a.unshift(this.reverseComplement[b[c]] || b[c])
		}
		return a.join("")
	};
	this.translate = function(b, g) {
		var a = {
			top: [],
			bottom: []
		};
		var m = g.split("");
		var e = this.getReverseComplement(g).split("").reverse();
		for (var h = 0; h < b.length; h++) {
			var l = b[h];
			var f = {
				seq: [],
				off: 0,
				rf: b[h]
			};
			if (l == "-1") {
				f.off = e.length % 3;
				for (var d = e.length - 1; d >= 0; d -= 3) {
					var n = e[d] + e[d - 1] + e[d - 2];
					var k = this.codon[n.toUpperCase()];
					f.seq.unshift(k ? k[0] : "")
				}
				a.bottom.push(f)
			} else {
				if (l == "-2") {
					f.off = (e.length - 1) % 3;
					for (var d = e.length - 2; d >= 0; d -= 3) {
						var n = e[d] + e[d - 1] + e[d - 2];
						var k = this.codon[n.toUpperCase()];
						f.seq.unshift(k ? k[0] : "")
					}
					a.bottom.push(f)
				} else {
					if (l == "-3") {
						f.off = (e.length - 2) % 3;
						for (var d = e.length - 3; d >= 0; d -= 3) {
							var n = e[d] + e[d - 1] + e[d - 2];
							var k = this.codon[n.toUpperCase()];
							f.seq.unshift(k ? k[0] : "")
						}
						a.bottom.push(f)
					} else {
						if (l == "1") {
							f.off = 0;
							for (var d = 0; d < m.length; d += 3) {
								var n = m[d] + m[d + 1] + m[d + 2];
								var k = this.codon[n.toUpperCase()];
								f.seq.push(k ? k[0] : "")
							}
							a.top.push(f)
						} else {
							if (l == "2") {
								f.off = 1;
								for (var d = 1; d < m.length; d += 3) {
									var n = m[d] + m[d + 1] + m[d + 2];
									var k = this.codon[n.toUpperCase()];
									f.seq.push(k ? k[0] : "")
								}
								a.top.push(f)
							} else {
								if (l == "3") {
									f.off = 2;
									for (var d = 2; d < m.length; d += 3) {
										var n = m[d] + m[d + 1] + m[d + 2];
										var k = this.codon[n.toUpperCase()];
										f.seq.push(k ? k[0] : "")
									}
									a.top.push(f)
								}
							}
						}
					}
				}
			}
		}
		return a
	};
	this.setReverseTrace = function(j) {
		if (!j.reversed) {
			var d = j.A.length;
			var b = j.T.reverse();
			var m = j.G.reverse();
			var h = j.C.reverse();
			var f = j.A.reverse();
			var k = [];
			for (var e = 0; e < j.peak.length; e++) {
				k.unshift(d - j.peak[e])
			}
			j.A = b;
			j.C = m;
			j.G = h;
			j.T = f;
			j.peak = k;
			j.reversed = true
		}
	};
	this.getCoordinateStep = function() {
		var a = 1;
		if (this.xAxisUnit * 0.2 > this.sequenceFontSize) {
			a = 1
		} else {
			if (this.xAxisUnit * 0.5 > this.sequenceFontSize) {
				a = 5
			} else {
				if (this.xAxisUnit * 1 > this.sequenceFontSize) {
					a = 10
				} else {
					if (this.xAxisUnit * 200 > this.sequenceFontSize) {
						a = 20
					} else {
						if (this.xAxisUnit * 500 > this.sequenceFontSize) {
							a = 50
						} else {
							if (this.xAxisUnit * 1000 > this.sequenceFontSize) {
								a = 100
							} else {
								if (this.xAxisUnit * 2500 > this.sequenceFontSize) {
									a = 250
								} else {
									if (this.xAxisUnit * 5000 > this.sequenceFontSize) {
										a = 500
									} else {
										if (this.xAxisUnit * 2000 > this.sequenceFontSize) {
											a = 1000
										} else {
											if (this.xAxisUnit * 10000 > this.sequenceFontSize) {
												a = 5000
											} else {
												if (this.xAxisUnit * 20000 > this.sequenceFontSize) {
													a = 10000
												} else {
													if (this.xAxisUnit * 100000 > this.sequenceFontSize) {
														a = 50000
													} else {
														if (this.xAxisUnit * 200000 > this.sequenceFontSize) {
															a = 100000
														} else {
															if (this.xAxisUnit * 2000000 > this.sequenceFontSize) {
																a = 1000000
															} else {
																if (this.xAxisUnit * 20000000 > this.sequenceFontSize) {
																	a = 10000000
																} else {
																	if (this.xAxisUnit * 200000000 > this.sequenceFontSize) {
																		a = 100000000
																	} else {
																		if (this.xAxisUnit * 2000000000 > this.sequenceFontSize) {
																			a = 1000000000
																		} else {
																			if (this.xAxisUnit * 20000000000 > this.sequenceFontSize) {
																				a = 10000000000
																			} else {
																				if (this.xAxisUnit * 200000000000 > this.sequenceFontSize) {
																					a = 100000000000
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.xAxisRange / a > 10) {
			a *= (a * 0.1);
			while (a * 10 > this.xAxisRange) {
				a *= 0.1
			}
			return a
		} else {
			if (a * 3 > this.xAxisRange) {
				return a * 0.1
			} else {
				return a
			}
		}
	};
	this.getGenomeObjectColor = function(c, b, a, e) {
		if (b[c]) {
			return b[c]
		} else {
			if (a[c]) {
				return a[c]
			} else {
				if (this[c]) {
					return this[c]
				} else {
					if (e) {
						return e
					} else {
						return false
					}
				}
			}
		}
	};
	this.drawBoxSequenceName = function(k, b, e, p, n, j, c, r, d) {
		this.functionCaller = "drawBoxSequenceName";
		var l = this;
		var m = function(s, i) {
			var u = l.getGenomeObjectColor("featureDirColor", s, i);
			if (!u) {
				u = l.getGenomeObjectColor("featureFillColor", s, i);
				if (!u) {
					u = l.getGenomeObjectColor("fill", s, i, l.foreground)
				}
			}
			return u
		};
		var f = r.dir;
		var q = m(r, d);
		var g = this.getGenomeObjectColor("featureNameFontColor", r, d, this.foreground);
		var a = r.counter;
		var o = this.featureNameFontSize / 2;
		var h = this.measureText(b, this.featureNameFont) + this.margin;
		if (j >= this.xAxisMin && c <= this.xAxisMax) {
			e = n + e;
			this.addToRender(["drawText", b, e, p + o, this.featureNameFont, g, "left", "middle"], ["track-" + k + ":" + a])
		} else {
			if (j <= this.xAxisMin && c >= this.xAxisMin) {
				e = n;
				this.addToRender(["drawText", b, e, p + o, this.featureNameFont, g, "left", "middle"], ["track-" + k + ":" + a])
			} else {
				if ((j <= this.xAxisMax && c >= this.xAxisMax)) {
					e = n + e;
					this.addToRender(["drawText", b, e, p + o, this.featureNameFont, g, "left", "middle"], ["track-" + k + ":" + a])
				} else {
					e = n + e
				}
			}
		}
		if (f == "right") {
			this.addToRender(["drawShape", "polygon", [e + h, e + h + (this.margin * 2), e + h],
				[p - 1, p + o - 1, p + (o * 2) - 1], false, false, q, q, "closed"
			])
		} else {
			if (f == "left") {
				this.addToRender(["drawShape", "polygon", [e + h, e + h + (this.margin * 2), e + h + (this.margin * 2)],
					[p + o - 1, p - 1, p + (o * 2) - 1], false, false, q, q, "closed"
				])
			}
		}
	};
	this.drawGenomeLabels = function() {
		this.functionCaller = "drawGenomeLabels";
		if (!this.featureStaggered) {
			var g = this;
			var h = function(j, i) {
				var k = g.getGenomeObjectColor("featureDirColor", j, i);
				if (!k) {
					k = g.getGenomeObjectColor("featureFillColor", j, i);
					if (!k) {
						k = g.getGenomeObjectColor("fill", j, i, g.foreground)
					}
				}
				return k
			};
			var z = this.marginLeft;
			var c = this.marginTop + this.top + this.margin;
			var b = this.featureNameFontSize / 2;
			var a = 0;
			for (var y = 0; y < this.data.tracks.length; y++) {
				var r = this.data.tracks[y];
				var d = r.type || this.featureTypeDefault;
				var p = r.height || this.featureHeightDefault;
				if (!r.hide) {
					if (r.name && !r.hideName) {
						c += this.trackNameFontSize + (this.margin * 2)
					}
					for (var w = 0; w < this.subtracks[y].length; w++) {
						var A = this.subtracks[y][w];
						if (!A) {
							continue
						}
						for (var t = 0; t < A.length; t++) {
							var o = A[t];
							var e = r.data[o];
							var x = e.counter;
							var u = this.getGenomeObjectColor("featureNameFontColor", e, r, this.foreground);
							var v = h(e, r);
							var m = this.shortenText(e.label || e.name || e.id, this.maxFeatureStringLen);
							var f = this.measureText(m, this.featureNameFont) + this.margin;
							if (!e.hideName && !r.hideFeatureNames) {
								this.addToRender(["drawText", m, this.marginLeft, c + (p / 2), this.featureNameFont, u, "left", "middle"], ["track-" + y + ":" + x])
							}
							if (d == "box" || d == "sequence") {
								if (e.dir == "right") {
									this.addToRender(["drawShape", "polygon", [z + f, z + f + (this.margin * 2), z + f],
										[c, c + b, c + (b * 2)], false, false, v, v, "closed"
									])
								} else {
									if (e.dir == "left") {
										this.addToRender(["drawShape", "polygon", [z + f, z + f + (this.margin * 2), z + f + (this.margin * 2)],
											[c + b, c, c + (b * 2)], false, false, v, v, "closed"
										])
									}
								}
								if (e.translate && this.genomeResolution == "high") {
									var n = (this.featureNameFontSize - 2) + "px " + this.fontName;
									a = -5;
									if (e.trace && this.featureTracesShow) {
										a += this.featureTraceHeight
									}
									if (e.translate && this.featureTranslateShow) {
										for (var s = 0; s < e.translate.length; s++) {
											var q = "+" + e.translate[s];
											if (q == "+1") {
												this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
												a += this.featureTranslateHeight
											} else {
												if (q == "+2") {
													this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
													a += this.featureTranslateHeight
												} else {
													if (q == "+3") {
														this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
														a += this.featureTranslateHeight
													}
												}
											}
										}
										a += this.sequenceFontSize + 2;
										for (var s = 0; s < e.translate.length; s++) {
											var q = e.translate[s];
											if (q == "-1") {
												this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
												a += this.featureTranslateHeight
											} else {
												if (q == "-2") {
													this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
													a += this.featureTranslateHeight
												} else {
													if (q == "-3") {
														this.addToRender(["drawText", q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle"]);
														a += this.featureTranslateHeight
													}
												}
											}
										}
									}
								}
								if (d == "box") {
									c += this.getBoxFeatureHeight(e)
								} else {
									c += this.getSequenceFeatureHeight(e)
								}
							}
							c += p + this.margin
						}
					}
					c += this.margin * 2
				}
			}
		}
	};
	this.setMinMaxGenome = function(c, a, b) {
		if (a != null) {
			c = Math.max(c, a)
		}
		if (b != null) {
			c = Math.min(c, b)
		}
		return c
	};
	this.plotGenomeData = function() {
		this.functionCaller = "plotGenomeData";
		var A, z, ai, y, ag, x, g, U, C;
		var M = this.marginLeft + this.left;
		var a = this.marginTop + this.top;
		var af = this.xAxisUnit / 2;
		var P = this;
		var e = function(i, h) {
			var j = P.getGenomeObjectColor("featureDirColor", i, h);
			if (!j) {
				j = P.getGenomeObjectColor("featureFillColor", i, h);
				if (!j) {
					j = P.getGenomeObjectColor("fill", i, h, P.foreground)
				}
			}
			return j
		};
		this.addToRender(["setClipArea", this.setClipBoundaries()]);
		for (var Z = 0; Z < this.data.tracks.length; Z++) {
			var E = this.data.tracks[Z];
			var ah = E.type || this.featureTypeDefault;
			var f = E.height || this.featureHeightDefault;
			var D = E.subtracksMax || this.subtracksMaxDefault;
			var G = this.setMaxY != null ? this.setMaxY : E.setMaxY != null ? E.setMaxY : null;
			var ae = this.setMinY != null ? this.setMinY : E.setMinY != null ? E.setMinY : null;
			var r = ah.match(/bar|heatmap|line/) && G != null && ae != null ? [G, ae] : ah.match(/bar|heatmap|line/) ? this.getGenomeRange(E.data) : false;
			var B = ah.match(/bar|line|box/) && E.fill ? E.fill : false;
			var F = ah.match(/bar|line|box/) && E.outline ? E.outline : this.foreground;
			var p = B ? "closed" : "open";
			var O = false;
			A = M;
			if (!E.hide) {
				if (r) {
					if (G != null) {
						r[1] = G
					}
					if (ae != null) {
						r[0] = ae
					}
					if (r[0] == r[1]) {
						r[1] += 0.1;
						C = f
					} else {
						U = (r[1] - r[0]) * 1.05;
						C = f / U
					}
				}
				var T = this.getColorBrew(this.colorSpectrum, r[0], r[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
				if (E.name && !E.hideName) {
					var w = E.name;
					if (E.displayedFeatures != E.totalFeatures) {
						w += " (Showing " + E.displayedFeatures + " out of " + E.totalFeatures + ")"
					}
					this.addToRender(["drawText", w, A, a + (this.trackNameFontSize / 2) + this.margin, this.trackNameFont, E.trackNameFontColor || this.trackNameFontColor, "left", "middle"], ["track-" + Z]);
					a += this.trackNameFontSize + (this.margin * 2)
				}
				if (E.highlight && this.genomeResolution != "low") {
					var aa = E.highlight;
					for (var X = 0; X < aa.length; X++) {
						if (aa[X].offset) {
							var ad = aa[X].color ? aa[X].color : this.colors[Z % this.colors.length];
							A = this.marginLeft + this.left + (((aa[X].offset - 0.5) - this.xAxisMin) * this.xAxisUnit);
							z = aa[X].width ? aa[X].width * this.xAxisUnit : this.xAxisUnit;
							ai = (E.endY - E.startY) + f;
							this.addToRender(["drawShape", "rectangle", A + (z / 2), E.startY + (ai / 2), z, ai, ad, ad, "closed", false, false, true])
						}
					}
				}
				for (var X = 0; X < this.subtracks[Z].length; X++) {
					var u = this.subtracks[Z][X];
					if (!u) {
						continue
					}
					if (this.featureStaggered) {
						O = this.isNameInSubtrack(E, u)
					}
					for (var W = 0; W < u.length; W++) {
						var ac = u[W];
						var N = E.data[ac];
						var ab = N.data;
						var w = this.shortenText(N.label || N.name || N.id, this.maxFeatureStringLen);
						var J = this.getGenomeObjectColor("featureNameFontColor", N, E, this.foreground);
						if (ah == "box") {
							if (ab.length > 0) {
								this.setGenomeBoxExons(N);
								if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
									if (!N.hideName) {
										A = (((N.start - this.xAxisMin) * this.xAxisUnit)) - af;
										this.drawBoxSequenceName(Z, w, A, a, M, N.start, N.end, N, E);
										this.functionCaller = "plotGenomeData"
									}
									a += this.featureNameFontSize + this.margin
								}
								this.drawGenomeBox(a, f, N, E);
								this.functionCaller = "plotGenomeData";
								if (this.genomeResolution == "high" && N.translate && this.featureTranslateShow) {
									a += this.featureTranslateHeight * N.translate.length
								}
							}
						} else {
							if (ah == "sequence") {
								var v = this.setGenomeGaps(N.gaps, N.sequence.length, N.dir);
								if (N.offsetLeft && !N.offset) {
									N.offset = (N.offsetLeft - (N.sequence.length + v.total)) + 1
								}
								if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
									if (!N.hideName) {
										A = ((N.offset - this.xAxisMin) * this.xAxisUnit) - af;
										this.drawBoxSequenceName(Z, w, A, a, M, N.offset, N.offset + N.sequence.length + v.total, N, E);
										this.functionCaller = "plotGenomeData"
									}
									a += this.featureNameFontSize + this.margin
								}
								if (this.genomeResolution == "high") {
									if (N.trace && this.featureTracesShow) {
										this.drawGenomeTrace(a, N.counter, this.featureTraceHeight - 1, N.offset, N.trace, v, N.dir);
										this.functionCaller = "plotGenomeData";
										a += this.featureTraceHeight
									}
									this.drawGenomeSequence(a, f, v, N, E);
									this.functionCaller = "plotGenomeData";
									a += f;
									if (N.translate && this.featureTranslateShow) {
										for (var V = 0; V < N.translate.length; V++) {
											a += this.featureTranslateHeight
										}
									}
									if (N.quality && this.featureQualityShow) {
										this.drawGenomeQuality(a, N.counter, this.featureQualityHeight - 1, N.offset, N.quality, v, N.dir, E);
										this.functionCaller = "plotGenomeData";
										a += this.featureQualityHeight
									}
									if (N.signalToNoise && this.featureSignalToNoiseShow) {
										this.drawGenomeSignalToNoise(a, N.counter, this.featureSignalToNoiseHeight - 1, N.offset, N.signalToNoise, v, N.dir, E);
										this.functionCaller = "plotGenomeData";
										a += this.featureSignalToNoiseHeight
									}
									if (N.coordinate && this.featureCoordinateShow) {
										this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E);
										this.functionCaller = "plotGenomeData";
										a += this.featureCoordinateHeight
									}
									a -= f
								} else {
									if (this.genomeResolution == "medium") {
										if (N.trace && this.featureTracesShow) {
											this.drawGenomeTrace(a, N.counter, this.featureTraceHeight - 1, N.offset, N.trace, v, N.dir);
											this.functionCaller = "plotGenomeData";
											a += this.featureTraceHeight
										}
										this.drawGenomeSequence(a, f, v, N, E);
										this.functionCaller = "plotGenomeData";
										if (N.coordinate && this.featureCoordinateShow) {
											this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E);
											this.functionCaller = "plotGenomeData"
										}
									} else {
										this.drawGenomeSequence(a, f, v, N, E);
										this.functionCaller = "plotGenomeData";
										if (N.coordinate && this.featureCoordinateShow) {
											this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E);
											this.functionCaller = "plotGenomeData"
										}
									}
								}
							} else {
								if (ah == "bar") {
									var n;
									if (this.genomeResolution == "high") {
										n = this.xAxisUnit / ab.length
									} else {
										n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault
									}
									var Y = n * ab.length;
									A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit) - ((Y / 2) + 1);
									if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
										if (!N.hideName) {
											this.addToRender(["drawText", w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true], ["track-" + Z + ":" + N.counter])
										}
										a += this.featureNameFontSize + this.margin
									}
									z = A;
									var b = r[1] < 0 ? a : r[0] >= 0 ? a + f : (a + f) - Math.abs(r[0] * C);
									for (var R = 0; R < ab.length; R++) {
										var m = N.fill || B;
										var Q = N.outline || F;
										var L = this.isArray(m) && m.length == ab.length ? m[R] : this.isArray(m) ? m[0] : this.foreground;
										var t = this.isArray(Q) && Q.length == ab.length ? Q[R] : this.isArray(Q) ? Q[0] : this.foreground;
										var aa = ab[R] * C;
										if (ab[R]) {
											if (aa > 0) {
												this.addToRender(["drawShape", "rectangle", z + (n / 2), b - (aa / 2), n, aa, L, t, "closed", false, false, true], [N.counter])
											} else {
												this.addToRender(["drawShape", "rectangle", z + (n / 2), b - (aa / 2), n, -aa, L, t, "closed", false, false, true], [N.counter])
											}
										}
										if (E.autowidth) {
											z += n
										} else {
											z += n + 2
										}
									}
								} else {
									if (ah == "heatmap") {
										var n;
										if (this.genomeResolution == "high") {
											n = this.xAxisUnit
										} else {
											n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault
										}
										A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit) - ((n / 2) + 1);
										if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
											if (!N.hideName) {
												this.addToRender(["drawText", w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true], ["track-" + Z + ":" + N.counter])
											}
											a += this.featureNameFontSize + this.margin
										}
										var aa = E.autowidth ? f : f / ab.length;
										ai = a;
										for (var R = 0; R < ab.length; R++) {
											var I = ab[R];
											var o = this.getColorForValue(T, I);
											if (isNaN(I)) {
												this.addToRender(["drawShape", "rectangle", A + (n / 2), ai + (aa / 2), n, aa, this.missingDataColor, this.missingDataColor, "closed", false, false, true], [N.counter])
											} else {
												this.addToRender(["drawShape", "rectangle", A + (n / 2), ai + (aa / 2), n, aa, o, o, "closed", false, false, true], [N.counter])
											}
											if (E.autowidth) {
												A += n
											} else {
												ai += aa
											}
										}
									} else {
										if (ah == "line") {
											var n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault;
											A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
											if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
												if (!N.hideName) {
													this.addToRender(["drawText", w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true], ["track-" + Z + ":" + N.counter])
												}
												a += this.featureNameFontSize + this.margin
											}
											if (this.isArray(ab[0])) {
												var d = 0;
												for (var S = 0; S < ab.length; S++) {
													d = Math.max(ab[S].length, d)
												}
												for (var S = 0; S < ab.length; S++) {
													A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
													var t = this.isArray(F) && F[S] ? F[S] : this.foreground;
													for (var R = 0; R < ab[S].length - 1; R++) {
														var K = this.setMinMaxGenome((ab[S][R] - r[0]), ae, G) * C;
														var H = this.setMinMaxGenome((ab[S][R + 1] - r[0]), ae, G) * C;
														this.addToRender(["drawLine", "line", A, f + a - K, A + n, f + a - H, t, false, "butt", false, false, true], [N.counter]);
														if (E.autowidth) {
															A += n
														} else {
															A += n + 2
														}
													}
												}
											} else {
												var t = this.isArray(F) ? F[0] : this.foreground;
												for (var R = 0; R < ab.length - 1; R++) {
													var K = this.setMinMaxGenome((ab[R] - r[0]), ae, G) * C;
													var H = this.setMinMaxGenome((ab[R + 1] - r[0]), ae, G) * C;
													this.addToRender(["drawLine", "line", A, f + a - K, A + n, f + a - H, t, false, "butt", false, false, true], [N.counter]);
													if (E.autowidth) {
														A += n
													} else {
														A += n + 2
													}
												}
											}
										} else {
											if (ah == "triangle") {
												A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
												B = N.fill ? N.fill : this.foreground;
												F = N.outline ? N.outline : this.foreground;
												if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
													if (!N.hideName) {
														this.addToRender(["drawText", w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true], ["track-" + Z + ":" + N.counter])
													}
													a += this.featureNameFontSize + this.margin
												}
												this.addToRender(["drawShape", "triangle", A, a + (f / 2), f, f, B, F, "closed", false, false, true], [N.counter])
											}
										}
									}
								}
							}
						}
						if (this.featureStaggered) {
							if (W < u.length - 1) {
								if (!O) {
									a -= (this.featureNameFontSize + this.margin)
								}
								if (ah == "box") {
									a -= this.getBoxFeatureHeight(N)
								} else {
									if (ah == "sequence") {
										a -= this.getSequenceFeatureHeight(N)
									}
								}
							}
						}
					}
					a += f + this.margin
				}
				a += this.margin * 2
			}
		}
		this.addToRender(["resetClipArea"])
	};
	this.setGenomeBoxExons = function(b) {
		var e = b.data;
		if (!b.start || !b.end) {
			b.start = e[0][0];
			b.end = e[e.length - 1][1];
			if (b.sequence) {
				var g = b.dir == "left" ? b.sequence.length : 1;
				for (var a = 0; a < e.length; a++) {
					if (e[a].length == 2) {
						var f = e[a][1] - e[a][0];
						if (b.dir == "left") {
							b.data[a].push(g - f, g)
						} else {
							b.data[a].push(g, g + f)
						}
					}
					g = b.dir == "left" ? g - (f + 1) : g + f + 1
				}
			}
		}
	};
	this.drawGenomeBoxLines = function(d, j, h, k) {
		this.functionCaller = "drawGenomeBoxLines";
		var q, p, o, n;
		var a = h.scaleHeight ? h.scaleHeight : 1;
		var c = d + ((j * a) / 2);
		var b = h.dir == "right" ? d : d + (j * a);
		var e = this.marginLeft + this.left;
		var r = e + this.x;
		var s = h.data;
		var g = this.validateColor(h.fill || h.connect || k.connect) || this.foreground;
		var f = this.xAxisUnit / 2;
		var m = [];
		for (var l = 0; l < s.length; l++) {
			q = (((s[l][0] - this.xAxisMin) * this.xAxisUnit) - f);
			p = ((((s[l][1] - this.xAxisMin) * this.xAxisUnit) + f) - q);
			if (!h.insertion && (k.connect || h.connect)) {
				if (l < s.length - 1) {
					o = ((s[l + 1][0] - this.xAxisMin) * this.xAxisUnit);
					n = (q + p + o + 1 - f) / 2;
					if (Math.floor(o - (p + q)) > 2 && e + q + p < r && e + o > e) {
						if (Math.abs(b - c) < 3) {
							this.addToRender(["drawLine", "line", e + q + p + 1, c + j - (j * a), e + o, c + j - (j * a), g, false, "butt", false, false, true], [h.counter])
						} else {
							this.addToRender(["drawLine", "line", e + q + p + 1, c + j - (j * a), e + n, b + j - (j * a), g, false, "butt", false, false, true], [h.counter]);
							this.addToRender(["drawLine", "line", e + n, b + j - (j * a), e + o - f, c + j - (j * a), g, false, "butt", false, false, true], [h.counter])
						}
					}
				}
			}
			if (h.insertion) {
				q = ((((s[l][0] + s[l][1]) / 2) - this.xAxisMin) * this.xAxisUnit);
				m.push([e + q, (d + j) - (j * a) + ((j * a) / 2), f / 2, (j * a)])
			} else {
				m.push([e + q, (d + j) - (j * a), p, (j * a)])
			}
		}
		if (h.showDir && this.xAxisUnit > 0.001 && !h.insertion) {
			g = this.validateColor(h.showDir) || g;
			q = e + (((h.start - this.xAxisMin) * this.xAxisUnit)) - f;
			p = e + (((h.end - this.xAxisMin) * this.xAxisUnit)) + f;
			o = 10;
			n = 5;
			if (h.dir == "right") {
				if (p < r && p + o > e) {
					this.addToRender(["drawLine", "line", p, c, p + o, c, g, false, "butt", false, false, true], [h.counter]);
					this.addToRender(["drawLine", "line", p + n, c - (j / 3), p + o, c, g, false, "butt", false, false, true], [h.counter]);
					this.addToRender(["drawLine", "line", p + n, c + (j / 3), p + o, c, g, false, "butt", false, false, true], [h.counter])
				}
			} else {
				if (q - o < r && q > e) {
					this.addToRender(["drawLine", "line", q, c, q - o, c, g, false, "butt", false, false, true], [h.counter]);
					this.addToRender(["drawLine", "line", q - n, c - (j / 3), q - o, c, g, false, "butt", false, false, true], [h.counter]);
					this.addToRender(["drawLine", "line", q - n, c + (j / 3), q - o, c, g, false, "butt", false, false, true], [h.counter])
				}
			}
		}
		return m
	};
	this.drawGenomeBoxAlleles = function(f, t, e, s, g, b) {
		this.functionCaller = "drawGenomeBoxAlleles";
		var o = s / g.length;
		for (var n = 0; n < g.length; n++) {
			var r = g[n].split("");
			var k = (e - f) / r.length;
			var q = t + (o * n);
			for (var m = 0; m < r.length; m++) {
				var d = f + (k * m);
				if (r[m] == "-") {
					r[m] = "Gap"
				}
				var p = "sequence" + r[m].toUpperCase() + "Color";
				this.addToRender(["drawShape", "rectangle", d + (k / 2), q + (o / 2), k, o, this[p], this[p], "closed", false, false, true], [b])
			}
		}
	};
	this.drawGenomeBox = function(d, v, m, x) {
		this.functionCaller = "drawGenomeBox";
		var q = this;
		var a = {};
		var s = function() {
			if (q.genomeResolution != "low" && m.sequence) {
				return m.dir == "left" ? m.sequenceRC.split("") : m.sequence.split("")
			} else {
				return false
			}
		};
		var A = this.validateColor(m.fill || m.connect || x.fill || x.connect);
		var F = m.outline || x.outline || A;
		var o = A ? "closed" : "open";
		var B = this.xAxisUnit / 2;
		var u = this.sequenceFontSize > v ? (v - 3) + "px " + this.fontName : this.sequenceFont;
		var r = s();
		var f = m.translateRC;
		var p = m.data;
		var g = this.marginLeft + this.left;
		var G = g + this.x;
		if (this.genomeResolution == "high" && f) {
			d += f.top.length * this.featureTranslateHeight
		}
		var w = this.drawGenomeBoxLines(d, v, m, x);
		this.functionCaller = "drawGenomeBox";
		for (var C = 0; C < w.length; C++) {
			var E = w[C][0];
			var D = E + w[C][2];
			if (Math.floor(D - E) < 3) {
				var z = parseInt(D);
				if (a.hasOwnProperty(z)) {
					continue
				}
				a[z] = true;
				a[z + 1] = true
			}
			if (E < G && D > g) {
				if (this.genomeResolution != "low" && m.alleles && m.alleles[C] && !m.insertion) {
					this.drawGenomeBoxAlleles(E, d, D, v, m.alleles[C], m.counter);
					this.functionCaller = "drawGenomeBox"
				}
				if (!f || this.genomeResolution != "high") {
					if (m.insertion) {
						var c = m.dir == "left" ? "triangle" : "triangle2";
						this.addToRender(["drawShape", c, w[C][0], w[C][1], w[C][2], w[C][3], A, F, o, false, false, true], [m.counter])
					} else {
						if (this.genomeResolution != "low" && m.sequence && (m.sequenceFill || x.sequenceFill || this.sequenceFill)) {
							this.addToRender(["drawShape", "rectangle", w[C][0] + (w[C][2] / 2), w[C][1] + (w[C][3] / 2), w[C][2], w[C][3], m.sequenceFill || x.sequenceFill || this.sequenceFill, F, o, false, false, true], [m.counter])
						} else {
							this.addToRender(["drawShape", "rectangle", w[C][0] + (w[C][2] / 2), w[C][1] + (w[C][3] / 2), w[C][2], w[C][3], A, F, o, false, false, true], [m.counter])
						}
					}
				}
				if (this.genomeResolution != "low" && m.sequence && !m.insertion) {
					var e = {};
					var b = p[C][0];
					var n = p[C][1];
					var H = m.dir == "left" ? r.length - p[C][3] + 1 : p[C][2];
					var h = m.dir == "left" ? r.length - p[C][2] + 1 : p[C][3];
					var l = H - 3;
					if (n - b != h - H) {
						this.errors.push("Exon length for segment " + C + " in feature " + m.id + "is different to the box dimmension")
					}
					if (r.length > 0) {
						E += B;
						for (var y = H; y <= h; y++) {
							var t = r[y - 1];
							if (!t) {
								this.errors.push("Nucleotide " + y + " in exon " + (C + 1) + " in feature " + m.id + "not specified")
							}
							if (t) {
								var k = "sequence" + t.toUpperCase() + "Color";
								if (this.genomeResolution == "high") {
									if (f && (!m.cds || (m.cds && y >= m.cds[0] && y <= m.cds[1]))) {
										this.drawTranslationTop(f, E, d, B, l, F, u, 0, e, m.counter);
										this.functionCaller = "drawGenomeBox";
										this.addToRender(["drawText", t, E, d + (v / 2), u, this[k], "center", "middle", false, false, false, true], [m.counter]);
										this.drawTranslationBottom(f, E, d, B, l, F, u, 0, e, m.counter);
										this.functionCaller = "drawGenomeBox"
									} else {
										this.addToRender(["drawText", t, E, d + (v / 2), u, this[k], "center", "middle", false, false, false, true], [m.counter])
									}
								} else {
									this.addToRender(["drawShape", "rectangle", E, d + 1 + ((v - 2) / 2), 1, v - 2, this[k], this[k], "closed", false, false, true], [m.counter])
								}
							} else {
								if (this.genomeResolution == "high") {
									this.addToRender(["drawText", "-", E, d + (v / 2), u, this.missingDataColor, "center", "middle", false, false, false, true], [m.counter])
								} else {
									this.addToRender(["drawShape", "rectangle", E, d + 1 + ((v - 2) / 2), 1, v - 2, this.missingDataColor, this.missingDataColor, "closed", false, false, true], [m.counter])
								}
							}
							l++;
							E += this.xAxisUnit
						}
					}
				}
			}
		}
	};
	this.drawGenomeTrace = function(b, m, q, f, z, t, s) {
		this.functionCaller = "drawGenomeTrace";
		if (this.genomeResolution != "low") {
			if (s == "left" && !z.reversed) {
				this.setReverseTrace(z)
			}
			var o = [];
			var g = ["A", "C", "G", "T"];
			var D = this.marginLeft + this.left + (((f - 1) - this.xAxisMin) * this.xAxisUnit);
			var u = this.marginLeft + this.left;
			var p = this.marginLeft + this.left + this.x;
			var a = b + q;
			if (z.max == null) {
				for (var A = 0; A < g.length; A++) {
					o = o.concat(z[g[A]])
				}
				if (this.meta.system.browser == "Firefox") {
					o = this.radixSort(o)
				} else {
					o.sort(function(j, i) {
						return j - i
					})
				}
				var B = Math.floor(o.length * this.featureTraceTrim / 100);
				z.max = o[o.length - (B + 1)]
			}
			var v = q / z.max;
			var e = g.length;
			for (var A = 0; A < e; A++) {
				var c = 0;
				var h = [];
				var y = [];
				var C = D;
				var d = "sequence" + g[A].toUpperCase() + "Color";
				var F = z.peak.length;
				for (var x = 0; x < F; x++) {
					if (C > u - this.xAxisUnit && C < p) {
						var n = this.xAxisUnit / (z.peak[x] - c);
						if (t[x]) {
							var E = Math.floor((z.peak[x] - c) / 2);
							for (var w = c; w < (z.peak[x] - E); w++) {
								h.push(C);
								y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
								C += n
							}
							c += E;
							if (h.length > 1 && y.length > 1) {
								this.addToRender(["drawShape", "path", h, y, false, false, this[d], this[d], "open", false, false, true], [m])
							}
							h = [];
							y = [];
							for (var w = 0; w < t[x]; w++) {
								C += this.xAxisUnit
							}
						}
						for (var w = c; w <= z.peak[x]; w++) {
							h.push(C);
							y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
							C += n
						}
						C -= n;
						c = z.peak[x]
					} else {
						if (t[x]) {
							for (var w = 0; w < t[x]; w++) {
								C += this.xAxisUnit
							}
						}
						c = z.peak[x];
						C += this.xAxisUnit
					}
				}
				if (C > u - this.xAxisUnit && C < p) {
					for (var w = c; w < z[g[A]].length; w++) {
						h.push(C);
						y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
						C += n
					}
				}
				if (h.length > 1 && y.length > 1) {
					this.addToRender(["drawShape", "path", h, y, false, false, this[d], this[d], "open", false, false, true], [m])
				}
			}
		}
	};
	this.drawTranslationTop = function(q, d, l, g, k, o, n, p, e, b) {
		this.functionCaller = "drawTranslationTop";
		if (q.top && q.top.length > 0) {
			for (var f = 0; f < q.top.length; f++) {
				y1 = l - ((q.top.length - f) * this.featureTranslateHeight);
				var j = q.top[f];
				if (k - j.off >= 0 && (k - j.off) % 3 == 0) {
					var a = j.seq[Math.floor((k - j.off) / 3)];
					var m = k % 2 ? this.oddColor : this.evenColor;
					if (a == "M") {
						m = this.sequenceStartColor
					} else {
						if (a == "*") {
							m = this.sequenceEndColor
						}
					}
					if (!e[j.rf]) {
						e[j.rf] = d - (this.xAxisUnit * (p + 2.5))
					}
					x0 = (d - e[j.rf]) + g;
					this.addToRender(["drawShape", "rectangle", e[j.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2), x0, this.featureTranslateHeight - 1, m, o, "closed", false, false, true], [b]);
					this.addToRender(["drawText", a, e[j.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, n, this.foreground, "center", "middle", false, false, false, true], [b]);
					e[j.rf] = d + g
				}
			}
		}
	};
	this.drawTranslationBottom = function(q, d, l, g, k, o, n, p, e, b) {
		this.functionCaller = "drawTranslationBottom";
		if (q.bottom && q.bottom.length > 0) {
			for (var f = 0; f < q.bottom.length; f++) {
				y1 = l + ((f + 1) * this.featureTranslateHeight);
				var j = q.bottom[f];
				if (k - j.off >= 0 && (k - j.off) % 3 == 0) {
					var a = j.seq[Math.floor((k + j.off + 1) / 3)];
					var m = k % 2 ? this.oddColor : this.evenColor;
					if (a == "M") {
						m = this.sequenceStartColor
					} else {
						if (a == "*") {
							m = this.sequenceEndColor
						}
					}
					if (!e[j.rf]) {
						e[j.rf] = d - (this.xAxisUnit * (p + 2.5))
					}
					x0 = (d - e[j.rf]) + g;
					this.addToRender(["drawShape", "rectangle", e[j.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2), x0, this.featureTranslateHeight - 1, m, o, "closed", false, false, true], [b]);
					this.addToRender(["drawText", a, e[j.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, n, this.foreground, "center", "middle", false, false, false, true], [b]);
					e[j.rf] = d + g
				}
			}
		}
	};
	this.drawGenomeSequence = function(a, d, m, y, u) {
		this.functionCaller = "drawGenomeSequence";
		var f = y.counter;
		var t = y.fill ? y.fill : u.fill ? u.fill : this.background;
		var v = y.outline || this.foreground;
		var k = t ? "closed" : "open";
		var e = this.sequenceFontSize > d ? (d - 3) + "px " + this.fontName : this.sequenceFont;
		var D = y.offset;
		var M = y.sequence;
		var P = y.sequenceRC;
		var C = y.translate;
		var L = y.translateRF;
		var O = y.dir;
		if (O == "left" && !P) {
			P = M;
			M = this.getReverseComplement(M)
		}
		if (C && !L) {
			L = C;
			C = this.translate(C, M)
		}
		var g = M.split("");
		var q = this.marginLeft + this.left + ((D - this.xAxisMin) * this.xAxisUnit);
		var I = this.marginLeft + this.left;
		var G = this.marginLeft + this.left + this.x;
		var p = (g.length + m.total) * this.xAxisUnit;
		var H = 0;
		var F = u.subtype.match(/DNA|RNA/) ? 1 : 3;
		var E = this.xAxisUnit * 4;
		var K = this.xAxisUnit / 2;
		var N = -2;
		var w = {};
		var Q = a;
		var B = 0;
		var z = 0;
		var A = this;
		if (this.genomeResolution == "high") {
			var o = q + (H * this.xAxisUnit);
			if (C) {
				a += C.top.length * this.featureTranslateHeight
			}
			while (g.length > 0) {
				if (o > I - E && o < G + E) {
					var b = g.shift();
					if (b == "[") {
						b = g.shift();
						var x = [];
						while (b != "]") {
							x.push(b);
							b = g.shift()
						}
						this.addToRender(["drawText", x.join("/"), q + (H * this.xAxisUnit), a + (d / 2), e, this.sequenceMColor, "center", "middle", false, false, false, true], [f])
					} else {
						var j = "sequence" + b.toUpperCase() + "Color";
						if (C) {
							this.drawTranslationTop(C, o, a, K, N, v, e, z, w, f);
							this.functionCaller = "drawGenomeSequence";
							this.addToRender(["drawText", b, o, a + (d / 2), e, this[j], "center", "middle", false, false, false, true], [f]);
							this.drawTranslationBottom(C, o, a, K, N, v, e, z, w, f);
							this.functionCaller = "drawGenomeSequence"
						} else {
							this.addToRender(["drawText", b, o, a + (d / 2), e, this[j], "center", "middle", false, false, false, true], [f])
						}
					}
					H += F;
					o = q + ((H + B) * this.xAxisUnit);
					N++;
					z = 0;
					if (m[parseInt(H / F)]) {
						for (var J = 0; J < m[parseInt(H / F)]; J++) {
							this.addToRender(["drawText", "-", o, a + (d / 2), e, this.missingDataColor, "center", "middle", false, false, false, true], [f]);
							B++;
							z++;
							o = q + ((H + B) * this.xAxisUnit)
						}
					}
				} else {
					g.shift();
					H += F;
					o = q + ((H + B) * this.xAxisUnit);
					N++;
					z = 0;
					if (m[parseInt(H / F)]) {
						for (var J = 0; J < m[parseInt(H / F)]; J++) {
							B++;
							z++;
							o = q + ((H + B) * this.xAxisUnit)
						}
					}
				}
			}
		} else {
			q = this.marginLeft + this.left + (((D - 0.5) - this.xAxisMin) * this.xAxisUnit);
			this.addToRender(["drawShape", "rectangle", q + (p / 2), a + (d / 2), p, d, t, v, "closed", false, false, true], [f]);
			for (var J in m) {
				q = this.marginLeft + this.left + ((((D - 0.5) + parseInt(J) + z) - this.xAxisMin) * this.xAxisUnit);
				p = m[J] * this.xAxisUnit;
				z += m[J];
				this.addToRender(["drawShape", "rectangle", q + (p / 2), a + (d / 2), p, d, this.missingDataColor, v, k, false, false, true], [f])
			}
		}
	};
	this.drawGenomeQuality = function(a, f, p, d, c, v, q, t) {
		this.functionCaller = "drawGenomeQuality";
		if (this.genomeResolution != "low") {
			var h = q == "left" ? this.cloneObject(c).reverse() : c;
			var m = this.range(h);
			var C = this.getColorBrew(this.colorSpectrum, m[0], m[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
			var x = this.marginLeft + this.left;
			var o = this.marginLeft + this.left + this.x;
			var A = B;
			var u = 0;
			var k = t.subtype.match(/DNA|RNA/) ? 1 : 3;
			var g = k * this.xAxisUnit;
			var e = (this.featureQualityHeight - 3) + "px " + this.fontName;
			for (var z = 0; z < h.length; z++) {
				if (A + g > x && A < o) {
					if (v[z]) {
						for (var y = 0; y < v[z]; y++) {
							A += g
						}
					}
					var b = this.getColorForValue(C, h[z]);
					this.addToRender(["drawShape", "rectangle", A + (g / 2), a + (p / 2), g, p, b, b, "closed", false, false, true], [f]);
					if (A > x && this.genomeResolution == "high" && this.featureQualityValues) {
						this.addToRender(["drawText", h[z], A + (g / 2), a + (p / 2), e, this.foreground, "center", "middle", false, false, false, true], [f])
					}
				}
				A += g
			}
		}
	};
	this.drawGenomeSignalToNoise = function(a, f, o, d, z, u, p, q) {
		this.functionCaller = "drawGenomeSignalToNoise";
		if (this.genomeResolution != "low") {
			var c = p == "left" ? this.cloneObject(z).reverse() : z;
			var k = this.range(c);
			var C = this.getColorBrew(this.colorSpectrum, k[0], k[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
			var v = this.marginLeft + this.left;
			var m = this.marginLeft + this.left + this.x;
			var A = B;
			var t = 0;
			var h = q.subtype.match(/DNA|RNA/) ? 1 : 3;
			var g = h * this.xAxisUnit;
			var e = (this.featureSignalToNoiseHeight - 3) + "px " + this.fontName;
			for (var y = 0; y < c.length; y++) {
				if (A + g > v && A < m) {
					if (u[y]) {
						for (var x = 0; x < u[y]; x++) {
							A += g
						}
					}
					var b = this.getColorForValue(C, c[y]);
					this.addToRender(["drawShape", "rectangle", A + (g / 2), a + (o / 2), g, o, b, b, "closed", false, false, true], [f]);
					if (A > v && this.genomeResolution == "high" && this.featureSignalToNoiseValues) {
						this.addToRender(["drawText", c[y], A + (g / 2), a + (o / 2), e, this.foreground, "center", "middle", false, false, false, true], [f])
					}
				}
				A += g
			}
		}
	};
	this.drawGenomeCoordinate = function(a, g, m, e, C, b, x, p, u) {
		this.functionCaller = "drawGenomeCoordinate";
		if (this.genomeResolution != "low") {
			var A = this.marginLeft + this.left + ((e - this.xAxisMin) * this.xAxisUnit);
			var y = this.marginLeft + this.left;
			var k = this.marginLeft + this.left + this.x;
			var v = C;
			var j = u.subtype.match(/DNA|RNA/) ? 1 : 3;
			var h = j * this.xAxisUnit;
			var B = this.getCoordinateStep();
			var o = b + x.total;
			var i = C + o;
			var f = (m - 3) + "px " + this.fontName;
			if (p == "left") {
				var z = A + ((o - 1) * h);
				while (C < i - x.total) {
					if (x[(o - (C - v)) - 2]) {
						z -= (h * x[(o - (C - v)) - 2])
					}
					if (z > y && z < k) {
						if (C % B == 0) {
							this.addToRender(["drawText", C, z, a + (m / 2), f, this.foreground, "center", "middle"])
						}
					}
					z -= h;
					C++
				}
			} else {
				var z = A;
				while (C < i - x.total) {
					if (x[C - v]) {
						z += (h * x[C - v])
					}
					if (z > y && z < k) {
						if (C % B == 0) {
							this.addToRender(["drawText", C, z, a + (m / 2), f, this.foreground, "center", "middle"])
						}
					}
					z += h;
					C++
				}
			}
		}
	};
	this.setGenomeWireFrame = function() {
		this.functionCaller = "setGenomeWireFrame";
		var b = this.marginLeft + this.left;
		var a = this.marginLeft + this.left + this.x;
		var f = this.getCoordinateStep();
		var g = Math.floor(this.xAxisMin);
		var e = this.getFontPt(this.featureNameFont) / 2;
		if (this.genomeResolution == "low") {
			f *= 5
		}
		while (b <= a) {
			b = this.marginLeft + this.left + ((g - this.xAxisMin) * this.xAxisUnit);
			if (g % f == 0) {
				if (this.xAxisTickStyle == "dotted") {
					this.addToRender(["drawLine", "dottedLine", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt", false, false, true])
				} else {
					this.addToRender(["drawLine", "line", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt", false, false, true])
				}
			}
			g++
		}
	};
	this.setGenomeTicks = function() {
		this.functionCaller = "setGenomeTicks";
		var e = this.marginLeft + this.left;
		var b = this.marginLeft + this.left + this.x;
		var f = this.marginLeft + this.left;
		var h = this.getCoordinateStep();
		var i = Math.floor(this.xAxisMin);
		var g = this.getFontPt(this.featureNameFont) / 2;
		if (this.genomeResolution == "low") {
			h *= 5
		}
		while (e <= b) {
			e = this.marginLeft + this.left + ((i - this.xAxisMin) * this.xAxisUnit);
			if (i % h == 0) {
				var a = this.measureText(i.toString(), this.featureNameFont);
				if (e >= f) {
					this.addToRender(["drawText", i.toString(), e, this.marginTop + this.top + this.y + this.margin + g, this.featureNameFont, this.xAxisTickColor, "center", "middle"]);
					f = e + (a * 1.5)
				}
			}
			i++
		}
	};
	this.setGenomeLeftDimentions = function() {
		var e = [];
		for (var d = 0; d < this.data.tracks.length; d++) {
			var a = this.data.tracks[d];
			for (var b = 0; b < a.data.length; b++) {
				var c = a.data[b];
				e.push(c.label || c.name || c.id)
			}
		}
		return this.measureText(this.shortenText(this.getMaxText(e), this.maxFeatureStringLen), this.featureNameFont) + (this.margin * 4)
	};
	this.setGenomeYDimentions = function() {
		this.bottom += this.margin + this.getFontPt(this.featureNameFont);
		if (this.adjustAspectRatio || this.height < (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) {
			this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom
		}
		this.resizeCanvas();
		this.resizeViewport()
	};
	this.setGenomeAxisUnits = function() {
		this.setAxisUnits("xAxis");
		this.genomeResolution = this.xAxisUnit > this.sequenceFontSize ? "high" : this.xAxisUnit * 5 > this.sequenceFontSize ? "medium" : "low"
	};
	this.setGenomeXDimentions = function() {
		if (this.featureStaggered) {
			if (this.width) {
				this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
			} else {
				this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
			}
		} else {
			this.left = this.setGenomeLeftDimentions();
			if (this.width) {
				this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
			} else {
				this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
			}
		}
	};
	this.setGenomeFontsColors = function() {
		this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "px " + this.fontName;
		this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "px " + this.fontName;
		this.sequenceFont = (this.sequenceFontSize) + "px " + this.fontName;
		if (!this.wireColor.match(/,0.1\)$/)) {
			this.wireColor = this.wireColor.replace(/\)$/, ",0.1)")
		}
	};
	this.drawGenome = function() {
		this.setGenomeFontsColors();
		this.setGenomeXDimentions();
		this.setGenomeAxisUnits();
		this.setGenomeSubtracks();
		this.setGenomeYDimentions();
		this.setGenomeWireFrame();
		this.plotGenomeData();
		this.drawGenomeLabels();
		this.setGenomeTicks()
	};
	this.initializeGenome = function() {
		this.drawGenome()
	};
	this.initializeGenome()
};
CanvasXpress.prototype.Circular = function() {
	this.setCircularXYDimensions = function() {
		this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
		this.r = Math.min(this.x, this.y) / 2;
		this.d = this.r * 2;
		this.padX = this.x > this.y ? (this.x - this.y) / 2 : 0;
		this.padY = this.x > this.y ? 0 : (this.y - this.x) / 2;
		this.cx = this.marginLeft + this.left + this.r + this.padX;
		this.cy = this.marginTop + this.top + this.r + this.padY
	};
	this.setCircularSampleOverlays = function() {
		this.validateSegregation();
		if (this.segregateSamplesBy.length > 0 && this.data.x.hasOwnProperty(this.segregateSamplesBy[0]) && this.smpOverlays.length == 0 && this.circularType != "sunburst" && this.circularType != "chord") {
			this.smpOverlays = [this.segregateSamplesBy[0]]
		}
	};
	this.setCircularFonts = function() {
		if (this.autoScaleFont) {
			var a = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea);
			this.setPropertyFontSize(a, "varLabelFont");
			this.setPropertyFontSize(a, "varTitleFont");
			this.setPropertyFontSize(a, "smpLabelFont");
			this.setPropertyFontSize(a, "smpTitleFont");
			this.setAxisFont("NA", a)
		}
	};
	this.setCircularLegendDimensions = function() {
		this.legendVariableWidth = 0;
		this.legendVariableHeight = 0;
		if (this.showLegend) {
			var a = this.getFontPt(this.legendFont);
			var b = this.shortenText(this.meta.data.y.maxVarStr, this.maxVarStringLen);
			var c = this.getVariableInLegends();
			this.legendVariableWidth = (a - 1) + this.measureText(b, this.legendFont) + (this.margin * 3);
			this.legendVariableHeight = (c * (a + this.margin)) + this.margin
		}
	};
	this.getVariableInLegends = function() {
		var b = 0;
		for (var a = 0; a < this.ringsNumber; a++) {
			if (this.rAxisIndex >= 0 && a == this.rAxisIndex) {
				continue
			}
			if (this.rAxisIndex < 0 && this.ringsType[a] == "heatmap") {
				continue
			}
			b += this.ringsVarIndices[a].length
		}
		return b
	};
	this.getCircularSampleLabelLength = function() {
		if (this.showSampleNames && this.rAxisIndex < 0 && this.circularType != "sunburst" && this.circularType != "bubble") {
			if (this.smpLabelOrientation == "circular") {
				return this.getFontPt(this.smpLabelFont) + this.margin
			} else {
				if (this.meta.data.y.maxSmpChr > this.maxSmpStringLen) {
					return this.measureText(this.meta.data.y.maxSmpStr.substring(0, this.maxSmpStringLen), this.smpLabelFont) + this.margin
				} else {
					return this.measureText(this.meta.data.y.maxSmpStr, this.smpLabelFont) + this.margin
				}
			}
		} else {
			return 0
		}
	};
	this.getCircularOverlaysWidth = function() {
		var b = 0;
		if (this.showOverlays && this.smpOverlays.length > 0 && this.circularType != "sunburst" && this.circularType != "bubble") {
			if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]]) {
				b++
			}
			for (var a = 0; a < this.smpOverlays.length; a++) {
				if (this.data.x.hasOwnProperty(this.smpOverlays[a])) {
					if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]] && this.smpOverlays[a] == this.segregateSamplesBy[0]) {
						continue
					}
					b++
				}
			}
			if (b > 0) {
				b = b * (this.overlaysThickness + this.margin)
			}
		}
		return b
	};
	this.getCircularXAxisTickLength = function() {
		return this.measureText(this.xAxisMaxStrLength, this.axisTickFont)
	};
	this.getCircularRAxisTickLength = function() {
		if (this.rAxisTickFormat) {
			return this.measureText(this.formatAxisValue(this.rAxisMax, "rAxis"), this.axisTickFont)
		} else {
			return this.measureText(this.rAxisMaxStrLength, this.axisTickFont)
		}
	};
	this.getCircularRAxisPercentTickLength = function() {
		return this.rAxisPercentShow ? this.measureText("100%", this.axisTickFont) : 0
	};
	this.getCircularSmpTreeHeight = function() {
		var a = 0;
		if (this.showSmpDendrogram && this.smpDendrogram) {
			a = this.dendrogramHeight + this.margin
		}
		return a
	};
	this.getArcSegmentsCenter = function() {
		if (this.circularType != "normal" || !this.xAxisShow || this.circularArc < 270) {
			return 0
		} else {
			if (this.xAxisShow) {
				return (this.margin * 1.5) + this.arcLengthToDegrees(this.r * this.circularCenterProportion * 2, this.getCircularXAxisTickLength())
			}
		}
	};
	this.setCircularArcSegments = function() {
		if (this.circularArc > 360) {
			this.circularArc = 360
		} else {
			if (this.circularArc < 90) {
				this.circularArc = 90
			}
		}
		this.rAxisIndex = this.rAxis ? this.getVariableIndices(this.rAxis) : -1;
		this.arcSegmentsCenter = this.getArcSegmentsCenter();
		var g = this.circularArc < 270 ? 1 : 0;
		var q = this.circularType != "normal" || this.circularArc < 270 ? 0 : this.xAxisShow ? ((this.arcSegmentsSeparation + this.arcSegmentsCenter) * Math.PI / 360) : 0;
		this.circularStart = (Math.PI * 1.5) + q + this.radians(this.circularRotate);
		this.currentRadius = this.r;
		this.arcSegments = [];
		this.arcSegmentsSampleIndices = [];
		this.arcSegmentsSamplePosition = [];
		this.arcSegmentsRange = [];
		this.arcSegmentsMin = [];
		this.arcSegmentsMax = [];
		this.arcSegmentsRangeMap = {};
		this.arcSegmentsDims = [];
		if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]] && this.circularType != "sunburst" && this.circularType != "chord" && this.circularType != "bubble") {
			var b = [];
			var x = [];
			var a = this.getSmpAnnotations(this.segregateSamplesBy[0], this.smpIndices).sort();
			for (var y = 0; y < a.length; y++) {
				this.arcSegments.push(a[y]);
				this.arcSegmentsRangeMap[a[y]] = y;
				var f = this.getSamplesByAnnotationLevel(this.segregateSamplesBy[0], a[y]);
				this.arcSegmentsSampleIndices.push(f);
				b = b.concat(f)
			}
			for (var y = 0; y < b.length; y++) {
				if (this.hiddenSmps[b[y]]) {
					x.push(true)
				} else {
					x.push(false)
				}
			}
			this.smpIndices = b;
			this.hiddenSmps = x;
			if (this.rAxisIndex >= 0) {
				var l = {};
				var h = 0;
				for (var y = 0; y < this.data.y.smps.length; y++) {
					var p = this.data.x[this.segregateSamplesBy[0]][y];
					if (!l[p]) {
						l[p] = []
					}
					l[p].push(this.data.y.data[this.rAxisIndex][y])
				}
				for (var p in l) {
					var y = this.arcSegmentsRangeMap[p];
					var d = this.range(l[p]);
					this.arcSegmentsMin[y] = d[0];
					this.arcSegmentsMax[y] = d[1];
					if (this.rAxisZero) {
						h += d[1];
						this.arcSegmentsRange[y] = d[1]
					} else {
						h += (d[1] - d[0]);
						this.arcSegmentsRange[y] = d[1] - d[0]
					}
				}
				this.rAxisUnit = this.radians((this.circularArc - ((this.arcSegmentsSeparation * (this.arcSegmentsSampleIndices.length - g)) + this.arcSegmentsCenter)) / h)
			} else {
				this.rAxisUnit = this.radians((this.circularArc - ((this.arcSegmentsSeparation * (this.arcSegmentsSampleIndices.length - g)) + this.arcSegmentsCenter)) / this.data.y.smps.length);
				var p = this.circularStart;
				for (var y = 0; y < this.arcSegmentsSampleIndices.length; y++) {
					this.arcSegmentsSamplePosition[y] = [];
					for (var w = 0; w < this.arcSegmentsSampleIndices[y].length; w++) {
						this.arcSegmentsSamplePosition[y].push(p);
						p += this.rAxisUnit
					}
					p += this.radians(this.arcSegmentsSeparation)
				}
			}
			var p = this.circularStart;
			var B = this.sortObject(this.arcSegmentsRangeMap);
			for (var k = 0; k < B.length; k++) {
				var t = B[k];
				var y = this.arcSegmentsRangeMap[t];
				var u = this.rAxisIndex >= 0 ? this.arcSegmentsRange[y] : this.arcSegmentsSampleIndices[y].length;
				var z = this.rAxisUnit * u;
				this.arcSegmentsDims.push([p, p + z]);
				p += z + this.radians(this.arcSegmentsSeparation)
			}
		} else {
			this.arcSegments = false;
			this.arcSegmentsSampleIndices = [this.smpIndices];
			if (this.circularType == "sunburst") {
				var m = this.createHierarchy(this.hierarchy);
				this.arcSegmentsMin.push(0);
				this.arcSegmentsMax.push(m[0].value);
				this.rAxisUnit = this.radians((this.circularArc - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / m[0].value);
				this.arcSegmentsRange.push(m[0].value);
				this.circularSunburst = m
			} else {
				if (this.circularType == "bubble") {
					this.setCirclePack()
				} else {
					if (this.circularType == "chord") {
						this.arcSegments = [];
						var p = this.circularStart;
						var A = this.circularChord;
						this.rAxisUnit = A.unit;
						for (var y = 0; y < A.segments.length; y++) {
							this.arcSegments.push(A.segments[y].value);
							this.arcSegmentsRangeMap[A.segments[y].name] = y;
							this.arcSegmentsMin[y] = 0;
							this.arcSegmentsMax[y] = A.segments[y].value;
							this.arcSegmentsRange.push(A.segments[y].value);
							this.arcSegmentsDims.push([p + A.segments[y].start, p + A.segments[y].end])
						}
					} else {
						if (this.rAxisIndex >= 0) {
							var d = this.range(this.data.y.data[this.rAxisIndex]);
							this.arcSegmentsMin.push(d[0]);
							this.arcSegmentsMax.push(d[1]);
							if (this.rAxisZero) {
								this.rAxisUnit = this.radians((this.circularArc - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / d[1]);
								this.arcSegmentsRange.push(d[1])
							} else {
								this.rAxisUnit = this.radians((this.circularArc - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / (d[1] - d[0]));
								this.arcSegmentsRange.push(d[1] - d[0])
							}
						} else {
							this.rAxisUnit = this.radians((this.circularArc - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / this.data.y.smps.length);
							var p = this.circularStart;
							for (var y = 0; y < this.arcSegmentsSampleIndices.length; y++) {
								this.arcSegmentsSamplePosition[y] = [];
								for (var w = 0; w < this.arcSegmentsSampleIndices[y].length; w++) {
									this.arcSegmentsSamplePosition[y].push(p);
									p += this.rAxisUnit
								}
								p += this.radians(this.arcSegmentsSeparation)
							}
						}
					}
				}
			}
			var z = this.rAxisUnit * (this.rAxisIndex >= 0 ? this.arcSegmentsRange[0] : this.smpIndices.length);
			this.arcSegmentsDims.push([this.circularStart, this.circularStart + z])
		}
		this.arcSegmentsNumber = this.arcSegmentsSampleIndices.length
	};
	this.setCircularRings = function() {
		this.ringsVarIndices = [];
		if (this.rAxisIndex >= 0) {
			this.ringsVarIndices.push([this.rAxisIndex])
		}
		if (this.circularType == "sunburst" || this.circularType == "bubble") {
			var f = this.hierarchyVar ? this.getVariableIndeces(this.hierarchyVar) : 0;
			this.hierarchyVarIndex = f >= 0 ? f : 0;
			this.ringsVarIndices.push(this.hierarchyVarIndex)
		} else {
			if (this.circularType == "chord") {
				this.ringsVarIndices.push(this.varIndices)
			} else {
				if (this.segregateVariablesBy.length > 0 && this.data.z[this.segregateVariablesBy[0]]) {
					var d = {};
					for (var f = 0; f < this.data.z[this.segregateVariablesBy[0]].length; f++) {
						if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
							continue
						}
						var c = this.data.z[this.segregateVariablesBy[0]][f];
						if (!d[c]) {
							this.ringsVarIndices.push(this.getVariablesByAnnotationLevel(this.segregateVariablesBy[0], c));
							d[c] = true
						}
					}
				} else {
					var b = [];
					var e = 0;
					for (var f = 0; f < this.varIndices.length; f++) {
						if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
							continue
						}
						b.push(this.varIndices[f])
					}
					this.ringsVarIndices.push(b)
				}
			}
		}
		this.ringsNumber = this.ringsVarIndices.length;
		if (this.ringsType.length < this.ringsNumber) {
			for (var f = this.ringsType.length; f < this.ringsNumber; f++) {
				this.ringsType.push(this.circularType == "radar" ? "line" : "dot")
			}
		}
		if (this.ringsWeight && this.ringsWeight.length > 0) {
			while (this.ringsWeight.length != this.ringsNumber) {
				if (this.ringsWeight.length > this.ringsNumber) {
					this.ringsWeight.pop()
				} else {
					this.ringsWeight.push(this.ringsWeight[this.ringsWeight.length - 1])
				}
			}
		} else {
			this.ringsWeight = [];
			for (var f = 0; f < this.ringsNumber; f++) {
				if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
					this.ringsWeight.push(0);
					continue
				}
				this.ringsWeight.push(1)
			}
		}
		var a = 0;
		for (var f = 0; f < this.ringsWeight.length; f++) {
			if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
				continue
			}
			a += parseFloat(this.ringsWeight[f])
		}
		for (var f = 0; f < this.ringsWeight.length; f++) {
			this.ringsWeight[f] /= a
		}
	};
	this.drawCircularRadialAxis = function() {
		this.functionCaller = "drawCircularRadialAxis";
		if (this.rAxisPercentShow && this.circularType != "sunburst" && this.circularType != "bubble") {
			var t = this.getCircularRAxisPercentTickLength();
			var d = this.currentRadius - (t + (this.margin * 1));
			var c = this.currentRadius - (t + (this.margin * 2));
			for (var u = 0; u < this.arcSegmentsRange.length; u++) {
				var z = this.arcSegmentsDims[u][0] + (Math.PI * 2);
				var e = this.arcSegmentsDims[u][1] - this.arcSegmentsDims[u][0];
				var n = [0, 0.2, 0.4, 0.6, 0.8, 1];
				var f = 0.02;
				for (var s = 0; s < n.length; s++) {
					var w = this.measureText((n[s] * 100) + "%", this.axisTickFont);
					var h = (z + (e * n[s])) % (Math.PI * 2);
					var C = (n[s] * 100) + "%";
					var m = ((this.currentRadius - (t - w)) * Math.cos(h)) + this.cx;
					var l = ((this.currentRadius - (t - w)) * Math.sin(h)) + this.cy;
					for (var r = 0; r < 10; r++) {
						if (n[s] < 1 || r == 0) {
							var p = h + (r * f * e);
							var b = (d * Math.cos(p)) + this.cx;
							var q = (d * Math.sin(p)) + this.cy;
							var a = (c * Math.cos(p)) + this.cx;
							var o = (c * Math.sin(p)) + this.cy;
							this.addToRender(["drawLine", "line", b, q, a, o, this.rAxisTickColor], false, false, null, false, [this.cx, this.cy])
						}
					}
					if (h > (Math.PI * 1.5) || h < Math.PI / 2) {
						this.addToRender(["drawText", C, m, l, this.axisTickFont, this.axisTickColor, "right", "middle", h], false, false, null, false, [this.cx, this.cy])
					} else {
						this.addToRender(["drawText", C, m, l, this.axisTickFont, this.axisTickColor, "left", "middle", h + Math.PI], false, false, null, false, [this.cx, this.cy])
					}
				}
			}
			this.currentRadius -= t + (this.margin * 4)
		}
		if ((this.rAxisShow && this.rAxisIndex >= 0) || this.circularType == "chord") {
			if (this.rAxisLabelOrientation != "circular" && this.circularType != "chord") {
				var B = this.rAxisUnit;
				var g = this.axisTickFontSize / 2;
				var d = this.currentRadius - (this.axisTickFontSize + (this.margin * 1));
				var A = this.currentRadius - (this.axisTickFontSize + (this.margin * 2));
				var c = this.currentRadius - (this.axisTickFontSize + (this.margin * 3));
				for (var u = 0; u < this.arcSegmentsRange.length; u++) {
					var z = this.arcSegmentsDims[u][0];
					var n = this[this.axisAlgorithm](this.arcSegmentsMin[u], this.arcSegmentsMax[u], this.rAxisTicks, this.axisWilkinsonLoose);
					var f = (n[1] - n[0]) / this.rAxisTicks;
					for (var s = 0; s < n.length; s++) {
						if (n[s] < this.arcSegmentsMax[u]) {
							var w = this.rAxisTickFormat ? this.measureText(this.formatAxisValue(n[s], "rAxis"), this.axisTickFont) : this.measureText(n[s].toString(), this.axisTickFont);
							var h = (z + (this.rAxisUnit * n[s])) % (Math.PI * 2);
							var C = this.rAxisTickFormat ? this.formatAxisValue(n[s], "rAxis") : n[s];
							if (this.rAxisMajorTicks) {
								var b = (d * Math.cos(h)) + this.cx;
								var q = (d * Math.sin(h)) + this.cy;
								var a = (c * Math.cos(h)) + this.cx;
								var o = (c * Math.sin(h)) + this.cy;
								this.addToRender(["drawLine", "line", b, q, a, o, this.rAxisTickColor], false, false, null, false, [this.cx, this.cy])
							}
							if (this.rAxisMinorTicks) {
								for (var r = 0; r < this.rAxisTicks; r++) {
									if (n[s] + (f * r) < this.arcSegmentsMax[u]) {
										var p = (z + (this.rAxisUnit * (n[s] + (f * r)))) % (Math.PI * 2);
										var b = (A * Math.cos(p)) + this.cx;
										var q = (A * Math.sin(p)) + this.cy;
										var a = (c * Math.cos(p)) + this.cx;
										var o = (c * Math.sin(p)) + this.cy;
										this.addToRender(["drawLine", "line", b, q, a, o, this.rAxisTickColor], false, false, null, false, [this.cx, this.cy])
									}
								}
							}
							this.addToRender(["drawArcText", C, this.cx, this.cy, this.currentRadius, h - (B * w / 7), B * w / 3.5, this.axisTickFont, this.rAxisTickColor, false, false, true])
						}
					}
				}
				this.currentRadius -= this.axisTickFontSize + (this.margin * 3)
			} else {
				var t = this.getCircularRAxisTickLength();
				var d = this.currentRadius - (t + (this.margin * 1));
				var A = this.currentRadius - (t + (this.margin * 2));
				var c = this.currentRadius - (t + (this.margin * 3));
				for (var u = 0; u < this.arcSegmentsRange.length; u++) {
					var z = this.arcSegmentsDims[u][0] + (Math.PI * 2);
					var n = this[this.axisAlgorithm](this.arcSegmentsMin[u], this.arcSegmentsMax[u], this.rAxisTicks, this.axisWilkinsonLoose);
					var f = (n[1] - n[0]) / this.rAxisTicks;
					for (var s = 0; s < n.length; s++) {
						if (n[s] < this.arcSegmentsMax[u]) {
							var w = this.rAxisTickFormat ? this.measureText(this.formatAxisValue(n[s], "rAxis"), this.axisTickFont) : this.measureText(n[s].toString(), this.axisTickFont);
							var h = (z + (this.rAxisUnit * n[s])) % (Math.PI * 2);
							var C = this.rAxisTickFormat ? this.formatAxisValue(n[s], "rAxis") : n[s];
							var m = ((this.currentRadius - (t - w)) * Math.cos(h)) + this.cx;
							var l = ((this.currentRadius - (t - w)) * Math.sin(h)) + this.cy;
							if (this.rAxisMinorTicks) {
								for (var r = 0; r < this.rAxisTicks; r++) {
									if (n[s] + (f * r) < this.arcSegmentsMax[u]) {
										var p = (z + (this.rAxisUnit * (n[s] + (f * r)))) % (Math.PI * 2);
										var b = (A * Math.cos(p)) + this.cx;
										var q = (A * Math.sin(p)) + this.cy;
										var a = (c * Math.cos(p)) + this.cx;
										var o = (c * Math.sin(p)) + this.cy;
										this.addToRender(["drawLine", "line", b, q, a, o, this.rAxisTickColor], false, false, null, false, [this.cx, this.cy])
									}
								}
							}
							if (this.rAxisMajorTicks) {
								var b = (d * Math.cos(h)) + this.cx;
								var q = (d * Math.sin(h)) + this.cy;
								var a = (c * Math.cos(h)) + this.cx;
								var o = (c * Math.sin(h)) + this.cy;
								this.addToRender(["drawLine", "line", b, q, a, o, this.rAxisTickColor], false, false, null, false, [this.cx, this.cy])
							}
							if (h > (Math.PI * 1.5) || h < Math.PI / 2) {
								this.addToRender(["drawText", C, m, l, this.axisTickFont, this.axisTickColor, "right", "middle", h], false, false, null, false, [this.cx, this.cy])
							} else {
								this.addToRender(["drawText", C, m, l, this.axisTickFont, this.axisTickColor, "left", "middle", h + Math.PI], false, false, null, false, [this.cx, this.cy])
							}
						}
					}
				}
				this.currentRadius -= t + (this.margin * 3)
			}
		}
	};
	this.drawCircularOverlays = function() {
		this.functionCaller = "drawCircularOverlays";
		if (this.showOverlays && this.smpOverlays.length > 0 && this.circularType != "sunburst" && this.circularType != "chord") {
			var t = this;
			var f = this.meta.data;
			var A = this.circularStart;
			var z = this.segregateSamplesBy;
			var r = (this.overlaysThickness - this.overlayFontSize) / 2;
			var h = function(e, c) {
				if (e.type == "Numeric") {
					return t.getColorForValue(e.colorBrew, c)
				} else {
					return e.colors[e.order[c]]
				}
			};
			if (z.length > 0 && this.data.x[z[0]]) {
				var a = this.rAxisIndex >= 0 && this.circularArc == 360 ? 0.033 : 0;
				var x = this.sortObject(f.x[z[0]].order);
				for (var q = 0; q < x.length; q++) {
					var b = x[q];
					var w = h(f.x[z[0]], b);
					var d = this.rAxisIndex >= 0 ? this.arcSegmentsRange[this.arcSegmentsRangeMap[b]] : (this.getSamplesByAnnotationLevel(z[0], b)).length;
					var u = this.rAxisUnit * d;
					this.addToRender(["drawShape", "arc2", this.cx, this.cy, this.overlaysThickness, this.currentRadius, w, false, false, false, false, false, false, A - a, A + u + a], ["SmpOvrSgr-" + 0 + "-" + b]);
					this.addToRender(["drawArcText", b, this.cx, this.cy, this.currentRadius - r, A, u, this.overlayFont, this.overlayFontColor, false, false, true], ["SmpOvrSgr-" + 0 + "-" + b]);
					A += u + this.radians(this.arcSegmentsSeparation)
				}
				A -= this.radians(this.arcSegmentsSeparation);
				A = A % (Math.PI * 2);
				if (this.circularArc == 360) {
					this.addToRender(["drawArcText", z[0], this.cx, this.cy, this.currentRadius - r, A, this.circularStart - A, this.overlayFont, this.overlayFontColor, false, false, true])
				}
				this.currentRadius -= this.overlaysThickness;
				A = this.circularStart
			}
			if (this.rAxisIndex < 0) {
				for (var q = 0; q < this.smpOverlays.length; q++) {
					var b = this.smpOverlays[q];
					if (z.length > 0 && this.data.x[z[0]] && b == z[0]) {
						continue
					}
					var u = this.rAxisUnit;
					if (b != "-") {
						for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
							for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
								var y = this.data.x[b][this.arcSegmentsSampleIndices[l][g]];
								var w = h(f.x[b], y);
								this.addToRender(["drawShape", "arc2", this.cx, this.cy, this.overlaysThickness, this.currentRadius, w, false, false, false, false, false, false, A, A + u], ["SmpOvr-" + this.arcSegmentsSampleIndices[l][g] + "-" + q]);
								if (this.showLevelOverlays) {
									this.addToRender(["drawArcText", y, this.cx, this.cy, this.currentRadius - r, A, u, this.overlayFont, this.overlayFontColor, false, false, true], ["SmpOvr-" + this.arcSegmentsSampleIndices[l][g] + "-" + q])
								}
								A += u
							}
							A += this.radians(this.arcSegmentsSeparation)
						}
						A -= this.radians(this.arcSegmentsSeparation);
						A = A % (Math.PI * 2);
						this.currentRadius -= this.overlaysThickness;
						A = this.circularStart
					} else {
						this.currentRadius -= this.margin;
						A = this.circularStart
					}
				}
			}
			this.currentRadius -= this.margin
		} else {
			if (this.circularType == "chord") {}
		}
	};
	this.drawCircularSampleLabels = function() {
		this.functionCaller = "drawCircularSampleLabels";
		var k = this.guides == "dotted" ? "dottedLine" : "line";
		if (this.showSampleNames && this.rAxisIndex < 0 && this.circularType != "chord") {
			if (this.circularType == "sunburst") {} else {
				if (this.circularType == "bubble") {} else {
					var h = this.rAxisUnit;
					if (this.smpLabelOrientation == "circular") {
						var p = this.circularStart;
						for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
							for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d += this.smpLabelInterval) {
								var b = this.data.y.smps[this.arcSegmentsSampleIndices[f][d]];
								var m = this.getSmpColor(b);
								this.addToRender(["drawArcText", b, this.cx, this.cy, this.currentRadius, p, h, this.smpLabelFont, m, false, false, true], ["Smp-" + this.smpIndices[this.arcSegmentsSampleIndices[f][d]]]);
								p += (h * this.smpLabelInterval)
							}
							p += this.radians(this.arcSegmentsSeparation)
						}
						this.currentRadius -= this.getCircularSampleLabelLength() + this.margin
					} else {
						var p = this.circularStart + (h / 2);
						var g = this.getCircularSampleLabelLength();
						this.currentRadius -= this.getCircularSampleLabelLength() + this.margin;
						for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
							for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d += this.smpLabelInterval) {
								var b = this.data.y.smps[this.arcSegmentsSampleIndices[f][d]];
								var m = this.getSmpColor(b);
								var a = p % (Math.PI * 2);
								var o = (this.currentRadius * Math.cos(p)) + this.cx;
								var n = (this.currentRadius * Math.sin(p)) + this.cy;
								if (a > (Math.PI * 1.5) || a < Math.PI / 2) {
									this.addToRender(["drawText", b, o, n, this.smpLabelFont, m, "left", "middle", p], ["Smp-" + this.smpIndices[this.arcSegmentsSampleIndices[f][d]]], false, null, false, [this.cx, this.cy])
								} else {
									this.addToRender(["drawText", b, o, n, this.smpLabelFont, m, "right", "middle", p + Math.PI], ["Smp-" + this.smpIndices[this.arcSegmentsSampleIndices[f][d]]], false, null, false, [this.cx, this.cy])
								}
								if (this.guides || this.circularType == "radar") {
									var o = ((this.currentRadius - this.overlaysThickness) * Math.cos(p)) + this.cx;
									var n = ((this.currentRadius - this.overlaysThickness) * Math.sin(p)) + this.cy;
									this.addToRender(["drawLine", k, this.cx, this.cy, o, n, this.guidesColor, this.guidesWidth + 0.7, "butt"], false, false, null, false, [this.cx, this.cy])
								}
								p += (h * this.smpLabelInterval)
							}
							p += this.radians(this.arcSegmentsSeparation)
						}
						this.currentRadius -= this.margin
					}
				}
			}
		} else {
			if (this.circularType == "chord") {}
		}
	};
	this.drawCircularData = function() {
		var b = this.circularCenterProportion * this.r;
		var a = this.currentRadius - b;
		var f = this.varIndices;
		var c = 0;
		for (var d = 0; d < this.ringsNumber; d++) {
			if (this.rAxisIndex >= 0 && d == this.rAxisIndex) {
				continue
			}
			if (this.ringsType[d] == "heatmap") {
				this.circularHeatmap = true
			}
			var e = this.circularStart;
			var g = (a * this.ringsWeight[d]);
			this.setVariablesVisible(this.ringsVarIndices[d]);
			if (this.circularType != "chord") {
				this.setAxes(false, true, this.ringsType[d] == "stacked")
			}
			this.xAxisUnit = (g - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.xAxisRange;
			this.drawCircularRingLegend(e, g, this.ringsType[d] == "heatmap");
			this.drawCircularDataAxis(e, g, this.ringsType[d] == "heatmap");
			this.drawCircularDataPoints(e, g, d, c);
			c += this.varIndices.length;
			this.currentRadius -= (g + this.ringSeparation)
		}
		this.varIndices = f
	};
	this.drawCircularRingLegend = function(o, j, d) {
		this.functionCaller = "drawCircularRingLegend";
		if (this.showRingLegend && this.circularType == "normal") {
			var k = this.circularArc != 360 ? 0 : 2;
			var n = [];
			var g = this.arcSegmentsDims[0][0];
			var b = this.arcSegmentsDims[this.arcSegmentsNumber - 1][1] % (Math.PI * 2);
			if (d && this.rAxisIndex < 0) {
				var m = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
				for (var c = 0; c < this.varIndices.length; c++) {
					n.push(m[c] + ": " + this.data.y.vars[this.varIndices[c]])
				}
			} else {
				for (var c = 0; c < this.varIndices.length; c++) {
					n.push(this.data.y.vars[this.varIndices[c]])
				}
			}
			v = n.join(", ");
			this.addToRender(["drawArcText", v, this.cx, this.cy, this.currentRadius + (this.axisTickFontSize / 2) - (this.margin * 0.5), b + ((b - g) / 2), (g - b) * k, this.axisTickFont, this.axisTickColor, false, false, true])
		}
	};
	this.drawCircularDataAxis = function(u, K, H) {
		this.functionCaller = "drawCircularDataAxis";
		var o = this.circularArc == 360 ? this.arcSegmentsNumber - 1 : this.circularType == "radar" || this.circularType == "sunburst" ? 0 : 1;
		var J = this.arcSegmentsDims[0][0];
		var B = this.arcSegmentsDims[o][1] % (Math.PI * 2);
		var L = this.showRingLegend ? this.currentRadius - this.axisTickFontSize : this.currentRadius;
		if (H && this.rAxisIndex < 0) {
			var x = (K - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.varIndices.length;
			var N = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
			for (var F = 0; F < this.varIndices.length; F++) {
				L -= x;
				this.addToRender(["drawArcText", N[F], this.cx, this.cy, L + (x / 2) + (this.axisTickFontSize / 2), B, J - B, this.axisTickFont, this.axisTickColor, false, false, true])
			}
		} else {
			if (this.circularType != "sunburst" && this.circularType != "chord" && this.circularType != "bubble") {
				var A = this.rAxisIndex >= 0 && this.circularArc == 360 ? 0.033 : 0;
				var w = [];
				for (var F = 0; F < this.xAxisValues.length; F++) {
					var O = parseFloat(this.xAxisValues[F]);
					if (O >= this.xAxisMin && O <= this.xAxisMax) {
						w.push(O)
					}
				}
				for (var F = 0; F < w.length; F++) {
					var n = L - ((this.xAxisMax - w[F]) * this.xAxisUnit);
					for (var D = 0; D < this.arcSegmentsNumber; D++) {
						if (D == 0) {
							if (this.circularArc == 360 || this.circularType == "normal") {
								this.addToRender(["drawArcText", w[F], this.cx, this.cy, n + (this.axisTickFontSize / 2), B, J - B, this.axisTickFont, this.axisTickColor, false, false, true])
							} else {
								this.addToRender(["drawArcText", w[F], this.cx, this.cy, n + (this.axisTickFontSize / 2), J, this.arcSegmentsDims[0][1] - this.arcSegmentsDims[0][0], this.axisTickFont, this.axisTickColor, false, false, true])
							}
						}
						if (F == 0) {
							this.addToRender(["drawShape", "arc3", this.cx, this.cy, L, L, this.foreground, this.foreground, false, false, false, false, false, this.arcSegmentsDims[D][0] - A, this.arcSegmentsDims[D][1] + A])
						} else {
							if (F == w.length - 1) {
								var z = L - ((this.xAxisMax - this.xAxisMin) * this.xAxisUnit);
								this.addToRender(["drawShape", "arc3", this.cx, this.cy, z, z, this.foreground, this.foreground, false, false, false, false, false, this.arcSegmentsDims[D][0] - A, this.arcSegmentsDims[D][1] + A])
							} else {
								this.addToRender(["drawShape", "arc3", this.cx, this.cy, n, n, this.xAxisTickColor, this.xAxisTickColor, false, false, false, false, false, this.arcSegmentsDims[D][0] - A, this.arcSegmentsDims[D][1] + A])
							}
						}
						if (D == this.arcSegmentsNumber - 1 && this.circularType == "normal") {
							var I, G, m, g;
							var q = L - ((this.xAxisMax - this.xAxisMin) * this.xAxisUnit);
							var M = L - ((this.xAxisMax - w[w.length - 1]) * this.xAxisUnit);
							for (var C = 0; C < this.arcSegmentsNumber; C++) {
								I = q * Math.cos(this.arcSegmentsDims[C][0] - A);
								m = q * Math.sin(this.arcSegmentsDims[C][0] - A);
								G = M * Math.cos(this.arcSegmentsDims[C][0] - A);
								g = M * Math.sin(this.arcSegmentsDims[C][0] - A);
								this.addToRender(["drawLine", "line", I + this.cx, m + this.cy, G + this.cx, g + this.cy, this.foreground], false, false, null, false, [this.cx, this.cy, this.cx, this.cy]);
								I = q * Math.cos(this.arcSegmentsDims[C][1] + A);
								m = q * Math.sin(this.arcSegmentsDims[C][1] + A);
								G = M * Math.cos(this.arcSegmentsDims[C][1] + A);
								g = M * Math.sin(this.arcSegmentsDims[C][1] + A);
								this.addToRender(["drawLine", "line", I + this.cx, m + this.cy, G + this.cx, g + this.cy, this.foreground], false, false, null, false, [this.cx, this.cy, this.cx, this.cy])
							}
						}
					}
				}
				if (this.circularType == "radar" && this.circularArc != 360) {
					var I, G, E, m, g, d;
					var q = L - ((this.xAxisMax - this.xAxisMin) * this.xAxisUnit);
					var M = L - ((this.xAxisMax - w[w.length - 1]) * this.xAxisUnit);
					I = q * Math.cos(this.arcSegmentsDims[0][0] - A);
					m = q * Math.sin(this.arcSegmentsDims[0][0] - A);
					G = M * Math.cos(this.arcSegmentsDims[0][0] - A);
					g = M * Math.sin(this.arcSegmentsDims[0][0] - A);
					E = M * Math.cos(this.arcSegmentsDims[0][1] - A);
					d = M * Math.sin(this.arcSegmentsDims[0][1] - A);
					this.addToRender(["drawLine", "line", I + this.cx, m + this.cy, G + this.cx, g + this.cy, this.foreground], false, false, null, false, [this.cx, this.cy, this.cx, this.cy]);
					this.addToRender(["drawLine", "line", I + this.cx, m + this.cy, E + this.cx, d + this.cy, this.foreground], false, false, null, false, [this.cx, this.cy, this.cx, this.cy])
				}
			}
		}
	};
	this.drawCircularDataPoints = function(aa, ap, am, Z) {
		this.functionCaller = "drawCircularDataPoints";
		var T = this;
		var V = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
		var ae = this.rAxisUnit * 0.3;
		var an = ae / 2;
		var aw = this.rAxisUnit * 0.7 / this.ringsVarIndices[am].length;
		var at = this.smpIndices.length > 100 ? this.margin : this.smpIndices.length > 50 ? this.margin * 1.5 : this.smpIndices.length > 25 ? this.margin * 2 : this.margin * 3;
		var M = this.showRingLegend ? this.currentRadius - this.axisTickFontSize : this.currentRadius;
		var w = this.meta.data.x;
		var ak = this.marginLeft + this.marginRight + this.left + this.x - this.right;
		var ai = this.marginTop + this.marginBottom + this.bottom + this.y - this.top;
		var u = this.circularType == "sunburst" ? 0 : ak > ai ? this.marginLeft + this.left + ((this.x - this.y) / 2) : this.marginLeft + this.left;
		var o = this.circularType == "sunburst" ? 0 : ai > ak ? this.marginTop + this.top + ((this.y - this.x)) / 2 : this.marginTop + this.top;
		if (this.circularType == "sunburst") {
			var G = function(l, m) {
				if (l.children) {
					var h = 0.002;
					for (var k = 0; k < l.children.length; k++) {
						var a = l.children[k];
						var b = a.depth * ac;
						var p = a.value * T.rAxisUnit;
						var s, c, i, d, e, r, q;
						if ((T.hierarchy.length == 0 || a.depth < T.hierarchy.length) && a.name) {
							if (h >= 0.002) {
								i = T.measureText(a.name, T.smpLabelFont) + (T.margin * 2);
								d = p * ((T.currentRadius - ap) + b + P);
								s = a.color;
								ol = d > T.margin ? T.foreground : s;
								c = T.addToRender(["drawShape", "arc2", T.cx + u, T.cy + o, ac, (T.currentRadius - ap) + b + ac, s, ol, false, false, false, false, false, m, m + p], ["Sunburst:" + a.tooltip]);
								if (d > i) {
									if (ac > T.smpLabelFontSize) {
										T.addToRender(["drawArcText", a.name, T.cx + u, T.cy + o, (T.currentRadius - ap) + b + P, m, p, T.smpLabelFont, T.smpLabelFontColor, false, false, true], false, false, c)
									}
								} else {
									if (ac > i) {
										if (d > T.smpLabelFontSize) {
											e = (m + (p / 2)) % (Math.PI * 2);
											r = (((T.currentRadius - ap) + b + P - (i / 2)) * Math.cos(e)) + T.cx;
											q = (((T.currentRadius - ap) + b + P - (i / 2)) * Math.sin(e)) + T.cy;
											if (e > (Math.PI * 1.5) || e < Math.PI / 2) {
												T.addToRender(["drawText", a.name, r + u, q + o, T.smpLabelFont, T.smpLabelFontColor, "center", "middle", e], false, false, c, false, [T.cx, T.cy])
											} else {
												T.addToRender(["drawText", a.name, r + u, q + o, T.smpLabelFont, T.smpLabelFontColor, "center", "middle", e + Math.PI], false, false, c, false, [T.cx, T.cy])
											}
										}
									}
								}
								h = 0
							}
							if (a.children) {
								G(a, m)
							}
							m += p;
							h += p
						}
					}
				}
			};
			var ac = ap / Math.max(this.hierarchy.length, 1);
			var P = (ac + this.smpLabelFontSize) / 2;
			var az = this.smpLabelFontSize / 2;
			G(this.circularSunburst[0], aa)
		} else {
			if (this.circularType == "chord") {
				var M = this.circularChord;
				var N = (this.chordThickness - this.smpLabelFontSize) / 2;
				var C = [];
				for (var am = 0; am < M.segments.length; am++) {
					M.segments[am].ribbons = {};
					var L = (aa + M.segments[am].start);
					var al = (aa + M.segments[am].end);
					var O = M.segments[am].color;
					var Q = M.segments[am].name;
					var R = this.addToRender(["drawShape", "arc2", this.cx, this.cy, this.chordThickness, this.currentRadius, O, false, false, false, false, false, false, L, al], ["Chord:" + M.segments[am].idx + ":" + M.segments[am].name + " (" + M.segments[am].value + ")"]);
					M.segments[am].ribbons[R] = true;
					if (this.showSampleNames) {
						R = this.addToRender(["drawArcText", Q, this.cx, this.cy, this.currentRadius - N, L, al - L, this.smpLabelFont, this.smpLabelFontColor, false, false, true], false, false, R);
						M.segments[am].ribbons[R] = true
					}
				}
				this.currentRadius -= this.chordThickness;
				if (this.chordColorOrigin != "target") {
					this.chordColorOrigin = "source"
				}
				for (var am = 0; am < M.chords.length; am++) {
					var D = (aa + M.chords[am].source.start);
					var K = (aa + M.chords[am].source.end);
					var aq = (aa + M.chords[am].target.start);
					var f = (aa + M.chords[am].target.end);
					var I = this.cx + (this.currentRadius * Math.cos(D));
					var aB = this.cy + (this.currentRadius * Math.sin(D));
					var H = this.cx + (this.currentRadius * Math.cos(f));
					var aA = this.cy + (this.currentRadius * Math.sin(f));
					var F = this.cx + (this.currentRadius * Math.cos(aq));
					var ay = this.cy + (this.currentRadius * Math.sin(aq));
					var E = this.cx + (this.currentRadius * Math.cos(K));
					var av = this.cy + (this.currentRadius * Math.sin(K));
					var O = M.chords[am][this.chordColorOrigin].color;
					var ao = ["Connect:" + M.segments[M.chords[am].source.idx].name + " (" + M.segments[M.chords[am].source.idx].value + ") -- " + M.segments[M.chords[am].target.idx].name + " (" + M.segments[M.chords[am].target.idx].value + ")"];
					var R = this.addToRender(["drawShape", "arch", [I, this.cx, H, F, this.cx, E],
						[aB, this.cy, aA, ay, this.cy, av],
						[D, K, aq, f], this.currentRadius, this.addColorTransparency(O, 0.67), this.addColorTransparency(this.foreground, 0.33)
					], ao);
					M.segments[M.chords[am].source.idx].ribbons[R] = true;
					M.segments[M.chords[am].target.idx].ribbons[R] = true
				}
			} else {
				if (this.circularType == "bubble") {
					var U = this.data.bubble.plot.descendants();
					var aa = Math.max(this.top, this.right);
					var V = this.data.bubble.plot.diameter / 2;
					if (this.hierarchy.length > 0) {
						for (var am = 0; am < U.length; am++) {
							var af = this.meta.data.x;
							var aw = U[am];
							if (aw.children) {
								var ae = this.rotatePoint(aw.x, aw.y, V, V, this.radians(this.circularRotate));
								var X = u + ae[0];
								var W = o + ae[1];
								var at = aw.r * 2;
								var ad = aw.depth == 0 ? false : ["Bubble" + aw.data.id + ":" + aw.data.name + " (" + aw.value + ")"];
								var au = this.colorBy && af && af.hasOwnProperty(this.colorBy) && af[this.colorBy].order.hasOwnProperty(aw.data.name) ? af[this.colorBy].colors[af[this.colorBy].order[aw.data.name]] : this.bubbleColor;
								var ar = this.addToRender(["drawShape", "circle", X, W, at, at, aw.depth == this.hierarchy.length ? au : this.addColorTransparency(au, 0.33), this.foreground], ad, false, null, false, [this.cx, this.cy, 0, 0]);
								if (aw.depth == this.hierarchy.length) {
									this.addToRender(["drawText", aw.data.name, X, W, this.smpLabelFont, this.smpLabelFontColor, "center", "middle"], ad, false, ar, false, [this.cx, this.cy, 0, 0])
								} else {
									this.addToRender(["drawText", aw.data.name, X, W - (aw.r + (this.smpLabelFontSize * 0.5)), this.smpLabelFont, this.smpLabelFontColor, "center", "middle"], ad, false, ar, false, [this.cx, this.cy, 0, 0])
								}
							}
						}
					} else {
						for (var am = 0; am < U.length; am++) {
							var aw = U[am];
							if (!aw.children) {
								var ae = this.rotatePoint(aw.x, aw.y, V, V, this.radians(this.circularRotate));
								var X = u + ae[0];
								var W = o + ae[1];
								var at = aw.r * 2;
								var ad = ["Bubble" + aw.data.id + ":" + aw.data.name + " (" + aw.value + ")"];
								var au = this.colorBy ? this.getPropertyValue(this.hierarchyVar, aw.data.idx, "colorBy") : this.colors[am % this.colors.length];
								var ar = this.addToRender(["drawShape", "circle", X, W, at, at, au, this.foreground], ad, false, null, false, [this.cx, this.cy, 0, 0]);
								this.addToRender(["drawText", aw.data.name, X, W, this.smpLabelFont, this.smpLabelFontColor, "center", "middle"], ad, false, ar, false, [this.cx, this.cy, 0, 0])
							}
						}
					}
				} else {
					if (this.rAxisIndex < 0) {
						if (this.ringsType[am] != "heatmap" && this.ringsType[am] != "pie" && this.ringsType[am] != "stacked") {
							if (this.ringsType[am] == "line" || this.ringsType[am] == "area") {
								aa += (this.rAxisUnit / 2) - (aw * 0.5)
							} else {
								aa += an
							}
						}
						for (var aj = 0; aj < this.arcSegmentsSampleIndices.length; aj++) {
							var J = 0.002;
							var ab = [];
							for (var ag = 0; ag < this.varIndices.length; ag++) {
								ab[ag] = {
									x: [],
									y: [],
									c: this.foreground,
									s: "sphere",
									a: []
								}
							}
							for (var ah = 0; ah < this.arcSegmentsSampleIndices[aj].length; ah++) {
								if (this.ringsType[am] == "heatmap") {
									if (J >= 0.002) {
										var ac = (ap - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.varIndices.length;
										var ad = 0;
										for (var ag = 0; ag < this.varIndices.length; ag++) {
											var Y = this.getDataAtPos(this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]);
											var au = !isNaN(Y) ? this.getColorForValue(false, Y) : this.missingDataColor;
											this.addToRender(["drawShape", "arc2", this.cx, this.cy, ac, M - ad, au, au, false, false, false, false, false, aa, aa + this.rAxisUnit], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]]);
											ad += ac
										}
										J = 0
									}
									aa += this.rAxisUnit;
									J += this.rAxisUnit
								} else {
									if (this.ringsType[am] == "stacked") {
										if (J >= 0.002) {
											var ad = 0;
											for (var ag = 0; ag < this.varIndices.length; ag++) {
												var Y = this.getDataAtPos(this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]);
												var au = this.colors[(this.varIndices[ag] + Z) % this.colors.length];
												var ac = Y * this.xAxisUnit;
												this.addToRender(["drawShape", "arc2", this.cx, this.cy, ac, (this.currentRadius - ap) + ac + ad, this.addColorTransparency(au, 0.67), au, false, false, false, false, false, aa, aa + this.rAxisUnit], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]]);
												ad += ac
											}
											J = 0
										}
										aa += this.rAxisUnit;
										J += this.rAxisUnit
									} else {
										for (var ag = 0; ag < this.varIndices.length; ag++) {
											var Y = this.getDataAtPos(this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]) - this.xAxisMin;
											var au = this.colors[(this.varIndices[ag] + Z) % this.colors.length];
											var af = this.ringsType[am] == "bar" || this.ringsType[am] == "pie" ? Y * this.xAxisUnit : (this.xAxisMax - (Y + this.xAxisMin)) * this.xAxisUnit;
											if (this.ringsType[am] == "bar") {
												this.addToRender(["drawShape", "arc2", this.cx, this.cy, af, Math.max(af, this.currentRadius + V - (ap - af)), au, au, false, false, false, false, false, aa, aa + aw], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]])
											} else {
												if (this.ringsType[am] == "dot") {
													var X = this.cx + (M - af) * Math.cos(aa + (aw / 2));
													var W = this.cy + (M - af) * Math.sin(aa + (aw / 2));
													this.addToRender(["drawShape", "circle", X, W, at, at, au, au], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]], false, null, false, [this.cx, this.cy])
												} else {
													if (this.ringsType[am] == "pie") {
														this.addToRender(["drawShape", "arc2", this.cx, this.cy, af, Math.max(af, this.currentRadius + V - (ap - af)), this.addColorTransparency(au, 0.67), au, false, false, false, false, false, aa, aa + this.rAxisUnit], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]])
													} else {
														if (this.ringsType[am] == "line" || this.ringsType[am] == "area") {
															ab[ag].x.push(this.cx + (M - af) * Math.cos(aa + (aw / 2)));
															ab[ag].y.push(this.cy + (M - af) * Math.sin(aa + (aw / 2)));
															ab[ag].c = au;
															ab[ag].s = this.lineDecoration == "symbol" ? this.shapes[ag % this.shapes.length] : "sphere";
															ab[ag].a.push([this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]])
														}
													}
												}
											}
											if (this.ringsType[am] != "line" && this.ringsType[am] != "area" && this.ringsType[am] != "pie") {
												aa += aw
											}
										}
										if (this.ringsType[am] == "line" || this.ringsType[am] == "area" || this.ringsType[am] == "pie") {
											aa += this.rAxisUnit
										} else {
											aa += ae
										}
									}
								}
							}
							if (this.ringsType[am] == "line") {
								for (var ag = 0; ag < this.varIndices.length; ag++) {
									var S = null;
									for (var ah = 0; ah < ab[ag].x.length; ah++) {
										var ax = ab[ag];
										var ar = this.addToRender(["drawShape", ax.s, ax.x[ah], ax.y[ah], at, at, ax.c, ax.c], ax.a[ah], false, S, false, [this.cx, this.cy]);
										if (!S) {
											S = ar
										}
										if (ah > 0) {
											this.addToRender(["drawLine", "line", ax.x[ah - 1], ax.y[ah - 1], ax.x[ah], ax.y[ah], ax.c], false, false, S, false, [this.cx, this.cy])
										}
										if (this.circularType == "radar" && ah == ab[ag].x.length - 1) {
											this.addToRender(["drawLine", "line", ax.x[ah], ax.y[ah], ax.x[0], ax.y[0], ax.c], false, false, S, false, [this.cx, this.cy])
										}
									}
								}
							} else {
								if (this.ringsType[am] == "area") {
									for (var ag = 0; ag < this.varIndices.length; ag++) {
										var ax = ab[ag];
										this.addToRender(["drawShape", "path", ax.x, ax.y, false, false, this.addColorTransparency(ax.c, 0.67), ax.c], ["Line:" + this.data.y.vars[ax.a[0][0]]], false, null, false, [this.cx, this.cy])
									}
								}
							}
							aa += this.radians(this.arcSegmentsSeparation)
						}
					} else {
						for (var aj = 0; aj < this.arcSegmentsSampleIndices.length; aj++) {
							var aa = this.arcSegmentsDims[aj][0];
							var af = this.rAxisZero && this.arcSegmentsMin[aj] < 0 ? this.arcSegmentsMin[aj] : 0;
							for (var ah = 0; ah < this.arcSegmentsSampleIndices[aj].length; ah++) {
								for (var ag = 0; ag < this.varIndices.length; ag++) {
									var au = this.colors[(ag + Z) % this.colors.length];
									var n = this.getDataAtPos(this.rAxisIndex, this.smpIndices[this.arcSegmentsSampleIndices[aj][ah]]);
									var g = this.getDataAtPos(this.varIndices[ag], this.smpIndices[this.arcSegmentsSampleIndices[aj][ah]]);
									if (this.rAxisZero && n < 0) {
										continue
									}
									var B = (n + af - this.arcSegmentsMin[aj]) * this.rAxisUnit;
									var A = ((g - this.xAxisMin) * this.xAxisUnit);
									var X = this.cx + ((this.currentRadius - ((ap - A))) * Math.cos(aa + B));
									var W = this.cy + ((this.currentRadius - ((ap - A))) * Math.sin(aa + B));
									this.addToRender(["drawShape", "circle", X, W, this.margin, this.margin, au, au], [this.varIndices[ag], this.arcSegmentsSampleIndices[aj][ah]], false, null, false, [this.cx, this.cy])
								}
							}
						}
					}
				}
			}
		}
	};
	this.getCircularCoordinates = function(m) {
		var f = this;
		var h = this.rAxisUnit;
		var i = this.currentRadius;
		var q = function(t) {
			for (var e = 0; e < f.arcSegmentsSampleIndices.length; e++) {
				for (var c = 0; c < f.arcSegmentsSampleIndices[e].length; c++) {
					var u = f.arcSegmentsSampleIndices[e][c];
					if (f.data.y.smps[u] == t) {
						return f.arcSegmentsSamplePosition[e][c]
					}
				}
			}
			return false
		};
		var g = function(e) {
			var t = f.arcSegmentsRangeMap[e[1]];
			var x = f.arcSegmentsRangeMap[e[3]];
			if (t != null && x != null) {
				var c = f.rAxisZero && f.arcSegmentsMin[t] < 0 ? f.arcSegmentsMin[t] : 0;
				var A = f.rAxisZero && f.arcSegmentsMin[x] < 0 ? f.arcSegmentsMin[x] : 0;
				if (e[2] >= f.arcSegmentsMin[t] && e[2] <= f.arcSegmentsMax[t] && e[4] >= f.arcSegmentsMin[x] && e[4] <= f.arcSegmentsMax[x]) {
					var w, z, u, y;
					w = f.arcSegmentsDims[t][0] + ((e[2] + c - f.arcSegmentsMin[t]) * f.rAxisUnit);
					z = f.arcSegmentsDims[x][0] + ((e[4] + A - f.arcSegmentsMin[x]) * f.rAxisUnit);
					if (e[5] != null || e[6] != null) {
						u = f.arcSegmentsDims[t][0] + ((Math.min(e[2] + (e[5] || 0), f.arcSegmentsMax[t]) + c - f.arcSegmentsMin[t]) * f.rAxisUnit);
						y = f.arcSegmentsDims[x][0] + ((Math.min(e[4] + (e[6] || 0), f.arcSegmentsMax[x]) + A - f.arcSegmentsMin[x]) * f.rAxisUnit);
						return [w, z, u, y]
					}
					return [w, z]
				}
			}
			return false
		};
		if (this.rAxisIndex < 0) {
			var s = q(m[1]);
			var j = q(m[2]);
			if (s && j) {
				var d = this.cx + (i * Math.cos(s));
				var p = this.cy + (i * Math.sin(s));
				var b = this.cx + (i * Math.cos(j + h));
				var o = this.cy + (i * Math.sin(j + h));
				var a = this.cx + (i * Math.cos(j));
				var l = this.cy + (i * Math.sin(j));
				var r = this.cx + (i * Math.cos(s + h));
				var k = this.cy + (i * Math.sin(s + h));
				return [d, p, b, o, a, l, r, k, s, s + h, j, j + h]
			}
		} else {
			if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]]) {
				var n = g(m);
				if (n) {
					var d, p, b, o, a, l, r, k;
					if (n.length > 2) {
						d = this.cx + (i * Math.cos(n[0]));
						p = this.cy + (i * Math.sin(n[0]));
						b = this.cx + (i * Math.cos(n[3]));
						o = this.cy + (i * Math.sin(n[3]));
						a = this.cx + (i * Math.cos(n[1]));
						l = this.cy + (i * Math.sin(n[1]));
						r = this.cx + (i * Math.cos(n[2]));
						k = this.cy + (i * Math.sin(n[2]));
						return [d, p, b, o, a, l, r, k, n[0], n[2], n[1], n[3]]
					} else {
						d = this.cx + (i * Math.cos(n[0]));
						p = this.cy + (i * Math.sin(n[0]));
						b = this.cx + (i * Math.cos(n[1]));
						o = this.cy + (i * Math.sin(n[1]));
						return [d, p, b, o]
					}
				} else {}
			}
		}
		return false
	};
	this.drawCircularConnections = function() {
		this.functionCaller = "drawCircularConnections";
		if (this.showCircularConnections && this.connections) {
			var k = function(b) {
				if (b.length > 3) {
					return b[1] + "[" + b[2] + "] " + b[5] + " - " + b[3] + "[" + b[4] + "] " + b[6]
				} else {
					return b[1] + " - " + b[2]
				}
			};
			this.currentRadius += (this.margin * 1.5);
			var j = this.rAxisUnit;
			for (var g = 0; g < this.connections.length; g++) {
				var m = this.getCircularCoordinates(this.connections[g]);
				var d = k(this.connections[g]);
				var h = this.addColorTransparency(this.connections[g][0], this.circularConnectionsTransparency);
				var a = this.addColorTransparency(this.foreground, 0.33);
				if (m.length > 4) {
					this.addToRender(["drawShape", "arch", [m[0], this.cx, m[2], m[4], this.cx, m[6]],
						[m[1], this.cy, m[3], m[5], this.cy, m[7]],
						[m[8], m[9], m[10], m[11]], this.currentRadius, h, a, "solid"
					], ["Connect:" + d])
				} else {
					this.addToRender(["drawLine", "arch", [m[0], this.cx, m[2]],
						[m[1], this.cy, m[3]], false, false, h, a
					], ["Connect:" + d])
				}
			}
		}
	};
	this.drawNetworkColorIndicator = function() {
		if (this.circularHeatmap) {
			this.drawColorIndicator(this.margin * 4, this.top, this.meta.def.colorBrew, "Color Indicator", true)
		}
	};
	this.setCircularTempParameters = function() {
		this.arcSegmentsSeparationTemp = this.arcSegmentsSeparation;
		this.circularCenterProportionTemp = this.circularCenterProportion;
		if (this.circularType != "normal") {
			if (this.circularType == "radar" || this.circularType == "bubble") {
				this.circularCenterProportion = 0;
				this.arcSegmentsSeparation = 0;
				if (this.circularType == "bubble") {
					this.circularArc = 360
				}
			} else {
				if (this.circularType == "chord") {
					this.arcSegmentsSeparation = 3;
					this.circularCenterProportion = 0
				} else {
					if (this.circularType == "sunburst") {
						this.arcSegmentsSeparation = 0
					}
				}
			}
		}
	};
	this.drawCircularPlot = function() {
		this.setLegends();
		this.setCircularArcSegments();
		this.setCircularRings();
		this.setCircularLegendDimensions();
		this.drawCircularRadialAxis();
		this.drawCircularOverlays();
		this.drawCircularSampleLabels();
		this.drawCircularData();
		this.drawCircularConnections();
		this.drawLegend();
		this.drawNetworkColorIndicator();
		this.drawTitle()
	};
	this.setCircularAttributes = function() {
		this.setCircularTempParameters();
		this.setCircularXYDimensions();
		this.setCircularSampleOverlays();
		this.setCircularFonts();
		this.setDendrograms();
		this.setOverlayFont();
		this.validatePropertyValues()
	};
	this.resetCircularAttributes = function() {
		this.arcSegmentsSeparation = this.arcSegmentsSeparationTemp;
		this.circularCenterProportion = this.circularCenterProportionTemp
	};
	this.initializeCircular = function() {
		this.setCircularAttributes();
		this.drawCircularPlot();
		this.resetCircularAttributes()
	};
	this.initializeCircular()
};
CanvasXpress.prototype.Video = function() {
	this.videoPlay = function(a) {
		this.functionCaller = "videoPlay";
		return function(b) {
			a.drawVideo(this, a.width, a.height)
		}
	}(this);
	this.videoUpdate = function() {
		this.functionCaller = "videoUpdate";
		var h = this.video.currentTime;
		if (this.videoCurrentTime) {
			this.addToRender(["drawText", h, this.width / 2, 20, this.font, this.videoColor])
		}
		if (this.videoGrid) {
			var g = (this.width - 1) / this.videoGridStep;
			var f = (this.height - 1) / this.videoGridStep;
			for (var d = 0; d <= this.videoGridStep; d++) {
				this.addToRender(["drawLine", "line", g * d, 0, g * d, this.height, this.videoColor]);
				this.addToRender(["drawLine", "line", 0, f * d, this.width, f * d, this.videoColor])
			}
		}
		for (var d = 0; d < this.data.video.length; d++) {
			var j = this.data.video[d][0];
			var b = j + this.data.video[d][1];
			if (h >= j && h <= b) {
				var c = this.data.video[d][2];
				var e = this.data.video[d][3];
				var a = this.data.video[d][4];
				switch (c) {
					case "text":
						this.addToRender(["drawText", e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]]);
						break;
					case "line":
						this.addToRender(["drawLine", e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10]]);
						break;
					case "shape":
						this.addToRender(["drawShape", e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14]]);
						break
				}
			}
		}
	};
	this.initializeVideo = function() {
		if (!this.data) {
			this.data = {
				video: {}
			}
		}
		if (!this.data.video) {
			this.data.video = {}
		}
	};
	this.initializeVideo()
};
CanvasXpress.prototype.initLeaflet = function() {
	this.drawLeaflet = function() {
		if (this.meta.leaflet) {
			var t = this;
			t.resizeCanvas(true);
			t.setLeafletDimensions();
			t.updateLeafletState();
			t.meta.leaflet.layers.eachLayer(t.styleLeafletLayer);
			setTimeout(function() {
				t.meta.leaflet.layers.eachLayer(t.addLeafletLayerDataEvent);
				t.setLegends();
				var s = t.meta.render.objects.length;
				t.drawLegend();
				t.drawTitle();
				t.drawCitation();
				t.render();
				t.isMapCanvas = true;
				t.render(s);
				t.isMapCanvas = false;
				if (t.debug) {
					t.drawArea()
				}
			}, 100)
		}
	};
	this.setLeafletDimensions = function() {
		this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
	};
	this.addLeafletData = function() {
		var arr = [];
		var prp = {};
		var ids = [];
		var l2cX = {};
		var layers = this.meta.leaflet.layers;
		var that = this;
		var data = {
			y: {
				vars: [],
				smps: [],
				data: []
			},
			z: {}
		};
		layers.eachLayer(function(l) {
			arr.push([l.feature.id, l.feature.properties]);
			for (var p in l.feature.properties) {
				prp[p] = prp.hasOwnProperty(p) ? prp[p] + 1 : 1
			}
			ids.push(l.feature.id);
			delete(prp.tooltip)
		});
		if (this.isExample) {
			var map = {
				vars: {},
				ids: {}
			};
			for (var i = 0; i < arr.length; i++) {
				var o = arr[i];
				map.vars[o[1].name] = true;
				map.ids[o[0]] = true
			}
			var vk = this.getKeys(map.vars);
			var ik = this.getKeys(map.ids);
			data.z.id = [];
			for (var p in prp) {
				data.z[p] = []
			}
			data.y.smps = ["Order"];
			for (var i = 0; i < arr.length; i++) {
				var o = arr[i];
				data.y.data.push([i]);
				if (vk.length == arr.length) {
					data.y.vars.push(o[1].name)
				} else {
					if (ik.length == arr.length) {
						data.y.vars.push(o[0])
					} else {
						data.y.vars.push(i)
					}
				}
				l2cX[ids[i]] = i;
				data.z.id.push(o[0] || null);
				for (var p in prp) {
					data.z[p].push(o[1][p] || null)
				}
			}
			this.updateData(data, false, true);
			layers.eachLayer(function(l) {
				l.feature.properties.varId = l2cX[l.feature.id];
				l.feature.properties.vars = data.y.vars[l2cX[l.feature.id]]
			})
		} else {
			var map = {
				vars: {},
				ids: {}
			};
			for (var i = 0; i < this.data.y.vars.length; i++) {
				map.vars[this.data.y.vars[i]] = i;
				if (this.data.z && this.data.z.hasOwnProperty("id")) {
					map.ids[this.data.z.id[i]] = i
				}
			}
			if (!prp.hasOwnProperty("id")) {
				prp.id = true
			}
			for (var i = 0; i < arr.length; i++) {
				var o = arr[i];
				var idx = null;
				if (o[1].hasOwnProperty("name")) {
					if (map.vars.hasOwnProperty(o[1]["name"])) {
						idx = map.vars[o[1]["name"]]
					} else {
						null
					}
				} else {
					if (map.ids.hasOwnProperty(o[0])) {
						idx = map.ids[o[0]]
					}
				}
				if (idx != null) {
					for (var p in prp) {
						if (!this.data.z.hasOwnProperty(p)) {
							this.data.z[p] = []
						}
						if (this.data.z[p][idx] == null) {
							this.data.z[p][idx] = p == "id" ? o[0] : o[1].hasOwnProperty(p) ? o[1][p] : null
						}
					}
				}
			}
			this.updateData(this.cloneObject(this.data), false, true);
			layers.eachLayer(function(l) {
				var idx = map.vars.hasOwnProperty(l.feature.properties.name) ? map.vars[l.feature.properties.name] : map.ids[l.feature.id] != null ? map.ids[l.feature.id] : null;
				l.feature.properties.varId = idx;
				l.feature.properties.vars = idx != null ? that.data.y.vars[idx] : false
			})
		}
	};
	this.zoomLeaflet = function(z, a) {
		if (this.meta.leaflet) {
			var m = this.meta.leaflet.map;
			CanvasXpress.stack[this.target].afterRender.push(["setViewLeaflet", [m.getCenter(), m.getZoom()]])
		}
	};
	this.centerLeaflet = function(c, a) {
		if (this.meta.leaflet) {
			var m = this.meta.leaflet.map;
			CanvasXpress.stack[this.target].afterRender.push(["setViewLeaflet", [m.getCenter(), m.getZoom()]])
		}
	};
	this.setViewLeaflet = function(c, z) {
		if (this.meta.leaflet) {
			this.meta.leaflet.map.setView(c, z)
		}
	};
	this.styleLeafletLayer = function(layer) {
		var cX = layer._map._cX;
		layer.setStyle({
			fillColor: cX.getPropertyValue(layer.feature.properties.varId, 0, "colorBy"),
			fillOpacity: 0.7,
			color: "grey",
			weight: 0.8,
			opacity: 1
		})
	};
	this.updateLeafletState = function() {
		if (this.meta && this.meta.leaflet) {
			var parse_transform = function(a) {
				var b = {};
				for (var i in a = a.match(/(\w+)\(([^,)]+),?([^)]+)?\)/gi)) {
					var c = a[i].match(/[\w\.\-]+/g);
					b[c.shift()] = c
				}
				return b
			};
			var map = this.meta.leaflet.map;
			var state = this.meta.leaflet.state;
			state.center = map.latLngToLayerPoint(map.getCenter());
			state.delta = state.center.subtract(state.ini);
			var style = parse_transform(map._container.firstChild.style.transform);
			this.meta.canvas.ctx2.canvas.style.left = (parseInt(style.translate3d[0]) * -1) + "px";
			this.meta.canvas.ctx2.canvas.style.top = (parseInt(style.translate3d[1]) * -1) + "px"
		}
	};
	this.setLeafletState = function() {
		if (this.meta.leaflet) {
			this.meta.leaflet.state = {
				zoom: this.meta.leaflet.map.getZoom(),
				ini: this.meta.leaflet.map.latLngToLayerPoint(this.meta.leaflet.map.getCenter()),
				tileSize: 256,
				pixelOrigin: this.meta.leaflet.map.getPixelOrigin(),
				CRS: "EPSG3857"
			}
		}
	};
	this.addLeafletLayerDataEvent = function(layer) {
		var gid = null;
		var cX = layer._map._cX;
		var p = layer._parts;
		for (var i = 0; i < p.length; i++) {
			var x = [];
			var y = [];
			for (j = 0; j < p[i].length; j++) {
				var d = p[i][j].subtract(cX.meta.leaflet.state.delta);
				x.push(d.x);
				y.push(d.y)
			}
			var col = cX.getPropertyValue(layer.feature.properties.varId, 0, "colorBy");
			var idx = cX.addToRender(["drawShape", "polygon", x, y, false, false, col], [layer.feature.properties.varId, 0], false, gid);
			if (gid == null) {
				gid = idx
			}
		}
	};
	this.addLeafletLayer = function(map) {
		if (this.leafletLayer) {
			L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
				attribution: 'Map data &copy; <a href="https://openstreetmap.org">OpenStreetMap</a>',
				id: "mapbox.light"
			}).addTo(map)
		}
	};
	this.addLeafletMapEvents = function(map) {
		map.on("contextmenu", function(e) {
			this._cX.contextmenuCanvas()
		});
		map.on("click", function(e) {
			this._cX.clickCanvas()
		});
		map.on("zoomend", function(e) {
			this._cX.zoomLeaflet(this.getZoom(), true);
			this._cX.drawLeaflet()
		});
		map.on("dragstart", function(e) {
			this._cX.mousedownCanvas(this._cX.tmpLeafletResizeEv)
		});
		map.on("dragend", function(e) {
			if (!this._cX.resizeCanvasCursorShow) {
				this._cX.centerLeaflet(this.getCenter(), true);
				this._cX.drawLeaflet()
			}
		});
		map.on("mousemove", function(e) {
			this._cX.mousemoveDoc(e.originalEvent);
			if (this._cX.resizeCanvasCursorShow) {
				this._cX.tmpLeafletResizeEv = e.originalEvent;
				e.originalEvent.target.style.cursor = this._cX.resizeCanvasCursorShow;
				return false
			}
			map._container.childNodes[0].childNodes[2].childNodes[0].style.cursor = "";
			if (this._cX.tmpLeafletResizeEv) {
				this._cX.tmpLeafletResizeEv.target.style.cursor = "";
				delete this._cX.tmpLeafletResizeEv
			}
		});
		map.on("moveend", function(e) {
			this._cX.drawLeaflet()
		})
	};
	this.addLeafletMap = function() {
		var config = this.leafletConfig;
		config.preferCanvas = true;
		config.zoomControl = false;
		config.attributionControl = false;
		var map = L.map(this.leafletId, config);
		map._cX = this;
		map._container._cX = this.target;
		return map
	};
	this.initializeLeaflet = function() {
		this.meta.leaflet = {};
		L.TopoJSON = L.GeoJSON.extend({
			addData: function(jsonData) {
				if (jsonData.type === "Topology") {
					for (key in jsonData.objects) {
						geojson = topojson.feature(jsonData, jsonData.objects[key]);
						L.GeoJSON.prototype.addData.call(this, geojson)
					}
				} else {
					L.GeoJSON.prototype.addData.call(this, jsonData)
				}
			}
		});
		this.meta.leaflet.map = this.addLeafletMap();
		this.addLeafletMapEvents(this.meta.leaflet.map);
		this.addLeafletLayer(this.meta.leaflet.map);
		var topoLayer = new L.TopoJSON();
		this.meta.leaflet.layers = topoLayer;
		this.setLeafletState();
		for (l in this.topoJSON) {
			var topo = eval(l);
			topoLayer.addData(topo);
			topoLayer.addTo(this.meta.leaflet.map)
		}
		this.addLeafletData();
		this.drawLeaflet();
		this.meta.leaflet.ctx = this.$(this.leafletId).childNodes[0].childNodes[2].childNodes[0].getContext("2d");
		this.meta.leaflet.ctx.canvas.parentNode.appendChild(this.meta.canvas.ctx2.canvas);
		if (this.deferedAfterRender) {
			var m = this.meta.leaflet.map;
			for (var i = 0; i < this.deferedAfterRender.length; i++) {
				var th = this;
				var ar = this.deferedAfterRender[i];
				var fn = ar.shift();
				var pr = ar.length > 0 ? ar.shift() : [];
				var cn = ar.length > 0 ? ar.shift() : {};
				this.flashInfoSpan(20, 20, fn);
				for (var c in cn) {
					this[c] = cn[c]
				}
				if (fn == "setViewLeaflet") {
					setTimeout(function() {
						th[fn].apply(th, pr)
					}, 100)
				} else {
					this[fn].apply(this, pr)
				}
			}
			delete(this.deferedAfterRender)
		}
	}
};
CanvasXpress.images = {
	"081": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAFQSURBVHjapFNLasMwEB0X400JhULagwS8ViABL7L1GXIEn6FX6BW8zcILg7s29CCtSRdx2lof251xJMVKSUip4KE38puZJ1ny+r6H/ww/TdM+jmPvGvH6+ZWmAsH00ovfdd1RkT5dLDCbJVCWJQvDcIiJ+0qpq+22bWth4hsTwHr5K2EJeYHoNQpqdgpfSnm2IwpYFEUDz7KMkdaABs0Xt0AC832c7BQYOSggz+3pwmIxF0IAgYbhUh7XiNsComlYsFod+GbDApw559A0zbBGnLRCHB0QtwW+93sI6trhlMQbbgscHMiRg9EZfO52cLfdOpwrdMBdB2fP4AuToKocLm6F3YLpTg1NzvAbzT0g26AdGC4D1y4lkN64Jm63IKiTPgPD1VRZsUk+vYlekiTjx/H314iYIyaIe8QU8Yh40PFE68jaB+Id8YaodFz/CDAAbztQlsKQhv4AAAAASUVORK5CYII=",
	"083": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAFqSURBVHjapFM7TsQwEHVQ2i2MBFQ0ewWfAMlpqLYJRyBHwA0SosoVdq+QZiuaRILQp8kB6AGJFFvmM8z4t0lYtgBLo4wnb+a9GdsBALD/rDDLMojjOGBJdBghJbCiIO9qFn+meDgMw1GGSin9FXePD4fiYdd1x/JBSBlo7/Z+8kNUr6ZA3/fauYk5NE1Drk7ICwaRNL5e2bRFbvFh27Y6UJal/q4un9i6UpCIFJMVi5c5VFXlC7u1ra+nLWCiBrxxZZlNj5vNxjDKbNLaihn8iVOw5gUQs2XSZ7tsUsDEgIx8lzxW41twU8XjcXIB1Xig9WHeildA03YTt2xeyZh5pGQ6g0iaAAFGzAHnZtoY97ERwV4BTdsl58WegU6nruv5/QiEEFQE/D1w0xYiZYkgJbpvfzrz5fC+Baz4A4iKfr2iDk9v4UUpBfyvr9G+sgXaKdoZ2gXaud0vLG6H9oX2gfaO9mn3u28BBgCmP7IZ0Bm6VQAAAABJRU5ErkJggg==",
	"084": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIbSURBVHjapFM7b9pQFD64rikggZogZHfgB7DZrEQCiWxeK6LMpv0LXYKqTK06dStkrFQhZWWLUjwwFLUWykAkJAibMZRHQQaMefVcC98ihS7tkc59nHu/c7/zuJ7tdgv/IywZXhe0fVsM9QxVzmtvJJzJCzXUEmoR9Z7ezN8A467j8TiZsizL3kYikQtci5BOg21ZsJUkcS0IF/Z6fYv7rGunDFarFVSr1azf7y9Eo1EIhUKg67pzYW6awB0dwRPU7fExb93dFeZFQgSuOBwcBrZtxzabzSXP8+Dz+cjeUeh0YDqZODNRFvP1VBBgPp9foj1GGViWdYZgnuM4cgg7G4JaMCMOWi0atpeAOI7/NRiQPOUcB4uFJT/zemE2ndKLaHNeJSE4DPbEjyF3TFOmDixrIXoYBqazGb2ENmcmydI07VAFxf0QKHUi3W6X2NRddTyH0K5TdpfE2mg0EgOBgAM2DEP9lvyZOoXnZTxOHuygl+naDYDklrE0HA7FCSYMy6f+yL9KnXw+KcuyfBBcr9eh3W6XKAPSYf1+X8FSNpBySvoklTOZTHI8Hj8CDwYDaDQaxnK5LO47uEfwuah8V7+qH8qKoiSbzeYjMIaJFW2BaZo5t6U99DNdv4cX9Y9JhmG+YEsI4XAYgsGgc0RCQ4bQ6/UMDDeXSCSuKpUK6G/1Pw7cD3X9cEo/k1uqv32m4bvhHoN/lN8CDADC1RzhZ9STGgAAAABJRU5ErkJggg==",
	CRAN: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACkklEQVR42qWSX0hTURzHv+fezW1uRndLy5bpnNMKSdTMVCzRQsFCiIKSCIKeorcIMugpCuqh5x6CfAgKUh+EeinqpdA00KFOlw/O+WfzT5vt6u52d3dP9x5JXGQE/eDC+f3uOZ/z/f7Oj+A/g/xeUBSFxmIixI0NKCmF1SwWMxwOB0xZRrIjQD+4EFpCKBRGMpnUc6iqqq1ltk4raTid+SgvPwyb1UoyAIlEgk5M+SFJCahpFalUiv2xWrLB8zzLRXEdK8ur4A08WppPIi8vl2wBvGMTNCaKoCoFxxG4XUUQ7HYoGizDnixjZHQcs4EALlzsYEpIJBKlk9+mmUSO43CsqgJms5nc7fbS3uEoKKXsMKWqZimN9uq9aDogIl8woa6uhpDZuXkaDM4zmWWeEt0nU6UDeoYi0ATBZuYhab2Q5DQD3mxzosy8iLPtrYTMBII0MBtkjaqurIDdLjBAV/co7R2KorwgG31dtWQ1lqQ1tz4yFdfPuFCZM7cJCC8t07FxH9Ka32JXIUo97i1Az5fvEKwcLjc6EVyJo29ggdm5fa4AlbkSGhpqCdv86fMgjUTXQLS0of447IJA7jwfoa8HV5hk/dNvNvIEnacKUGYJo6O1frOJOiAel+jA4DCiGkR/e7fbhe6BON54Y3DkGHGidDf6h0Kw23icP2pC5+lDcBfmk4xBSsop6vNNYmpqGrLWsJe+bPgjJuy3Kbh0ZAMvRgkW4yYc3GPBhwct2lTymYDtExkKL+FhXwBvvWsoyTPi8RUP5n5wuPH0K7Pz6FoVrjYX/xnwK+6/8tFn72ZQUbQL/fca2b6mrvfUP7+GfYIFw0/aYDDwZEfAuiRT/d0N2nAJOSayvaaHYM36O+Bf4ycC1zggzvjnSQAAAABJRU5ErkJggg==",
	RepRsrch: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACUUlEQVR42oWSX0hTURzHv+dex5x3ilu6/qzlVlYIg1FS9JAlSSKE9FJBEmQUgZFP0UMPvdRDhG+C0EPYa5BGjLJgiUnetmaQo1zaS66y2Vbbcrq73d3d072HMMc2/MGFc84Pvufz+9xDoJWiKHQx+hPR6BJyuZy+h6qq2lpm64JSgN2+FW53C8yCQLCuSDabpbNz85CkLNSCinw+r50CgqkGPM+zfTq9gnjsF/gqHh3HjsBma1wLIaEPs3Q5nQZVKTiOYJfLCYvVCkULW1+KLOP9zEdEFhbQ29vzP0AMBKmOyHEcxj5XY3Q6CUopa1KqaqMUcKJ1M26dcbGz5y98RRTktRigOube3c0Y8sUwEkxAA4G5moekOZDkAgu82mXHxY6mNYpTp08yH2Ricorqolr3eTDgjWA0mITbUYPhvhYonBEHrk0wikvHXejv2l5K4Bt/RQvavDtdTXggpjHy9jcsAoezbXZ8jWfw2L/I0K93O3Cu3VnigUxpIySSKRBCIMZseBSIM2T902828AS8oaasl8HLHkIyGYn6A9NIaiGTS414FlrGploDDu2phzcYhdXMYzVvrOiFYeTkPA2HP2FYXMXTmT/YZlb+/boMfmSMMJnqKnopelV9gyIdC6XQbDNg/E4nefImQq/cewdBqK/opSjg9sMwve/7Ao+zDt6bbazXfuMl/ZZQS7z0HHXAJtDigBVJpvp8VdqjstQaWa9/yE/Leek+aMf5ww3FAeVKDyjnZUeDCeJAJ9kwoJIXfZy7F/ZvTFDJy/z3FLZYTPgLN2NmirAwbrAAAAAASUVORK5CYII=",
	X: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAArElEQVR42qWTAQ6AIAhF4R52jzqIp+wgdI86SLqB+xG4tdiYjeT5QWT6ady8NF90jeyC7+LipwE29RIki662r9vZ/PCAGkB64q4JXeUK0AGgCQQVmAnGGH7MICZZPBABBqkA8aXsCqAMQKCiBqUY4PoKSFVEJdiVrvSeDwFI2sQtiGEpDxWcJOPw+Ft5qPCDVOAU0RKmDeXg9DGm0NRoQgUBS7DBANlDG4/pl92yoEi5GT/1LgAAAABJRU5ErkJggg==",
	accept: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAiVJREFUeNpi/P//PwMlgIlUDS2ro4SAmJksAxqXh+WwMLK+/ff37x8g2wkkxkisF2oWBeZzsfNM8DKNZvj47S3D3gvrGf79++sJd0HZbG82XJqBcvksDGwT3I3CGN5/vs3AyvSLwUk3gOHv77/bwQYUTHGtA3J+gmggRjEIyM9nYWSb4GEazvDi/TWG919eA+n7DA9fXmH48eMnA/Mrnr0VwrziLSGOqQx/fv9yfPryvv7WY/M/eFsl3cnqsc1nZ+Gc4GMVzfD8/WWGL9/fM/z+84vh+evnDJdvXQaq/23LmNpq8T/MPZXh8ZsLDNIiWgzfv/9h2HVsDcOPX98qebj42v0d4xievLnI8P3XZ7CL3r5/z3Dv4SMGYNjZzq05dYRZw1Lw572nV13YuZgZXn98xMAEjCBzHXeGT18+utibeDHcfXESGGhvGH4BbX7x+jXDnbsPGH4DbV7YcO4IPBZCStS7eHi4ShWUpRiYmJgYONh4GNRlzBnuPDvD8PXHR7DNH95/Znj88AXY5jU9N4/AwggejX458l3cPJylssriYEOQwcf3XxiePXwN1rxpysMjyHIo6cAjVbKLi5ezVFpJhIGRiREs9vn9V4YXD9+BNe+Y/fwIehRjJCSnOOFeLl6OIillIYYvH38wvHzwHqx536K3R7ClEawp0TaSr5edi63o1/ffIM0Oh5d/OogziYIMwIYtQzgNgJgZlzwMM1KanQECDABGPi0ENq7EYAAAAABJRU5ErkJggg==",
	add: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAc5JREFUeJyNU8FqE1EUPffNdOxIrGJ04wR3FSwoQmPduBFEyC4FNxW/wLWrLhSF7l35C1kmu27ciC40xGIVgyiixKlkYalmknQmk3uvixj7mgmpZ/V499x7znmPS6oKGxc/3L7s0dwjR03RgSmwMBIZhImkjUQGD78vb76z+WQPuNK8U3XIlFtJG3scgcEAAAcGOfjI6wJSGdZaK5urhwbcD5/MP4+2Pv8c/ip8G/zALOT5BHz2wqB3evHVzUpsAOBZp175n2YA2HUidGm/8GW+XQEAKjbvXhVofav/MUPW5cbI5ptipnaml4OIrJhYBhutpD1b9nUnc9X1YqTEG8anY0t7HB1pfRKJy6BUl1xVDcavbdu2ofc+/TuP4ygphCUwLJxpmAkrDqvAHQrvODABQw4U/pLGyvT0QmYOKcDCO25X+s0c/OA3egfVawtZ5Yk7igF2pWnmxFnP65SGI2AihqS8TqqK8/VStY+4vOtM+Y1xZsuB6Qg05pqUtlcNACwm59Z89sJT6fHp1ieb+xzq1/01YGKZzr68UYVouevFSFyG0qhGOspsIgZDalLaPrxMNk6+uH4JrI+VtahDKbAKGBwySUNIH8itt+9t/h/sYf0JXvR+8AAAAABJRU5ErkJggg==",
	add1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAO1JREFUeNpi/P//PwM6aFkdNQ1IZaIJT68JXZaFrpaFAQv4+/dvZppbDYrYrF0tIAOJNODPH4ZbT/djiGEDWA348/sPw68/vzDEiDbg9+/fDD9//8QQw2pAwRQXbAHG8PPXd1QDfv1iAKpFD/HpLL9+/srMD2/FMPnMrQ0o/MyAegw1E1dWZ7KATD58ZRkDIYBNDUgvyAUM339+ZyAHgPRCDfhGvgFAZ0w/dfICRiDqGqqh8C+fv4XNjOmM2JKyX47Cf20jZRSxq+fuMmya8oCRuHQADBxs0UibhESTpAzMONNvnHyAkZ2xqQUIMACEko/8sPYHvQAAAABJRU5ErkJggg==",
	add2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABpUlEQVR42pXSXUvCUBwG8Gebg6KICnoRosKLogzpI+gn6MbLbqSom16IPkkXXQsVhTeZBEEWaJ8gBNGIoDJJigpisKQ513PcSlMv5uCMc447v/3/j5PQ7hq6TvEeBGRA4UwSN6RRmgs1Pyq1BzJWZDvwbyu6kwdKs5I7wJu1Ipt+pM4NvL7LUEYUaNlbAtOdAQd7BowK2xhgC6V7oOBzC+QIzCB2aEAvExgmUHjkmGwD1AKTg/AozhYPcB7ZmEJs34Re4f4gtwvFhlOKHa6JIwEwsHmgChgWoIofOIwKkDgGtG+eHwcWQq2FRndfRAVMfCuA5AUDK5pQuxW7Ckr6F6cqh4dIn42qXfba4NBybwRGM9biegCxmAmj7NB/7dSB2vhdi0tAxQ8CTHxxzY/EJUW96ZDmrAcagMbr4bMG2CGKxlXVLp/z8OoY4ifMSXaAu08HketBkmj/N44/WeFlAqcNAN+Gm36X34EAWEHijGGJJ3oFwH5u+lwCE89WeMWLRNIBujoFfASWvIhfsYWqE+AjE873uK4gBc9vsHaokNQ0gZbP6QeTtZD71G8wMAAAAABJRU5ErkJggg==",
	alignBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPklEQVR42mNkgIL/YIQKGMEIP2AcNYCwAYZ+/zHEz29iZBw1YFAaQC6AGfCfXL1g4sCBAyQb4ODggDCAEgAA84c5EQvEkCoAAAAASUVORK5CYII=",
	alignLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPUlEQVR42mNkoBAwgogDBw78d3BwgPMpMuA/A8P/UQMoNIAUzVgNMPT7j9MF5zcxMo4aQIQBZMUCJYBiAwBfDlIHHhC2qgAAAABJRU5ErkJggg==",
	alignRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQUlEQVR42mNkoBAwkqnv/4EDBxgcHBwYGf8DOSTayDhqAJoBpGhGAvgNMPT7j9NV5zcxEnbBqAFEAYoNgAOKDQAAbldSEYIq7KMAAAAASUVORK5CYII=",
	alignTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAwgogDBw78J1Wjg4MDI9wAICDZAJheRjI0YpoCdcJ/LJKMhn7/McTPb2JkHDVgSBnAQACMGsDAAACueDkR2b7HeAAAAABJRU5ErkJggg==",
	alt: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkklEQVR42u3XywqAIBAF0BGhb6r/X/RNLqRGIRBRxx6jBFewB9rckwtBQ0QLd0dz2mb4coQn7/3QZGttvEfA6PAUAQAAAABwC3DtXqX5+Vhr7mtAqbA6IA2XANLcx4DW36muQE/xIYBSqwV+BqgVkgLVAfmYCkAq0gL0fv+vnRAAAAAAQA0QXmYeTlfu+5Ql4PwTMtDaO1Md92oAAAAASUVORK5CYII=",
	alt24: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAgUlEQVR42u3VYQqAIAwFYN9p7Uh52mSRMadJ5RMi3B9hxvsmJMIdFcK6OWJ5v0BWjAjXCHR4UntLZ54AK9wiE6AB8g0avWL/CaB/YYwCUAnR/WIAJtB1gtoNBxu4M/UrIE2Pix4FaJ3KAtkwn7toE/gDwESyJ9M2mLU/+jWVFS5rBAIetM0iFaunAAAAAElFTkSuQmCC",
	altToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMUlEQVR42u3XvY5EUBQH8P8dvIpCLVFSKTWj0KgkSokHUE0tEqVkqmkUo9DqlBJP4FV83LWS3VhrdpLNXKZwGk7ujfNzEfcQOkbXdYjjGNfrFU3T4DNnETzPQxRFOI4Dz/OmnLRtSw3DQFmWcF0XiqJAEAQmgLEWqqpCkiTQNA15noOEYUiDIJgAsiwzKbyMuq6hqioulwuIJElU13VEUbRJ8a/wfR9FUYCMz4HebjdYlrUpIE1T2LYNMp7T+/2O8/m8KSDLMpimeQAOwJsDhmH4kXMcNx37vv81dzk2z0+n02sBawjmgHnxZ4Dl3PF/9xrA2t1tsgJ/XXxTwFo8Qr0M8OjNf7YqzAHLIkwAhJCHxZ8B5uP//gpYxgE4AAfgG7D7tnz3xmT31mz35nTv9vwD6gGSTuZUDwAAAAAASUVORK5CYII=",
	altZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAjElEQVR42u3XSwrAIAwEUD2g4FEDHrCtgiCiif3EUJgsWsSQee1C0LuriOhwBhVj9L6GhxC2hqeUyrsAdoe3CAAAAACAJUA9tUZ9/R7X+xowGqwOaMMlgNT7GMB9neofWBm+BTCqWeBngNkgKVAd0O+pAKQhHOAO4j8nIQAAAACAOiAvzC6n+WF5PT8BN7Ad8soKt7UAAAAASUVORK5CYII=",
	altZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMUlEQVR42u3XsYqDQBAG4H9FX8XCWrCMVUohaJHGSrAU8gBW1iJYCqnSWCiS1s5S8Al8FcU9I9yR8/SEkNUUTqPDLjvfrgoOoX20bYswDHG9XlHXNR45i+B5HqIowrIsOI4z5KRpGqppGoqigG3bUBQFgiAwAfS1UJYloiiCqqq43+8gvu9T13UHgCzLTAqPo6oqHA4HeJ4HIkkSPR6PCIJgleLfcblckOc5SP8c6O12w/l8XhUQxzFM0wTp72mSJNB1fVVAmqYwDGMH7IAPB3Rd9yvPsmy4nk6nP3PHY885x3HvBUwhmAOeiy8BxnOn1n4JMLW7VU7gv8VXBUzFHOptgLk3f+lUmAPGRZgAHpPmii8Bnsdf/gpYxg7YATvgB7D5b/nmjcnmrdnmzenW7fkXNr6STvELKhkAAAAASUVORK5CYII=",
	amp: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42sVTyw4AIAiK///ounWRh6u1vKlBwCbGZeEVwex+BAOG6P8QHFmI/jsEEPO9gwBDeC8zt2RKSh6WnSgqlhNBVILwkIVnQ2QAl8m7Y2rXAn5zGhEIQ04gAAAAAElFTkSuQmCC",
	application1Toolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFHElEQVR42sVXW0hjVxTdeaoxadREcaKxiQl+1DrVFgZR/BIVFHwMaCf+aaWTD1G0IAhOpAPjGJBxpDgoaCJCoR+KxV8RtGCUKrQMtor1wVg6tnVifESjedl9bnLTmNwbM+m03RBy7zn33LPOWuucvS/nGgP+x+AQAJOTk9DR0QE2m41qJJg4HA7Q2Mg1UwT3s12HPkd+crkcRkZGoK6uzgdAJpPB8fExcLlciIuL+1dXfHV1BR6PB9RqNezs7PgAEFR8Ph8WFhYgLy+PAhJJGZohRkqDVi2RSODs7OzGOIvFAlVVVSASiai+AADScH5+/s5XXFBQAHt7e9Si6Dg9PYWEhARmAHK5bMDrvZaMjo7m1dfXF93GApP2wUwIhULY39+HxMTEQH9KSgo7AIGAv45yXJlMJolO15hDTxZKb/C1xbL0w+rq6r7X6xViu6u0tPSDu3c/0pL+kpISWF9fvyEZIwPEAy6Xi/xvIogLBCB+8ECXEw3Njx9/+d3AwIDd5XKn8fk86/PnQ5ktLS25bM/zeDx2D2DnhkAgcJjNJjHNQKQgDPT2Gn5++rRf6na7M1Dr34eHh716vV4RkweQgQ38OQgDjY3RAniEAIwBAC9eDHsfPvQBeGsPIIUUAyaTWXz//n2VXv/5FyiN1D/wemjoqyehIEIBBDMQiweQAR4FoLa2NluhSP/Wbr+4RwYqlcqN3d3dinAA7BJE7QGiETmh/mbAJK6urtGkpaVaLi4cJYRtpTLzx1ev9gtCX2gwPPqpv9+Y9I88EMyAUChwjI8TANWa1FS5xeG4DACYnZ2NMxr7v/Z6PYkAXHdxcbH68PDwEwTAyACTB5KTk2/bBXxKgpoawkAaMnBBAVAoFC8nJswpdXW1v1xeXmk5HO6lTqezojQyo9EoQQbvhJowag8E7wIfgHAJMjIyXo6Njd1BZmzIVg4OO8Ot+qtKpRKwAWAKwnYkAJv4uzCbzX4JUlGC2AGweSA+Ph7sdjuzBMQD5ChGBrKRgaVgBsbHxxQI4MjpJAA4CEAXDCCdx+P+QTyAADJi8kDwLqipqVWrVFkmNOHHfg/s4cvvNTQ0rCED7+O4c0xYrqysLNHg4OApAkhFANZnzwYzm5s/+5DNAycnJ5FN6GdA3NDwqXZ19fs9TDIi/2qcGo1Wvrm5eYjDSOXiweqGj0UM//Xr3xzYxsd3udXq7PfS09OlMXsA73nd3d3esrIy2W1HMdsJjQs5KSoq0saSC7aQyiyU4k8cRJczKN6NCojcXJMSD6h0QLSlOL6mmjkcb0JC/JLNdqKPOheQBtzv+KDoG0yrSn99QV6Ir+ZyyDz+uf1IfPekNPCDCTzB5XI8YnHi3Js3R0+iPgdoAP9FsHpgZWUFtFotdSSzFZ5MpTrdRvY2rbXT6aS2IN1H36+trVE7g3EXHB0dQWFhYZhpogmSyPLz82Fubg7a2tpgamoKmpuboa+vD1pbW2F6ehqampowc/aCVCplZgCTCiQlJYWZhi442UpxEgcHB4CJCba3tykWCZDKykrY2toCPKhgfn4eKioqqH4yRxgAMiFhAAvKMNOEUh0qAd1HAJCVGgwGmJiYoJjo6uqCnp6ewH17ezvFQJgExBiLi4uQm5sLePDcmCjSpxYdZAwpNEIjdMzy8nL4hwmmXLBarUAXJqErDS3Dg9vYvgvYxhOvkNBoNJQ8FICZmRno7OykQET6JGNy/m3BJBUe04A5BcrLy30A3sru7zj+AsE9Cd3tl5Z+AAAAAElFTkSuQmCC",
	applicationToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEdUlEQVR42sWXy28bRRzHf2s7fqyfa0dWRITAdqmp0igSEqeGEEQThMKhOXLgVhAIqVLybyAQEoqUG1KQEPEBU6CC9hSrig3i0qoSTWNM2sAhTpzYjh0/6sfynX3YW2ftOA6BkSzvzO7MfOb7e8wMJ6LQ/1g4BrCyskILCwuUzWalRsbEcRypbOxZr2jfd3vu/I79hoeHaXl5mebn52UAn89HuVyODAYDWSyWc11xtVqlRqNBgUCAUqmUDMCoTCYTra2t0fj4uATSyzKqQrqSdqy6s188Hqe5uTnieZ4KhUIbgDWk02m6dCn8QS53+JbfP7yaSm1F/m0FisUieTwestls+gA+n/fXWq3+stcrfJ3J7H/0nwMIgudeo9EM4j+yv39wfZBJwuGX3qlUKs83m00zq1utlu1k8s9oTwDmAywKBEG4DycJAGAVAO8PAoC+X2HwqWZT5Fmd523rxeLRNRXA7XZ39wHQ3QN58CwAHo/7+8PDwlUMLQEgsmJQ5PU+TSDABPUgPlo9OMgOCOACQLEFABPEyuVTATTOqMAAAG0fkJ0QUbCKKJAAJiYuv1oul0fxyIJchKR7Dx78vt4vQKcJdH2AJZ98Pq9rAuSEL3K5/IwMwIlwqt9Qf69fHxhQAU8kk5HD0OVyRguF4rwyPgD4u0dHR1M9FLgJBWZOpcCzeaCh5IHsdWVF0Xz+UANgA0CpK4Db7boJ4JmBnZCFIXwgsreXkQCcTkcUcdwCsNv5u6hPhcMX3mC+gf4GmKZuNpszyWTqjsvl+gETvdlWwAwFqv0BsDzAFMCqI9lsTlcBTLSOXW2ym284HPY7pVJ5sq2AFQqUnwFAm/TcNQyZAogCXR+w2axxTHAFE92CKd5GGxSgKtoTaJ+GQrch+WvdTHCCDwiKAiwK5DwAm0bh1S0ADLiOASdhmlswRQsAq0pgpdMAuw2QgQGUvUBAIpLzgNPphA8UNQDWOCbqqsBxE5zCCTV7QWs31FEAAJUr3RXgAVAZDEBvOwZARAuAzvCB0jQAvlMBMEYFCvwCRWYcDsePeN8yAdpjUORqTwDWsLu7q7sXhEKBDzHgKySduDhxaGgo+eTJX58Egy9+jPAaB5MR72qIjj8eP97+LBh84Ua1+vQilLQoCmxsbW1/2hcAQg4mEM+0GfUqfSWier1+gSUT7A3vngfAiWEIgMsmk/FvONUjvCuRctyXh5BOvWo/qYLDrqgc+dnJVzk0K6/wGXswGg1P4Rs/PXz46MueCni93vu1Wm0CfZr41dkgyqx653T1bK73jbbOnps8b/05nd67pgtgt9tpZ2eHRkef+xxpNoDtmVPO9tKS5LpcVVbH6iK1LkOiMhEna0Lae4PIGY3GCvzrm42NzW91TcC241gsRmNjYwTvbS/jhKuWWlgfTHJcoo4+iUTi+MXE7/cTsh6pBxPtrUYF0A6kbdO7E3YCaPuzaxkroVCINjc3ZYBoNEqLi4sSRK8rmXbF/V6qO69wrN/IyAgtLS3R7OysDNDXSOdU/gEePzbd28AGbQAAAABJRU5ErkJggg==",
	area: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAj0lEQVR42qWTURKAIAhE5WTu0b0ZaYOBhI7WTh8R8NytiVJVKYUBUBJxvWrx1DPJnAL4fqZaQfosteV2k4FwMILYgx4HM0AEWQJIemx2LOAVs0cAcpBzhPjlwUEE8JBJvDUggpAxsowQQcilGB2wJD2QAjJcx4A4eA/S1wge8NvBKeDTdtr447YB+jlBJ/UFYjRjdSgdKiMAAAAASUVORK5CYII=",
	areaLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAxklEQVR42qWT0RHEIAhEoTLtScuIPdkZJxIRyDg3l+NHg+5bIAnCiN475Zx5iwRwzQ1ABR8kaZe40AB4TyPZ1gUDWWKFqBGLecOAm1gCpATnaCIVpJydiC+ZtYay1eQAmJXGSuoq25msFhggQjskN7NHMMQMMbVwPHqndoKwGZ8dACI+QXalWPZbSGMGSEYcYXA7ksvvCiYAgjhACCGa2A+JLUSMfpgiHHA+11Xu+Ba+xRL7N2FaeBEKeCNWwD+hAPtT/fL8ASFmlYbeMRjkAAAAAElFTkSuQmCC",
	arrow: "data:image/gif;base64,R0lGODlhAwAFAIABALW1tf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTlDMzQ5NDg5RjJBMTFERjk4Q0ZCRTMyRDcwNkNBOTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTlDMzQ5NDk5RjJBMTFERjk4Q0ZCRTMyRDcwNkNBOTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OUMzNDk0NjlGMkExMURGOThDRkJFMzJENzA2Q0E5NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OUMzNDk0NzlGMkExMURGOThDRkJFMzJENzA2Q0E5NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAAEALAAAAAADAAUAQAIFRGKHuwUAOw==",
	art: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAJ0lEQVR42mNkYGD4zwABjFA2IyNU4D+SIAO6IJiNLAg3ghFNFVgBAPsNCgI9B/Z5AAAAAElFTkSuQmCC",
	ats: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42rWTSxIAEAxD5f6Hjo1F0UYxzcYveUaB9ilUApjxQwSRmT+ZOPq2nXIeAAusBdANwGDMF4ANUW10C5A1uD7/CYAMSN1CpLAG1qDW5EPyQNJf+plS6uTCIhEGHbKnAAAAAElFTkSuQmCC",
	axes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42t2PUQoAIQgF9WR5dD1ZtcJKWNjq5z6CEHvDhDDT50EAhEKwa1/bNUBkwMx9nYloexMafAKsBr7gczV4AK01W4rIHeANIsDJKGXgdwrIGBwBPzSARDaDTPmNGVTKBli/kb0HB9t8DwxAzZsAAAAASUVORK5CYII=",
	axesMinorTicks: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkAIL/QMTIwMDIQAZg/A/Wz8Bw8MABcvRDbB11wagLRl2AcAFZuhmQnA3zBqk0ACl9O8i+QcHhAAAAAElFTkSuQmCC",
	axesS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42r2SCQ7AIAgE4Wc8nZ/ZaCWhVex6pBsSL1xHkakqlSDiErgeydkENVDVJCLM1lkmMIM3gZ/vjRuD4wTI/SGCCH2LYPkNejRDgi/8euCt339iaDCzuTHwFGg7hQsReOUqRGtWnQsoHmYPNhZtQAAAAABJRU5ErkJggg==",
	axesTickType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42t1SOQ4AIAyCn/Xp+DJvN5cSJ0kTJiikZQX6AOwjqUZEijnEw4TTIw9+lMDZvhcvnBpZtnpfE9gGp3+R/ARPzvhBAkuNB4/UAIGTjIcSFbTaAAAAAElFTkSuQmCC",
	axesTickTypeDotted: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOklEQVR42mNkAIL/QMTIwMDIQAZg/A/WD9bNeODAgf8ODg4k0YyjLhh1wagLUF1Aju1QiyEA5g1SaQASDerIeRQUrwAAAABJRU5ErkJggg==",
	axesTickTypeSolid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkAIL/QMTIwMDIQAZg/A/Wz8Bw8MABcvRDbB11wagLRl2AcAFZuhmQnA3zBqk0ACl9O8i+QcHhAAAAAElFTkSuQmCC",
	axesTitles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42u3S0Q4AEAgF0Pqy+vT6srxgljYZ3tw3yz1jIBwGjwEDsCpNmIjYuGZmfAv4gk8KIKI+VNW7QHSiLcDPPlCBccPqH4SvsFOIMgHtSokiXgEKoTdoEXweOTEAAAAASUVORK5CYII=",
	axesTitlesS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZ0lEQVR42rWRWQoAIAhE82Ye3ZvZQkF7o5AE/syMT6NQS0Q0d2amYKhBnEPQgKalNFaTg9wELWAmmGlOdP8IkP0hgleoi8B9g92AKwFCNIhdv2A5GBRgMS8BPQXaTbgQQV9a3tFYvBGjXXlQ9bByeQAAAABJRU5ErkJggg==",
	axis1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42sWSYQrAIAhG62R59DpZI0H2zabZCCb9EK3Hq8wJovNKKfO6o9baJSeiRy9LUxoD8hmABngII2ww6qUU3tRaiwG0wRtA22wbYG0CRAxcwD8G+mG2DaxJtOZg+oXVplWYAHwbK3cBxwy8+x8BXOtZmhHnXVVzAAAAAElFTkSuQmCC",
	axisTitle1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR42sWSbQrAIAhA58n06HqytdwfMS0bwSQo1B6vD7hMMPPdZyKCKB/V4KloEXS8zZ8B1sBuslE26DMiapOI1ADeIAJ4m20DmxsAFYMp4B8DfzHbBtlPzP7B8AqrplWkgMjGr6eAYwaz8x8BNGQvoBHZBWFKAAAAAElFTkSuQmCC",
	background: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB6klEQVR42p2STUhUURTH/+9pTgSDizAIqxE3FRFILiL7ooWLKYv3pfDcCAq2KpQWs2mjaRAUtJkKU4ii0vC90aRBxmljPR1aRa6i1dgo8x4zEX0MM1b3eH1qozYxMn/OXdxzOT/+59wjYIOmIpOpXeW0++SzJURVwo8cwx9Ga68CD4GHYCiSpCGfXVX0deToY9P6sFNkGMgcAw1KKCTHcfDGsoY1RdE3Adqu9FDjuRM4XLMP9fc+AgUAoy+eQ23WYSeTeBuLDWuyrLuAjq4bdPb0cUSi07jefRmHbr/HVY+FVz4d0pEq3PHvdQETxgguSCoEsdx1YsVmDaHz2k061VCP/dXVqPR6cTf4EBcbz8BZTGDgay0+JVLI3FddwNPJGXh/fkbuN4PWosMcGwMH9FNbq4aKHRVwUml8SacxPfMOlR5grsyHKdsDNtjyTzvEZ+sCVi7tXb2kq5ewsJiEbdtYSMxjKZvDnuYAeodeAo9aCwNCofwQO7r76GDtAcTn48hmshgK9rl5XyCM+K3z/wGYecD6T7BfOTx50I9iKggIhyfI729a2ZfSADxBsiSXDjBMgxRZKR0wapqkytt3YGz8hdUWQrwFqXj1mkLre/A3MT7+jYh5GWNFi0VR5E7F71vN1vFTtm0LXMsyZtVTnbf4FAAAAABJRU5ErkJggg==",
	backgroundGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACNUlEQVR42o2TTWgTURDH/7ttk1QIPYiCVI30oiKC2IP4jYceYlR2s2lhcym0oKAoLRVyEcHaCEILemiVmoIoapXuprUYShIv1a3Bk+ipeEpNSxISET9ikuo+30s3Zk1T7PCGB//Z+TEzb5aDySLhmcyGerLx8OMiohLB94KO3zoxohw9HD2c4hYEDyrqikVfhvc+ULX3Nl7HaG4/SEBALUun03ilaeMet1v+B9B58RppO3EQu3dsRevIPBAQLlN52Qg3ULdOPHvil9plpJJJvI7Fxj2iKJcA3T3XyfGjBxCOzuJK7znsGnyHS1YNLxwyhD2bMOTccoF+ZptWng65BAkcX1+qRIu9UbizfTfIkUOt2NbcjCa7HbeG7+F02zGklxIY/dKCj4kMcnekLgZ4NDM3Yv/xCYVfOjwdMtTJSVCAn3R6PbA0WJDOZPE5m8Xs3Fs0WYEPdQ5EUlbogQ4vAxjeyG5C4C8BWAtdPf1Els5gcSmJVCqFxcQCivkCNrf70D/2HLjvFcuJxt1IAYNqMFgZYnfvANnZsh3xhTjyuTzGhgdcVC46fKFI/OZJVznRBLitBtUKoPwS+nIBD+/62Tv/ZAAjZFkXIBSaJk7nKbYv3jUAVS1UAahAREFkADb1fBVg9RCrAYqqELfoZoDzBsC8SDazU8DVVYAJVSWSWKqgbw2A1XAG8CnmV1hpIUhbqP0P1LJgeQ/+ClNTXwnR7bqu/zeZ53laKf+Nq9L3Ua9bdwnU/gAi5e1TilSTEwAAAABJRU5ErkJggg==",
	backgroundGradientWindow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACG0lEQVR42o3SS2gTQRgH8P9uayNCKCIKUjXSi4oIYg/iM3io2PpgXy1uUQoG1INKi9Ae9GJtBUsPHuqDGkEUtYK7aX2EkkYw1W2DJ9GTeEpNQ3ZJRHyEpOqOk8RN1pol/pm9fDPzY2a+ZWDLZGgitaSWLNtxfx5hkeBbzsQvk/yZZehg6GAUgeMklKvFhJ+HNt1RtbeLWRMjmS0gfg6VYhgGXmraqCQI8l9A5+kLpHnPNmxYuwpN197jxZGl/2xOGQmIbTL0ZBKvotFRieflAuDruki8u7YiFJ7C+e4TWD/0BmdcGp55ZHAbl2No38oC8FR9iP2cCIatLZxEi84ozPGzl8jO7U1Y3dCAercbV67exMHm3TAScYx8bsSHeAqZ6+LRPHBvYvqu+/tH5H6akNplqGNjoMAA6eyQULeoDkYqjU/pNKamX6PeBbyr8WBSd8H0t5+yrkEIhiORCLxebxHIF4919RFZPIS5RBK6rmMuPov5bA4r2nrRd+sxcLvjnA0YKAGBQPkRfd39ZF3jGsRmY8hmsvAP9+e7NujpDfbELrcO2oCeMqCWAasT5o8cfIf3FhZQ4MbCTlDgpCMQDD4hLS0HYC2gwIMKgOwI0ALhOd4OBCsArY6AoipE4IUS4BRH4JGqEpEvnqBa8oBi70LxCgF6Ba7qZisB6z8oFcbHvxBiuk3TrLqZZVn6RuxXZkF9M/1q/vsINL8BAdv7UxBD7DUAAAAASUVORK5CYII=",
	backgroundType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhATCQm6uGoAAAH1SURBVDjLlZJNSNNhHMc/z7O/W6VSEKxRWJKQXYLoULQYFREoXSylgqAOlodqEu0QFRVRejLQIK3ADhkb2dzfRZBsdvEQdKhDQfcMmmNCaaL/vfT/dXCTvWDaB348b3x/r4+iiHhsbHqdIRsPBDOMtwpzaZs/tuRfFSiFUmrkREtLG+WMv4vtOnvpjnT4bwntpixHMpmUcCQSqnBwzn9XXkRi8vHTV+G8KSABkM68BUBuhIeDIiIylUhI2DRDABqg/co9OXJoP2PxCaprakEbdPqv9zT0fO4LvE30AQuA5XJoxM6xyePB5/WejkRHw7oj0C0HfXup27KZq5cv0N37hFfNLhp37qAm/ZOB1+/JO1iYra7jzegI4eEQbrcbsaXVAKGhvh5nlZNEMsXRwz5iEx9Y7wKPw+BL1gVgAZxp8l4E+gHk5GLp+umDm2pw6CW/ZmZIpab5kZhibRXMzafZ13QcO5crZGAVxEuIYAA8672tlNLSuH0rk98nseYtBh/dP8ZDMtuubYh/gwxgVnQeQZVPws6mGXrc1ZaPmil8kQqpQMSMLE6hwKnmPTwf6AJwFlmcf2AUH6x0trBdk19NVkCXpiXFDoKsAr1MS/pXIxZUaQlaqaUGrSq6UqVTMKPRWRG71rbtlcVao5T+rcrudwMO/oO/yMzfb0o4U5cAAAAASUVORK5CYII=",
	backgroundWindow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42p2STUhUURTH/+9pTgSDiygQLcVNhQShC7G0aOFi+uJ9KTw3QkKuCqVFLdpkKi4M2iihSVBgFr43mjTUOG6sZ0OrqFW0SRtl3mNGRFNmLO/p9hxnVCa1/py7uOee8+N8XAGbNB58HTuQSwfPDK4ipBJ+JBnWGKVeBW4CN8FQJElDxruu0ETw5BPT+rRfZOhbKQc9kpBNjuPgrWUNaYqibwE0Xr9LteercKKkCBW9X4AsgOEXz6DW6bCjUbwLh4c0WdZdQFPLPTpXU4lgaBJ3WptxvPsjbngsvCrWIZUdwn1fgQsYM57joqRCEHPdSqzwe0O4drOTqk9X4EhhIfK9Xjzo6cfl2rNw5iLoWyjF10gMy72qCxh8MwXv8nckfzFo9TrMkRFwQAc1NmjI25cHJxbHfDyOyakPyPcAn3OKMW57sNZfn25DSDVNfLYu4M/laksb6eoVzM5FYds2ZiMzWE0kcbjuFtoGXoIeN2QH+P2ZITa1ttOx0qOYnplGYiWBgZ52N6jkdgDfui78BWBmABubYD+TePqwIx20XTsCAoEx8vkubQn6JwB3kCzJ/w8wTIMUWUkH7aSsgGHTJFWW9wwwNm9hvQU/b0HaPTsl/8Y/SDtGRxeJmJcxtmuyKIq8UnFpe7Gn+MnZcwlcvwHnft5TWRqJHAAAAABJRU5ErkJggg==",
	backgroundWindowGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJklEQVR42o2STUgUYRjH/zOaG8HiIQrCUvFSUUHkIcpKOnhY+2C+lMaLkFBeDCWooC6ZGxEFXZTFD4IC3cKZ0aSl1u2QNbZ0iuoSXXRbZXfZjaiUXct5e2ccZ7fdhfXPOwzzPP/nx/O8zzDI0XTwRXJLOdnaMLqCkEjwO2Ng1SB2lqGHoYdRBI6TkI2uKfQqeOCRqn/czBoYXD4EMsyhmBKJBN7oul8SBPk/QHvXTdJ08gj21u5E/cAXYJhrzC8efzr2WmyREY/F8DYc9ks8L1uAju5bpPH4YQRDM7jRcxF77n3AJZeO5zUyuH3bcN+z45zpm1Ke+E9xIhi23OpED79TmAuXb5NjR+uxq6oKlW43HvQP4UzTCSQWoxj8UYev0SSWBkSrg9GXs3AvfUPmrwGpVYY6MQEK8JL2NgkVmyqQSKbwPZXCzOx7VLqAT2U1mI67sDrU6oxB7/G6+SYEXgtgfpzv7iWyeBYLizHE43EsRCNYSWewveUqekeegTxsywXctQFXVE3LXmJHTx/ZXVeN+cg80stpjPT3+aips/ZaAHN3mnMBPhvQqWpqFrC+CeNPBo993jHbJOdvggKcXAEgEJgiHs9p0xSwTc1FAE6uAEADhOd406TbpoYiACdXAFBUhQi8YJo+o4QoYH8BYFxVichbHUQ2AKhWcrewNoJGR+BK1TrS1v8DJzA5+ZMQw20YRslilmVpp+wvJi9+kD5lG26B6h9UzuxTTr7dBQAAAABJRU5ErkJggg==",
	bar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42t2TUQ6AIAxD2cnWo28nE3GaLAuCTL/sFyPlpSVAZZeIbACoJEQjQNv3c89Dl+kOAPC51j5gluBTQFQ7s1Th8DFsVjGATxAvzcCLAIYZVOQZwFdIAV4n+FGFklTqBw4B8WXO5gr2qr5QBHQHPQAAAABJRU5ErkJggg==",
	barLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAApklEQVR42qWT2xXEIAhEsTKpKakj1oSVsSK6yxLzMnyJwHWGkwQoQUSMiAEmIpwByv1m89Kz7gAy3IpDAGJs5zwGOAXc72YBYCEe4Ows0ndkgZu9HQAjCn4ptSSK/hTYpckL2uQA8jJDokwwBETE2piJmkxOZgd1uOYdYC14wM+rQIIqilq/pUABYkGHvzt4DnBLfGbhAvBaQQfAZEz9gacA/2Ve5R+6ndBQHhOxdwAAAABJRU5ErkJggg==",
	bg: "data:image/gif;base64,R0lGODlhoAMBAJEAAP///+Dg4N/f3wAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6REE3NkYwMTc5RjNBMTFERjkwOTFBMkJCNENGN0UxQkIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6REE3NkYwMTg5RjNBMTFERjkwOTFBMkJCNENGN0UxQkIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpEQTc2RjAxNTlGM0ExMURGOTA5MUEyQkI0Q0Y3RTFCQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpEQTc2RjAxNjlGM0ExMURGOTA5MUEyQkI0Q0Y3RTFCQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAAAAAAALAAAAACgAwEAQAIlhI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuIcRCQM+1bNN0AQA7",
	biggerFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABu0lEQVR42qWSv6uBYRTHv28WJT83sRmkDAaDQRkZZRAbmzKzkIFJyWSwIYWBDMTAH6BMEiULJSElYZA4932fGze3e7tv3aennjo/Ps8533M4/PNwYgP3+z3N53OoVCqYTCbuVwCx+3IyfyaToXQ6jcfjgdPpBIfDgXw+D4PBwP1YwRMiAIrFIgUCAcRiMfh8PsxmM/j9fjidTrTbbe7HCoTE5zsYDGi9XsPj8bxivV4v9Xo9HA6Hd8Az6TuUB1ChUMB2u4VMJkO9XsftdsNisfgC/JZcqVQoGAzCaDSyshUKBcrlMq7XK5bLJffnFPR6PWm1WgyHw1csrwFrgZ/MO2C1WhGf8GZTq9Vks9nQ7XaZvdPpkCCiTqfDdDr9BEwmE4pEIrjf76y3bDYLi8XCfIlEgpLJJMxmMyQSCc7nMxvnbrfD5XL5BFSrVeJ/Bw/hwuEwbTYbNBqNVyW1Wo36/T7kcjlCoZAgHlqtFnK53FcLwrLwY8FoNIJUKhWUFrWlLMjtdpNSqUSpVOLi8TjxLaHZbIoH2O12slqtcLlciEajTKCnaKIA4/GYUqkUNBoNE+t4PAqrKx7wn/MBCr7QEfUMm00AAAAASUVORK5CYII=",
	binData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42q2QQQ6AMAgEd19mn44vw6bxoGgpiKTJhpaZpBC9tB8CxFmZntcLmxZ4e3cFqywLRoqIolCswBGBrmbogKFZz66RufQX7NJDS7TQ1trIXWQu8KCpIArdBF+ghyAL/So4ACnNjAdXAplhAAAAAElFTkSuQmCC",
	blueCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQyLGsfm74AAAI3SURBVDjLhZPPS5RBGMc/z8y877s/lNyI9Q9Igm4eVqqlHwdB61BsRVCWnbsFJaQkSRAd+nWtY+RiF9vdtF/UglGEEdQlCW+7a4gsCgapJO2+0+F11zWNHhgY5pn5zPP9PjPydHx8sVKttljfx9IYFhCUCCIyfyKVirNVPMlm7f+iXC7b0UxmZKvzytrg3kKxRKE4Q7E0Q6E4Q6FYAiA9MkI8Hmd/MnlmNJt9vBmwNjFG4zjrwxgNgCjF/MICra2tHEgmT2dyudFGgGFNuVIGpaSe8P1gfVdbG6/zeazvc66nB2vtyY0AW6tAIbIO0NqyvLJMRyJBRyJRX5e/rDZ1LUrXAUrAKIVTrbD68we/Kj4A22LbaTZsDahpVgKuVoQ9jfTng4be7AQL0jeOCYc2mthYgVaakOMQDntI/xveXewCI2AccBzQ8OFCJ7GhF3YTwGhF2DN4ERe58pKH5w8yNPEdqhZEglGpMpAv8eDUPnZcDyB1CY7ROK5GLj3jRipJ5tsi76ensXeOQeU3YLF3UzgDYzR7iqtdHdxSr+wGE5HAh9mlVSKeEHgqoHRDFyDqKmaXVoPU2i601kGT7h3n/sQXXKPp2duO9OUCgNLI5Rxnk+00hRyGJ78yN3i4Vyml6i8u4IO9nWL44xRNERftrvfNeIZY1GXs8xTla0d6gbQ8SqffRqPRQ761YC1KhJARYp6iezJE1Yfne1YAOPopQrMDc4PdvUC6Jmkn0LLFR9vNvyNdm/wBqxXMUVW3/TgAAAAASUVORK5CYII=",
	boldFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABHElEQVR42mNkoBAwInMMDQ3/41H74f///wuAdMOFCxc+YjVAT08PnwFgADRkw+XLlwOxGqClpUXQAKghCtevX3+IYYCamhqyAQ23bt1qhIqvB1IBSHIOQLmDGAYoKyujGHD37t1GqHg/kCpANgAoh2mAvLw8sgEPoBisATkwmZiYFO7fv/8RwwBpaWliwiDg6dOnG7EGooSEBDEGgKLT4OXLl5iBKCIigmzAAqBTF0BDPQGEkcPnzZs3jRgGCAgIoATihw8fGnHIHQDKOWIYwMvLi2LA58+fwQbw8PD4MzIybkCS2wCUC8QwgJOTk6iEBAQF379/n4hhACsrKzEGXACGjcPPnz8xoxEogdcAoDcWAHHBnz9/sGcmcgAABnt2EUVfzu0AAAAASUVORK5CYII=",
	border: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALUlEQVR42mNkoBAwgoj/DAy/yNTMBjcAxCFFM0zPqAGjBgw3A0jRDANwAygBAC8eNBGnh6k9AAAAAElFTkSuQmCC",
	bottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABAElEQVR42rWSoYqFQBSGf4PgYwhmg0WxCKJgUASzRrGLySq227T5DIIvYDIYDb6JRcTgrGNaFu9l3GV/Jp0z5zvn/DMcblSWJZnnGYIg4DgOJEkCwzC4u7u3QVVViWmaCIIA0zTh9Xqh73tIksQxAc5ikqYpfN+/8rIsk6ZpoOs6G8BxHLKuKxRFwTiOEEURbduyr2BZFjm7wrZtbNuGuq4RhiH1gn2FLMvged6Vr6qKnBNgGAY2ADVR0zS4rotlWVAUBaIoQp7nbADakT4jz/PY952ahziO2T14oo+AruvI+Re4xwBa+DP2DvSW/h3yaYr/WeGJLgC5zq+KuT9P8AUI62ER5SBzowAAAABJRU5ErkJggg==",
	boxplot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAg0lEQVR42p2SgQ6AIAhE5cu8T8cvM80sIlHpNjfR8wkMCkXMnAFQsJXLGt7TDFDPZTzyUDdZACBe+yQ9d0bLDP4Ccs9OArTqG6sEE4CIFiduAJmBbtpIS0BEMyTmT82nTwNkCRPA01RPCW6AbuLOYE0HaaK9QXIBHI9f8vy6B9A9WcUHvD6hUL877ooAAAAASUVORK5CYII=",
	bpdata: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBAbI3VHeScAAACASURBVDjLrVNbDsAgCKNmB+Po7mTdz1wIVmLi/CI8SgsCE6/3TuV3d2QfRiYKIFXICmCHgUyoAFagjQUazUgRjjWtYCHtiQEWA3znAohwrJkkhG4MEpiZDGcTkzaxGKTYmYQoY7kFd/+2kDtvbWH3XSg+0z3sRBJ/3sKxBJye8wPlgExQ+gkthAAAAABJRU5ErkJggg==",
	brick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAJUlEQVR42mNkYGD4z4AAjDDiP7IAsiAjkur/yBwGmC5GdAEQAAA/TQYDNQKYuQAAAABJRU5ErkJggg==",
	camera: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACeElEQVR42q2TXUhTYRjH/2cfTWSnbco87qNMoq7qsFykTrRhyJwQQYEXUZEVdlG2i2iURWWxCjMv8iLxwt3YRZdhBcaypbgSWs68200E205uaymzsdPaOb07O4LdZi/8OS/Px+88z3POQ2GTh/ovALf7qFhdzWBi4gnlch0RjUYGqdQypqaeU6Nj42IpplgUpASFWo3ffB75fAFrazlQ/Td9orayElodjQriLB1BKP71FnfXYQjFsk2hUqLOYpTutwYGy4DOzi60OfZJxljiO4qCgHgshs+RBXAcJwEtFiv2sCwsVit2bGOk2Nt3H4K6MTAoul0uOBpZyRjnMpibm8XiQgQ2217o9UaoVEA6nUIksgS2oQG1ZjO0lTReTk6WZnCH9KiTi9UT/QTLjuLB4BDeB6cRnp+XPPbGRjQ729F/1UtAx4lFQ7RaAtwnAEYGFCTj8LAGyXgMCx8/QG8wAGQ02fQPsPubYNlej76+NImzEi2vA9YroImiCAZduOy5ABPD4Mv51/Aeu4dnXdNIcyk8ejyK1tZXJM5ExK8DzDKg9BW+YnbWibM9J2E21+LUTCd6cB0H21vwjUvCP/4ULc0vZMDqxgq2yIAERkZ0WFqMIDgTwNYq4lOSyaysoOmAkwzWDo8ns7EF34YW1NIc7HY/fL4h+P1jCLx9B1H4hY5DHTjTew793msIh7tJXAVRBtTFS1fENqcTfCGP+ro6qAjyUziMaDQKh8MBk6ncHsclEAqFsHPXbtTUMKjQ0pgJvAF14nSvqFIoodVqoFaXqOU/LptdQzK5TJ7Z8nhpWkrUVRnA53LgeQEFviDtgk3OEv9hj5Sb3sY/lAHgFY7+jH4AAAAASUVORK5CYII=",
	cameraSVG: "data:image/png;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAA//8AAP//AAD/////////////AAD/////////////AAD//wAA//8AAP//AAAAMAAAAC0AAAAsAAAALP///////////////wAA/////////////wAA/////////////wAA////////AAD//2ZgXP9pYmD/cG5s/3hzcf//////AAD//wAA//8AAP///////wAA////////AAD///////8AAP///////wAA//91bmz/ta6q/62po//MyMT//////wAA//////////////////8AAP///////wAA////////AAD/////////////hQAA/5QAAP+UAAD/mQAA//////8AAP//AAD//wAA////////AAD///////8AAP///////wAA//8AAP//AAD//4cAAP+WAAD/nAAA/6EAAP////////////////////////////////////////////////////////////////+HAAD/oQAA/6EAAP+mAAD/hwAA/8fDw/8kJCb/PD5A/4QAnv//AP//OkI+/yQpJv/Jx8X/fQAA/5YAAP+HAAD/hwAA/5YAAP+WAAD/owAA/30AAP/EwMD/Ly8z/0ZGTP8ArSv/hgCh/0RKSv8vMTb/x8PD/30AAP+WAAD/jwAA/4cAAP+eAAD/ngAA/5kAAP+KAAD/kY6O/3VzeP89P0f/TlBX/05VV/89QUr/dXV4/5aTk/+CAAD/ngAA/4cAAP+CAAD/kQAA/5EAAP+hAAD/lgAA/y4uLv+6uLb/eHh9/0FBSv9BQUr/eHh9/7q4tv8wMDD/igAA/5EAAP+CAAD/ioF8/9HIxf///////////+3m5P+wq6n/gHp6/62qqv/Curr/wr6+/62qqv+Aenr/sqyo/8zGwP/Z0Mz/jIOB/4V+ev/PxsL/AAAA/wAAAP/t5uT/6+Th/8/Ixv+emJj/hX9//4J9ff+emJj/zMbE/+ji3////////////4qCf/+Ffnr/j4iG/5yXkv+hnJr/oZya/56amP+empj/npqY/56amP/r5OH/6OHf/+jh3//r5eH/AAAA/wAAAP+KgX//AAAAAFJJSf9pXFz/AAAAAE9HR/9mXFz/T0dH/wAAAACempj/npqY/5yXlf+cl5X/oZyX/5mVk/+UjYv/ioF//wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8ACsQQAArEEAAKxBAACsQQAArEEAAKxBAACsQQAArEEAAKxBAACsQQAArEEAAKxBAACsQZEArEH//6xB//+sQQ==",
	cameraToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAD9UlEQVR42u1XWSi1axR+tjlTynAhIiRCLpRkyDxcmDKXGyFTRIQMpYQLlIgLc0oZokwXhsic4UIiFyREkigyJMr+91q19zn7P3uyD+d06jw339r7e79vPe9613rW+gRCEfAvQvA/ga8QeHt7w8rKCl+VwcXFBQ4ODt9HgJb5+/tjbW1NJbJaWlqYn59HYGDg9xAYGBhAWlqaqsFiuLm5YW9vD5qamsoJbG1tISMjA6+vr3zDwsICY2NjsLa2xsvLCxwdHXF9ff0lAoTOzk5kZWUpJkBOU1JSMD09LXXT29ubHZ+fn2N5efnLzglmZmaIjIzkI3F2dkZiYiJvSkJAtCthQEAAjo+PERYWhq6uLo5CUlISDg8P5b5YV1cXnp6esLe3h76+Pm5ubrCzs4OrqyuFhIhIeXk5amtroaGhAYHIkXB0dJRvHhwcwNXVle3x8XEkJCTI3FFVVRXS09NhbGz8l/vr6+uoq6vD3NycQiKZmZno7u6GQE9PTyguq4WFBYSEhLDd1taGwsJCqYcoo0dGRmBubq409H19fcjNzcX7+7vcNTMzMxCIrpIqsLS0REVFBZ6entDQ0IDn52cp57QrbW1t/k0hHxwcxO7uLh+ZjY0N4uLiEBQUJHlmYmIC8fHx+Pz8lEmAjlyKgDxQ2I+OjiQ7p8wuLi6WVMyfERwcjOHhYX6GUFZWhqamJpnvNTAwUI1AS0sLioqKJM5zcnIUrnd3d8fm5iYnJ5UwRef+/l7mWqUEKNtvb2854SjslPWydv47KisrUV9fzzblEuWUWgT8/PywurrKdnNzM0pLS5U6J5CQEWGBQMD6Eh0drR4Bkt/+/n62k5OTIS5ZVXB6ego7OzucnJywoKlFIC8vDx0dHWxHRUVx6agKsa5cXFzA1tZWPQJUWiRKhPz8fAkZZaAG9PDwAENDQ2xvb8PLy0s9AlZWVri8vGR7aWmJy0wVhIaGcjsmtLe3o6CgQD0CBJoBfH192SalXFxcVLie9H5jY4N7BcHHx4fLUm0C4eHhmJ2dZfvu7o5J7O/vy3VOWkG9gkBkxfKuNgFCb2+v5KWkA1TjPT09rBEEOnOSYWpE4p0/Pj7Cw8ODq+FvE9DR0eFGFBsbK/mPZpmzszMmRFlOCScGOY+IiOBBRxEERkZGQmo+qoD6d0lJCWpqaljH5YHCnp2drXDnBJFvCGJiYoSTk5MqERDD1NQUqampfLZOTk4cHVI96oxDQ0NyE+53iHxDIBqzeSL6pz8PSKJpzOOZUFHL/ClQT2lsbPxjKm5tbUV1dbXUEPIToESlShFPW1LfBSSdU1NTPIx+fHx8q2OapKgvUFc0MTGR/P/f+jb8CfwCf1rNSUuRCpcAAAAASUVORK5CYII=",
	cancel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAx9JREFUeJxVk09om3UYxz/v722ydEmb2HYiS50dWDdT5sS1uoOitTo7LSMFFRHRwnbaSUFBpzgsDHGX1YvgofUg7CIutd2GTIR2A1vcULN2rTYwti7tivRP0vRPkvf9PY+HFmm/1+9feHgcVWUrbr76+BNOMPgFxm1W49aLWKRcykq5dEPLpdMtQ/dubtU7WwPGO59MYdxk8f40Xn4Ja+0GYVzccAQnWgO+3394aLpzW8D02Q9DhevDGW9pvn41e4fA7gZqXkoS3n8QVWFl8i8Wfh3Am72LidXCjlB2ra6+8ciF0SKqyljyYOrPtga9tg+d/LhLvfySirUqXlltqah2fVXX57I6O3heR57fo0OHYjr8TF1KVXHGX29uUZHf87f+oLazi/1ffoeKMNZ7juzoMOXlHAfePUlD61FUhL+//4b7X3+GidXiqD5dIaXimdL8HE5VjEc/OYeK8MNrTzE/kabSQLg6Smz3w6gIiGVvx5vcPv8tVfl/kUDwjHFClQkvv8Su5Hu4kWrG+nqYn0gTdSFSHeXFvktEGxMsTqb57atPQZQHnj1C2SvjqZMwIhq31rIj/giI5faVn6g0EKyK0tp3iVhjgoXJNAPHk+SmxgnsDFPTmGDFKr5I3IhsnkpkY6Yqkert5sHjSfyVPGGj/+uKAiqWCvH9GYwbL87cAbE0tHVQ1fn2hnkizeCJJH4hT8SF+HOvoGJZmLq10WntjHO9be8VL7/4si9Ky+UJAuEIKsLiRJqBExvNEQN1jzXR2nsRbznHha4OQguzhF3zi1E3cMqJ1qAry2TOfoRaAWtZnpnmwX1NJFrbaX7/NK29F0GEkZ5u1uZmqDAGK3LKUVVGX9iT8tfXkn5ugZ3tb9H0QTfBzSWIRUXwlnOM9HST+TlFXcAh5NB/LCOdjqpy9Z22kJn+J2PXVuu1kKMQqibW/gbhh+KgSmH2HpnLP+KvFqgJOAQdsrNlbTx5V4vbnunq4V0pTzRp1lawXpm8VcqbtOs4BFyDK9J/LCPbn2krhg9FD/hKty/a7InWq1iwNuuIveGqfH50Ssa26v8D7vnE690mEL0AAAAASUVORK5CYII=",
	cancel1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmtJREFUeNqMU0toE2EQ/naTqDSPkoc2pbSlWpAG9ODrkosoLfV1EEUwJ0GwpAQtSEpBvAlCCxIfmKsnb6KCj5ioCKJotVDRSsVqqTUmJtkNyea9u1n//7eJq+nBgW9nmfnm25llhtM0DXqLuq0O4k4R7CLYTmAgmFlBeCgppfV8Ti8QcVsvmixtE517vLBt6oWlrwccz0FaXEaBIP74OeR8YWo4KY23CDxwW686tg4EPCM+cOIS6rk06vkMy/FWJ3ibC1jfh/kbt5Ceng3vT0qjNGekj3sdtguubVsCHt8Qaq/uIHrzIwaP9f/pU8ojFoph8PgANh/ZTSX9pKZw8Gd+nL/bYevizW3n+g95UZp+hLcfTPDFU5iZN0OVVQb6zmJza1B6E8XGfTthtLcHWa2qwd+114vq3EsoVRnDD2Pso9TPfrEx6GNKTUXl/Qt0eneA1vIquAMWCyAXikRAQSp0ptk5LWgUU6M5ypGLZVjtRpDaw7yiwcOVMkRZYci/foLEVAD/Go3RXIOHXAKktp92UCun0pCp8grePf3UIkBjek5FFGkHIAJYKOarUCoyw1K5+6+29ePQXINXzlWJAL7REe5nJTRb0xd/PX+SQS/S4GUljY4QoSOEk4kiamWF/aDPEycYmXrhWYRBH2M/saLg+48iHSHMNjHstE/abcZg7wYD/seW0yqEnHLZL2THmqt8zWm/bjdz/m6nAWT9V7U6ocbFOoRCPRwQsqMtx3TF6Zg0Gbigy6yhfR2w1vg7TnYHuTKQKXGoKdql04J4dtVrpBZyOHqI8xMcJWgcxCLBbXrOY6K4oOf/EmAAfyhg+goYmG4AAAAASUVORK5CYII=",
	candlestick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42o2SYRIAIQSFORlH18nsttWOEcqfXc3z5QnCGyKizIyQh87vpsEK0M9tHmlwiTIAMX//TcRq/o6OHRQArCzoPAcL8NFrMgu67HkAEY28tQGwHfihRXEEeMHWkQdYCwngn3gIqCz4lzkC/BBvFit6hXRtowvKRSqKYQNcFm9xe+s9wM/klD/orqJQOaYIOAAAAABJRU5ErkJggg==",
	canvasXpress: "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
	caseSensitive: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABYElEQVR42qXSTShEURjG8XvGR1KymVJshuRrhQ2llIad2YxSspliNSnZ6E4obMxGjGxMFr4jZrKSYiWxYDaKhZXsZDZqJjbi/zbv1MTmzsytX++595zz3HPOvcYq8jJ/HwzZbhelF4+xcPK9kIA6yjGiBGwVEuD7sawVmvd0Bgj5yjdgn9Kltz0EvDkO8NvuRsoy6lGJmXg4eeQogDdLO4g0utGPWyuzjW8nAWWUA9hoxSpk/4MEvOiYFsooynGH09yANlkyxnVAQrumCYjT79GvsyQHjBjmjU4uoSygA/I2+Re8Wq8JCDCmhvaYvFVXfoh1o4dXS9nACIeW8mfOYwKTuopOpNCOYTwhhEg2wCeHxuTsBHnWRDnT21k8YxtTjLuk/4b2jqEh+93FBR2bOQEuPYcqPOAEi5jDB9ZwLgFR3furLImQK55V6BIHUI1P/aTNKMUe+tDw70/M9yo64Bd1Pm0FibtU7QAAAABJRU5ErkJggg==",
	ceil: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNkoBAwjhwD/uNSS44L/iPrZcQmiIPPiGYI3ACckkhskg1A9yLZLmAgxgBiwwDZQoxAJBuMGsDAAAAIyhcRGF+DhQAAAABJRU5ErkJggg==",
	checked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAVJJREFUOE/Nk01LAlEUhv1vRUX9gFaGJS6jTRTUrlVENAgiVFRIIIFQQpuYikAUyfFrFl6jsRlrYJgYhsScD2fzxr0glNiVcNOFF+7inOd88J5Q6F+8A0HAX/WjcZrc6/V+le/76Pf7cF2XxdD4kYBr8QrDqsgSLh5OsJvZwIv+DMdx+IAakfBdH10ba6eLCMenkJNF1gW3g0FynVTxamgQa1ksxaexnY7BNM3xIzypDZbYVBr4dLpYT4URScygQO6gKAofUCznIaslXBZTsG0beSJiJTmHrXQUnueBEMIHaG0VO5lVVrGpy6ztaHIeOXLDltdSW3xAVa6gbbawnJhllWny5nkEfuAxgK7rY0Z4LMDqvONI3GOA2OECbuUsgiBgAMMw+ACpXGKLejM1HIv7OLsX0HU6bB9UlmXxAQM30mrUedSB9D/s0pE+mOgWJrnoL9c9HmLH1TloAAAAAElFTkSuQmCC",
	circles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHUlEQVR42mNkwAIYgfg/lIaB/zDOf2QFOAUxtAMARVoIBH4zv+4AAAAASUVORK5CYII=",
	circular: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkklEQVR42o1SCQ7AIAij/380izq3ciox8SptUSAudA4RzLHWa6vvGmA8smQi4FulNASCIlktLpLgrByKNCS4U66dwD3aBs9zfI+HPQeSkqBx0hKwepLILhqC1MnawZIVJahkjXRXggUN3aG653CnRPBbPH+jmq9fjYQfwo3kiUzywJYXkkWCQQnoggSi0onEuXsA+SNlAUVDy0YAAAAASUVORK5CYII=",
	citation1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42rWRAQoAIQgEz5fl0/Vl3RkIi5XVQUuQxbaMRiJSn0/MTLbb2WuXe9DnIgyIYccBSICPUNsEVpdSmklV9wIiwSgg0hwT4F0XsEOQBvwiiH0dE4z+O/vGbogr00rTgGw2OPT7BFn/dwlcta25XrDZoA/0ZIQgAAAAAElFTkSuQmCC",
	citationH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42r2RUQrAMAhD9WTm6HqyDgZiN2yx4Jaf5iOkL8iUSFUHFcUeBnB7f0VkSnH4Ed1m1lzQOgGQ7NMHjak2F/ReAYgQRd9Ms79CtSDDOppQDR4XvKdl/h+Clb4ncA2iLckFmH2KhV0zTwoAAAAASUVORK5CYII=",
	citationS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42sWRYQ4AEAiFuVlH72aMLQup5Ic3W0xen8qJCRFLiwCQk1NbYjMhA76XzsOALsIEWtWTKM9FoJmGCcI9WAuYBBbRvylMBusfvY/HGE+NsqJIcCt1XBq6afBMwFX6klUBdid+D0VDG2kAAAAASUVORK5CYII=",
	clock: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAqhJREFUeJx1kz1MU1EYhp9z6R8tbYFWQNviT9ABg4kGUCEO6qAjJiRKdGUzmjg4GH+iiYmDi4MOGlcdHCQukkiMicZfjP9ViyLRCooXbK20t/fec46DkbSo7/q933PO9735hNaaSu269nRNna/muFeITo8g6SpJoexm52x3tGC7x0Z29z6v9ItKwODwy6taun03n71m1jRRVhGAunCYmrooHctTOIihG3s27agCvM8VA2ceT4zdTb9PZjJvEf4gRjTGikX1nNnazv5Lw7zLW2inTHNqKa3Ni7JrQ3rl6f7Nlgfg1P3xy0/GPiQzr9MYi5dhRGMAbGtvpactSVMkxLg/jnZsvk6MI6VKFmKNl4Ednn0j6S4t3b5M5m1VM0BvogGl4c+Uf2rm5CcaIuG+deeudxn5snvy5rM389+u1Op4HQuXbERjCH+Q7LRJSaqTRoO/pn3W/IZY0NwaqSUZDqCAagSIaAyrkMOQbrshlU4oq4jw+qpMPYl6lNYorelpS1UDvD60VcKVMmG4SvIvrY6H5+c/sH0jR3pX/eVxpaKmY+fg4Jvslwi+ACIQnC+OfZ/j49QUpWKJeDhE99ImtiQi3P78g3wuB04ZbzD02fOtZKcjjY2JfG4GKvaQLVhcnLW58HgcXbxFd0uE9cuXcLCjhb2vnuIJhbEx0qL/yr3OOct+dOfBQ4ym1F9JVEoXC6jZafRcnuDiVlylu4wr/RtGHcRQc2oZamoClZ/5P8Cx0T9zeGPNuIgh8+jAqAdgS9w3MCLjY1KqpDn5EZ2fQURj88lox0bnZ9DlIt54C8Lry9qTEwOw4Ji6z9+4Kh2nLzttYhVyaKv0OzZ/LZ5QGG+g9vfLh3dWH1NVfGeHO1DyhJayU0o36UqFrcg6Wo+6Whw1D/W/qPT/AkFjRsBfYQQQAAAAAElFTkSuQmCC",
	close: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAOCAYAAAD9lDaoAAAAcUlEQVR42mM8e/bsfwYCgBGkSE9PD6eCS5cuIRSxsrIy/P79Gy4J42MoAgGQBDIbRRFMNwzATMVQhGwNVjehm/T582cwfevWLfxu+vTpO8Pt29ew++7Hjx8MvLy8mIpgAKTg/38WOB+uiGCIE1JAXUUA5WZpcWW3WYkAAAAASUVORK5CYII=",
	cluster: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42qWTQRLAIAgDzf8fTXvoQceAa+Gmk4QFR41mCepi9ryH0OcVNKXaU4BMWEmAulaCrOviORHQxW4EYe7caIjA4aNXmAMcHSIoOyKsDoEzXO0gq19/AVU74AENwCIRDRpuzgAAAABJRU5ErkJggg==",
	clusterSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42qWTSwoAMQhDm5t7835gBBliidZVCyZ5KGI8FpQmM5vhjf2Z+LRQRC4sERwDF8kEampKkKX+Ta8ESiol8ERmUJrBaWD40haiQRS0tqDOgja1CZigNIOsWreg1rPBAuwxXhH250nfAAAAAElFTkSuQmCC",
	clusterVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAw0tyAhoaG/0DMSJIBIE14DGQkygBstmITZ0RXgM9GogzApQHdcJg4SQZgY1PPAGQngiSx8bGJY9hGKk09A8gFcAOAHvsP5DCSStM+MxECALpLmhHlv+W/AAAAAElFTkSuQmCC",
	cog: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAGSSURBVCjPVVFNSwJhEF78Ad79Cf6PvXQRsotUlzKICosuRYmR2RJR0KE6lBFFZVEbpFBSqKu2rum6llFS9HHI4iUhT153n6ZtIWMOM+/MM88z7wwH7s9Ub16SJcnbmrNcxVm2q7Z8/QPvEOtntpj92NkCqITLepEpjix7xQtiLOoQ2b6+E7YAN/5nfOEJ2WbKqOIOJ4bYVMEQx4LfBBQDsvFMhUcCVU1/CxVXmDBGA5ZETrhDCQVcYAPbyEJBhvrnBVPiSpNr6cYDNCQwo4zzU/ySckkgDYuNuVpI42T9k4gLKGMPs/xPzzovQiY2hQYe0jlJfyNNhTqiWDYBq/wBMcSRpnyPzu1oS7WtxjVBSthU1vgVksiQ3Dn6Gp5ah2YOKQo5GiuHPA6xT1EKpxQNCNYejgIR457KKio0S56YckjSa9jo//3mrj+BV0QQagqGTOo+Y7gZIf1puP3WHoLhEb2PjTlCTCWGXtbp8DCX3hZuOdaIc9A+aQvWk4ihq95p67a7nP+u+Ws+r0dql9z/zv0NCYhdCPKZ7oYAAAAASUVORK5CYII=",
	collapseFolder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMklEQVR42mNkQID/DKQDRkYkzYxkGPB/1AAaGUBMdDLiM2DgvTBSDYAZQipgJMdWFAAAgAUdBKIiH2cAAAAASUVORK5CYII=",
	color: "data:image/png;base64,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",
	colorShapeSize: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42tVSSRLAIAirLye83GI3laXtDJeWgw5CMpJQlmSUdgCoXlHei8qrrl0EBExglnwk2Hqo9zDv9R8RPGrwRsTQhUx8lKBpEs1/6jWJaMEkN7su4LASo40a3HM2uxASaPAdiRkh2gP1O1eTtAsrkPt0EQ6Mk/cAAAAASUVORK5CYII=",
	colors: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAT0lEQVR42mNkoBAwgoiGhob/2CSB4gTl4QrqGxpQJBuBfGQDGhrq0TQ3DjsDKApEiqORYgOokg4a6lEDsaERNRDr0eQbofLDyQCKApESAADMNJARz8XIQgAAAABJRU5ErkJggg==",
	communities: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsUlEQVR42qWT0Q2EMAiG8RIncgk7SWdiknYJJzLRo5ZWFJIruT40QuGDH+IEf56pXPsH1vfDfEBW0Qs+47aYJSBxYrGDCauAxO5gAsoDJSTygbCHAMCJrXrviJMDt53EdwX8ksEdnJQIsnofoiVDDdJoXwGkBGMLZ2+d238AelDzoVhtpMpI4KhX+wZUCLL+mnjrdgFaVal7CIB6mD4JEhAv2ykB1X/hlGBD2jYGAY7zBUChYRGjnbjbAAAAAElFTkSuQmCC",
	communitiesOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAfElEQVR42q2QYQ6AIAiFn22dqEN5Jg/lidoiTdvIoUT2/jARPng4TMr9BtgXUI7roYC3cNUhetcD5BylN9hbB1TRnWs24rXE+x4AxQal6eDTRwD5Bs36QwuCxL+3gC5YKyZU2/B2QImh3MUCgNBkssAB+GJB28YIUDQNOAGPeDMRd2gLMgAAAABJRU5ErkJggg==",
	communitiesOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsUlEQVR42qWT0Q2EMAiG8RIncgk7SWdiknYJJzLRo5ZWFJIruT40QuGDH+IEf56pXPsH1vfDfEBW0Qs+47aYJSBxYrGDCauAxO5gAsoDJSTygbCHAMCJrXrviJMDt53EdwX8ksEdnJQIsnofoiVDDdJoXwGkBGMLZ2+d238AelDzoVhtpMpI4KhX+wZUCLL+mnjrdgFaVal7CIB6mD4JEhAv2ykB1X/hlGBD2jYGAY7zBUChYRGjnbjbAAAAAElFTkSuQmCC",
	configure: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADA0lEQVR42oVSa0jTcRQ9/23qdLDle482S/vgykzLVhJGvobPpYKRQmgmJjNFtIdmfTEJLEMMB/bJrMZ8ZA81S60tcm0jTYQsDDVNnTqV0cNsztm/rQgsVp1vv3vPOb97LpdobbndSaNRxQeTk+kALLAPxzOnTrXExSdITCsmfFn+cjElOaXM1iA2CwQXX715U9ra0jyXcTSLY08tk8k0Uqk0VK/X44Q0ry04KDB1aXnZ+3LVlQXCRhDwuKeLioorY8RRCv/tO9LXi0UiUXhXV5eSTqejrq4OFFDHeFyu34JxoU+pVDYQv4jbuGxeWnb2dIJEUhsUIsr/VY+Li8uUy+X1ZrMZ4+MTmNLPYtY6iVR63NbLIdb/FrjRm5569NjXhMTEimBR6Hlbzddvy76e7i61VqtFZGQk1tbWwGAwMDIyYhKLxXsIe5nLy0rI4vCIQkaUuKYyOZc82VILRWMjCIKAVQSDwYDS0tKa9vb2QrsGNsxXXiLNGjX6+/oRPzqGQ2n57VP66Qmh0JOj0+m6rRPcsNJW/mrw2seH5FdX4VFeAYxmi66EX/b+w2Dh4T95dg1cMobI1Oa9OMlxxaarMqiyc20Hcj9lbibpvwY+eYOkg7sXRtV6FEQ7m+Jroul7qiqxdPsOOjQasF2o1KSJ2W92DfjSQdLJwxNjOgOEEXws3pQ9r168dpdBQVWsuheLZ89BoXyCAD4jJGZg4uVvBt5ZAyTLh4uR3hn4W8XjnT1NJnX6j8wNbPZ5FoVSHqvRwnihAk1t97AzgCXYrxqd+nmJua+XXDZ6MIafTGKreBPePVQ9NT07FL5+ultsNunLZGJXdzeM5RV43NmBI3NzBOGU+FLlFyo4MKyahH+4AKM92n6zSrLb3nIVHA4pdHWFsOOBNc5ZLBmm7xM0L3Gmm6Sunu3PxNvrNcaVoQvu+AcKWayPxWFhTBqPhxK53OtHBEeqYw4cNvAJ03yr9cmkUeG8SmDVQoHlm21NFCcqQHPEGvWzg+XTrBtBpBhJsneVJF98BwuhK7qE1LMYAAAAAElFTkSuQmCC",
	configureShow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACGUlEQVR42mOMm3SukAEC5IHYBoiNGRj+/2f4z8DI8O8/AxMTIwMQMfz794/h31+GD6ws/++oy/CZgORAgBFkwMJcwz4GMkD3mhtgA2YDDUhxm+bI8B9o6j+g5XtzDzLcf/YRRbGiFD8DuprOVdfBBtwAGqDuMcOZQUVNhuHmtYcMu3MOgA3g5WIDa/787RfYAHQ1iT3HfjLGTTj7YWG+Eb/3bDcGRWVJhls3HjPsytqH1QB0NREtB/8zxvaf+bWowJg1ZLEfg4S0IMODu88ZtqTuwmoAuprwxn0MjDG9p/8tLjJhDFsawCAmyc/w8P4rhs3J27EagK4mtG4PA2N096n/S0pMGSKXBzEIi/MyPH7wimFjEnYD0NWE1OxkYIzqPPF/aZk5Q9TKYAYhUR6GJw9fM2xI3IbVAHQ1wRXbGBgj24//X1ZhwRC9MpTh1+9fDL9//4YbgB6N6GoCyzYBXdB65P/SKmty0hFDQNEaoAtaD/9fVmUDNh2YRMAJ5S8o2QIxExMTmP779y8QA+l/f8FskNiurP0M/oUrGBjDGw/+W1Fnxxi6xJ9BXEqAKJthCckvf/l/xpD6/fdWNzgoBsz3Akv+//8fnE/+A21jZGIG0/9AyRfkKlAeg9KgpOybt+wdY0jN3v7VzU4F5IQB0ICjYAOgNqsBsSXQKsF///6AnAC2/T+Y/RdsM8h14KzO8O8zAwPTZZA+AF9OX8yipJioAAAAAElFTkSuQmCC",
	connect: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB3klEQVR42mNkwAIuvvr0/+effwy///0H4n8Mf/7+Z2BhZmRwkBNmRFfLiK7x8wI/MPuJ7zKGP0ADYICFCaJUgIOFwUNRjBHDgHMvPv7/tsifQUTdgUHdr57haLcjwwPvpRiu+/sfaCgQxevKMMINANn85tsvBvZVIWADQODNzQNYDQCB73/+MghxsDIEq0sygg049ezD/1vvvzIobI1GUZi7ZT9D8fRnWA159uUHQ5m5MiMjyOlPgJxPP/+AJWCGwGzvzZQCGwKjYeDLrz8M7CxMDIwg2+99/AYPMHSFuMRA4N6HrwyMR5+8/38faAAuxch8dNede/mJgfHAo7f/n3z+ARY4u1SK4cARBgYHGwYG42hUG0Ga0WPo5LMPDIx7H7z5//zrT4LOhRkAi6G7nksYLr/5DHHBC6ABsDBAdyayAcjgpMM8BmZg4gJH44rrz/6DDMDmTGyGgMSPPX3PMM1NB5IOdtx/9f/l118MyttiiEpIt4FpRoiDjSHfRIERnpQXXnnyH2QAMsBmAEjzhx9/GCa6aCGSMgysvfn8v/jGSDD7rtcSBmao+X+B3nvz/RfD3Q/fGNSFeMA2w/RgZE8QWHL16f+Hn34wvAVqAmnmYmVikOblYMgxUsBQDwAu7QTZ3H8hggAAAABJRU5ErkJggg==",
	connections: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42uVTRw4AIAgrP+Pp/KyeHCGuiBdjj9A2DUMAEBWCPbAVkFW5bZA1ciNBgZlRVacmniMrwqo3I/oaesajuGSf+I1BaIihNZ4e0uPPlACo/0YLzqjjLwAAAABJRU5ErkJggg==",
	connects: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAP0lEQVR42mNkoBAwgogDBw78R5dwcHBgRObjUgM3AFkDOh+fGnQDMGzB5XJcBpDvAorCgOJYGAYGjCakAU5IAC/wchHTLzdWAAAAAElFTkSuQmCC",
	controlForwardBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACz0lEQVR42mWTe0hTURzHv/fePVtmMsmSUIOSSBiUmGngA0yrDYf9oUmJJWGa0kMkqdTQDUQLRdNe0EMjQiHLMQ3FaJaZDxSKEixCjR5iCpmm27q7t3Mmm24duHDO9/5+n/N7nB8DrxVT9qzhr0PIEgRR4dJYlrFKOfbuy8sH8rztGdcm3tCZuGTnO3MTdkAfHgJf1YrR3B+gbXgCN7pHoZRJkl6UJHV5AKgzy6KzMScOnFyGoW9WzCzybgO1SoKIQAV4qx3HbllAoiOQ/V1uwJ6SdrHl7D5YOSne/rBBFAQIogCWYcARMrWyO0RoApRQwYbDtc/Rb9A6fRma8/G47af0USEofTSCobGvMGQfhJ13OAEdve+dWhnRrHYeUZsVaB8ax33L2HVaEya61Gx9WqSVjy8Ap2tNOJSSgNYn3biSr4MoAucbzG6tIlcLKQko1JdDSlW7ra9cp2Aii80iCQe9UwIKr5nBrPdDSny40+FmYTJyrpo8tMo8LWIDOZo2Bow6xgl4QwDDM0B+jQkbt24h+YvuDkx/nvhPa8vSIGo1oI8ARueAE1UmhEXshL9Kih7LIB4WJ+OI0VOjUWn8gGgXILrEbGsu0socEiCtfKUG1JneedS4ojVdIpoDUDIi0qs67H0GnZyJLGhsztLHpKbHhOBi03IXmkuTScXJCySNqmv11NRrgMe947hnetUyUJ2ZRnsZRAoyeedMAgLUMkzPCZCTUvPC8iORksgWrQ4o5RwUZD/zy4bsum70G3XB5PcX52MIS72Qt0kTV199MhaB/nIskZscBEBToFFwpHVyKfD9pw0Ft3sw9c6S/6GlomH1LKwjkAyf0L31GWQWEncFY4MP6wRQg+l5AV0jk3hAZmH+42vq/IDIvz2GiULIt233ucYiyVq1XhAhcwFIFHZ+YbZtsCazkhw/uZy9Aa4VROeH+q3SSEKYpTl7G/8DtjE4IMaQs40AAAAASUVORK5CYII=",
	controlPlayBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC/UlEQVR42l2TeUgUcRTHv3PsjqtrinaYkBp00EFUHolaGomWbVlCWpDYAUXZQXaXFrZBWKBkWugfXRKmf0iWWmtGHiladhAdVoSlYRYZmLrurDM7vRlbU4f5DTNv3vv83vu+32Mw7lqWeT9/SHZsczgUF6eNZRmbjmOv1p9elTren3G+LDdbYgbtkmVX9FzEBwbAw+2/U+8AUP78C67UvINBz8c+zoitHgNYbn4QQ7tYru+MBCcIaO2yoccqjQC8XDkE+xogiyK2FNSBsiPIyuoRQGhGpXJ7/wr0K3q8+m6FjmXAcywY+is7FEiyA7ICLJzqCiNjx8aLj9BsXq3FMmrNW6Jm744Lmo6GDis4Mgs6Dnfq3qC1rRNZqSaIdgmkC4iFCD9XVLW243rth8uqJkzYqQpb2ZE44f1vCX02CRzt7qLncexKFU4mBcJc3IrsvSYM/oMYBR5zvHgknK8Sm86YXJgl6RUKpQPLF5tWjwowCDoczK0EPD2RFOSLW5Y3uJS2BlbaYIjSiA0Q1LLRctbEaIBGAtR3DhFA0QBuBEjNuYcpMwJUwSDR+tb2GQWH4iFKDiydpkP4aMATAjzrJtUVRe05AXhsP38X80MWYZKbDg9rmnHzxDoMiLImarAPjwgnICyjQiw+HKfvk4HBIVkDGAQOm813kLQhBsUlFpRmrodVHO6GC8/CnQM2XaiyN5lNArMk7UbJ1rVLExPCp+NHv0NNgrrA4nL5S9Q8b0fluYR/wYrW1ilGFmWN7bh2t6G0JTslSdXNLzS94mvhvmh4ewgYsENz5GmXAZtMHeEo7eEDZdQDPb0iduTWoPmsyZ9MHdphmJd4PNVnQVRe9o5I+E4UqBRNDnpoN5UFGHRA1y8RaYV16H5du+dt6bn80bMwgSDJ7rPC85JpFmIW+2OyO6sFqw4/+xyofvEVRTQLfR8b1eAiMv8ZM0wqhNbMkAM3jvJG73gSW+8EkK52qb+n/GlOShZ9fnIGjwc4Lz9a3mrcKJuqQo9a83jnv4gWQiC554IcAAAAAElFTkSuQmCC",
	controlRewindBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR42mWTe0hTcRTHv/fetV1NM9DEHvggSrAomPjILCeJko5ZBkqE2gN6WYpSiuCUnBWG2IOZJmGFhekfyWSrNMEHpJlYMDDCgjTCMhxmtva+t9+9ueXWD35w7/d3zuf8zvmdQ8Fn7b30rMnh4o5zHM+6NZqmrKsYum24Zn+Rrz3l/kjV9KZb7M7eM2kxyI6NRNDqf0aLZkA3MY3m/nfwk0oyBtQZfV6AVM3zdBKl9/4pBSSsFOOzVpjMTvDLRiH+EsRtZOGy2VHYMgiOgwciAhLVBv5xyT6YIYNxzgIpQ2Ti7SKWHM+DpmhQNI2d62VgXQ7k3niBV5os0ZcScj6qiD6bFReF0S9WsFIJalqfIi56EzKTt4sAqYSBelmrPSyHbnQa9wbf3xZqQiVV663d5VmyqUUXHBxQ2WxAzsE0POnux7UiJSgS56JW79FulagQFQAcqDfYRmqVLJVQpefJdTA060JF01/n7oEJ8D8W0HJBhdMNPV5aw3klksNoIW2M1SkpETBKANltRk/VaRL228dPCN0c+Z+mLVUhNgTYtRIwQgDGBYjRUhTxmDc7MDn+Fo+qVDhS563dLVchJghIcgOS1HpbR3mm1MJToBig4HKPJ9+HBCCUWoC4tc5qFRgnkFdvsI9olDIqoexB5zHVntxDyVEw/QZ5BXJY2yNWvDhHTl7BW7tSIEfH8DTadMNdY42FeUKA8MQq/UxrcRpC1spgJXSLzQV/loHDKbYDJDRgI08UGkRjzmTHiZv9Qh9EkKPPYjNsy60sCtuh0DaeTMGGdTJiLDQRxOiCAUMAfuQWs/M2lN0Zwlfj4LnJrqtNK2dhDYHkB27drc0ns5Auj0BoIC1GFwy+L3HoezODdjILS1MvBed2Iv/0GiYBQvaW+NIHFZKA4GwSXeoG0BTszl8m3evrhfXk94Pb2RfgXuFkBwt+KzSSEExCzr7GfwAmmzUg2PWC2gAAAABJRU5ErkJggg==",
	controlStopBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC7UlEQVR42mWTfUxNYRzHv8899633JcWKEqmN1kZ0U9GNXqjI2MIf7WJLlJfVhrHKdBvDVkNF2tD6A21M3KJudKMXRWwWW4kUNUpaerv3du85nnPr3nI927Od85zf73O+39/v+RFYrQ1nnxROGdn9LMtJzWcCAdGKGMHNF2e2pFnHE/NDhLI6elJvqD4UuQIJgUvgZDcbNDIOVLR9xbXaj7ARC2PqsmJq/gFEKJ9G079Ul6bIwUjFeNOvxdCE0QJwsWWwxl0Ko1YPRbEGVB2FbK6xAIKzKrm7xyIxQcRoH9BCJBBAQGa+cgBL9xTLwt9NCltOj92Xa/FKGWfKJbznvXK/1Li13mjp16Givh2dfb+trcLXYx4Swv0hc5eg8nU3bms6iviakJBslfbBiVhJx7ARehbIKa1D8qZlM8WZlkAFoOTZZ2QrIiAWAH7ODHZcrNI15cRLiSxTxVE5UPfoYCMR4nTJcyTJfVDc2AuGEBg5DimhnijTdOFc8kZM6gyI8pLwttGSG09MgEYKaPhugB0FZFxXY+s6H9R3j4ChhTDSAoR7O+FxcxfyDkZhnALCFgkROhfQQAFtP42wlTBIu6qGPMgX38Y4ULWgrrDYnkDT2onCI1GY0BkRuIBBmBkQkqXS3TkeKx7nqF+akZKvhkwWAIik0y2gdXC0YaBWN6M4PcpEtCMc9lyq0jcp4yVEllF6b9+29Yk7w7wxrAWKHr5D25df/3UhcOl8pG5fBWfKvd/QjVuPXpa35Cl28WX2DM5U9ZQcjYSrs8TUCf4OEDKbzM3cBb4Dg8M6JF+h9yA33ot+6jWFrUw8lbYwQF6QdyAcHq4SaKdoAms2wM8CIBUBfYM6ZNyox4/3msMfys8Xzp0FRwpJcvANLUiisxC92gtuDgILYGCURc3bHpTRWRjtbOSTy+jxn3+GiYfQvTwovfSk0N4lgUoWWxQQ6A1jQxWt+YoL9PWTOdkaYF6e/PzA1BPL4rs5xHu2Dv4L7iIjIOH9LMEAAAAASUVORK5CYII=",
	convert: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnUlEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZkIMBoN0POqQJZig/L/IBqQTcA1eF4A0o9NEG4DNO2QZQCgsiA5tJPCfARF7jKQa8B9dgOouYMShgXYuAAC9qCgP+MlNhQAAAABJRU5ErkJggg==",
	convertNumberString: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnElEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZkIMBoN0POqQJZig/L/IBqQTcA1eF4A0w2iSDcBmGNkG4DOEaAOQwH8GROwxkmrAf3QBqruAEYcG2rkAAPjsJg8sltUGAAAAAElFTkSuQmCC",
	convertStringNumber: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAmklEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZgINTifCIGQFTFD+X1IMIWgDzBBchhHl15mQcGIgywCYZrINwAL+MyBij5FUA/6jC1DdBYw4NNDOBQDg7CYPDuLnvAAAAABJRU5ErkJggg==",
	copy: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmVJREFUeJxlU89LVFEU/u6d93SGkawWUjiLhgrKSIhUggiqfyADqaSWtWjROpAwDKQWFbWoRftQCFJsM6irNv3wGVEpkpgiY/4YU8fpOTPv3XNOizfznJkOnMXlnPN953znHiUiqLRrI19bG+oifbZSbZZCwjAhVzRp1zNOzjP3x6+f/VaZryoBbqV+DNladTorWSzm8vAoiNlaoSlmIRm3kTc0PHbj3OUqgLmtnejzyYXZuc2dxJOLx2GY4bPAJ0FqPoNnzkJIkoxb2GshfSouRx93XShoAHj08dfA3OZO4sPvLXjEmFjOwlnJYnI1i/0xG93JxhBg3jXIFCjxfsMMAIC6MzbVblg+D84sAwBGr7Tjy+o2brYmwCJgAVgEPzf+4vzgRAh0uI5AzB06WzT9zko2DPgsMMylYgEzg1kQr7Px7lJrmLdmFPLE/XpffaRlMZcPAx4xfAaIJXAJHAAONDZgpATisoIm06KJpbmsdhmgqoOS12tgzS1g0TXg5QUwFAxRs2WYqv6BxwK/xMwsoQ7RiMaRxhiSe6Lg7B/og4dgiKGLPi3ZWtV0UFksYAk6otK7tH/4xEs6k/emm2LWfyOUZ6eaUZgDAIs8eNDTOqrRk4zbIcDt0Sk8ff02TOaymBWiAoAuuDC+36PfdJ1x8oaGk/HdLqxjp4PCWvaS25EIfJbh9d5uR4kIHqY+RcdX87OZAiXSxd2NmJlJ1JodiUBEYJhj2y/vFqqOqePV2JAwd64ZBZcVGCoUzCIPuuAGzPeuVh9TpZ14kToJpgdC1EZkEoYYHiPtizhGVO96T9f3yvx/4x7QnhAe7rEAAAAASUVORK5CYII=",
	correlation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAk0lEQVR42q2TWQ7AIAhE4WRydDiZrdFp1WJDF35MRniyyfTR+DeAqmYRGYARjSEmETJVwmVUY4iwclksohUIZ6LcpxgFQB8yqNTUajVCuilVzcxo9N0zQG3lRPDZMDuCj1d3SPVtPRi7GwNcpuBBViXMY70sEsrxmjgHu4B+3vPIPN/lKntL8whw9kRuff77TG9tAxJwhVCGm0qWAAAAAElFTkSuQmCC",
	correlationConfidence: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVR42p2SUQ7AIAhD5WTb0fVkWyQjIbUEmNmPi++1EmU01qPfuN2vKU3B5eEt+yuY1qQkYMm26QoMrjX4QAattAFMHGsvO9NpoCKBUAmgaGALzzOBVVeYQVQQJB+VDwF7nlltFNA7ZyATtJJR4OH03tkMyul7vYinNAX9Fi/ZAAAAAElFTkSuQmCC",
	cross: "data:image/gif;base64,R0lGODlhDwAPAKEBAAAAAP///////////yH5BAEKAAIALAAAAAAPAA8AAAIklB8Qx53b4otSUWcvyiz4/4AeQJbmKY4p1HHapBlwPL/uVRsFADs=",
	crossHatch: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAIUlEQVR42mNkYGD4D8SMDAjwH8aBSYBpFBUwHThVYpgJAMxBCQRrBbTvAAAAAElFTkSuQmCC",
	crossStripe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAG0lEQVR42mNkQID/QMzIACOwCf5nQAOMRGsHAAhoBQVbShS0AAAAAElFTkSuQmCC",
	ctrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAg0lEQVR42u3X0QrAIAgFUMP//+TYkBAkNm0b5h7ufatVHloENRo5qCatafHe+9bKzDwEAthd3CIAAAAAAFyA3lYaO06/efhojAuYJ0ftGSz9rwF3E6XfLnxVLBXwZIc+/QIAojOQDlgpkA6wC2i8nUoBZAcAAAAA4D8AaVQ+TokKn+cnUgXvA0CKYtIAAAAASUVORK5CYII=",
	ctrl24: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAfElEQVR42u3VYQqAIAwF4O20dqQ8rWJkzLEh6Qui3B9rwfsMFZnOinFPBKwQNi4jPxEuEZbhVZ0tmXkBqHCNLGAK0DuLRd+aTNPvAckIre8wwAuRf+TCo4D+5j3/BCDqL/IwoBf0LvaOg7aArwFIpLkydQNZx6VvqajwMmaq2LfNglE6YQAAAABJRU5ErkJggg==",
	ctrlToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMElEQVR42u2XsY5EUBSG/xszr6JQT6KkUk5DoVFJlBIPoFJPJFNKVBoFhVannMQTeBXDXSQmViS7O3HHFvdv3HPI+T8HNw6hg57PJ+73O+I4RtM0GGMWOp1OEEURtm3Ddd0pJm3b0uv1iqqq4DgOZFnG+XxmAjB44fF4IIoiqKqKoihAbrcb9X1/ArhcLkyM16rrGoqiIAgCEEmSqKZpCMPwI+azPM9DWZYgw3OgSZLANM2PAqRpCsuyQIY1zbIMuq5/FCDPcxiGwQE4wD8G6Pt+OgqC8C3fdd1rPZ9b5taarxl2/L8DrA1+itfAY/5tAELI5t2NBZeFt8yYAmy19zcd4QC7vwPMAd75CnYHWBaYtdWROb8rAGtxAA7AAV4Ah/+WHz6YHD6aHT6cHj2efwFZV5tOVqxNlgAAAABJRU5ErkJggg==",
	ctrlZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAjElEQVR42u3X3QqAIAwFYPeAgo868AGrCYMhNfth2sU5F4Wm7sMikNIRZt7SgpRSiLR4znlq8VpruzfA7OIWAQAAAADgAvRvpbHj9JmHH41xAf3kUbsHS/9rwNVE6bcLnxULBTzZoU+vAIDRNxAOuFMgHGAX0Hg7FQKIDgAAAADAfwDSWHY4lcvK4/kOJewy8tE81EwAAAAASUVORK5CYII=",
	ctrlZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABK0lEQVR42u2XP8tGYBTGL8VXMZifMjIZlRgsJmVUPoDJLGVUJouBZLUZlU/gqxAvypNX6n168ucdXIv7HHfn+jmo+xDDqK7r4Ps+wjBE0zSY4jNEkiRomoau6zBNc46Jtm0HURRRliUMwwDLsqAo6hSA0QtVVSEIAvA8jzzPQbiuO9i2PQO8Xq9TjLeq6xocx8FxHBAMwwyCIMDzvEvMF1mWhaIoQIzvYYiiCKqqXgoQxzE0TQMxrockSSDL8qUAaZpCUZQH4AH4xwB938/XLMt+5SVJeq+Xe+vcVsuebf2PALYGf8Vb4Cn/NcC0Ye/ppoLrwntmpwLstfeTjjwAh38DpwN88xccDrAusGivI0v+UICz9QA8AA/AG+D2Y/ntg8nto9ntw+nd4/kPBtSbTs3WXOsAAAAASUVORK5CYII=",
	cx: "data:image/png;base64,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",
	cxn: "data:image/png;base64,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",
	cxt: "data:image/png;base64,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",
	dashed: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwjhowWAz4D0YMv5EE2YACv9AUYhWjjgEDHwajBlAGAAbTDhE8Ag75AAAAAElFTkSuQmCC",
	data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADf0lEQVR42m3TW2xTdRwH8O/petqe0572nN5b6GFbu05BUpbgNrNh1EgWRGIgJMsCySTxshfZxTDkYQ4SfdiLq09ovEQfNCJqjCGbMi8hLrhAFmIAzS4wttl27Tl0vZ+W04v/LWHy4C855//0+/zy/53voUDqwqXLbiPDdOcVpVNP002g4KzWoFdKD0q1GmRVVRc5lrmaLSgXThx9cRWPFHXl2o2n88XSZJ1GxzY3+mDjOZBG3E/nIKfzSJBTWs8gIcnwCGzJv8195Ln2lokt4N1Pvh7o6mgd11AUeI6FidFDVStIZgvkIc0EkVM55AtF+FwCOMZw9sBTu89tAa29w/0WszG8v60FuxpFeG0CWMYAjQaoVGqgCPywbi5FsBSVzp7q6foP2HNs6HWWYT7gzSY4LDycBHDbrfBvc+Ix0Y0dHhsyOQVRKYW5f+JYjklvnT7+wtgWcHLsvIHMmbkTk0IOwf6/QEJKYnF5FemiurCyGtk70Hs0swVcnr5+4vPvLn06e3sOjNEIq8CDN5shcCbscJjR6LLiyuwt9HTtw/mLkzjUEfpNisf6ht48Nb8JHB95r791ZyCMShkxMqmkljdltahAdAp4pfsl/Dj1K55oDuDW3CLqUK7G12JtqfX0ysjoaIJqOTbUzzBM2OeyY+/OIHxOGxgt4NBXUSpXEfQ3oEgwkgUoigJZlnME+JPMsCzMz++h2l8ePqjR0j+QJWoeLtHBmyFyFJ5pCyGXy2MtIaNC0dDTGmhRxb27d/Nr8bW+ZHL9C2rs46+cJVX9eWL6+m6Xy41GnwjRVNu8f3PAj3KlglSphunZm3DyxkyowWtOyImyLElLkdXIO9S3U9MDFyemxpej8a3vHar3oMnnwcHn94FEAX3n3keZnAJLY+TVHtxPyrlYNPpNNBb7knq2b6S/fVcwLLps4FgDCsUSctksOM0D+Ld7EGgKYIXgC/dW8Hi9CJOJgVJQKjMzVz+6s7D4BlniIFkiG94IkpMX0CR64bXzMJdTsNsdBKXBcRbodDS0Wi0ikWjm779uf5heTwVODg4eoTp7hzop2vATZ+bYR5PY4CXNlRyUbBJWAtWL2zH5y++V7sOH6sLj44ffHh39fjMHG68Dr51203pDN8eZOgTOErRaOKfHyeutjK6k5lIyhZpiMeqCf1y7sd+gpZ4kv/xnw2fOKBu9/wInnGoZdAhekAAAAABJRU5ErkJggg==",
	databaseSearchToolbar: "data:image/png;base64,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",
	datatable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAHISURBVDjLpVPNK0RRFP+9D98syMwUspHkm9I0YkFZWBFKkZ0s7a3Ewh+ilChK7FgoZCJFKYlYKB8zk2+Z5t0P577He29kQU7dd+6575zf+d1zztWklPiPmOozt/U4SThjXIoyIQS4AJjSXO0lGGlvcXAm6Vzsz4xUhm0AIeX4QLig+C+ZpxbOG1wGhGYHr1zMUmZGWRgs0ha3PE1nX/8mWmdgWTzLB+DUYbhm9FfZ35IEyrhXA3VXJfPbsV8B9LQUIeUHYJ8ASobag1jcucNgW8g9W4reYSDi2YnnZDoDiwCokDANct6NwTB0LEdj0HRA/wxa2SN25JNBEdWluUhZ366gqmAaGvrCAXKOozccTGPgt8+vn8GYSGcgyTYp3dpBnBg42nbQPRBTo5bTvqYkmxL6AQhNTWQGBXY3B7BxlEBXozcW64dxRKoKUZBju+P06gl5WaaviMJBM3TNDlbypemIZgHYOnlwASsCmW7nHADGnBoQ3c76YmweJ9BR5zFYjsbRHwm4tmJg6PhWA7pCXXk+bu7fURHKweXtq/sWaksz7SC/CCGFrwtyZ3r+rCnFRZ7qr1qc6mLZj4f9OEyPL8lVpbX/PucPv5QPKHB1TdEAAAAASUVORK5CYII=",
	decorationArea: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAhElEQVR42pWRUQ7AIAhD7cn06HoyN7KQOGkn88eItn0gSmL13mdrDewOXwLb66McyhzqYpZS1/O43RhFKHj6bqAoKIGJLdHwTxTSQKQNUostsGQ1zGCg0lMtsPRTG78IGAWYWP2A11YKrGImPLXyMsgI9x9Bdng7HSXItOBvfJjIoqt1ARvjaE9SPeI5AAAAAElFTkSuQmCC",
	decorationLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42q1SMQ4AIQiz9zKezr8cNA4mDpYrahdMSloKohzA3ZuZYbzBCBWp5p0Bss6zd1YpQmSAyEXhwgiKkHwFxr2JoGyd8ahfaX8iEeiYo673TglkYtDTqb/zfomsUZ2gA3Lfag2wICqCAAAAAElFTkSuQmCC",
	decorationLines: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAd0lEQVR42mNkQAK/mRj+s/5jYGTAA0Bqju47wODg4ABWx0iOAchqSDLgwIED/62dHBgwDABJgJxEigtgeohyAUwx0V5A1kBUGODyAjaDyPICPkuo4wV8LkA3jKJ0QFIsgPggm6niApLSASyj4ApI2gUiekYh1gUA5m2oEQdDgmkAAAAASUVORK5CYII=",
	"delete": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAp9JREFUeJxVk8tr1FcUxz/3/n55VFMT8gCtQ6uLUBqqCCbiSgqFgpa2mVIEQUo2QnFZioj0QQVduOhf0FXBnTQDpVJ3RkTETqXkYTudjRknhj6m6TiTYfL73XNOF7+ZMHM253Lvh/M9j3ucmdFry2feOOoGB7/GR7Pmo5yqoMlOVZOdoiU7X83dfbbcy7veAKv5Y4v4aL69WSGtbyEi2YOPiPaO4EbHIYTCybuVfF+Ayo3Phhs/L5XTrX9y29WniMHUhwtMX/4GQylf/5Q/C98RAX5sAoaGq63J3PQ73z9sOzNjNX9sMTTq883qU4JBMHjrUY2fzhyhFuDs7cfcOrGfAzHEDtzLY7g4Lpx6+HferX40O2eqj+prj0kNpvILzFz/FtTAFFMFU1Bl5YtP+OuHmww4kNEJnNkJrzvta+3NCtJRPnzxcxDFVDAR6HhT5bULl9hMM863mlhIr8Vu+KWZtL6FAAK8WPqRRhRlHeo2uOM1BJqacT4kpPHQjFe1gyKCkWUdHXqdqfwCmDH5wcdMvncegIl3z5G+cpghl3GYEVQPetVsVN1h1n/7tVO3ZWWo7J5rv6/gHLu8qeA1hA18ROee1sY6dOcvWQDDQJXGxjqDXRCHimx4bTWfRHtHcIB30Cgt96miCgYmQq20RuwyLjhHrPLEWzRwxY2OEwER0Cqt9KmaSJawCrXyGkMu49rmENUrfu5OqUgIBT82QeyA7Rf8W7zPyJtzu2McPPAqz395QNJssMdD4jxOtfB+WYvOzLh3/u1hXymVpbWds8Z/BIPNAA3p2zP2RTA+4EnUqs8Tm764bu2+Zbp3cmoxVZvPPkmS9aHTsOAcbXNd5f5l6rWl46NHgnE1qM2majlTAZGqUylGpl+e/kNXevn/AT0JpV86x3yxAAAAAElFTkSuQmCC",
	deleteSaved: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACi0lEQVR42p2TbUhTURjH/8fFRtlkotvSqc1tbmuVer2VRokiKb0QGVjQCMtIVxYSvTGIKCgqM2KIZJpEGWlaBvlCoqRZX8QaDA2TfCvzgySI3stkbrp1d8x98sPowOH8n3PO8zvP+R8OOWj98BDAaaEjzSRfgyBa7+D04j9ZQw5c6eQ0yXqpPyo3xwWTj5K6CTqOOX7wZN/Fdk7HbvovwIj9O09ySto4LWuigEf5aoxOL2Dkz8KqiTqFBFq5BMW1P2k8ah/kSVbxO07DbqGAJ6c0QVVQ+HRs+Qr2bzzJKGziNrJbKeC5JSGoCk5UDdP4l32AJ7tONnCxbCIF1J83BlXBsYohOv629/Mk1fySU7FJFHBmTzSyE8MDG4ft/YhoqINXq0Okhb40Zh39WNf0BpcdTvSFsTxhjzzjNqQkS1c76W31YYgVCiA0FLxaA2feUSjK7iHEUgS0tODQkNhFknJrODnDrApoK02H2GQCNIK58/PwTUyAWK0Aw8DX2oqC6i432bz/MRfBpAQAZeZoaJViqiev34axvhYSvR6IjwdiYgQndfAtLmLAVglzdJ6TGLIruHCGDQBar2qRdbaD6q7KHIwdLwD7pRchCQmAWg0olZhpbobNbEVjn4cnukwbF8ZsCwA6rumRYWmnuqdqL9yqOER53DSRAoRKlubm8GrSiZvhuTxR735AP5OU2UEh3TeMSC9cBrzovgB2doZqn0gEl0yGtQYDhXjGx5ExJXcR/2JsWimFrGdSpZ9vmQImTipVSFrywCfozqgojKTthLnnI2SCD17B1MwZhZusbFZtv0Mh5/JZycrcVGejKPNTc8i4LBILl2we/9z7u/d9llmH+KtI6n1tLCr/C8Ut4ia21HG2AAAAAElFTkSuQmCC",
	disk: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAU9JREFUeNpi9K3Y28fAwJACxAwWWqIsDESAE9de/4Ey57D8+/svRclAjRfEq4qSI0Y/Q96yR2D63oVbKUz//v5lIBeA9LL8/fOX4c+ff3DBu69/Mtx59ROrBhUxdgZlUXa4epBelj9//jD8RjIApACE8QGYepBelr+//zD8+v2XJBfA1IP0svxBM4AYF8DUg/Qy/fkFNODXXzDefek9wYADqYGpB+kFuuA3w89fkGiduO0RGBMLQHrBXvj5i7yo/AMOA6gXYKA7SopBWZwNq4a7L38xxGWtYBC3sYMY8AtbIAI1O2XuArP3TXdDMQBmMHIgYkQjOHr+/SMqFv6CY+HPnznvTp/4DEocsAQC0o/PDJhaUEJiun+4uAiYJOd8OH38MyyJHp7tAcY4Aw+s+R8kKUMzRRGI/nTmWMqs5T/xpqIv3379ZDhzDMadAxBgALae7bsNa2kaAAAAAElFTkSuQmCC",
	distributeHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwUs2A/2CEIUnQAtobYOj3H0P8/CZGxsFnAIYiIgAjnDhw4ADJBjg4OCAMGBRhQDsDiApJqhhALqDYAAB9FDERg324LAAAAABJRU5ErkJggg==",
	distributeVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42mNkoBAwEpD/f+DAAQYHBwdGggb8ByNMSZAB9g4O2DQyjhqAZgDFsQADhn7/4S45v4kR7ILCPnsGJDHGUQMIGEBxLJAKKDYAAJe2UhEjPBXbAAAAAElFTkSuQmCC",
	dna: "data:image/jpg;base64,/9j/4AAQSkZJRgABAgEAjACMAAD/7QG4UGhvdG9zaG9wIDMuMAA4QklNA+kAAAAAAHgADAAAAEgASAAAAAAC+gJA//H/7gMJAlIqAgUoA/wBAAAAASwBLAAAAAAMZwlgAAEAAABkAAABAQABAAAAAAABJw8AAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8L/tQylCasACAEAAAAAAAAAAAAAAAAAAAA4QklNA+0AAAAAABAAjAAAAAEAAQCMAAAAAQABOEJJTQPzAAAAAAAIAAAAAAAAAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EBgAAAAAAAgAC/+4ADkFkb2JlAGSAAAAAAf/bAIQADAgICAkIDAkJDBELCgsRFQ8MDA8VGBMTFRMTGBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAENCwsNDg0QDg4QFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgBGQEVAwEiAAIRAQMRAf/EAT8AAAEFAQEBAQEBAAAAAAAAAAMAAQIEBQYHCAkKCwEAAQUBAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAABBAEDAgQCBQcGCAUDDDMBAAIRAwQhEjEFQVFhEyJxgTIGFJGhsUIjJBVSwWIzNHKC0UMHJZJT8OHxY3M1FqKygyZEk1RkRcKjdDYX0lXiZfKzhMPTdePzRieUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9jdHV2d3h5ent8fX5/cRAAICAQIEBAMEBQYHBwYFNQEAAhEDITESBEFRYXEiEwUygZEUobFCI8FS0fAzJGLhcoKSQ1MVY3M08SUGFqKygwcmNcLSRJNUoxdk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",
	dna1: "data:image/png;base64,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",
	dna2: "data:image/png;base64,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",
	doe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MEgIpMDyPrG0AAAEXSURBVDjLjZGxSgNBEIa/OQJpRVJYiQTBR7DMCZYpBLVLKaa28xEsElLbJAgBMS/h5gHsDYi1VZ5AHYvL7O1e9s4MDOzOzv//M/9CEAqqoCiqQRGF6wVcvVAfBjYCFA0JLC+f/wFHBEZTyYt5AzhBkCTpzwp8ix3DNgIQhN+fzVkJXgCJrxu0SEgiiDUjWnqdBCsi1uSWzjfkvVwQyEy4Dlyt9fLcq0ceKCISfX8JDpUj+xE/gQdZVj3xypXIpsHl/uCEYIi0ofZ281Ss8A08Ah+dY8bndzwAaDGDc8tahtfBkTJwZENgtd9ldHqLzoflOkrj6FZvAUzWn/D1bt/RqLzlgT+9TaG9B4dnjcpbXqSKzrmdJ/gD9HKQM0jUN9YAAAAASUVORK5CYII=",
	dotplot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42r2QWQ7AIAhE5WYcnZtRrEuqUkmEOD8uE54zQhIRESMipEXMZQXFq44bkIfzRgfYGhIIievlB7ZP4QeEVnjfU1O0MMUTB+IA4RVMTSn8gPsV/gAnwx3g0QKY/8Q6P6ObW1BNWDGgAAAAAElFTkSuQmCC",
	dotplotLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42q2SWxKAIAhFZWeuKdeha3JnhJPRyEObjJ8UvKcLCoGi1ooxRggqMF9fSMEJ2AY0cVvYgId0/2zqgE7lnkyjGAtlDwuyAnQxt6GczFrwbA95NcTmghamXSrmruK6dQtIkCLmIAFcky2403av0XAwD+FiH/DyIf3Yggf4ImbATiiAnMlqfwI5aWNQRTjQ1gAAAABJRU5ErkJggg==",
	dotted: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJUlEQVR42mNkoBAwjhowWAz4z8DwC8phI5VNHQMGPgxGDaAMAADuwBQRkqnajgAAAABJRU5ErkJggg==",
	edges: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAIFJREFUOE+tU0kOgCAM5OirPfpU3uANbHUimDKMUZJeKLN0IaW/Ts65IF5zArhvKyUZiljCwIjDQWnCDVERkmyJOhHDdKVeF15C1AO1zBAMwpmIvYNlNggqMiNRBFw8UpHBixE8lkoG+7yNAEsl9uXu2WCp9O1W500ZP30s3ev5sgLi+dtLomkSqwAAAABJRU5ErkJggg==",
	edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAqFJREFUeJx9009o03cYx/H395tf1iZpqFJxpA1bwxZkageKFVR2UPCgp3YTKrMMPXj04mVQ/IOibIgwJkzF26biQKH1zyFbPOlhKhFqZ2UuVmyobTUhtk3T3y+/3/fPDmKXUPFzfZ7XA88Dj7DWUp/dN4a/bPkodCwsxAZHkFRGU6mpiaqvchVfHb29Z8tIfb+oH7A/83gwLEVPbnqWQsXF129rYSlYGXFIxcK4Sg9l+7/qbRgwNrPQ/PPDF/mxNwvJvyZn+FBSMYdlDhPrYjZ9etdWTwL8eO/5lQ/hfYXrZM5t59eLexBjjyl6OnmnrK4AiAPZ0W5l7IPf/5l6L76cHmb58Ajyt4sAzDsRvu49T7r9Y7QxG+VsTZ3MTc++F19bm6Va7aR5x0Em+74DoEW5mNIUr2oGV5uTzvKm0OpCxV2CL627yrZUnELpOW6ki9iWftyFe9x9Fgeg6gfEw3a1o43teHftdznT9Qc7U3GYy/CJHmVkqsj4+CrKiS84Nb+JUKIT2xRFBXMdUhm9BPenLcxlwB1lpgJO8TTlyi1+yncTSnQiWtsAUNoga4F+GZYCgHgoYHPrmwY8WYRsuZsT+U14ic8XsbCWQJuXsuj6T1ZGHADWx19jPcmfYx0N+PCjb5Ar2hcxgKN9fOQT2SwZSMXCAEQf3iR75wWftX1Kvtz+P25tQ65INKwqvSoqCAaEtZbtl+4Olmu6xzuzlx3fbuNfkyQ3HWE+kG9xorMBO948xq8NlQ719QprLT9k7jfffuXmi55OjuefQiiEaIoioi2IaHwprrkT/lQhPXf2e6/hmTZeyA5aY3peK0HVCAxi8WCO9pFelcDYodKhvsZnqs+aXzJdGH3car1Ba5VU2uAbJgJrc8qKI6WBXX/X9/8HJzReCr+o8qIAAAAASUVORK5CYII=",
	editNumber: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALZJREFUeNpi/P//PwMlgImBQkCxAQwgL4AwIyMjOtYG4jVQGoUP0wPC+FxgCsS/gPgqDj5BL3gC8R48fDBghMUCExPYLD0gbifk7X///nkTCoM0IN6Ii09MGPgD8Q48fJxeOExExOUBvXAenxfygXgfHj52LyAl6Qgg3opkI5wP04QMWJDYzEBJOyAtC8S3gVgKGiswvggQfwTi31jDAOg0ZiDFB8ScOPz+C2YAsisYBzw3AgQYAPe7bHJIc8toAAAAAElFTkSuQmCC",
	ellipses: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkElEQVR42p1SURYAEQisk21Hd7NWyBaP2PlJXjNNgiklhgwiQtiCuUZ0dSURkbXASPQ57h1Ise1o83oOHNhuSvZxcpATxjbatQMlzyIHb/AQwUcanRxsQQTaRXGgZwhw4WAhYB3Y+Z0AAy/YGDsQMprotlxqgi1Y4igmAvt/8HVajrD/iTG6wB9yF1Cok5v4AjrtoIs4vdJTAAAAAElFTkSuQmCC",
	errorBars: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42u2OUQrAMAhDm5Pp0fVkHQwmxdmi7T4X/BASX0Q7FFZmv8eCKAMeCBY5jMGoLQ3wYRHpo8fMiEpKgOgjW/yBVwpARHagqt8CZh+lAd77ARNAK+gF2NUFRjVkEbh0R9oAAAAASUVORK5CYII=",
	esc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAh0lEQVR42u3X0QqAIAwF0In//8mjGGKIuKRc1x7u3srpDssEk5Q4ZE+kVIurKrRyzrkIDIAu3iIIIIAAAv4JqMekF1HgKeDrziwD+k61+XdjIQDLGRW0d/18b71Xe2C26AgH/wQwgDcHAniyB7yuLJ0Do5ywvwAVBBBAAAEXwB52Xk5FNl7PT0iaywNJapmrAAAAAElFTkSuQmCC",
	esc24: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAfklEQVR42u2VSwqAMAxEM6etR7KnrVSsxBCVNuPKziYllHnkA4EcynktQlRKC2rEF+YaAm3eqFFpzxPAMreQCRgCeBvVDX8DhKsZAdjK8JTvaZEHbu9y9ydSAUzObWdkBhpEBVBbZAUhDpmiCfgjgAm5nEybYGo/+h6VZV7jBj5Or81hFKhVAAAAAElFTkSuQmCC",
	escToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABN0lEQVR42u2Xu4qDQBiFz6h5lRTWgZRaWdpokcYqYBnwAaysRbAMWNlYaGGbzlLwCXwVLxMNuCyDu6whjlt4Kn/ncj7mDOhP6KC2bRGGIaIoQl3XGOs1JEkSjscjrtcrbrfbqyZN01Bd11EUBWzbxvl8xuFwWAVg8EJZlrjf71BVFXmeg/i+T13XfQGcTqdVjFlVVQVFUeB5Hogsy1TTNARBwMV8kuM4eDweIEMONI5jXC4XrgBJksCyLJDhmaZpCsMwuAJkWQbTNHeAHeAfAvR9D1EUf13cdd1bpoIgLAN414gbAHtS3+fPjX0UYJwzZzi+Y9dP9fDhXQYwJ3bTOUgWjnsE3ADmYKYIVgdYcgem8Y/cAdZkLoKf4vnTCfDSDrAD7ABfAJv/lm/emGzemm3enG7dnj8BzVqGTrFYhBgAAAAASUVORK5CYII=",
	exactValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgElEQVR42p2T2w2AIAxFbyeDgVzACVzAgcpkyEOMYGza8kFoCKf3QCAAGX2QZV2msxQbwTiYOYcYH9ogqkELgFSAeuhdrwl0XUNo65QSzAoC4F/hE1tIoOtqVVACZgUxtkZB7KpRcAC6QiHsbZP58CSoEfINgEth3JwDML2C61tfAfWYBg2hAqkAAAAASUVORK5CYII=",
	exp10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAwjhoAN+A/Ev8/Ek3QImQNDGiaCdEoBmBzEVEGobuAAYsBeA0mJgwY8RhMMBb+E1JDcwMIgmFgAABCAB4N7Oxl4AAAAABJRU5ErkJggg==",
	exp2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwjhoAN+A/Ev8/Eo1LHVwMWQMDmmZsNAOaOrw24TIIrwsYsBiAzWCSwgDd6RguwAf+E1JDcwMIgmFgAABJFxkREs6UWAAAAABJRU5ErkJggg==",
	expandFolder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOUlEQVR42mNkQID/DKQDRkYkzYxkGPCfLgbglRumBhATnYz4DBh4Lww+A/AB6hkAM4RUwEiOrSgAAKjkJQQcORDoAAAAAElFTkSuQmCC",
	eye: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAvVJREFUeJyNk09oXFUYxX/3zXszGTKpCZ0kxBnapklBElsMTVtrUFQUI25SCMZiNy6kbsSNG6VYtQhZKFKsGykipVBBJEGpJKaCpkpqm0KtCa2tk0qYSWpnSDJO5s977977uWhsUxfi2X7n/PgW5ygRYb1e+OrSjkQ08o6nVK+rSGtrKPk6Ww70dCnQh8+82Hd5vV+tB7w8NjPiOWpg+maR+VKVwNy+eY6iJe7SXu9R1WZ04sCj++4BZFYqdUcv/nE9s1xJTy2s8F9qr3dpdMn21Mu29wefqDkAw+fmTv2fMMCNsiZfM+nJJX0KQL06MbtLWzn/+dVFADZtiNOXaqI7maArmcBYYcUPGZsr8OW1m3dAHVGDsXZ35IGhg59dzpc6jAiH+zo53r+dZ7cmKeQLnPjhAh+eniThCEee6WWgs5nzi0UK1RAtoKzZ4jTFIl3zpSrHnurmlYc2YUUYn5ljJpenpz1Na3OS8avzvPf1JG0NcT7t76LNE8pW4Rjd5RgrqcAIz3U0I4AVODpxDtfzOH1smOyJD9jc1srZzAJWoD4W4+297ZgwRBuTcrU1ABR9TSIawYowm8uTD4TstQzxuhiNDQkqlTJWBCvCzi33Yxe/Rbe04PihyXmO4o3J37By+4Pn9zxIpebT89oRHn59mJXSKo91ptcAcPKnS0ilRGhsLpIeeKk/tNIxtVDkm19+Z2uDx4FHdrCwVORKLk/Nr7F3cysHH99Jsepz/PtpPhqfwm3cCLH4z2rwi6leX9sLP96qACB+lTZ/mT2pJlJNGxABK0J2+S++m82wGhqcplbidTFCbXYpEeHpk2dHlnwzcKOs7zYmDJBKCQmDu733oqiGRtygig380cKhoX0uwJPJ6P4zf1avp2MqnfXXtuFFUfdtRP2riW5tFetXs8Hi/P47W/hHuz+ZGBFrB25pRdkq7FpcieCaAKdWJrQyWjg0dO+Y1qv747HtWPOuGNNrjE5rYwks2VBkWot6q/Dm4K/r/X8Dq3ySEVvXjw0AAAAASUVORK5CYII=",
	eyeMinusIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgdJREFUeNrEU89rE1EQns3a/EDq2lgE0QQ2LQRJSA9NIIVFtOg2ggheQg+heDEnD976H+Qf6EEkILTklEMEL8bAipDASsBL7HqSBEMhRNBDShKzdPP8Zk1EevGQgwMf772d+b5582ZWEkLQIuahBW1hAQnmbmalXAJuAzoQAYKzuB9AG6gB74HBnDcXkCDw0OfzPdF1fT2Xy121LOtio9HwslPTNDsWiw1LpdK3Wq32ZTKZFMF7zXm5BD/wLJVK7dfrda1SqUQdx1kJhULe4XBEDJC8/I19HMOxzHG5sixnkPVdv9+fjEYjwTAMQ7AViy+Fpt0Ruv5A4FZi7udY5jD3AlR20+l0ENf32rbt1lUoFJDZoYOD5+55bS1OJyefae7nWOYg0S4LHDabzZXBYBD1wzhAVVUyDJO2tu65BL/fR0tL6h+BnzBwvjJX9ng8vU6nMzVN00kmk6uKoiyjXrKsTxSJbJCiBJHdou3tW65wu93u5fP5N3iLV9wVtwUQ4W6kA4HATiaTiWez2Xi3273WarWW2Z9IJE7D4XCvXC4fV6vVY3U8fntTiA+PplPBAjJwGbgCkSDErmMN46zMOkRPHWcnKsQq6rUZaJ0D0hnWJr8BT9AY+I6HP8X1u9ibf0/bOtH9x3t7N85P4eHRkSP9a1Tv/h7NF2dEm+d9yP5R+u9/4y8BBgAeV+c/GRjpjAAAAABJRU5ErkJggg==",
	eyePlusIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAkVJREFUeNqkU89rE1EQns1udhOCrk2KlxIhaaGHFPfQBFJYxFbc+gtvkQq5+uPoQfAPEHJQemnFIAFFzCFYycGLGEgVElgMRhG7OTRiKiaVKCkYSTTbbF5nYuJBDxYy8LFv3sw384b5lmOMwShmgxFt5AIcWv8wGOUg4jhCQ/gR7kHeDuIjIoN4iWgOecMCHBY4L0nSJU3TpqLR6GHDMFz5fF6koKqqZiAQaCWTya+ZTOZDp9NJIO8p9aURHIhroVDoRi6XU9Pp9LRlWWNer1dstdpAQJJIdxSjHMolTp/L8/wp7Lper9c77XabEbLZLCNLJO4zVZ1nmnaO4avYME65xCGugFWWwuGwG58vmqbZnysWi2FnC1ZX431/cnIGqtUSDOOUSxxstEQFHhYKhbFmszntQKMEn88H2awOc3Mn+wSHQwK73fenwC805HwiLm+z2b5UKpWerutWMBgcl2X5AM4LhvEe/H4FZNmN3Q1YWDgG8e4juLm5vLvyPP7ZePD2Dm2Fx1EtPGzUarXtVCr1vVwuNxRF4Z1Ou1gqvRIbjS1QlMAPj8ezdbt6Vzhz+qwrV9W/Iedq77qrSzvkEYcQHlyNG180gd8j6MuDDYF12bnIpvhxEDgzcjHiX3uyZgDPdVGGBW6gRkp0Imjv3D9yW5GfzUdOHP37+kV6/Q33X60uSqhL6R4wmCV35oIyu/H4XfG3DKEo7EvwDK5AF6W+y17vWKjqnz0AOxfEkUDY919TxxV2WXH71iYgsUhkmJBgT4ABAOtC+bduhTyuAAAAAElFTkSuQmCC",
	file: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAXhJREFUOI2dk71q1UEQR89vZiMWShJDKhWujS9goWKVRh/Dx0jro6T3KbSwuSBYRUzjB15CQItoBO9+jMVu/lyiIXin2Z3dncMZdlesxNHHw+A/I11c2Lo1o7ZGbUFtgZlIydhwI7mTkuEmJPH50/u/AW4CjKARQGtBrYF6hgTCMLvEwK0fdQQBCGptAL24jkJ1gg5fP3pO08FF0M3ZPte2n1JGK0GQ3EhubKTezvHiiETjxY3NO+zefoBwkHPydc7Z4oDrO8/wASwtqLUhhNTbAUi1ttnm9i4tf0NKIGdr5y6n319xMt8DXXELJRdMv2jlN5KDEibn3v3HIO/QYXa+D33+4d1LUl5mov4ARGAgmw5MRaQVQM8lJ+dMyrkMmQAqRAUyEeer1q9igvlklpdlFXBZtEGqE7TbipIzqSzzFYB/RQBBzsNg/uYtkmEmzAyZMI3RDEloPF9bmY8WMk/2Hq5hAYsvx6RosbZByaX/hZ+nZ2sZAPwBqhiaxc42syQAAAAASUVORK5CYII=",
	filterTableConfigure: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42mNkYGD4D8SMDKSCmf9B+sAacRgAUQCUYqSNAVBAXRf8h7BBHEbaG4DNCzgN+A8RB4oykucCmhgwoF74DwSMs1BdQCpgxGCQCxhhfqHMgHRoYiGDTbELACOjZY4CmrSxAAAAAElFTkSuQmCC",
	find: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACM0lEQVR42pWSTYhSURTHj4pihikimcxA+ZHhKiyIQKdAWqSDiDAgjrbRSNSFC0HMQEPRQBJS8AmBRovJTbgSXRY4EQlu3CUiBCZZjvFwMB6ide9rJuY1Bnbg3D/3Hvidr8uCE1Yul3eQPEB+/eipjfy52+1+Df8wFj4IgriCJKhUKn0ajQakUikdHI/H0O12od/vF9E15ff7P68E5HI5Qq/X+7RaLZAkCdPplA4KhUIQiUTQ6XSg1WoVg8Gg/xQgk8nsoqx7RqMRBoMBzGYzWCwWdJDD4dAQuVwOtVoNx53hcPgVA5BIJJoOh8PA5/NhMpnAcrlkZGCz2SCTyeiqKpXKfiwW22IAotEoFYlEeKPRCObz+cpBYThuJZvNkul0WswAhEIhKh6P81ZlP1mFWCyGZDJ5iCBCBiAQCDSRG3CZFEWtBAgEAhgOh1AoFPaRM1vweDy7Op1uDyk9wL8ND5LL5UI+n4der+cslUrMIeLD5XIRNpvNZ7FY6A0ct4JLx4BqtQr1ev0rWvV5r9fLOgWw2+0bSB6hf+AzmUygVqvpIMoIjUYDf6RvCDS8vRW5+izThh+Hi1sfB/eafwDHZrVa7yLxIb9x9NRCXjSbzY2XLxSgUInAoD8LGEKSc+OX7/ffsGBNO3eG+HlhYxNUKglsbwvhSeodTA7md9YGcOHpTSTvxaKLcFktgR27BKIP38LaAHqokEKtsT/wYBMuKSRoRZ/+D/DbHl9DkDYb1bQEyvkLPezMRnAzq2cAAAAASUVORK5CYII=",
	firstAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42u3OQQ7AIAgEwOVl+nR4mS0kNqYlCJ674aSyDg3gHoBs8mHmuWcN46Sg904UCeYvGn1cFuwKXMG6tCYt0IvWmj0SERwJvIK3pixYz2ZBSeAV/IJAgE1CQTYfgTBX9h/JBTbMswmbgKoPAAAAAElFTkSuQmCC",
	firstAxisTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAwUmzAfwaG/1CTMAw7cODAfxjbwcGBEZsc9Q1A1oQMSDLA3t4erOjgwYPUMwDdNSQbgCw2agCaAfgSDy6AHKWU5wVsgvhcgZ6gKDYAAIvMjIdmoEiUAAAAAElFTkSuQmCC",
	floor: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOElEQVR42mNkoBAwjhoAN+A/uYYyQjUjG0QVA/4jyTPg46MrJlojPheQbQCxLvmPbgBFYNQABgYAWmAVEXFss5sAAAAASUVORK5CYII=",
	fontSizeStyle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABo0lEQVR42r3TvauBURwH8O8pYlNWZhaDQREGGWSkzJSXhUESBgYyWKQsykuKAQMpJZv8C5RBoZQiAymTt999HrfuTYZ7b/d2z3Q6ffuc5/t7Ogy/XOzPgcViQZPJBHa7/Vv4S8jv91OhUMBoNILJZPoSeQkolUpaLpfw+XzgoJ8BjUaDQqEQXC4X6vU6ttvtzwCLxUJCoRD9fp8JBAJqtVpwOBxPmfV6TXK5nL0Aq9WKFAoFyuUynE4nMxqNJJVK0ev1HpnpdEqRSAS32w2XywW5XA5qtZp9APl8nlKpFPb7/eOsVCpRMBjEfD6HTCZjzWaTuNvBISwQCBBXD51O5xMwm800HA7BfR6u1yvu9zt2ux2q1Srcbvcjl81m6XA4YDweQywWo91ufwJ852Qyyf8FnM9niEQiZDIZSCQScDCz2WzE72u1GkskEsRVQrfbfQfC4TAVi0WcTqengVUqFfJ6vZjNZvB4PNBoNLBarYhGo3wtDAaDd0Cr1ZJOp+Pn8ARsNhsyGAyIxWLQ6/VIp9PgB6tSqXA8HhGPx9nfv4V/B94A9QizEV+4wUYAAAAASUVORK5CYII=",
	format: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwUsOA/zCD/kPYIA6cz4iw5D8Wi/8Ta8B/Buyu/Y9TEovtOA3ACog0gIE2BqBpppoBWPUQCjzSXTCwBiBrRktUdDKAHECxAQB26DIOz80UywAAAABJRU5ErkJggg==",
	fullScreen: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABeSURBVDhPtYxBCgAgCAT9/6v8mSkUWK1lRQN7KJyhHCLx0iBZx8yyWy0oTwEg2/qjCCC27QNA8v/rgJfaPPqOA6Noo/keB7BsJAKxbFwEeg4DM4nAmn+B01X9NUBUANHihzxFW9B2AAAAAElFTkSuQmCC",
	funnel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB7klEQVR42mNkoBAwwhgb5gpFASk/IFaBCgkBsSKU/QiIX0PZd4B4U0Dyu2VwA5ZNEdwtLsrkIinOxMDLzQRWxcHOwMDFCTH/2/f/DD9+QnR//vqP4fnLfwwvX//bE5Xz3hWsYvEkgf8/gQp0NVkYRIUhBvByM6IY8PnrfzD79dt/DJev/2FgZWVgiC/4wAhzwX8mZgaGW3f/gBWD2D9/ImwFGSQkwMTw799/BhEhJgYDbVaGuw/+MgBdADFg4QSBaawsjJkfPv9jYGZiAHuDh4cR7AopcWawJpCXQAaCvHDj9h+Gl2/+TQe6IAseiDM7+XuBhhRB/M+I1QCQ646e/g3U/HdievnHApRYAIEpLfx1QL818vMxwcMAZgDI+TsO/GT4+Ol/d07NxzKMaISBnjq+IqA3ehVlWYD+ZmQQF2UGB9juQz9BAVlT0vSpFWs6QAat5bzhQGqFvSU7g7gIE8P67T8Yfv/5n1Xd+Xk6zoSEDmoLeP77u3OAQ3/+ym8MzRO+YFWL04DSTJ7/4X4cYP9PXfCNoXs6iQbkJXH/jwvlBBvQN/Mrw6R5X0kzIDOO639aNDcDKwsDw9SFX19MX/RNkiQDEsO5LsUEcepu3v2D4ePn//XAcGgiyQCg5kx2dsZpwCSdtWTd9+m41AEAxqy3EaxL75cAAAAASUVORK5CYII=",
	funnelCross: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACAklEQVR42mP8z8Dwn5GBAYhIB2C9/8E0A8PGuULRQMoPiFWg8kJArAhlPwLi11D2HSDe5J/8bimIwwgzCURfPyDKwMvNBFbFwc7AwMUJcdi37/8ZfvyE6P789R+DpgPELJDLwSoWTxL4H5P3ASx4/7gYmOblZkQx4PNXsB0MipavwPSiCQIM8QUfIAYsmyL4n4mZgSE88z1YsjqPh+HnT4StIIOEBJgYKto/gfmntogw3H3wlyEq5z3EgIUTBKaxsjBmfvj8jyGz8iNY0eYFQmBXSIkzM4gIMTEI6bwAiz88KcZw4/Yfhpdv/k0HuiALHvozO/l7gYYUgdiJxRDvHFgtDDZAzQ7i7DeXxBmOnv4N1Px3Ynr5xwJ4IMLAlBb+OlZWhkZ+Pia4d2AApHnHgZ8MHz/9786p+VgGE8eI/546viJmJoZeRVkWBmBUwQN296GfoICsKWn61IqsHmsCai3nDa/q/LwCWaytnDeruvPzdHS1WA2ApYuz20XAoQ+LOmwplhGX5rJMHoZwPw5wDExd8I2ha/oXrIYwYtMMUpSXxP0/LpQTbEDfzK8Mk+Z9ZUSWxzAAXTIzjut/WjQ3AysLA8PUhV9fTF/0TRKbOkZsguC0EM51KSaIU3fz7h8MHz//r5+/8lsTNsuwOgsEgJoz2dkZpwGTdNaSdd8xQh+mDwBKqMUL3B5gSQAAAABJRU5ErkJggg==",
	general: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACLElEQVR42qWT0WtSURzHvydTYTa9Iuium1aLVq21O6+yVVtB0V5iUAQVCFEPo7da9K8UvUdEW26MiGlPtb05mTW2wunDdJF6t9qupKbX6T0d79NEC1qHA4cD5/v58ft+z49QgO39L1IHEHbuR6xp9wIURaE7OzJ4voMsRT9SaXMLlYqCG9evEUnapEajEVYrR1oCCsUiXVyMQJIkOJ1OJJMp9AsClpc/oZPd05lsXYyR4fNw2O2kCZBOp+mbt3PwDHiwW92FxWLG960fMJvboVIVtVoN6+tJnDrZA5/XS1q2MBcMUUoOsAoO5GSZiVT2SIWV41BWFCQSa7g/Pt66hfcf5mk8kYDoEVEqlbH6eRV6/UFUlArc7sPoPtaNhYV5nOnrw4DQD47jSAPg+YuXVBRF5At5lBng68YG7t29Q4Khd7TMIDzPw2g0YHtbhpO343RvbyPgydNntFqr4uzQOdYz1czziR58icXQ4eDh7HQiHA6DqirGxq7C1dVFmjx4HZim7WYOR4+4kf6Wxq9SCQa9QRMXCkVEImFMPHxA6nGzSBsBmUyWzszOwiv6NHtsNpvmvE6ng5zLsQpE8+XCyDBO9BxvTiGbzdLJqQDaTCbk8z8hsxT8fj9CwRAU9pnaTIfAesPlSxchCELrGFdWVmhsLY7bt26SV5NT1GyxIh6P4fGjCRKYnqGcxYLR0Svkj19570qmUjS6FIXL7cLQ4GDLWfkr4J+G6X/G+TfnJiAAMYYfXgAAAABJRU5ErkJggg==",
	general1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42mP8z8AAROQDRpABjECaHM1gvTQz4MCBAyhec3BwYKStAega0AFRBtjb28MlDx48SF0DsLmIJAPQ5UYNwGEAAwkAwwBSNGOkA3I0wwAAZwGL8Tu4vJsAAAAASUVORK5CYII=",
	generalH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42rWSUQoAIQhE9WTO0fVk7hJsGsRSSUMf/cxzBmUqip3Ij83vawBu/z19vg5Q1eUkAHgKEJGUL4XyYJvZRUC5AiCzoUMaU70IqG8BiKHpvnKa/y1UAaUKq+aeKgN2zVFzOLczPepcfBGjCFiyAAAAAElFTkSuQmCC",
	generalS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42rWRCwrAIAxD7c169N7MqaC4rZ9YMAhCNeGRUi2lnbyoB1C7M+bhnQEiMkiY+RfW37T5K+D70TLtc5jAInEJEKJ7HSBdQARRkcdbcEvcCTzssINolVAAIrUDbRPWrRKcagVkzFMP3pSz8SclsIYAAAAASUVORK5CYII=",
	genome: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVR42rVRQQ7AIAiD/z+6ZmZIBfWAmzFGqpa2qlwOhQj6pk8fOzyeMcEgfe6ACsbFlgWBegPZ4knBdQau1si4jmdTEogEpHSyzEkQiJICOBti+OUMks6jBw7hIwUYaejLe669PyJBNrCqzRrqCsDvfv+FtQnCG6oQSgOzCH4DAAAAAElFTkSuQmCC",
	gradientDiagonal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvElEQVR42p2OrRICMQyEe73+wXOhsFjsWSwWi8VisWgkiueCJpMyO5n2bnpiJ7ub5psOxnx3xpiQtenQNivR3ZABewAk9XApewIcBJDgQWpk7RlwJKOOimKjL2LABIAIR3MzIuAkgLhCjgBnAQQpW7PWMeBCRkp8UJPeMeAKAA/LlsfMgJsAPCy8Umj4kQB3AbjKYa3DngEPMmrhZjx2DHgKwHVoRMArG4tlx2TAu4QVsgT4wA/+i4VcOvsD4g0dlXTiNAIAAAAASUVORK5CYII=",
	gradientHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIklEQVR42mNkYPivyMDAwI+E+QjwUcQYRw0YNWDUgOFiAADKFh/xdBCOQQAAAABJRU5ErkJggg==",
	gradientOrientation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42mNkYPgfw8DAwI+E+RBsRm8GAoCRLgYcOHDgv4ODAyNZBoA0o2tCNoxkF6C7huQwoMgAZO/ADMEaMPgAFhdQBog0AOxNigzIptSAKkoN6KTUgOmUGrCMUgO24pIBAO9ENMZmhtGfAAAAAElFTkSuQmCC",
	gradientRadial: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAl0lEQVR42q2TsQ6DIBRFH4lF+WsHp05unTo5+YUgNalgn83N1e1pcsJbzokoOJHvLCIZWGBe5fc0Ba+0MHtXAhNIvH408CD5v9bAW4UrMNBeUQOvMiQVEsiJAh2Ix9zVwAgCwwFmf4MnSRHmrAEPUsBIDQwgRghECgQIHOyBnmSEAyduCZi3YP6I5t9oPkjmo2y+TKbrvAHE8Ik9k/2dRQAAAABJRU5ErkJggg==",
	gradientToggle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdUlEQVR42mNkYPj/nwEnYGRkIAAY6WLAgQMH/js4ODCSZQBIM7oosmEkuwDdNSSHAUUGIHsHZgjBUCbCBZQBIg34HwAkfkE5bEDMCcQcIJpYA7ywGMBJVwMo9kIkmgEcpBqQCCR+QzmsSAZwEGtAFhYD2EEYANRJOxMTsUqnAAAAAElFTkSuQmCC",
	gradientType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVR42mNkYPgfw8DAwI+E+RBsRm8GAoCRLgYcOHDgv4ODAyNZBoA0o2tCNoxkF6C7huQwoMgAZO/ADMEaMPgAFhdQBog04H8mkPgBxL+hAqxAzAHCxBqQCDXgF1SAjVQDIoHEdzQDOEkxIBiHAZx0M4BiL+AMRAAy50HHRG0GngAAAABJRU5ErkJggg==",
	gradientVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkYPivyEABYAQaYECpAfaUGuBHqQExlBqQTakBVZQa0EmpAdMpNWAZpQZspdSAI5QacJlSAx5SasAHSg34T4kBAK30GQIan/m2AAAAAElFTkSuQmCC",
	graphOrientation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6B6nA3ugAAACaSURBVDjLtZNRDoQgEENfjfeSow8nqx+KITpBdjfbhGQ+oLSlyGCBIgLAAKUUMYkVICLMl1jasG3baJ+HCu5oik4rTkj0UNCjqfGxdM5yd3BI8LgGpLcMJkhQYuciqLWSzX2KnYWLVx4krJtn8wxBLwXwJxazk65HQ1OUUrTOtC0rWa2ViGCKIAu1CV34F85nc0S4x/3j/WqBHcw6SJbtGdSxAAAAAElFTkSuQmCC",
	graphOrientationHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6DtAcZkwAAABpSURBVDjLzZI7DsAgDEOdinvB0Z2TuUs/QagfYGi9BAYHPwsTKgmA9UzTaRxS2g9OvjaVUiwuOF7POT+a3b26LxsLZhC6+RlwU2i1iXcjRQTNIEx38H0CCJAAkdSVSOq/HYz+g7aD0QQrWJJFRWqNZSEAAAAASUVORK5CYII=",
	graphOrientationVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6FsNw/hoAAABuSURBVDjLzVM5DsAwCLOj/is8HV5GF4SiKANJhtYLEojDYOiAAwABIqCqQPhHiAhnX8OQeIK26rSDJyZwVfXTApnYe8+AmZUp8JZCefSZpogwd1ApsKJ4fYXvdfAjJVbEs4oz2vsNhfjm3MWWfQEXtyLyxFk7CQAAAABJRU5ErkJggg==",
	graphType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAn0lEQVR42qWTaxKFIAiFOSvTpcPKKOJKaTe0iX4405zz8VIws9ZaQRGqfiL+3TVn4BtANQC76zCClDKA6WCyIxHwCtDMJ+TSwg2gPz9cU2qla+YGWQZ4C26OCZhqHVC6trotUBIGzzSgj4HHHev+wROkFYwr+idqWxBmKqWQiJDNhFmebiIwVjAFzCp4MYN+11HBkLlVhOylLQMy8+webGQ5ygXpKrTcAAAAAElFTkSuQmCC",
	greenCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQuBLjdbhkAAAIWSURBVDjLhZO9T5NRFIefc+59+wGIrZiyK3nRzaEY02BcmHSQSEyUyODk4NY/pIkhxBA30+AgUgybYTBOxjgYxsbY8uGAkIAIRmh7r8PblhYwnuQkN+fe89zz++Veebu0tFNvNFLeOTyd4QFBRRCRrXvj4xnOijelkv9fbG5u+vmFhbmz+tX76N5KdZVKdY3q6hqV6hqV6ioAxbk5MpkMo7ncw/lS6dVpQHNhrSEIjtNaA4CosrW9zeDgIDdzuQcLi4vznQBLU7mqRVXaG85F9XBoiHfLy3jneDQ5ifd+ohvgWxMoIscAYzwHvw8YyWYZyWbbdTlhtW1rUdMGqIBVJWjUOfy1y5+6A+B8+gLnLGcDWppVIGaUZNwQTqcAKD/dAQ9hIUBOALRzAqOGRBCQTMYJp1NcvGuiEzaAIACFgTuG4RnrTwGsUZJxS7wnRvisj4HbyuG6BweIROngcN2THlOGn0eQNiCwhiBmCQs9pMeU2jbsrzjK+aMI4jzlfI39FUftB6RGlSsvrO8yEYl88EedaAE1XbrFgq+3JDSdN8YAQjlfY/eDQxT6rythIYgAaggLAf03FLHw86NjY6YxparafnEQwcr5GnufHJqgy3WxoDHY++z4PtuY2v/ii/KyWHzf29t7y3kP3qMiJKyQjiuPv07gHcxeeg3Ak2/30QRszETNTYFcBlInP0nfNbnKP6LVDPAXG4PRfNQ1H3kAAAAASUVORK5CYII=",
	grid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAwgoj/YESWZka4AYxQw7Dx8amhngHozjt44AAK397BgTQvYDMArwvQNaADogywt7dHeOHgQdK8QMgAXC4i3gVocqMG4DCAFIBiACUAACUIcxEomAXNAAAAAElFTkSuQmCC",
	gridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKUlEQVR42mNkoBAwUs2A/2BEsmZGFAMY0Qwkhk9dA0a9MOqFgfcCuQAActNKEaLwWqoAAAAASUVORK5CYII=",
	groupSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAe0lEQVR42mP08/ObxsDAkAnE0zdt2pTFQARA1sPo4ODwf/LkyQy5ubkMBw4cYCTGAGQ9jLq6umDTlJSUrm7cuFGHGANgesAuQJb4D0YMDIxgRBwgyQBs8oPcAEL8UQOoZQA5mckzyPoK6x9hbQaqZiaQaZcvXybKBch6AN9MZ8kuIDQPAAAAAElFTkSuQmCC",
	groups: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdElEQVR42sWT0Q3AIAhEjxnq/hPSGTTSatBQpdqkfAH6LghC2DTSQQQOB3CWe9knA+YBH9SdUAVumB1QkxeBCfwkILA8I0oBUxidyL8CTc4jMOrPqwrYOludQu3DZwLA6kfKXrcDnmquBupdMIRMK/NX8Z4l0MwyMzDpAGsAAAAASUVORK5CYII=",
	handle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAUElEQVR42u3SwQnAMAwDQGlZeyZ7J8/k1KEpJCHQT38VGH3uJxN3RCSxxN1ZzQHMbDVQ1Q55ApWIKIQJkURmPv2jr9FxljHwdRsq0Ad+8yoNvcu0XQDURfEAAAAASUVORK5CYII=",
	handleMT: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAQCAYAAAA1Qw7OAAABGklEQVR42k3QsUsCURwH8O+DG1o8QXARHK4mFyG4RenCt1lHkeifUSCGUTQGbbXUFAhuIYQYNHlwYOLm7pbggYsgqDQIhX1/wqUHj/t9f5/H3Xs/hf/nYAXs8/2kJKkNlAlv6PdbsG1bER7ZSGM43INlZbihxPUs4BKWmExeEY/fs+lhPG7Lp14IZXjeOwzDgNbHayQEhCMGF0FwjmQyy/om/HmR+I3ZrIFo9JA5H8IVoU3oEArMuyFUCD7m80+YpoAVwinhB4tFA5FIjjkn8LWSAjjjMa+RSNisLwQeCHfw/SYUr6X1CaElUCL8YjqtIRa7ZfMDo1FPoEMwMRjsIJVyCZqrpraGWOWGOrrdJhzH2YbL9cxkgJL+AA2wVq67F3GJAAAAAElFTkSuQmCC",
	hash: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVR42mNkoBAw0tKA/2jy/7GpH3wG/CfV27hcQJTtw9QAqgQi0bYPXgNIAhQbAAADoxYRtMnqwwAAAABJRU5ErkJggg==",
	hatchForward: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAIklEQVR42mNkYGD4D8SMDEgAxkGRQFYBl0DRBpNAFwRLAAAAogUFS9iA0AAAAABJRU5ErkJggg==",
	hatchReverse: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVR42mNkwAT/GdEFgJiREV2AAUYgC8AEUQRAAAAATgUFPIeHBQAAAABJRU5ErkJggg==",
	heatmap: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYUlEQVR42q2QQQ4AIQgD4WX06fCy3XBYJe5BY+FiGsLYVoUcrcLdnytAHgLQfM1sLCNCDJjaXdZ9D6BGoAF0B4AVYMjOUQ+gRqABdAfrDztHPYAagQZcdcDMD/C5yE5O9AtM259EnSM6xAAAAABJRU5ErkJggg==",
	heatmapHighlight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAjElEQVR42q2SQRKAIAhFYd9tag9Hh33dpr1pjUXWpEVsHAZ8fj4iOANtIiLhEyBdZGZMJxHtRVUFYj5yESjr/wDsCG6AzaljKENnOXsQRlgv4QC4jXK8EEa8AGAwsKioDdDHlgkdgCcFbg8uayxct4pEtOEffAHYEdwAeBlYa8hbypuqArKK5MkdoKwvKfGeRBaxMNAAAAAASUVORK5CYII=",
	heatmapSeparate: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAc0lEQVR42t2SUQqAMAxDt5M1R29PpsuwWqeCrH6ZHwmkwTxWS1I1GlVdoheRYmaPfi/gIYDKL0MUg34gQDHVw4fMNwXpCa6laQpinJCGCMg2x06bRyadQePyRwZxnx+Qy8ikZ+7eQbogBXFGlwL/CzJ541fgdr6+KO9gOAAAAABJRU5ErkJggg==",
	heightSpace: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwDogB/8FoUBtw4MCB/w4ODoy4+HgNACkG0egGIIvhNACmEB8AGUI7F5AVBjAOIwkxMtwMIFYTLkCxAQDaH0P5mgJrvgAAAABJRU5ErkJggg==",
	help: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmBJREFUeJx9k09IVGEUxc/33pvJMZ2mxiCY2WolFANjQtDCKIIIQcOVtBDatTJo5aIyENoUroKEtrr0rXLTnxFbhIwyGg3+KZiccRQsnfHNjPNm3r23hfScl9HZfd/9nXsuF64SETTq4teBy37lG9VF69KhRYkJNtdyNteTNteeZOMzy428amwQSw9O60rr27C3sUcWCAQA0KGhBQGEJYg6O+ZG90y/p8Gj3HjTrLW4/tMpRDO1PP6nMLUiQP5cpHym/fPNqaoBAO/256eKVHLNfaEexJo7EAucR6aWh1lIIGEtAAB+6RZC3Bz93rQ9BaBfdaXvXWHI/GJlxU2RePJY8vjWJB7mX7rvtnILmLlbq3JtbMPe9sBP8xOIJQYQensV5tYHAMBQWy9QcFym5K+irmhMC6gTnXtkeRqMbk1gyfmGYshGitcBAIW6BZTIZWyDoOrSaYhI5M+2PTptYCjci+Fzg4dTrbwCtKOyKAETRwzif5gBfOx4jZ7WOFLlVQwvPcfsThII6h6GhKE5TJt6Y+u/ZGbfY3ZvAQj7gKDh/isBiGnTKHEl3YJApIiyxzicfYFQKYBMMQc0a0DAG6KqABmc1nysj4QleCw51TmJRPcbDF24C5zUj9U1i8B1GtFW42ayzo4ZplYPkLAWkNhNIrOTBXYdr3mfQWCT7ywnlYjgxtz9pjUjt15SB9GCr3JEFhygLoBPASHDNUuFcvLjoF0erFU9x3T20/VpsPSV/FXYBkGUuAtT1cOxCWzy7SXvMTXq1Ny1SyB5JiRd4nCUhEGgHClOspLHfCv1pZH/DQCsPJc3oUS/AAAAAElFTkSuQmCC",
	help1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAopJREFUeNp0k19IU1Ecx3/nur9KluafkKVLA4WQUbaI6MkejLAIqgchsH8vKSbMiBUY0kNImBlaFhgUBD1ED5Eklr301F/dFGEiOp06mzp1c/fPzr13p3NuOra5fvC5v8vv/r7f87uHcxAhBAbHw7AVT17/yqHpMqWKcpDCUVyb9DVePLwCCYESDbpf/WgzGXUtleUF+sK8rIz83Vkcoj3Lq4K6HBRUtycgi5Lc1VR/pDXJYGAsBN0vv3VYLbsaqo/vNwU2VLQuqBAWVSC0KducATspRdk68vX7tDTpDT5runTUETeoaf7YWlaSe9tuLzO7fALIKoGfM9OJk4LdWgo6Oo+tOBPcLq84MbXy8MaVY62ouuF9kcmonzh10pblXpCoIcCwzwu/204kGVS1fYFDxfu0d5vFTD4PjfIRPlrOqbJytbJij8E1J6AoVgHLqiaufz4ZhwWrsW+MkVkeVZQVGJhWp8hKjWow6yIRJb5aXY8H0gUTa5k9sjOZ9rROwUpFUAIOYzWt6J3jgJbPdY4n1QORDI5qS6mLLC+vSYQghFLF/U6blmvb3dunwQpQLbAxpkReKEAGE4L/RDTNdATjGNXOs18YVNbW7SQn35DaZG3u13LJjsJtBigUUqh2iKMuL9bm/TgalcnWLm8x87hWI7XOxl/1zWGq7eM8nxr9Qpjvinino6mNibufSNjrlcQw/9TRcsajncTeAR88uP+2U5+bd92412pEHJd+P2IxkBZ8kryy1HvrzgXtKHP/6gRuOs87pKVAx8boMC/4FzDmxZiixIAhC2JMXPTj8JiLl/4sPmK9TMPQJujpn4kv0n7vjYWma5SzlNLN8izlA7vOzrt1SZfkrwADADHTjb87FtdzAAAAAElFTkSuQmCC",
	hideSelected: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42rWQ3Q3AIAiEYTRHYhJGYjT6a4NUEy5p70VB7wsc0yWnUUxFHR994S5BKoDnWVVJRBgFnDIzb629+ugKPgNUQvQJjMtBhfF7TXtdB0RINEOAlSDAPQXDgG7MJ5xBv0MZZGOu/5/gswwiKPY2EsdSEZXS9kkAAAAASUVORK5CYII=",
	highlightSampleLabels1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42sWSUQ7AMASG52QcnZO1s+xB0FaXLfNClT9fFRzGmLmpJyLI8tkd+CY9PxbIYm9lAvWIeBWJSE3Ax5mAp9kmsLkgUCGYCvxD4AezTTDaxNEehF9YFa1sKGBpzqDdxWHo3wm89oTZANV3nUa0EcV8D7YAAAAASUVORK5CYII=",
	highlightSampleLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RUQ6AIAhA5WRwM9fN4GRUmwZrVDhdfDEGz4dAmQyIisysacDZTETQh3qOiJt1uXfU2CJS1wGmVzgmtH1Kq5mBepyzEea6DrD+CkSXARTjeZv3K2QBkdbQCtnGYcB9pSj/x+ApPg2ygB0TwY6HFKPU9gAAAABJRU5ErkJggg==",
	highlightVariableLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR42rWR0Q2AMAhE28m4zRo3g8nQGBGSVtNG5AfSXB53pZaPVUePzKzTABMDOGfrRLS5KuxRZ4tIywWkRgDcgUZccCPMLReQewXgdlCL86Kb9yvMAka2liLMCpcBMdox6CXuPv0/QFqEpzIHO/h1loekiAvfAAAAAElFTkSuQmCC",
	histogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42qWSSw7AIAhE4WTl6HiytmkyC8n4GctGE+H5RDwzb3sjItxK4AzBchyJI8AV8e1bJgesDJYAxYA9RzJgNpIBBVSD2nnZYHbrtoEEODUYzsEuAHupcRSAYqWIGvwG2GF004ffUNYHLMPhxoq1/LQAAAAASUVORK5CYII=",
	histogramStagger: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCQEIHumY2oYAAACPSURBVDjLtVNBEoQgDAsO/yJPjy+LB4VRt4vgzuZCYaBN0pIkGQBIJgCo+xNSDUgixPmRJBuwAR8xvJ+Hb5eg4hQyydRLsl7ZfcjJTwzKcXHdJfjuzVLNGwFZQJarhMrgrReNQSEb3RFIsiTnt5WrlCkP/jIHAwzcuudbH4fmoJe2wyCqFSP9MgNff+XMugHLQ24FNoCMXQAAAABJRU5ErkJggg==",
	hoverMT: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsklEQVR42mNkwAo6/jMwmANpR0YGAgCLgkag5nqgeD2QbiTHgCagxrpBYwAMHABiB5gXGUkwAKYYFKgVULH/UG0QOSINmABkFzBik0MywP4/xJmHgXgfUHz/f0Q0tgPZlUB2M5CuxWUATBBmCz6A0wUHKTFgH0iQAWIIIYDVAJiEFjDOwh3xGwBzLdZYcPoPCURcABS4B/BFI6oCTOAAkofL4VCELxmjyuFRhAs4MCBncwDZ/lcR22q9IwAAAABJRU5ErkJggg==",
	hoverToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABK0lEQVR42u3W6QqDMAwA4NQT//sIvv8D6UP4RxAVdGaQkXWxlxcDA2NX23xNj00ta8CNoThAtyilPq/LsoR5nqFtW/Ax87Z8PC8APusDuSIOAeR5DsMwPIAHsBsgIYIBUuAxtSEPA9hmJqFOBURRJCbDdtM0QZIkdsBWuACqqoK6rt8QU1V+JnkkoGmar6RZlsE4jsZ+pwKKooC+7/0Aetnw68sB+uWBpeQAKbAdbkId0HUdxHEcDqAlwIFoJ0vJbSuJbR6A1ybEj/GB7y8DUEKO4LGV5FAABd1oVAleHZ/gfb0AhNgL4BWQclgB1G4948tegPjzbAIQAi8i3IRpml4P4KcgBIBj8v0UBNhaP9eZm/o6AUwltIX0R8ULwKvwlwBbPy9AaDgD7ogXvqXxsLZTSnwAAAAASUVORK5CYII=",
	"in": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAcRJREFUeNpi/P//P8PO8wu2nb6zy9NUxW27u2GCV8vqKAZsoCZ0GYZali2n5mw7eWObZ5ZPI8O0LfWev3//2fbz+w9PkIbmuHWMILp2UdB/EA1Uux1dLUPhVLf/91+c+r/1VCuYhvFBNMh1IIwshq6WxVTVbXvb/DxPSyMThpfvFzGk+FQx7L+4iOHLp09wp4PYIDGYHAhs2JvH4Ggcsp0RZMP8Ta3bdh5b5qlvoA7XdPHCTYYVHVfBXoio0P6PLuduFbU90a/ai8knS5Zh7Y4ZnlnR9UAXPIdjdBcgy4HUgvSA5BgdYgVB9H9sob5/0TuwCxzjhHDLN6+KZIAFFjmYiYFCwAIigAnnP46Ew0hIngWYaMAcUOJABsCEAmeD1OCSZwGmNoZ1h6du715R4uliag9X8PXLVxT2+bub4fw9pw8y2Oj6bQcbsHx377b9Z9d4FkR1MJy8sQYl6tCjEQZACWrCsgrPnz9+bGPauHeeZ1pQDcPGYxMZXrx7yrBz3z4w/ekDwgAQG1kOpBasB6iXycEoaHvDhAywDUcPnWYA8UE0uguQ5UBqQXpAfHBcTlxUtg2YoP6DaBAflLiwYWxqAQIMAAUBf8O6iYXaAAAAAElFTkSuQmCC",
	indicator: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATUlEQVR42mNkoBAwUsGA//9VVBgYVFUZGLDRYHDnDgPD7dtY6eFhAHVi4T+OWCEoTjUDKPYCVQz4j8NAXOI4DUD2NzobXYy6BgxMIAIASGlSCRR+hPkAAAAASUVORK5CYII=",
	indicatorCenter: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42mNkoBAwDj4D/oMRXg2MBA1gxOEybHJAzv//KioMDKqqDAwgetJkRobt2/7D+WBw5w4Dw+3bDAxeXgwMubkIPpAeHgZQHIhUjkZSwagBDAwALepQCVgJvXkAAAAASUVORK5CYII=",
	indicatorCenterRainbow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwUs2A/2DEACORTEYV+A/XyMg4asCoAcPRAHIBxQYAAOItPBEiAomCAAAAAElFTkSuQmCC",
	indicatorHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAk0lEQVR42q3SOw6AIBAE0JlTaWNj56kMp7KzoYFTrSKgUcEfUpCwCy9hgCgc/BEQcXPTAG0LdB1QVaFlLTAMwDgCWseDvASU2lpizDdA5hLJ94DWDBUPrDt88xlgjOwyYF2XA8uuLf00EEtHwGVApZ4BfS/JZ/wFiNfIAH6ZA9wzMoSIM4AQotz+RKaB4q/8bRQDEwJvgBGspLx3AAAAAElFTkSuQmCC",
	infoToolbar: "data:image/png;base64,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",
	information: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAfpJREFUeJydk0trU0EUx/9n5ia9SbwI2lBsaUTsItbqTsGFIjbgVxBd+A1cdVNwXwi4cCGIrt121ZWYLqrdVAUfIGpbKUlqqolJSe773jnjwqp5XAp6VsP8zvmfx8whrTX67elO62LGkEuC6BwB+YgZbsRNL1bvfaUWb56Z3Oj3p36BF7udiinFtYYTwA4V+IARACkIBMBTvHr77NT8sID5aq9b7YZRvmEHOMyU1vBjbn53w8LdS6d9cZB5JSl42jIxbZkDd5IIgpC30nIFAOh5vX3ZlGLtU9sZyXZrdhIA8PBNDVZaDrCGEyBUfMVgrcsNJ7nstVobdTvAru2jeCw3wKyUxA/FZZGWYsYOVaJAreejG8SYOmKOsGxKwg7VjMGMcR56SgCYyI2hdPI4AODJh68jXBAhUDwuIubE7N/62vqYMB8AiBRDeDG3KBEfboo1Yq1bwo3UlhT/LtHyQpiG3BIh88L/VLC976IXxgviRvHEuqe4ooYGOZEb+3M+dTQzwDY7DkBUeXx9bp201nj0tmYCqApCPmP8/TBupFDt+QCAgmUim5LY7Dio94Lm8ue9QvtOyR9Ypvuvd55FrOetlEQ2JSHoV3OKNVpeiO19FyCqPCjNln7H0PA6lze+XAiVXvJjPu/FKh8pBghNInpnCFq8d7X4st//J3JK/Ibf2DGRAAAAAElFTkSuQmCC",
	information1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABCklEQVR42qWTMW+CYBCG30sgoYObNHFx6qpbjUlbB/FP+Qv8U8XBmNTUza52YYWpjZEEk/P9AFMEFUPf5DsO+O65g7tPUFZLB0gwo9fDAS4segeEvH7BxhS/8lncLqVg/6mL8Tagn+CybMwJ8c4Aquq4HQTRjhmvBf4BDDyk7SKWWPLM77RebXARAvisZCIMfmPZi+13dZ/u8zIfrkJGBvBBZ3h39nPISuxHDZMftBuEG0UCSzVt1QXd/IRcAocA/A9gWtJuCIgMIPuJzQAr04UXdmDZEPB6c5BqAD4ncZIBHHVoA/a1fpQzlUb5pPtGOs18upHK65Y+58e5z+Wmz+w044bLHOd1cfsRodhfLbNjQiMAAAAASUVORK5CYII=",
	inout: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA90lEQVR42mOU9LvynwENPN+kw8iABWBTyyjgcfL/lik6YI5PzhWGDzvMsWqGAXT1jGwO+/8HRqmDBdYvu8lQESnF0JSuDhb/dcARbBiMXTfz5v+O5c8YkNUzMtjugDuLT1qc4dPTlwjrDntAXINHDcQAoEKQ6U1LrgAVKIElPj29BzQgGGrA2v/I4nUxOmBXgvSi+tdh2X8GdmUI++ddBoYDUYx4xcEugAG7hRghzHAonpGQHN4QJwZQzwB8CQqfHIoLQInEPUgWzN657jE8UeESBxuAL5EgJyRciY0aCQl3IkExAEdiY8SXSLACNPWMeBMQOsCiFgAfVbP7i+f0cQAAAABJRU5ErkJggg==",
	italicFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnklEQVR42mNkoBAwEpCXB+IDQKwAxB+AWJBUA/KBeAI+9YQMiAfiBVD2BiAOJNUAmDcEgPgiOWHwHqoZBBKAeCEpBugD8QUkvgMQHyTFAGT/41SLz4B+IC6AskEuMSTVgP1QZzNAXZJIqgHIAdgAxI2kGACKugeEAhCfAf4MkIQDAyCXfCTFgHqosxmgLlHE5U9cBiAHINYkTEwgEgUALgQZEX/jz9wAAAAASUVORK5CYII=",
	jitter: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42mNkoBAw/mdg+A9mgBHxAK6PYgMGxAvIenAacODAgf8ODg6M6GwMA7DZANIAopENQObj9QJMMS4AMwRvLBDjAoKxgC8M6BMLRBtArCZcYBjkBQCVkUwFt2LOsgAAAABJRU5ErkJggg==",
	kaplanMeier: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42rXRAQ6AIAgFUP/NPLo3I62hwMTQFnNrFXuDLyilekbhPvGqzdQBqq/oHkKQarLTRCZyfrapgAZ+Bt6mWQDmi5NPOHGe5kEOAEb+AUoplHOG97RryFBdgJskYG9IAbI5CqgVLDBbQQJHGQxA5bAL6Nq6xlldZE17DbdAwpAAAAAASUVORK5CYII=",
	kernelHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAlUlEQVR42p2SYRqAIAhD5WR5dDyZYZ/UUCGLH2UGr7lFzFyTVM6Z0lDtnezj1tRD0OgCqp00fRQpkKp6Kcypq7GASEGbrX0BgNZ/f/BVAQIOAdAI+KJAAah+UgDPjwkAABPWCjA6hiEXsFKg0ZUYcC1dBREAE1mlYLL3AGrotnHuccZh3hia/Ng9dwhIP8v8fZrGl/sJnWvSh/A7SCwAAAAASUVORK5CYII=",
	keyAltIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJElEQVR42pWSUUhTURjH/+fuIXFZMHKJg7uVBqUPmcKGQlgRBBF7iIKol5DaZIOIHgxSUEF7SApJ7lpzmWVZYyVjmxERJYQTtagoMlY23HQw0Dti8/He071H1ooiu3849/Cd7zu/832XPwmFo05Jlr2yJAOgWF+EfTkdBx3HtZJHYyHa1GjF5rJNUEDrXlcusf17LofY1DRIIDhGy7cYsH9f83+8XtSLlxNYFrMgDwJBus3Cw2a1YiGZAiFrLVI2zZ8jUSVhMfOYjMWQWkyDjNx/SGtrdmJP3W6srIhKizrIVIYkSZDVkQoMUgRUVGzF9MwsvnxNgNwZGaUN9XWordnFkna7nRWGw2E4HA50dXezuLenB1f6+pDP5Rng7bv3+PDxE8jQ8F26t6kR1TuqsZROs0JV7R0d6OrshM/n+wktgFXNzX3GzOs3IP6hYXrwQDPMZgtcLhcEQWAFF9vakF9dhcfjYbGaU6GmykoWx+NxvJqcAvH6btEjhw/BZDKxooI26vX/BCQSCTx7PgEi3Bikx47aYTQaf+vA7XYjm81iQ0kJbDYbnoyPs/NIJML21NIiotGnIAOCl548cRwGg0GTDzKZDIKPQyD91z205fQplClO1CJRFHFvNABytX+AOs+2QF9aqgmg/p9B/22Qawqg1XkG8/PfNAGqqrbDe9MPcu78hV6eN1+S17xbMNxf9auxOcXyyeTCZbW+XFm8pueLSv4ARhjggP4/qOUAAAAASUVORK5CYII=",
	keyCtrlIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACLElEQVR42pVSX2jSURg9Vx8aixVIszHxz9KgtoeWgbFBrCIIInoog6iXGG4OHyIiJvTiU4FaMRpzv9SmtVqJNSRcREQNYg5dWVG0NJdMVyA0I9eexN/teoczKFoeuP+/73znuxwSehg2l0RREEsiAIq1QfgskUoglUj6yP3xEO3sMGBjwwYwojXTWRJffywtITIdBQkEx2njJhn27e36j+pVPHs+iW/57yB3A0HaolFht8GA+UwWhKxIpLybP1ui7EGjVmEqEkF24SvI6J17tK11G3a278DiYp5JlEKkIkqlEsRySxUOUiVoatqMaGwGn1JpkJujY3SXvh1trdsxLAhIJJM8sIVVSSSScDidnKiirFAoQNHcjNdv3uLd+w8gI/5bdE9nB3RbdTjf34/LDgfi8ThsNtuq7GNGI2LRKIrFItxuN7+bnf2I2MtXIN4RPz2wvwtqtWaVoAKLxYKe3l54WJLL5eLn8lpGkil9MTUNIrhv0MOHDkKhUMBqtcJut3MFer3+nwTpdBpPnk6CDA17qPHoEcjlcv4Hc6kUD9DqdHg0McH3SqUSJpMJTvYf6+rq4Pf5kP2ygHD4McjgkEBPnjgOmUxWkw9yuRyCD0IgA9dctPv0KTQwJ9aCfD6P22MBkCsDg9Tc04319fU1EfxcXobH6wO5ygj6zCbMzX2uiUCr3QLhuhfkzNlzF1Uq9QVxxbsVw/0VvxtbwoyVycxfKsc3sqGqqXwVmV+hMumAGuivtgAAAABJRU5ErkJggg==",
	keyEscIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACeklEQVR42o1SX0jTYRQ9d9Mmhg1GmjjYnC4sfZgtMLTEiiAIFZHpShFtqFuWOSQV6sFIK6Yl4pjNNLUsS6wh4UNElBAqWlFRZPin4bRAykWab+339e23JHrJXbgvH/ece879Dg09HDb7BMEp+AQADBsXQSKVQCqRWHKyMzvovmuIpaWmQB6xBZxoQzgH4sfqKsbGJ2DIzSEaGHSxyK0KHNifEcT2QD19NoJv3u8wGnKJ7g4MMk2sCntSUjDvWQARiUNMdPOvJcYfY9UqjI6NYWHxC44Z84j67txjSYk7sCtZh+VlL5cohcAE+Hw+CH5L6xwUIIiO3oaJyReYmXWjqNBIdLOvn+3WJyMpcSeqrFYQ96jhW8rKzSKB8OcufmUrKytQxsTg9Zu3ePf+A4qLCoi6e2+x9LRUaLdrcaa2FleamsSl5+vr/ShoNBrodDq0OxyQyWSw2+2YmvqIyZevcLy4iKiru5cdOpgBtToWBoMBcRxwouIUmpttyM83Ym/6PlxubERNTQ2koaHYxHt6ehrPR8dRaiohcl6/wTKPHIZSqURdXR1sNpso+Re/gcvlwuzMjCj9QkMDQkJCIOGq3G43Hj8ZgaXcROS41skMudmIiopCVlYWEhISEK/VikC5XI4Y7lmv13NFzZCFhaG3pwcLnxcxPPwIFZYyIrvDyQqO5kGhUASdg6WlJQw+GELlSQtRa1s7M5UUIoInMdjyer243T+AqsoKoqutdmYuM2FzeHjQBD/X1tDZ1YNqayVRCyewmEsxN/cpaIL4+Dg4O7oCBKet1RdVKvVZIZBd0H+A66H0/4THM3+prbXlnH8+krcq6PV/y8P7628o4u8ROgvGnAAAAABJRU5ErkJggg==",
	keyEscape: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAedJREFUeNqUUjtPG0EQ/m5v945HEldpXADm6N1FSpqEzhKK8gNAUPH4AYaCBgQSEjYKAgti0kDnNuD8hkBCCxYCBLbpuAojQXO7x+zad5AiAY9kaea88z1mxvqx93NSKlVUUgEI8XxYYDaDzdjUl89DWzwIguKH9++QeP0GBPRsOzXi5vYWv/Z/F6nc4pKYT05OMfjpI14aB38OYzKulERXV6cpavUrWJZl8tC4+dtSSB/7envgug6UlE2AIJBwHNcUr7q7SaINFSpIeqA0SxhbNwCmiQsEQaxAEYBjioXFBVjkMUUs4xOTBkC1pGpljUbD5Pq9Vm4ApAzgCmEKQX+s5HKGdH5uTnchlUohnU5jc2ODpLsoFApwnwAwzSAcborqxQVmpqdRvazB930a7CCGR0ZQ3t3F+toavq6uGiWc28aiAdAz0J50eJ6HXD5PrL1YJ6Zr/xr55WXc3d/DJpWcN4mEeDIDvUbRslCpVJDNZuENDOD87AyJRALJZBKZTAZjo6NwOzqws70N7ojHGegkQi6Xy//cfalUinOHFMcWmgo42gmtONoOk6SA2e0BOLSNSAHXd8do90fHlRcDeF5/nPNq9XJp89v3WdW6Mus/jdFRMlplvV5bit6/pV8P2o86nbb/IMAAm5HMuq9efzYAAAAASUVORK5CYII=",
	keyShiftIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACV0lEQVR42o2SUUhTYRiG32/eGRaMNEHYnDMsvcgKFgphRRCEExlHVspQh+ZYmENSSCGvCtxMhuKaucyyLNmS0XYRESWEE62oKAxWc3NaINNFmBde7PydneGqmzwf/By+n/d7/u89vOR94m9J8LyTT/AAGHYugixDhgyZzFRdVTlMnikvKy/TYE/WbgigHceFQfzc2EBgdg6crppo0j3FsvfKcfJEhYTXU/Xi5TTW4j+g53REDyfdTJWvwDGNBkvRZRCRKGKim38tMeEyX6nATCCA5ZXvOK+vIRp/8IiVFB/A4dJDWF+PCytmgGc8EokE+KSlbQalALm5+zA3/xpfvoZhqNMT3R2fYEePlKKk+CDaLBaQ4HElGoXH40n33Ve60NNzFQ6HQ2S9e/8BHz8toN5QSzQ6do8dLy9D4f5CXO7sRJ/Vis6ODlhttnSv1WrTNnw+HxYWPmP+zVs01huIXKNj7PSpCiiV+eA4DgUqlShcDIfFb7JPwsxmc3qDYDCIVzOzaDI2EDlv3WaVZ88gLy8Psdga+vpsoigUCkGtVqO3t1fs/waEBfiz59MwXTASDd0cYZyuCjk5OeKqRUVFoigSiWBra0tcOQk2GhvTFpa/rcDvfwqzqZlocMjJas/VQC6XS87B6uoq3I+9aL1oIrIPOJixoQ5ZQhKlVjwex/2JSbS1molu2AdZS7MRuzIzJQN+bW5ixHUH7ZZWon4BYGppEn7aomSAWl0A57ArBbhkab+mUCi7+FR2Qf8Z3A6lTIh7NLp0fcDe353UZwtHIfn5PxUVTuw3P9n0EUA079AAAAAASUVORK5CYII=",
	kmeansSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZ0lEQVR42qWRUQrAMAxC581z86yDFMIaQalfLa3mYfBcCsqniMh2xrpkmQHFtI0WwRewTTKBOpUSsKlnaNYbQANUoZsZ9r+D1UCWeyaY8KUt9IBusAicDRwErEyZYDJYHTDZBI6uA17l+V4RsehpQAAAAABJRU5ErkJggg==",
	kmeansVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYElEQVR42rWPUQ7AIAhD7c25Oasfm4urRpRBFCnyUJRDw+8AM3MuhAC1aQLEEkBNVTr6C7OJS4BRQw+/9RBAnfMA7yfWosqV/pkWjXmAXWsAp4M+isX5d4CbM3liImDTLudeqBF988IgAAAAAElFTkSuQmCC",
	labels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42mNkoBAw4pI4cODAf2S+g4MDI20NQNeADogywN7eHi5x8OBB6hqAy0VEG4AuN2oADgMYSAAYBpALUAz4D0ZgQUZi+NQ3gBwAABjcXBHyAqQ9AAAAAElFTkSuQmCC",
	layers: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAQAAAADQ4RFAAACf0lEQVR4AY1UM3gkARTePdvdoTxXKc+qTl3aU5U6b2Kbkz3Gtq3Zw6ziLGNPzrYx7946Tr6/ee/XeCQ4D3ykPtL5tHno4n0d/h3+xfuWHGLX81cn7r0iTNzjr7LrlxCqPtkbTQEHeqOrTy4Yyt3VCi/IOB0v7rVC7q45Q3Gr5K6jt+3Gl5nCoDD4MtO+j96Wu8atmhGqcNGHObuf8OM/x3AMx38+4Z2sPqzCxRFK2aF2e5Jol56XTLyggAMTL56XOMoS1W4pOyjUcGGQdZxU6qRh7B9Zp+PfpOFlqt0zyDZckPi1ttmIp03jX8gyJ8a/PG2yutpS/Vol7peZIbZcKBAEEheEIAgFbDkz5H6Zrkm2hVWGiXKiF4Ycw0RWKdtC16Q7qe3X4iOMxruonzegJzWaXFrU9utOSsLUmrc0YjeWYjCW4PDMADElpJSSQ0vQvA1Tm6/JlKnqFs1EGyZiFCqnRZTEJJJiKRYzVYzJck2Rm6P4iH+cmSY0YzimYa8l0EtTODFWhcMIMVqdsI2uiTvKmTisIDHJ3od5GILVhBCarCfVRmo4uTjkhrhzkiBV7SsaqS+TzrzM1qpGGUFt28pIySQHR6h7F6KSwGWm97ay+Z+ZqMcEjEWebE7wxCSQwpkhJqoZA5ivCdZDjJepuJ9IQjGGUmuXJdBFUygxVqVsxFsLMbDe8ZbDYVCGKxs+W080max1hFCarCfV+C1KATwcnvE9gRRuMP2prdbWGowm1KB1y+zwMMENkM755cJ2yPDtqhTI6ED1M/82yIDtC/4j4BijjeObflpO9I9MwXTCsSX8jWAFeHr05WoLTJ5G8IQVS/7vwR6ohirYM7f6HzYpogfS3R2OAAAAAElFTkSuQmCC",
	left: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAo0lEQVR42t3Suw3DIBAG4KPJLmzBCszikjVcIFwaCeOGwiUIufVKFoLkCltuEqNQJX/Bo7hPpwMCjSG4FID9dXj8MdD3fRnHEbZtI1XAuq47Y+y8D8NQ5nkG7/09gMW4XwGlVJmmCWKMn4Gj+BqEsANjzD3wrgMErLUQQvhuBlLKorWGruvOQs45qX4F51wRQgClFHLOkFKCZVnqgeZ/8ANAS56xeWcReLNUrQAAAABJRU5ErkJggg==",
	legend: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9IMEww6K5Rx3KkAAAE4SURBVHjanZCxSwJhGMZ/vu/3Ibo4ODn5pzgJLoo5ySEULU03BeJ+UBCtbY0dKC3tYWPtN0WjSdgglBxXchw1qUkI3j3bA+/z43mfXK/X80XEWSwWZNBxrtls/nieh7UWa22qdL/fx6gqxWKRcrmcpQEGQEQQkeyAfD5PoVDg8uwWgM+PCO/icD9AkiSoKsaYdXg+f8cYg+M4hGGI67r4vk+lUsEYg+d5G4CqIiKoKq+TN76+Q+J4iaoyGo3Wh41GY/cLAEmScHV9yl+/jwQgjmOyar0BwNPgCIDZdMLBzcN+AFXdqjubTphHSwC63S5RFFGtVqnX64zHYzqdDkEQ4LruZoNVg+D5ZYs+HA63fKvVAqBWq/0fEeDk7jH1BpJm8Z2A1Qtppark2u32OTBIG7bWUiqV7n8BNFhkNoDWY+MAAAAASUVORK5CYII=",
	legendInside: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABoSURBVDhPxY5RDsAgCEO5/6m4mQOUpTA+HFu2l1Rjhab0P8w8VOvZ41EANpBjVLLBgNoABpgBXD3PXeQGZs47e8JZCiTsNaiWRR82cGBRyQ0q2WBAbcADWmCDNq8E3NFai/jH7j0hOgD5ptCBL+GpPgAAAABJRU5ErkJggg==",
	legendInsideBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABKSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhjWLgAK/kfHUClUgM8AKBMMsBpAyAUIJg4DQICmLkDHUClUADOEHAw1AuEN0mgGBgDTFax1Zs+x4wAAAABJRU5ErkJggg==",
	legendInsideBottomLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABLSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhg2LgCagIGhSggDmAFQLhgQbQCyC6BCYJpoA0CAai5Ax1AlhAHMEHIw1AiIIaTTDAwAZK6sde813NAAAAAASUVORK5CYII=",
	legendInsideBottomRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABGSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhhRLgAq+o+OwRKkGABlggGYT6oLEEwkPl1dgI7BEjBDyMFgA0AAxiGNZmAAAMUHrHXPVrkiAAAAAElFTkSuQmCC",
	legendInsideLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABVSURBVDhP3Y9BCgAgCAT9/6v8WbWyUdShtA7RgKhRwyZAVZMNEfD4SAA+SVAMU/HKmirgamwL+gQ8sr4tANcSjMUrayDg6Kcm4BrjjQTRoqJ9w9dFMskZrHXNWcFoAAAAAElFTkSuQmCC",
	legendInsidePosition: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACMSURBVDhPpY8JEsAgCAP9/6v8WdtwGMSj184gDoaABdRaD7lMOTZvF2heG6DZY8PcIDZvTPYbgEVjZGZgI4ewZzJuAJ0oBzFrqmnQwAdFseRUoy5s4EUNHCLQLHet9TrU7zZosJaaaQBoMAuRyDXQG2SSODNu4HSDLRasN3jY/OsLwE2+hFnwG+9yKSdWsQcpOGs75gAAAABJRU5ErkJggg==",
	legendInsideRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwCBAwcO/AczyAEgzRQZAAIjyAVARf/RMViCFAOgTDAA80l1AYKJxKerC9AxWIJYA7ACUlyAEwwOF5CLoUYgvEEazcAAACmBrHX6cMj/AAAAAElFTkSuQmCC",
	legendInsideTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABLSURBVDhPYwCBAwcO/Acz0ABQ8D86hkohAEgzPgOgTDDAagAIEGEAmEbiIwDNXYCOoVIIgM8FRAOKDBh1wbByAbkYagTCG6TRDAwA9RGsdfKyFBQAAAAASUVORK5CYII=",
	legendInsideTopLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABJSURBVDhPYwCBAwcO/P/PwICBwZKEAEgzzACoEBgQbQAIoBkApok2gKouQMdQafwA5gIolzxAkQGjLhhWLiAXQ41AeIM0moEBAIaqrHVTc81FAAAAAElFTkSuQmCC",
	legendInsideTopRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABBSURBVDhPYwCBAwcO/AczCACgov/oGKyZFAOgTDCA88kwAEyD+XR3ATomyQU4AUUGjLpgWLmAXAw1AuEN0mgGBgDnA6x1eX3XUgAAAABJRU5ErkJggg==",
	legendLocation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABvSURBVDhPtY5LEsAgCEO5/6m4mS0/weJGsG+GOg0xBtog4qDR3xqtgN8avMLYja6d3IB87Exm18Qz8QB7KJr5/GjuCw1MlKEPGwKirT5eXGpgpICJa3rZWAMEMu9G105uUKAVcK1BZfS6YMLZCfAAv3XcwFXfqxQAAAAASUVORK5CYII=",
	legendOutside: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABsSURBVDhPxY4JDgAhCAP5/6v4GSssR1DU7JE4EY1NrYXzICLx6PUddQAlrV1YGGbRwDw3Yu5wLQekD3TaLkvgM7SxQRVAsqnBce3nBkY8ZsTc4do8IGBzNYsGD/gUcL4BYy12o/YaM+zODMAFQTLGxNIHZcYAAAAASUVORK5CYII=",
	legendS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42sWQAQrAIAwDzc/69P7MoczRbS6pICwIVTTXWBSi2hcXFADkzXmvAQEUE+ECuHs1M3wBaINmbgcGWEoQ9/8k2D6DInRL8KzK3AEswRADTmewNYGCIfMoNcQVU2z2+ne2Dt8BbiiI/18f4/YAAAAASUVORK5CYII=",
	legends: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42uXQXQqAMAwD4OVk7dHbkykUlSoscY9i2Mv+voVhkGw1eKAAkDPHvgYa1BvhNfChBhFxveDuWG4wA2iDfqnnBIZIAWZWk8y8AeoyBZ5tloG+9gdA/TQDdgTobv92RRE8AAAAAElFTkSuQmCC",
	levels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42mNkoBAw/mdgECZLIwPDW5gB/8nQL4JsALIL3uDThNUFMAGoQXgNgGlCM2jEGgALfLIMQIq5NyQbgKyZZBcgseHqiE1IIjjUiJCblFEMICszwb1AiWYQAACfICtTrJvm7wAAAABJRU5ErkJggg==",
	lightbulb: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAidJREFUeNp0U89rE0EU/ja7kZRWQwOS2sRgEayiRFGp9JBL/oN4EbyJtSG3eFFEpEUvHiMUpPXoteCPP8CbF1FQY6vWom2zCdt00yZx0242u7O+nbVl3awP3sybN9/73puZN4Jt2/DLm9lwjqZp0om/rnekC9nZ3gs/VvASUGCCpvupKzcK8XQOA9Ek9+utKpTyK8jvn88zs/uIiKr7MZKXLSRFHpzNPcnHTpyHbW7D7v3i/sjQAMYyUxgey+SXX94WyXXrIMaT/fqx9NX8cGIUbPcTbKMCmCpXx3Z80XgMI+nclIPtIyApjJyZgLX7GaynBqqzFz91kWODCC6IwjcquwFx6DJsq032lquWBnHwErdFfOXYIALL6qzA2vuJnroI6XCG7kGj4A4RTnKfpVdgapzACrrED53tZvbIUZOYmmDKM0SOz1CKCPS1u7DZb9AAraHtP2tfBU/lpXUwy6KsJpjRoHPX+ZFYb8f10V51eYNj+wjobRc1tTEnl9d4JledHrEP1vKXdWiqOudtKMnXWHeU1aoYkoTC6OmkG+yMFKys1KD8kJ3M9/7pHe+CmPdoeri5uulmhVsBM03UvtccyGPCaN4YfwV4O/5RidVfw6iP4+RgEnV1C+Wla6jokyx87uZG1ocPIUBCUhSxaII+ShhhegXTOIR2hwVjg5yGYaDVanN7p9lEt6vjfyIEfWdHisXivKIo0w5ZKpVaKJVK+SDcHwEGAD5qJSG2+HXsAAAAAElFTkSuQmCC",
	lightbulbOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgtJREFUeNp0k89r02AYx79JWs3mYHM4dROqCCLiYTv5V4jiTfwDJr0VD4LoSRA89iAO9xd4GMjAww6ePBY2XOfGQKfpxmqZbk1q1yx5f/k8iS2lzd70mzzv83yeb9/kTSxjDAbHx039gC7zpDv/UxXS4t3b9odB1uo3WF4XV+jyfHrcLl6dtDExaiV5v2NQO9L4FegFmr66P5vf7zWxQVdLq+HbrbowUmoTC2WiOBXHnOMaM/09dtfofeX40cSIKV6/YCEUEmE8IMpxjRlmu309AyFk8eYlB51IISSdxBqRSMUx57jGDLMZBmLOzZkE/LbfpiYFIXUijr/X0xwzzGatQMUEK60xPenCOzgGz1m1gw4un3chVTpndsggFnL1T0tAkgE9nsSk6vlY22lSfDbJce03McRWhlcg5cK69xeavJWiraWfm3cwcsYB7zTnuFYlhtkhgyf3ri3VDztvvu62obmBTtqkSmNgc68NZojtvVC5/reK7u3phuc7gC7emBkDrTgVNe/QQ6z+DPifn/X32P2TFw9v0XarlxteANtGct98cPTlR5OWrl4T0z7VIFmSYzXcwzV421u4mA9hBzV8/rSCYHtFU213kB8y4HEOLUyN2ZgaNZgZz8GER5DBXiabmYzjGEHQSuKm7yOKTnDasLI+Zx6lUuldo9GYZ7NCobBYLpcfZ3H/BBgAh/F5D+rprGgAAAAASUVORK5CYII=",
	linLogV: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAQCAYAAAArij59AAAARUlEQVR42p3Q2woAIAgD0O3/P3qFD90wWYlg1GFgFCACvfPiCjLM7FLRRcI2LRBR58OcdVlAFXwCcsAK42yD7zWvHzVSG0hxMQMQcjWdAAAAAElFTkSuQmCC",
	line: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAqUlEQVR42qVSCQ7EIAjUl8nT/RkL2LIDatu0xERF5kCtRaL3zkRUSwqWIckpj1F3BGzDCq4JFKwLJEDlOxfgoOl2CVqRnLnUAjNL3a5YzxWDhKmFUQBI4xsAPhxGEXfQiAqqnGCfnRxE2JwsXsFBs5Oh6k3U+RV2ipI/Gg910UFQngn8zNbjTv4EjUqwHUhSa+By+ZEuI93P9is/DSd4A3aCL+EE+S6e7n/HRZuL7+wQfQAAAABJRU5ErkJggg==",
	lineWidth: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAL0lEQVR42mNkoBAwgoj/DAy/yNTMRo4BrEgGMA6ICzANoARQx4CBD4PRQBzqYQAA0IISEdiDpJYAAAAASUVORK5CYII=",
	linear: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAhklEQVR42u2TAQrAIAhF5xE9qUd0a9Bwoi1bVIxJsIj8Pf0OtsUCZgP8QE1AfCwIwBERI2K4mJSX9zJf6t2AasHeAKU8ma+1pnbI0jE7xOfRdQEs4SyoH7AsiRTlApUs1K33vjXW6QKGA1nz8zjUEaCIZRrU7VDvaB367wNF/rIhQD1iOaAdj6C6EYM+H/IAAAAASUVORK5CYII=",
	loading1: "data:image/gif;base64,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",
	loading2: "data:image/gif;base64,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",
	log: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAhElEQVR42u2TYQ6AIAiF44ic1CNattXsJQbk1LWYm+gP38cDaZksaDTAD+QCCiFEZlbDxW2Ro5ikc+S5Xq5/AdKCvQFCHdQc6lBJt+iQZC0CxT09H7qdNW7hvQhUa2EOVNs1rcPCuwOV5udxqC1Alpbhe6JDrcM79N8HsvyyLkAtYjqgFdwatBFoz6IkAAAAAElFTkSuQmCC",
	log10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwjhoANuA/JYbBNP2nlgH/sYjjdR0uhf/xWIBsEUEDGAgZhO5skl2CL+D+M5DgBXyGEBWIZIOBNwAANecaDc1X2zcAAAAASUVORK5CYII=",
	log2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAR0lEQVR42mNkoBAwjhoANuA/JYbBNP2nlgH/sYhj48PFCCnE5cL/xBrAgEccbgCyZlJdgjfg/jPgDiOMMMBnCF51gyMlUgQAxRQVERNPpYQAAAAASUVORK5CYII=",
	margin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACO0lEQVR42o2TTWgTQRTH/7ObRFvTNlUQkVIQFRElYq0gCNaPQwta02ySgxK86EFUFBQPxbP0IAqKige9SKiHdjeNVWgPflQQBGvFoIhoEUoREbRpG1tNdnZ8s3U/aCL4lscMf2Z+7+17bxj+Wm5wcIpzHhFCgDGAFsg9LWDSSXR0uVdVtRDr7GxkDsAYGBDxWMzeD7/6jPZta7DY/Ho2l4PW1cVcgJ7NChLw7esX3Hn8Ccf2rYfJLfdyQFVw+9FHHN27DitXrZYBkYjHmS+DrKht2oKxDxMIBVRwS5Bb7i+oikLOUDI5WjY0Y27yDWUQ92dgUAZxzEx9x63hdzjRsRll7gGClMHNobc43r4J9Y0rZEDKQPMA/YYuSMB04QduPMzj1IEoyqaFhaIyBAMKrj/I4+T+KBoiy2VAJLWEB+jTdZHUNMzOTOPa/dc4c3ArpWvBIoBCx0IEuEr6adLr6hsooIFUogpg7ucsrhijOJdoRansAwQVXNZHcVZrRe2yun8Dfv+ax6W+Fzif2kEA7gOorr5kaU0VANUgSTXgZgk9956j+9BOG+DUQAIcXQ2E0E81SPlr4HQBsNDT+wzdh9toy53RAxQC9I6QvovOKJVdkHNQ0xTF2PsJu+JyiEy7jZQBfXKQpMvOtGxsxvxkfvEcLEyitIuZJ7iQ3lMxyn69yiR6b2Ho5Tg6tq+tAPj1irdwN5N5Gg6H27zXKGBZwr2sKMwupvMai8XiyJF0ejfzBZDoCP7fCuTjfwBA/B8gavi6XgAAAABJRU5ErkJggg==",
	marginBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJElEQVR42o2TTWgTURDH/+9tErWmbaogIiKIigelolYQBFv10ILWdDfJQQm96EFUFBQPxbP0IBYqKh70IqEe2t1trEJ78KOCIFgVix5EiyAiImjTNtaa5O1zXup+0ETowLDDn/d+MztvhuGfZYeGJoUQMSklGAPoAxXTB0w5ia6uYk3TcvH29gbmAqzBQanH4+V45OUntO5cj4UW1O1sFkZHB/MApm1LEvD921fcfvQRxw9sQkk43uWQxnHr4Qcc278Rq1avUQmR0HUWqMCWNWu34dX7z4iENAhHkjveL2ickzMUSgI7Nq/D7Jc3VIEerMCiCnRMT/7AzZF3ONm2FUXhA8JUwY3htzjRugV1DStVQqrA8AEDlilJwFTuJ64/GMfpQ40olhzMN5UhHOK4dn8cpw42oj62QiVE0kj4gH7TlEnDwMz0FK7ee42zh7dTuQ4cAnA6FiFAL+lnSK+tq6eEFlKJKoDZXzPoscZwPtGEQjEACHNcMcdwzmhCzfLa/wP+zP3G5f7nuJDaTQARAGievmTpsioA6kGSeiBKBXTffYauI3vKALcHCuDqWiiCAepBKtgD9xUAB919T9F1tJlC4Y4ewAnQN0r6XjrDK19BzYFeBizObAIsmIP5SVR2KfMYF9P7Ki4F9SqT6O/C8IsJtO3aUAEI6hW7cCeTeRKNRpv9bZRwHOld5pyVm+luYz6fH+1Mp1tYIIFCxxbdBCBHPvEXXlgRIH5MDbwAAAAASUVORK5CYII=",
	marginLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACPUlEQVR42o2TTWgTURDH/+9t0piYr1YpfpSCWBARKlYFQdDWSwWp6W6Sgxq9eBEED4KH6FkKigdBPHmSYA9tksZ6qAfRCoKgViyCiBShFBHFNknTxHy8XeclbnaJUftgmJfh7W8mM/9h+H0y09MrQoigYRhgDCAHeScHJo2CZlzeFUXJhkZGOpkJSE1NGWoo1Phhvmw5j998xvD+HfV7OpOBNjrKmoBkOm1QAN++fkH31u34Tr4m9ObHDoXj3pNPOH+sD91btsmECKsqs1WQNjw9ezH3cRHxM4O4Mf4cQtebf0HhnIyhUhMY2NWL4tI7qkC1V5CiClTkV37A37UZBfJVYQGcVMHdmfe4MLwH/s5NMiFVoFmAyVTSoABy2WUE6EE+S4CajkZTGZwOjjuP5nHxRD8CwS6ZEBEtbAEmkkkjomlYzefgCwRRyGWpXB06ATg96yDA7YdvcenkPvj8AUqYQjTcBlBcW4XH60dpLY9K1QZwctxKvsZl7QA8G31/B5R/luBye1AuFQkgbAAFNyde4kr0EFwb3G0A1IMI9UDUKlCcLohquQ4weyABY+MvED91GIqjA5PUg6i9B+YUAJo9U0hI5HVhSg/gBHgwi/jpI/SG/zkFqQN3Tz/mPizi6tkhjCWe1oUkxUwirgtJmpzMwO5elJbmW3XQUOK/pHydoNdiQ6b0W5X4/12YebWA4wd3tt+F+4nEM6/Xe9TaRgO6bkE4Z/VmmttYKBRmz8Vig8yWQKKDWP/Jki38AjkvGyBaGj6zAAAAAElFTkSuQmCC",
	marginRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACP0lEQVR42pWTTWgTURDH//s2HybdJluLIlIKIiKCVKwKgmAVD/ZgTXeTHCrBkycRPEgLwbPmIHgQBC9eNOqhzaaxCPZiqyAIasWCiGARSv2gaJsvE/Ox+5zdutnFRtFZHjM7vP3N7Lz/E/DLclNTq7quy5xzCAJADmZMDoK5KGnnzVgUxXxkaKhLsAHa5CRXIhErnn75Acf3bcM6swlk2VwO6vCw0AJksllOCSx/+YSbj97jzLEdaOpG61uPyLBpy1Ysf/6IzeSpIKKKIrg6yPJgzx7MvVuEzyNCNzgto/ULImMYGzmM1J1Z9O/sRWXpNXWguDvQqAMFxdVvuDH9BmcHd6OhOwAvdSB1daO48hUh8lSQOlAdwISW4ZRAIb+C6w/mce5EHxpNA2tDFeD1MITkbhSoQFjeaBZETI06gPFMhsdUFaViAdfuv8L5k3tRJ4BBAEbbfASQwjJKhTw6Q2EqqCEebQOofC/hqvYCF6L7UW+4AF6GQEcIlXIRwY7OPwNqP6q4Mv4Mo/GDBNBdABH+QBC1agX+DYE2AJpBjGagN+tI3XuK5MghC2DPwASIXj/0Rg2ix4cJmkHcPQP7FAADqbtPkDw1QKFuSw9gInlG75QDW38Kpg4CPX2Ye7toTdwUUdM6RuqAHlNIycRRXL49g/5dvaguzf+ugzUlmnYpPYOLtPlvUm6jROcuPHy+gMED2//vLtxKp2clSRpwbiOHYfDWt4wJ1jDt21gulx+fTiSOCC6+WVLGv1ue1sJPmS8bIKJDEyUAAAAASUVORK5CYII=",
	marginTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJ0lEQVR42o2TT2gTQRTGv9lNqq1pm1aQIkUQ9SBKQFuhULD+ObRQa7Kb5KAEL/UgKgoWD8Wz9CAWFBUPepHQHtrdTVqF9uCfCoJgVQiKBy2CiIigTdtoNcnu+GbrJkMToW8ZZvjY+b3HN+8x/Iv05OS8bdtBzjkYA2iDONMGJhaJni7Oqqpmw319TcwDmKkU18Jh9zz98iO627Zidci6lU5Dj0RYCWBYFicB375+wd1HH3Dy8A4Ubad02acquPPwPfoPbcemls0iIaKaxqQKLK5FNKw1rJRFFWhyBSZVoGFx/jtuT7/F6Z7dKFAFngd+quDW1Buc6t6FhqaNIiFVoJcB46bBScBC9gduPsjg7JEQCkUHK6Yy+H0KbtzP4ExvCI3BZpEQMT1aBowZBo/pOpYWF3B94jXOH92DPAEcAij0Ww0BrpF+jvT6hkZKaCIerQL49XMJw+YsBqLtyBckgF/BVWMWF/R21G2o/z/gz+9lXBl7jovxDgLYEkAt6evW11YBkAcx8sAu5jE0+gyDxzpdgOeBAHi66qvBOHkQlz3wXgFwMDTyFIPHu+hoe60HKAQYmSF9P/2jVL6C6IPa1hBevfvkOi6aqOg+I1VAn2gkscTL7N25BcufM6v7YKUTRVxOPsalxMGK5pH1Kp1YnoWpF3Po2betAiDrFbNwL5l8EggEusrTyOE4vHRZUZhrpjeNuVxu5kQicYBJCQQ6uOZhALK05v4CFbESILw1AS4AAAAASUVORK5CYII=",
	maximizeToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABx0lEQVR42tWXr8vCQBjHvwf6R2gwGAw2YWB0qCxaNFhMwjCI4JZNZhXEIILJYtBgFRWMwsBuMBj0j1DYu+fAFxXF7Xzn8X7Ldvtx38/uee72HLMdXS4XdLtdDIdD7HY7UNsPBQIBxGIxlMtl1Go13mbn89nO5XJYr9fQdR3JZBLBYNAXAMcLm80Gg8EAqqpiNpuBtVotu9FocABFUXwxfpRlWUilUmg2m2DxeNzWNA2dTucr5lfV63XM53MwJw72aDRCsVjkN8LhME6n092D7XZbyMQwjLsPC4VCOB6P/Hw8HqNUKoE55/ZkMkE+n+c3GGP8mM1mUalUkEgkEI1GhQD2+z222y36/T4WiwW/5uQ8P06nUxQKhecAmUwGq9UKTn7wEfhENAKmaSKdTmO5XLoDoPbhcOAvfgJxNac+IpEIN3wLQHGrVqt82G878Arx+C6Fo9fr/ebTS4B3HYmYP5NrAK8Qbp/1BOC2Yy+gngHeGXgNlRDAKyORPBEGeDQkicyUjwBuIUgi0/R/A0gNgdQklDoNpS5EUpfir/+MpP+OpRckBED1IJVPf1mSUZlHdaErANLXilLpZbn0jYn0rZn0zans7fkPPSZSXV87MrsAAAAASUVORK5CYII=",
	maximumValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVUlEQVR42r3O0QkAIAgEUJtMd6yBdLKiIDCi0CD98j7ucQmcVwGyzskLMHNFohlLDNBLOj8BiDh+EQkCttkvwFIKAa6zrcCx9A0wz74BptJXAJyngQZ/cJQx6aOL7QAAAABJRU5ErkJggg==",
	menu: "data:image/gif;base64,R0lGODlh+gABAIcAAOLj4/Dw8P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAD6AAEAAAgfAAMIHEiwoMGBAAQcXMiwocOHECNKnEixosWLGCMGBAA7",
	menuDropdown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTM5jWRgMAAAAVdEVYdENyZWF0aW9uIFRpbWUAMi8xNy8wOCCcqlgAAAQRdEVYdFhNTDpjb20uYWRvYmUueG1wADw/eHBhY2tldCBiZWdpbj0iICAgIiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDQuMS1jMDM0IDQ2LjI3Mjk3NiwgU2F0IEphbiAyNyAyMDA3IDIyOjExOjQxICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4YXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPgogICAgICAgICA8eGFwOkNyZWF0b3JUb29sPkFkb2JlIEZpcmV3b3JrcyBDUzM8L3hhcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhhcDpDcmVhdGVEYXRlPjIwMDgtMDItMTdUMDI6MzY6NDVaPC94YXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhhcDpNb2RpZnlEYXRlPjIwMDgtMDMtMjRUMTk6MDA6NDJaPC94YXA6TW9kaWZ5RGF0ZT4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUdUmQAAADQSURBVDiNxVMxCoNAEJyVgB/yFaKIYpHOVMmfbKJVLEQQbf1BfEryA/dSefGyGo5YZOCKZXaGmYUjpRT2wNmlBnAAgLIsN2NkWUZfDYgIRVEgSRJBNk1jlwAAfr2FNqiqSpCu69obpGkqyK7rAAB0GWW86QlMDzhzdGZGXdf6MfN7OfdoTayuRzJuEMcxlrOB3COc72opNiowM9q21ftRFMnCuUc43dQsFgZhGGI5b6Qx6hgV+r7XRBAEMsEKjAS+768msDIYhsFK8An6+298ATGNZjD6ZVlzAAAAAElFTkSuQmCC",
	met: "data:image/png;base64,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",
	minimizeToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABrUlEQVR42u2XIasCQRSFz4D7IzSIbDDYBMG4omK0aLCYFsQgLutmk1llxSCCyWLQYJVdwSgIdoOIQX+EwrozoIjvraxP1uGBJ82EmfNx73DvXGLZOp/P6HQ6GAwG2Gw2oHsv5PP5EA6HIcsyqtUq25PT6WRls1ksFguUSiXE43EIguAJgO2F5XKJfr+PRCKB6XQK0mw2rXq9zgBisZgnxo9arVaQJAmNRgMkEolYmUwG7Xb7I+ZXqaqK2WwGYufBGg6HKBQKHwUYjUYoFosg9toaj8fI5XIfBZhMJsjn884AoVAIiqKwUL0jmlpd17Hb7V4DoAc1TYP9SBnEdrtFt9tFq9V6alir1VCpVCCK4o87XgJ4hAgGg+yAXTaeAhBCQO/b7/eO5q4B7iFSqRQMw3AFkE6nYZqmo7lrABr29XqNXq/HzKncAFBRiHK5jGg0ytLxJwCaz/v64Pf7cTgcngIEAgEcj8fbnkbgt3fjOgVe6QvwBfgC/A8A7oWIeymmujajZDLJGowbANq45vP5+82Iazvm/iHh/iXzWjcA7t9y7oMJ99GM+3DKezy/APbIzk7bm681AAAAAElFTkSuQmCC",
	minimumValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42mNkIBEcOHDgPzKfkRwD7O3tweyDBw/SyQB0Z5NlALIm+hiAz9lEG4BLE+0MINbZeA0gRhN1DQC6uQJmwMEDB9rJNaAdagBRmmhrAKkAAHwSqgHvmpTtAAAAAElFTkSuQmCC",
	minus: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42mNkoBAwjhrAwJg/2XkakM4kU/90xswe2//54a1k6Z64spqBMaXN/L+5oSFZBpw8f56BMa7e8L+JoR5ZBpw5f4mBMaJC+7+hoRZZBpw/f42BMbhIlbJAJFMjHIwawMAAAD+TGcQ3EsqiAAAAAElFTkSuQmCC",
	mobileHandle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAgCAYAAAAmG5mqAAAD7ElEQVR42m1UVyj3fxR+vmZmRkLeIhfGjTKSVaQoQraSkmyyR3b23nuvEhcoIkqZF1IupKwbI8SFvWX8/r9z/P/e983/U258f885z3me5xzh4+NDhH/f4+MjoqOjsby8DBsbG4SEhMDJyQl/PuFPwPX1NYqLi9HV1QVNTU2EhoYiODgY2trafwPEf5CUlMTFxQWGh4dRWFiIq6sreHp6IikpCXZ2dn8D7u/voaSkxP/Y3NxEQUEBpqamoKOjA39/f5SXl/8GLCwsiPb29qCvrw9bW1u8vr5ifX0dfn5+eHl5gbW1NfLy8mBvb/8FEPMVjY+PQ1dXF8nJydDS0sLNzQ3Cw8MxPz8PPT09xMTEIDIyErKyshByc3NF1dXVkJeXx+DgIKysrJheW1sbMjMzISUlxbRKS0uhrq4OoaioSDQwMID9/X04OzvzwObm5nh+foajoyPTI4mzs7P5uzA3NyeiakSL5CsrK2N1JCQkIC6GmpoaqKmpoaGhAR4eHhAODw9FPT09aGpqYu6pqalIT09nimNjY4iLi8Pd3R2INvnCsk5MTHAFcpjozMzMcNWlpSWkpaVhY2MDAQEB6Ozs/AKcnZ0x96GhIcjJyaGlpQW+vr7Y3d1FbGwsFhcXYWlpid7e3i/A09MTGhsbUVVVhc/PT+Tn57OUFBWiNDo6ChMTE6bNAPoRRYL4Ezg+Ph4ZGRksaUpKCjo6OmBoaIju7u4vwPv7O7f38vKCWASuThSlpaV5NuqooqICEue7w+rqKqtAfri7u/NHRUVFNozkpQSQ/AwQP6ysrCAiIgIHBwdwc3P7BpAv1I08om7fgLW1NQQFBeHk5IRzVFJSAhkZGdTX1zMlVVVV9PX1/QZQjmjQ29tbjgHtAblNeSIqv379Qn9//xeAloWcpA80T0VFBc9DK0sCkOMU/+8OpJA4tZienmbe7e3t8Pb2Znq0ojSfkZERKKQMoAoUgePjYxgYGLBRxsbG7DDNc3R0xGs6MjICYWdnR9Ta2spo4kxUaBZlZWU2MzExkTePHKd5hNnZWRHtMOWedpg0pxw9PDygrq4OtbW1UFBQYHkDAwMhiDMkIvvJbQsLC1A3MzMzbG9vcyzEO8/r29zczDdKEF8HkY+PDxwcHNggChlliKoTBTpB5DwpR3kStra2eIFoWFdXV2hoaHA86KDRkORwQkICwsLCOE/C5eWl6PT0lE8IXQiqSDepsrIS4mK8Bzk5OXBxcfl5KukRd6pIJ4auIclKd4lO5w8A7QKta1ZWFs7Pz/lKUExMTU056j8Ab29v7AetKJ3PqKgokCBEVRCE/6c0OTnJhtGloOtBDhO1/94/a9tQuQRAQJMAAAAASUVORK5CYII=",
	more: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42rWTUQ4AEAxD9azO5awEEZZMGVk/rX3pBIRPQT/OeWPHBaCGQcByBmpIoTeJq096wOg6QHpBa/sBZkYCRuCkBnQBfK/wfokbiA2gQGwPiTQhM4/PZFMBl8ZIEY1jPdoAAAAASUVORK5CYII=",
	motion: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAd0lEQVR42mNkoBAwEqnuPy71pBpwFYh1yDEgFIhXQdmrgTiMVANAoAGI66HsRigfbEAo1FQGItiroGwGqCtWM0L9BRK8RgJbC2qINswL/5G8QywbJQwoMoBiL1AciMSCeljUoUcjMYDihAQLNFAYaCNL0C0z4QQA05w2Y3KoEb0AAAAASUVORK5CYII=",
	mouse: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEH0lEQVR42sWXWSimbRjH//bBGIz9wDKSA2tJlik1CiHClBlki4iQA6Uky3DkQJQZGjvJFpLlREwUcyBESY2aoSxNtoSEsXzf/5rMwXxjbN/LVU/v+z49z33/7mv5X9erhJ92gccxJaXLzc/Ozh50ZxUVlZ8EBLhq893dXbS3t2NwcBA6OjpITU2Fu7s71NXV/zeIvwIMDAzg48eP2N7exunpKbS1tZGVlYVXr17h6dOnigdobGxEU1MTTExMoK+vj7m5OWhpaSE+Ph6BgYF4/vy5YgEaGhrQ3NwMJycnJCQkiEf6+/slHK9fv0ZYWBhMTU0V7wEC5OXl4fz8HC0tLejp6cGTJ0/g7++Pt2/fwtzc/GEADA0NsbW1hd7eXvGMsrIyvL29ERcXBysrq4cBuLi4wN7enlRGTU0Nfvz4gZcvX0qFvHjxQjEAjo6OyM/PF4BLOz4+xsjICKqrq/H9+3fY29sjMzMTdnZ2UFVVVTwAjacfHR2VZ75+/Qpra2tkZGTA1dX1RhDXAnBhQlwFQKM+fP78WXJiYWEBZmZmSE9Ph5eX17UQNwZwcHBAQUHBHwFofH9mZkaen56eFt1ITEyEr6+vVIvCAWgs0S9fvqCurg7j4+MC8ebNG4SGhoqCKhyAxgpZX1/Hhw8fMDw8LM8TICIiAs+ePbs9AONaX18vAIWFhdcCXBq1orKyUlRTV1cXISEhiI6OFjl/EACGg1pB1WxraxPBSkpKQmRkJNTU1G4HwH7A2n737t2VAOyWOzs7ODk5kevw8FBa+erqKj59+oRv375JPhBCT0/v/gCMNcuPn5wNGO+Ojg7ZcH9/X0Tq0pT+nXmMjY1lc3bQO3uAITAyMpJNeWLWvqWlJZydnUWESkpKMDs7K+2a95j5/M7OaWtrCzc3NxgYGNw+B34HYILV1tZKqbEb8mRciLnC6YnqWFpaKh2SGqCpqQkNDQ3xxO92awAqG086MTGBo6MjuLi4/NJ/eiE3N1fiTTmOiYm5NllvBcBF379/j6mpKclyxpJXcnKy1DlDU1FRge7ubskVvkv33wugtbVVlI21zOze2NgQhYuKipJkYyg8PT0FzsbGBisrK/J9c3NTwGJjY//o+hsDjI2NoaqqStxKs7CwQFpamgwh1Pzi4mIcHBxIGAICAiREZWVl6OzslM5YXl4ueXNnAC4+NDSEyclJcXdQUJCM5TQmIxOvq6tLkpEDCTvh0tKSnJ5rpqSkSP3fGYB2qWqsd2b0pUt5nyLDUzL+OTk58PDwkOEkOzsby8vL8PHxQVFR0f0A/mZra2u/Go+fn594YHFxEfPz81KOHFgZMoUBUA37+vpkNqT80itUQcptcHAwwsPD/zq23xuAxh5AAWLno/LRE0xIqt5Vc8B/APjjMf+cAo/49/wfSfqZIRoYg74AAAAASUVORK5CYII=",
	mouseLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAl9JREFUeNpsk09oE0EUxr+dpBHBGmptEwK1EBURvFjxIAUPglDqwaNUEDxIL4IKHgqKHiwevbRUT4IUpSBBSCNCD0qJSJUQhSgISaVpjUmaNn93kzY7uzu+CU3ZhB328XZn5/3mzffmKUIIyKEoSstfebj4xKVYj4YG+/A7U8GNERNNUwFjbHpy4upjuaYdg/ZHe+Ly1GLu6UJcfEzkxNfkthi9FxJyGJyL8FJUvJh/l7PHSGNt0NiDyN1zp3z+s6cDqHML5R1jH+xyuzF+6QJ8A33+5/OhO7CNfQCz+K2TQT9KDQMqFwhHU5S2C58+r8AyTViWheHAAHRuTDkCFIWdEbSTqgtoOpBMb2F2cgQr8Z8QFCwBgcF+glkBO8DdfjnSfxg1Q4FpMjChQGEM2c0CajUNFC5PTiDRKaAdUCjWEXn/jQAW5BJLMKQ3MgieCGLudRi1ShWa1oDfd9QZMHZsG9fGL8Lr9VIwQWhTgzKx9jakMqJareHth6gzYJeEU3c5OOpSD5kw9p7WHZE6NHmTMjSdAU1dz2fyJb8UqsfT03FWCeA6R7ZQoiroeccq1NXq8laxjEajAc4NMrPDy/lKVUW9Vl12BCS+x2bSmU3S24RW1yhVo1U66TVVJS1MpNL/kPgRm3EELEVCcRIptbqWo3R1lCtlFEullucGx2o6J0VMyXWOABr6m5ez138l17G2kQejczPqL+nlt5yX/+U6O0Dp6kYWGBoenbh5+5nHc+B876GDULUd6HoztvBq7n727/qX1hWxC9zdzrJ3yI6T9do2Usn+kJnd7fxfgAEAVD9r0kV/tGAAAAAASUVORK5CYII=",
	mouseLeft2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACkUlEQVR42n2Sa0iTURjH/+d93ZyZSFRrzcuCJXQRs+milMQIUZQIL1AGRkEI4QcriVxhNwMJFCXoQh8s6IPVBymXQ6k0m1o0P4SNDGSlpXNp1rzOXd6dzvsuL9ns4X3gOed9nt/5P885BAGjWDQyH+RcaLrKE39FjHIN+oacKNIJcAsEHMdVFhcevDifTJcULcQZ55pG0hOjVLu3qxGukKHs1it01uZD8PnQ3PYG9u8/HCeP5m0k+NskQNZ5Y2niZmVdmi4WPsEPWQiPynozuuoKpCQfgxhfdMIxNl5KlheLQXZ544f8rKT4UDkHwhGYLV9g/TyGK7kqpKfsYlAB1k/9MPdY7f9Il3o3PKG5OXp4fYLYLx49fYeaEzo0t7SivOQ4vAzgdDrRYGxfmMFSI0XVbXRn8hYITD7HFJhMFpzJUaOjw4xrhhJp/9dPBnjWjuUzkCzTYKQer09KFOl+yuGIjoLnCVxuDyadE5ienoVqw7rggNrb9+ih7DRERkayYgbxs8FRwuLAf7GtiYlJPDa9Dg6oulFP8zJToFCEgRCOqaD487E1YUA/5twuNLZ0Bwdcrr4zslefoFIr10Iml4HSxTGJAK/HC/voOLudXkdQwNlL1xuSdsQfjtOosSo8HIH6wEWxeszOzGBgeBRve94/DD7EAwV79mVkd+9PTRA7hiJUEZDOSHMuF+NQvOzuRftzU0pQADO5obLOmrBVG6eJWi89HFGFeHoIz2NweAy9fbb+qopT8SsBELtJm1xUfNqyTRsNTbRSOl1UMTg0io+2ITy4W6v/OmDrWREgalfHaFILj5XUyOWh+ojVYZiadsHjcVsa7t8ss38b7BKfyP8AovHMtcwjluxNMbcxF8TFb6vUC9IlQ2juAAAAAElFTkSuQmCC",
	mouseLeftToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABkklEQVR42u2XYY+CMAyGCwISRYma+P9/HwZDIBoE4e7e5ZbgwkpnOO8u8f3igmv3rCuj9T6+RL8oTwrgeZ7I4W63o/P5PC/A4XCwOjXNfd9XEHmezwOAnR+PR8qyjAXouo4Wi4UaY/7pdCJJcFkALB6GIbVta3WgzfE7PKYoipTdFMQowP1+VwtLxC0QBIGKDEAwFgP0fU/L5VKBPAugI4KN3G43lRtiABjiPEFvarvdUlmWD8/SNKWiKNgo2EBHAZIkocvlMmqw2WyoqqoHh2NQQ63Xa6u/UQA4xCLS0CNiXC5oaDEAzmsqe10A4A95JQaQ3HomgMt8EQC3I/N/1/lvgFkATL0UwFVvgP8HwN1cLwGI45jqup4NAJ92fJLFAKhmmqaZDYCrqv5mDuiLZg6IKV/WolRTm8WmVNpu8lblAFCWIXl0ue0ilGFIPq4cYwGg1WpF1+tVjfFa2gpLc2ENPLR/CgBRQFHJ9QU2IfNRVT/VFwyFtgxCaybqdL7zZb/fi9oz5+ZUcke4vD1igJ/SJ0ySn7BBDep+AAAAAElFTkSuQmCC",
	mouseNone: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACq0lEQVR42n2TaUhUURTH/292MxXUdBzNCQaFxAzJKdTMVEIQJRAhJ0ujwLQFLQ0rMU2plLQsKs2gxZYJESE0UVoGMzUYP4RKBTLhkuOWormMzsyb233jh8xnXThw7nn/8zvnvnsPgzWrRvuqmGVtBZwvFArBsixWfEFJumb/pbV6ZvWmqrZhVOHpLo+LCoVILEJ59XPkZqTAarGiWdcF4/jPsczURK91Afdq67PkHm6VCTG7IRKJ7LHzl8tRWphr961WKxrffsTY5FTWidSk2zzAjQfa3r07twUG+KsglYjwvkOPVlo1lnYTHa6GxWpD77d+tHf3GbOPJXvzATUvSHzMLigVCkjEDB7VNSE4OASvW1qRfzoNZgvB9MwMtI06nE0/yPAAFfefEU18NFxdXSClgLwrVYiMjEBbWzvK8jOxzAGmZ6Ft0iHneAofUFVbTwzfh+Du4QZnRwcwQjH8fT3RPzxOf6IZUzR5fn4Rck93CjjEB5TeeUIOxO2Bi4szQFgI6RcBNRsBWMKAYQSYmf2FuuYPyDuVxgdcvfWQJMaGQSaj1QUCGiF/XRax2bC0bEJDSycuZh3lA4rKq0cj1EFyBT2CWCIGIX8ADMPAYrbAODGFdn3PWFFuhhcPcK6wTLtje2Cyn1KBDY6OWMkndgnNx+LCAgZGJvCp+/PL68V5Gh4gNiEpNGpfXGdMeBDdCSCTyuyVuU6WTCaqJHjX2QPdm+aw1sb6rvWesuRCSWVf0FaVn9J7E6x0BrguuOoiOhODI5Po+Wrov1aQHUi15nVnwXeLKuRw+hl9gMoHSh8Pe3Wui8EfE/hi+IGnNTfVQwOG7n8OE9e7YrMyXHPkZIVEIlU7bXTA3LwJZvOyXvv4bo5xeLCDamz/A3BLSE1FzWlVbI6agRq7Vvwbwv4BIJf3UbUAAAAASUVORK5CYII=",
	mouseRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmtJREFUeNp0k0toU0EUhv+ZPMRqX5ZqiEoXbrrQhQsXogtduHHhwp260IU7RQsuCgVdKF0WfGCFgg8qNQpVqEFFUSmVolCqUtRFrDR9JqbN4+amt8mdO3c8E01JwnWGw7kzc+ebc/4zw5RS0I0xVvYDkZGrynUvBzgw9IWjc0cL5lNZSMWvveg9dkX/U9mDyqAycWfwWWLkzZiSQtCUVAe7nqpPsRX1biqheh9PqiPdzxPVe7T5K6D+weEL29pbQ0cP7wf3+9fh2TUHjnSxtzOMZaMU8vVEL9LSjco+XvmwhdPdEW4HhQ9H2Lj+8BU457gX/Yq05RBIYk/ndnBXnEVVWwe40g2Ht7ZBEgCUUbPfQqTnENK5NSysWDBtCpkiY4zvrgb4q8T4p4WCSz2TzmFuKVUWtyiBgmTgimFLWxM8AZQC+gYiaGhoQEtLMza1tuHtx+8oOQwfxn9oPnw+jmDA7w1g1M+fPo7mpia4Og2KxEeV7aIkOdNl5jAMA09ejnkDpHRQskvImwUwEk+nw/6Sy3ClXBSLAkWh/peCnVxMZkJayEAwUHNZtA7CFlhKZegQO+lZhdW8MZozTFiWBUF6CCFrvJ5fTmexahqjnoDF+dmhWHwRrpIorBbKKWkttC+YJtVFIr7wG1OfJ256Ah7d73+fN/Kx6XiCwrWRzWWRzmTKXjgC0zMJEjH/83V0eNITQM0aunvr1LfYLGbmkqQ8K6uvvR7reVo/qeWqBrC618jDOzsOnDhzri8Y3LCvcfNGmIU12HZpIvLg9qWl+dlxfWlrBK5/ztR8ZLvIGqsOMsl+6WrXP+c/AgwAPQVgQ80KvJAAAAAASUVORK5CYII=",
	mouseScroll: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAj9JREFUeNpsU01oU0EQ/l7+TDRtKTZNDEgFr4J48CDePIqgHqsgHqSXgh48eNKD9iZ6qLQFS0FLSlWKUEqF3krRgwYViqe20lRN06hN8vJeou9n9zmzkvoS3y7D7MzOfjv7zazmeR54aJqm9OPZ+btCyNu8DofDEELg7zp0b2jw/B1et86gZbQcE9MvS/NLK55jOx6P+xM5pdlmP+/7z7CEWkDj03M30v29mbNnTiESjSjfz7KKVzb706neDMVdh2/sAfy2nGtHDqUgXBeQLkZm8ijGT2Akl1e2JyUGsinYjnsrEIDyOZZMJqCY8AQW3xYwdOE4Ft8VlM0A2f6DkEJm/QCRf+clkvEEPEimFFEicK0mlaYUyE9Teu0E+gH2J+J4OPkMfXRL94EEXC+Mp89fkwbGcgvYregwzSYy6b5gAL3ewPCVi+jp6VYpXz5H76P30KUQnkZlDqGm1/Hi1UowgKR6W7aFumFCCzE1/lQ1xYHlWHt98R+A7dg7xXIlw0RFY9G2t3KTUS9g+3tFxQVWoWHoyz92q2g2m3Acl0S0afbXdAONur4cCLD6IT9a+FYmvgXMhkmpupCUNmvTMIgLgfVCEasf86OBAEsLc+91vb6+sVmidG1Ua1VivqK04zrYKJTA+xwX3EhEw8zUo0uf1raw+WWHKqCpKrBmm/28z3F+AK3jN4ayhwdOD14dfhCL7TvZRZ1pmL9g21Z+9snYze2vW2+4YG0Ed35n/rkkR0m6fBcZJJ9JROd3/iPAAPBKWGT4TirwAAAAAElFTkSuQmCC",
	mouseToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABjUlEQVR42u2XW4+CMBCFB+RiBEmUxP//94yBB25BQNw9TWoIS8vUrWs28TxBaTsf06GcOvdv0RvlcAEcx2FNeDgcKM9zuwBpmopJ510BNW9zXVdAZFlmBwBBTqcTnc9ncX+73Wiz2fwAmLaj/+VyIU5ytQAI4Ps+dV33aEN3uRxTgGk7FAQB9X2/CrEIMAyDCCwn1gHqnnueJzIDEFyzAcZxpDAMH2+gKkAdgByHF7ler6I22AAYiPVEJlSBlwLqsqB6vggQxzFVVcVO/dpSRFFEdV3zAZIkoaIorAHs93sqy5IPgPVCHdgC0M2nrIE1zQFM+rMATD4/0/4fACsAc/0pgKk+AP8PYG0nfDnAdrultm2tAeDXjl8yGwBuZuqCfit4AngLNsDba0BuNDYg1uZSmlJJrbNkOslxq7uqDgC2DMUj7baJYMNQfDo7pgWAdrsdNU0jrvFZqozlPLAEno5/CgBZgKlUVbBOqHyY2qfOBVPhWAYtHc1U0NDxeGQdz4wPp5w9wuTrYQO8Sl+iDqiwSnW5CgAAAABJRU5ErkJggg==",
	mouseWheelToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABiUlEQVR42u2XW4+CMBCFB5BLUEiUhP//94iBB28BBN09TWoIS4fBrTEmnicobedjOpRT5/4reqMcKYDjOKIJt9stVVVlFyDLMjXpuCugxm2u6yqIsiztACBInudUFIW67/uePM/7AzBsR//9fk+S5LIACOD7PrVt+2hDd70cQ4BhOxQEAV2v11mISYCu61RgPTEHyD1frVYqMwDBtRjgdrtRGIaPNzAVIAegx+FFmqZRtSEGwECsJzJhCjwVkMuC6fkkwGazodPpxKZeCgCt12s6n89ygDRN6XA4WANIkoSOx6McAOuFOrAFwM1nrAHbWlQDc5/X0gxw830BPhNgqb4AnwcwtxO+HCCKIqrr2hoAfu34JYsB4GaGLui/gieAtxADvL0G9EZjA2JuLqMp1dScJeOkx83uqhwAbBmKR9vtJYINQ/FxdowFgOI4psvloq7xWZqM5TiwBh6OfwoAWYCpNFUwJ1Q+TO1T54KhcCyDpo5mJmhot9uJjmeLD6eSPWLJ1yMGeJV+AB9Tk7A1B0YCAAAAAElFTkSuQmCC",
	move: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABQklEQVR42pWTS0/CQBSFz0S60VQwUK0gFsWYsDBuZOHGxF9O4sYFbowLEyPaikWUNuERdYHmektL6SMd8CaTzpw552tmeisgq30ivAghswhZ2DgHrGueSyAiM9wEBq+AtseQdjYkLVZuCMrxbFo+VdG7nfj69AGwz4QcoHO4H5hqY8rXVYw6DDA3RWo/Bah+0uzZ3QgB6xUVX3YEkPSEAH1MCpun9mSBzvEoqoDL2k/klQZrFmt9HyqwMyDoJcDLqpGwV988lMShPW2Lh+kA71pwsyWGbDPkw4mb66x1EprBmsWao4n4HRR7/vncsgjXjV3g/i2uRT2pr1C4IgwvAnOXcMJNcMfN4FZFaj+zDwotwtqRP58DvPp9BIaXS/pgXnmT0DQW67YFjGordmIIeWLIAYefOXz4z38hCpGElwNWqD88CnURPEHKNgAAAABJRU5ErkJggg==",
	moveBack: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABEElEQVR42mNcuHDhNAYGhkwGTDA9Pj4+i4EAYJwzZ87/2NhYhn///sEFmZiYGBYvXsyQkpLCSNCAKVOm/A8LC2P4+fMnXJCdnZ1h1apVDDk5OYQN6O7u/u/v78/w+fNnuCAvLy/Dxo0bGUpKS7FrAiMou6mpCWzAhw8f4AoEBATABtTW1TVi0V+PYkBlZSXYgLdv38JVCAsLgw1oa2+fjMWAXBQDioqKsMaClDIrQ3F251IsBkSjGIAs8x+MGLYTCDdPQgacJGCAOSED7qDrmLa4ToXnnzI2w6ZjM+Aduqq5c+YI4Ups2AzAAFOnTGHAldiIMqCnu5sBV2IjmFRBAF9iI8oAfImNKANwJTZQLAAATrR8kyon97UAAAAASUVORK5CYII=",
	moveBackwards: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABLElEQVR42qXSsWqDQBzH8d9lyBBEJK6lL9An6BN0UkOgm5DBIbQgpAlCI4Xe0ggNUmigxcFBcCtIolOfoE/QN+hqCCIOGbyCa/+2Qv/c9v3fZ7ljURS9ALjC7/M6mUyuqcDCMBSmaaKua/Jmr9dDHMewLIuRQBAEYjwe43g8kkC/30eSJJhOpzSw2WyEpmmoqooEBoMBsiyDbds04Pu+0HUdZVmSgCRJSNMU88WC7MzzvAYoioJckGW5AW6XS05kzjjnwjAMHA4HElAUBbvdDvecPxH5hrmuK0ajEfb7PQkMh0Nst1s8rFYhkS3mOE4D5HlOAqqqNsDjev1G5Es2m83+/EjqaY27+fM7kS5+PI1oDj7Qbc7bgM+OwFkb8NUROGkDio6A3AZ0nn8D36Egbvmf8Kq/AAAAAElFTkSuQmCC",
	moveForwards: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA5UlEQVR42mP8z8AARMQDRjBC4kMNaCBSfwMuA/qJNKAQlwFziTQgGZcBq4k0IBSXATuJNMAdlwHHiTTActHChcj86TADrhJpgPaP79/BDCYmJoYlS5bAXfCESANknj19CmawsbExrFu3Dm7AJyIN4Lt+7RqYwcXFxbB582a4AUSDC+fPg2keHh6GTZs2kW7AieOQ8Obj44MYgEthQ0PDf39/f4YPHz5glRcQEGDYuHEjbgOqqqr+BwQEMLx79w6rvJCQEMOGDRtwG1BaWgo24O3bt1jlhYWF8RtQUFAwDUhlEgiS6QDlDVdMRRvQrwAAAABJRU5ErkJggg==",
	moveFront: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVR42mNcuHDhNAYGhkwGTDA9Pj4+i4EAYJwzZ87/2NhYhn///sEFmZiYGBYvXsyQkpLCSNCAKVOm/A8LC2P4+fMnXJCdnZ1h1apVDDk5OYQN6O7u/u/v78/w+fNnBiNjY0LqIZrACMpuamoCG/DhwwcGO3t7kFgjAf31KAZUVlaCDXj79i2Dl7c3SGwyAQNyUQwoKiqCx0JvXx+IWkrAgGgUA5Bl/oMRw3YCBngSMuAkAQPMCRlwh4ABKosWLoSxp2Mz4B0BA4R+fP8OT2zYDCAInjx+DE9sZBlw7uxZBl5eXoaNGzcyEEyqIICc2GBAQECAeAOQExsMCAsLE28AcmJDA9MBIP5pkzSIo3MAAAAASUVORK5CYII=",
	network: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAv0lEQVR42mNkoBAw4pL4pyDz/y8TE8Ovf/8Y3v7+zyD39CkjSQb8VJL7/z85nuHvuw8Md5auZdB/8Yw0Az7KSv9niQxh+P/1O8OF1VsYbF6RaMB9aen/r/8yMHz995/hNQsnQ9izu6QZgAHqz/xnaDRhhNMkGwAzBATIMgCmmWwDGLBHLUkGYIta4gwAOv9/gzHDJzkZBvSoZcTlNGSNjIwQddiilhGr09I3MSBrxAfACohNdTgNIDbV4TSAEgAAF2KSES1gCxcAAAAASUVORK5CYII=",
	network2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgElEQVR42p2TAQ7AIAgD6f8fzRKHimiRjZgsEnpQdRALbUsEbWWh+n4Bq5/iHgbRoMQUjxQyQNI9AIoWdJ3CWTgXXnPiAaFg6ULFBLD7PMyopkYV0HMY4g8Wzt0TgHIwt/DrBuYEjkjqImTst0NhkPDQrgCfQ/bUSxbugEKwf+UBzJJDDZsByN4AAAAASUVORK5CYII=",
	nextLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAAWklEQVR42mM8e/bsfwYyACNIo56eIVzg37+/cPaff/8Y/v7+B2f//w9hP7h3iwYarawswPT+/UeI1wjTBAMgzQQ1WliYYg2M3XsP4daISxMM7NpzgIaBQ0gjAL5Fk6CV32pMAAAAAElFTkSuQmCC",
	nextRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAAWklEQVR42mM8e/bsfwYyACNIo4KSGoTDyMTAwsQEZjOzItggwMTEDGdfunSeBhodHW3A9LFjJ4jXCNMEAyDNBDW6OtthDYwTJ07j1ujm4oA3JGGaaRM4hDQCAOLvQqCYTghDAAAAAElFTkSuQmCC",
	nodes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAALJJREFUOE9jYKAW+M3E8B+GSTbzPwPDfxD+0VaH1xCcloAkQJphGMTfu3fv/H379vXv37/fAOQivJbATEZ2AVCjAhAXAA06D8T7sVmC4lVCYYDNEoywgjpZAFcgErKEAejkBJDfcRkAlOcAWjIdbywBDdgOVOiBTRHIcJAleA0AKpAAKjyOroiQ6/AGKFCzBig2QF4gmMiwxTfUWxoENYMUEIxvQqYQFd/EGgIyjJBaiuUBDOrRYmwTjMEAAAAASUVORK5CYII=",
	nonlinearFit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdElEQVR42rWTUQrAMAhD9WTz6O5k3VooE1tr/Jj0p2BegihTsdp4XzEiUtUmItzFr4DnHwZMZ970/w/ocS8R8tFLCSJ3CHASHwF28rcq+ehQgswdApzcQ4CdfDajsAGJvwD8ymbiMEEZYDesIh6AzXnC4l4PMllCD2yRNZAAAAAASUVORK5CYII=",
	normalDistribution: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR42p1TgQnAMAjTy+bp7rINB47SJdquFFokTWKoKsW6ni1yuouZKcLAortfh9n7MIiUYGEx1fNR3JmLTyHUZ9VtB0iRuaAEsyJzAVuIAEcwqv1y0LaAAtxuocsgRSgBs8pyWAJVznQFVLnTLrwu4PanIaJx0DRHVovBYu3EeQNpdHwPZPim9QAAAABJRU5ErkJggg==",
	normalFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB4klEQVR42qWSO2sqURSF14iCaCVoFRsVfKCmSRMtFFKIhdiJjfjAWv+AWNiIlYWSykZsBRERKxFfIHa+GkEULXyRdBbxeTJzLvdyAxNv4K5qzuw53+y99mLwn2LuFZfLJZFKpZDL5cyPAfP5nLy+vqJarWK324EDmEwmRCIRuFwu5i5gOp0Sj8eD0WgElUoFg8GA1WqFyWQCoVCIXC6HUCjEfAtwu92kUqnA6/UinU7j4eGB2e/3tKNEIsGdMRgMoFAoGF4A+wfCjgCfzwej0fin9vb2RpRKJU6nE7rdLqxWKz/gb72/vxOG+VX++PiARqPB+XymgOfn5+8B5XKZlEolDIdDCAQC+u52u2E8HlMfWq0WLBYLPyAej5NkMonr9QqHw4GnpyeIRCIcj0fqCad2u80PYFsjLy8vEIvFyGazCAQCX+ASiYRwIG4EXkAmkyHRaBQcpNFofLnMrpJotVpcLhd0Oh1+QKFQIH6/H4+Pj6jVamBdp7XFYkHC4TAHpd01m01+E2ezGbHZbFiv1zR5TqcTm80GxWIRMpkMh8OBrrFer8Nut/ObyMaXxGIxuoHf4kCpVArBYJCGKJ/Pc8/3c9Dr9QibQKjVapjNZvpNv98n2+0Wer0eOp3u30H6qT4B/tLUEeubKNIAAAAASUVORK5CYII=",
	out: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAddJREFUeNpibF4VOY2BgSGTARVMB+IsNLH/DFgAy8/vPzKzfBpRBKdtqc/EYgADFnUMLF+/fGU4f3czXHDP6YMMNrp+24Nss1EUrzs8dXv3ihJPF1N7uBhIL9OXT58YXr5/DscpPlUMO44u8Vy+u3cbTCGIDRIDySGrBell+vThE8OLd08Zdu7bB6Y3HpvIkBZUw7Bx7zxPmAEgNlgMKIesFqQX5ILpRw+dZnAwCtoOokEmN0zIAPNhBoDYIDGQHLJakAsYHGIFwfj///8MExeVbQOy/4NoEB8Z45JjtAzhZCAHHFv9DUwzMVAKgAkJjEHO2XFu/jYg+z+IRvcCLjlQQgKnxC2n5mw/eWObJyixABOI5+/ff7b5mKV4gSwBym1DlwPxwS4onOr2//6LU/9h9NZTrXA+zBZscjCaWddWtOEP02sGP6t0hiNXlzN8/fGFYfn2uQzWOr7bdZWtloIseffhlfnibb2qgoJ8DA9eXoSrvffgPgOzqglfAw8/G8PNxycZvnz/zHD0+BlgPAdvj/Uq94KFE8igN+9emu88tEkVWe2jB88YGL0zZf6r6MrAAzXIppCha3oxiMmInhvLMnsZ1h3phwvcufyEgRGYOCjKzgABBgA0OmrABy5b7QAAAABJRU5ErkJggg==",
	overlays: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUUlEQVR42r3SUQoAIAgDUHf/QxtESoFFskyiD5EXkyBk4Qmg/YjdAtzDW8B76zD+Ackl6gBgXR6IIkSR6oBUBHsN6lvkgTkCDj+2DkhFYIoGGo3vNBHRIGvIAAAAAElFTkSuQmCC",
	overlaysSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42r3RUQoAIQgEUOdmHt2bGUQuy2KQTK5EHxIPZoKQgyuAzyNxC3AObwEz8+9jVcV/QLFEXwBiywNZhCxSH1CKECXCnxZ54B0h+75+oBSBGRoY0d9AES0899gAAAAASUVORK5CYII=",
	overlaysSamples1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42u3OUQ6AMAgDUHoyODqcjP2YRetIpvJp/5auL0CKuHue32aG1T+0ATzgbAGqOouI6AWqi7YB7n6gAORBbsDbTCBTclnM0IEAmgFhIGl+JXFsPwMDGtVgEWwXfGcAAAAASUVORK5CYII=",
	overlaysSamples1Edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABNElEQVR42mNkwAEOHDjwH5nv4ODAiE0dI9UMQNeADogywN7eHi5x8OBB6hqAy0VEG4AuRxsDGIgAGlfDGX5wODMwf17GIFvAwMhIjCYYeN3M+p/Bpp+BXcmK4ffDPQwvt9S/hBvw/z8DigvQTX5bz8DAEd7D8G1dJQO7dQMDM78sw8u9/T8QBjCgG4Dgni9mZVCrmMfA9aaJ4dtLboavh68xfGGRe6tUeVeEoBeOpjL/N2ibBdRcysDA/oPh9wcTho9bj/8Xrf3NhM2lGJp5nLIY5OXnM/BL/GP48caS4duWvQzCTQh9OA3Y1cL/3yJmB8O3xZ4MH39/YJDzs2P4svUQg2g9qh58Lvj/Z1MSAwPzb4b7OxczCAhzAjV/x1CP14CFcQx/tCX5gMH/7ZhJ4x97bIoAlJWL3qbhLiQAAAAASUVORK5CYII=",
	overlaysSamplesH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42t3SSwrAMAgE0JmT6dHHk9mST2mhKYFsQl0Z0bcYQiwWl4EEsnTZBgQl5cyxu3MImFl5RwTMvfYS7vNNgPOyAeyxFsC9LkqBEfYXoIfIvFKsIT4W37HNgemvPLP4VcvAAU8yshEIxWWTAAAAAElFTkSuQmCC",
	overlaysSamplesHEdit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABUElEQVR42mNkoBAwUsWA/yAEJBgZGRgPHDjwH5diBwcHRqIMsLe3Zzh48CCDvYMDw8EDBxhg/EFsAFA/0ABGEA9sgIODPcOBAwcZ0A2iigEvpor//8HhzMD8eRmDbAHI0SQYoH3YlYHBpp+BXcmK4ffDPQwvt9S/JNqAd3UMDBzhPQzf1lUysFs3MDDzyzK83Nv/Ax6IjP/BoQgJRLiTIQbxb3ZhUKuYx8D1ponh20tuhq+HrzF8YZF7q1R5V4SgAUdTWRgM2mYBNZcyMLD/YPj9wYTh49bj/0VrfzOhRCM2A1iXOjPwOGUxyMvPZ+CX+Mfw440lw7ctexmEmxBZAKsBILFfR/wZLGJ2MHxb7Mnw8fcHBjk/O4YvWw8xiNaj5h98men/n01JDAzMvxnu71zMICDMCdT8HVc6wG7AwjiGP9qSfMDg/3bMpPGPPTZFAObt7t7qkTlXAAAAAElFTkSuQmCC",
	overlaysVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42q2RUQ7AIAhD5WT26HAytmWLC3VfK3yYGNPXVmyIY9fh7vlHDMAWYM5JaKv3rB4R0QyQKwA1QTKSEoV7M0DfAlANR2Vyon0LKkCqoMwCnBHz8+EtQcrbvBEwGECfSEh7tDLgAKu5WBFpPfWqAAAAAElFTkSuQmCC",
	overlaysVariablesEdit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABRElEQVR42mNkoBAwgogDBw78J0ezg4MDI9wAe3t7NKMZUfn/Ue04ePAgqgEUu8DBAdUF/9GNRHPRwQMHqOwCewcHtNBFNRPdRWSHgcbVcIYfHM4MzJ+XMcgWYAQ1fvC6mfU/g00/A7uSFcPvh3sYXm6pfwk3AOhEFFegm/y2noGBI7yH4du6SgZ26wYGZn5Zhpd7+38gDGBANwDBPV/MyqBWMY+B600Tw7eX3AxfD19j+MIi91ap8q4IQS8cTWX+b9A2C6i5lIGB/QfD7w8mDB+3Hv8vWvubCZtLMTTzOGUxyMvPZ+CX+Mfw440lw7ctexmEmxD6cBqwq4X/v0XMDoZviz0ZPv7+wCDnZ8fwZeshBtF6VD34XPD/z6YkBgbm3wz3dy5mEBDmBGr+jqEerwEL4xj+aEvyAYP/2zGTxj/22BQBAAjrhd47ppvjAAAAAElFTkSuQmCC",
	palette: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACt0lEQVR42o2SfUhTURjGn3Pv8mtoLpwfhc7CUktHGcRMsmmlFSvUiEz9x6S0tAhNySKwklKIamRFijVMUakkiSQoktLEAkulWiqIWmYRbfkxnXP3ns6ExjQKn8OBc9773t+97/u8BA7KS0JARjwOB/pgKwgULERAMTRiRMuDFugKbqMT80T+HNou4WC4P69lR1fwAjr47ahwvoLdlqvYab1lS6EmM2rzK5F9txm/5gCeFCElMgTV5kdRRBx1h0tiM+qkWaglx6CmD5HH1iK5HFQQMGMw6E9XIeZ6E77PArYo4XwvH0NUJN4GnQqUIWX7OjDq5oEBuhJhpANOnAWuIStmv2fuG4RgsbZpihHd3guB5O5CVGESWm00q4UH4UXwPMVftco9IZpnQMZNs/e3/ciMP49ykh5Dgi/spx8JAYcFqMU/ENIZCyJGvn7wPcR+0BasP84diAwSyyQca+B/ZJbwKNy0GdMSCQpet9Py8jF/uws5cSQ0Jw41Uie67l8AC8dBqwyDE2tmhr4Hd5qsauKYkKwiniV7qa27Tgsp59ozxM4BVKYjQR2CBsf5cJT+hxQ33iiwXDaJ3I0DKGpEkD0xbBlI41H0CSKWfjZy1XJ3GsHKWe8IqOn0Qm2XHArZNLSa/qHgU1DYAWkqBJ9NwKfuL+RkYhkt3baGuN1Mo9+YO+6UuWoVY2CYHEfXSC+UfpMwTghnNFpabAekqhB+LgHdw0aURJeiMEsNnxPxGGAAl4mpVIyaSlhdInyXhEKgU/1HqqF8rqcmO2BtACT1WRhkVvra7GZ7Fdt+tmeGsT34acyG5+IqyDx0Bt0rLvbiY7EL85t1OZnboVGKDTwHF8e4rQTbbE5bSWfFS6Ron1K9fULndzpTTVYnbyC53h40mo2mF3txzGQh7170oE7XKt5/PwzBMf83oVT6gpyjkXcAAAAASUVORK5CYII=",
	patterns: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42mNkoBAwHjhw4D+6oIODA05xoGAbhgH2Dg4MjAwgxMAA4sMMANEwhTA+1IBKFANgCoGS/w8eOAB3AchgGICJ4zQApJkRiU+SC0a9MOoFqniBoszEQCEAAMs98wMavdMDAAAAAElFTkSuQmCC",
	pause: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAddJREFUeJyNk81rE1EUxX/vTSyBgtCd0OBCFKSom6a6E6v9A9KNtP+AH4j+BRpR6Fpw5cKdYN0li7pTQRClWhdqKUI3JkxA/OjU1jSZzNx7XaQtM/GrZ3e455x37ns8Z2ZkcerBqxNDgbvloRxgJVGlJxr2UlmKRW8uXzj7Pqt32YDTDxdrgacSbnRZj1NkexY4GC44RgqQiNWXL01N5wJuvFgtvmxFq987vVJzo8u/MBIYRSQ8QPfI0yuVrgd43lyb34sZIBJHW12pIfvmAdzko8UJM3v97svmf825JtpFVU/6ONW5cODktWtTfL16bpc3L0/y6eKZnKZNgdSY88XAja3HaW6oZqgZ6ce3u1wyHCDxAaTJmDfVURl4SjEQzQRqPzALw6Eqo15UGcROg1yg/SZD1fCi2gpcfiBqZFsNBvYrGKLa8u1EVoYL+YS+IbtSPhDAJzHigxU3fv9ZWVTfNDp5wc6FFY6O/5G7H99QkQlnZhy796TWEatEMrDLX+C2NtFeXI+qM9Me4NBQOltEwv1O9mbuboXyuTELA5/p8N3HNVOrtCmQ+ABju5EZPomxzk/UqEfVmfxnyuLgnYXjiNxWlbJJWlI1xAgFlhRXja6f/5DV/wJ0gjOMaq0XogAAAABJRU5ErkJggg==",
	pcx: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAI0lEQVR42mNkYGD4zwABjAxIjP/IAsiCKHwUFTBdjOgCIBoAQGcHBKQPXOsAAAAASUVORK5CYII=",
	pencil: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAhpJREFUeNpiPDo5i8EqZyoDseB+qc51no8PZRn//7sN5Kaw/P/3Fyzx+Qgjw7UL/hgalC/uZhCZ/RXMXjGr77+MjB2DxoeFIK4BEM+BG4ALwDQvB2qW0zZn+PfPlOHG72cMGjd3M/xnZFJl+ff3D07N5jkbwPThOVX/f7AoMggLCzPIyckxnGUoZrj0m5dB9t2Fr0z/cRgA03xqdsF/swBPBmeVJQzHDm9lePToEQM7OzvDEyFDBtXuy+JAF/zGqfnkzNz/BkFhDL8fpDEIMt1gsBT/x3DkABsDG8MvhriMYkaQGpZ/f35j1Xx8auZ/o7Aoht8P0xj+/7jB8OWrKsO3l6IMqv8uMNhnzWWEqWdCdgFM89EpqUDNkSianz3SYfjzixmu+U0qN9QAqAt4bf5DNE9I/G8cHgvUnI6i+fcPoAXZq1E0Y3jhcE/Mf7P4NAzNv779ZbDM3wjWfHJKAAODviskioGY8f9/iM0HuyP+mydkMfxB0/zzyy8Gq8ItCM1o4cUEYmwutDpjElXA8PdZM4rm759+4NQM98LGPFNjRXN3Yy4JI4bf/ysY3r/9AtQsyfDtwxcG29JdeDWDAxGYkMKVnSIZ/ry9B+TyM/DIpDN8e/+ZKM2QQPz7x4Pp9xuGb++eMbx/cofhxv5tDB4dxxnRoxanAe9//NLd1pJ5Gci+A8RbgXjHrydnGDY3xWHVEDzrGgofIMAAtJUTgspUaikAAAAASUVORK5CYII=",
	percent: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAg0lEQVR42u2TAQrAIAhF5xE9qUdsNHA4yZktZoxJUMkPH1+DbbGAbIAfaAiIiAoidsNF9RzlWGdhkHm+X4B6Cz0BqoUlgDynO6RhTIfqzoJWYUvnvWu5pfMm0F0LPb3noGyddCwFqDU/7lBHgCIt020yHZodo0P/faDIL3sFaEYsB7QDJT3CEaCc/7sAAAAASUVORK5CYII=",
	percent2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwDkoD/mOR/4/LMlwGMKJpItkAZHmcmokNA4oM+E9IDSMlmok14D8+9YwENKMbRLYBJLuAaDAMDAAA8VAREbrTaDwAAAAASUVORK5CYII=",
	pie: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABbElEQVR42mNkQAL7GBg4GRkYHBwYGLaB+Iwg9B8IgSB0NYPX//8MB9aEM3xH1sMIY+xlYFByYmC4iyYJNwAGglcwKK+NZLiHYsAuoGZXNM24DACBgKUMyhtiIIYwAt3K6cnA8I0BC8BlAAj4LGDg2pLI8J1xCwODpzfUz6QY4DWXwWtbCsN2RqAsVgWEDIAqYKSdAU3SWib1T6+dZSAAsBpQL6Vp0hxQ+/P/tMjLBLRjuqBGUsOkzafqx//ZsVcI2Q42YC4wFpKgsVAhoW7S5VH24/+CJIKaGVMW+v2fk7CZcSYwHQCdUH5HRGVzr0fJj/9L0omwGWhA/Fyu/wtTvoNTYqGQEmO/ZYYWw9ZS4jRHTFP5vyL7LiQiYMA4SYnh7Ny7BHUbJ6swnJ0HVwcygBmIhYFYhIGdn49B3FCX4dH+WRga5RzTGF6ev8jw8+NrIA+Ev8AMYAJiTiDmAmJWAvaDYuwHEH8F4l8gAQAZU3oREAfNfQAAAABJRU5ErkJggg==",
	pin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADK0lEQVR42oVTe0hTURg/59zdmc6sNg1XWD5KKkuthWVRUGmWklTaS6woZmmFaQuCKCoiKK2UgaYxCpVCSiRNK3totdJmrVJnTej6ysdwm2654bZ777ltSoL2OvDx/XHO9/t+Dw4E/zv8vch9ncSH5QGTozrDDjflIe7JUfzrGv5tLiitElE34rHvvtJLQ0MWmd1hpyAE15zDt3gxuZCpyeD+CbBd3kqUp4ewK09Wl6ApXsn16g4aMCYSIJQFao6dAhvlEDxN5/4IIEpUIGOZFPvEXZqLHbYX66I3BulH+IyysQlgxsEjSP4qtupQA4otQBMAUFwhxNWHR6kFXtBNFVip59DxI8JqGsAenl7QMEKwJrOZx9hte+iHKaVkvIL4jQEZneNNd+hAZEpqgZ9YlGBjENNFaVFvcy0aNhlecjPDspkfulf4mcw67gERfwuylQc5FHfzBN/N7WJAUDATFbnEk4UkaGrXw4Gur3CQem+3GTojraqbnzzXZCKLMgf/ZuKM3SUNEaHBKwPnzGbn+M2Cyi96RFEUa/ymIqwDHbkj9fJM983XyJHHMnpCjJGnalDDlRgcIL0n27I2/KpAIGBadTSvvXcQG6iPyNyj6bMZu8M5bbl+suRJHvgSq07fub9gXsA2sw3Qn79QUKd9y2MAv4cLjAl1bNh02flI4iw12KU/PAHg7oNaImnrerbmhfJkaaMxWzPsTdsxjzQMmrFl2IQs5qEVOOlMvjT2gETx6LYaJBuWjwMYjIPIWyTEDMtFvHvzWqWqfy2XPfOt8BS5neUAsXSh4LjHh9WcBiAO74hPlNyvLFOPbuWAepxBd4/Ow2YxqWvr6tjUtDQXum3F3PlQJUzwEm7L/xaWEuU9WX9dea0afu/sJPz8/dnW5pbr2jZtZkVVVXhxUVFTukKB5FLp2Kc5IigEgYRLO1i8M0yiudc0xqCdHWOQnZXlJRIKm1s0muyc3Nw8sVg8rb+/n3Eq5AApAADTGLB2DM4LGmft9w/rK+78BM5Zl/3ygAhZtCgYITTfCdBGkuR0mqadw4B1lqu7MneM9kOkMwVuCeBBNcinXSkwPwHqBXK/LIqBlgAAAABJRU5ErkJggg==",
	pivot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVR42s2RAQrAIAhF53aPztLRO45naAyXQZuIiKMNJhEZ+vr+YJkM4K2UQuMi5wwy94JrfwJ43YNPAa2Q4O5bHwGor+tl9grCANksIVMjuB6wvHYm3cD5XuuGiJBSOlwFQ7YGhBRYM8vZQ99oKTBgvolasgmYiRNiV2WU1yoyowAAAABJRU5ErkJggg==",
	play: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAjJJREFUeJyNU01rE1EUPe/NJG1q2zQGNya6UIoYUARbIWAFQSoBhRTcVPFHiK66UKx0oy78CUIX3QjJRrqoi0q1aCliI0ZBRIlTqdKQmq/OZObe62JonSRVPPA2755z7nn3cZWIIIjj76+cDKvQXUP0iAGdJCY43LIcdlcdbt35dnq+EOSroMGp4tWcoXS25GygQjUQCABgQKMfEcRlEC57+dKZ+Yk2g1vWo97ntTefNr2t5NfWd/wLcRpAhMJWorF/+NWFOVsDwLPqytz/iAGgbNRQV9vJz70bcwCgRz9cHzWUznaKc0cfYsgY2NNkK9QEWLLxxXOj2ubWTMnZ6CJdio7hY+oJLg+O7WlSD9twFc3oiOpJVajWRXDFwz6zD7NH7mH20DSiRn9b3TEJypWUFpHEzrSD8ITgiQdPCOOxNF4fe4yLA+nduigBEydM4m7xTgICg4VBQvCYwJUW4DIQ0QAAEobpMa0b0AkCdyUgEEgY8z+WcLPwADVuALEQAEAJQEzrZp2bxX5EEr/Q6DDwUHGruFG4j4Wfy37XWA/gN4eyATK5qENsTMVlsOsJT6svkV68hoXNZSAe8o/+U9c1Ars0pUQEh1cyuSbsbNno+I2y60fW7de6yhCb8pxZm9AAMOwcnIxQ2Bpy+9qZ8b+Im2TJl+1JfxaBZTrw4nwOLNl62IZjEkTJ7sCU7ccmcJ4za+3LFER06ewJkEwLyYh4nCRhEMgixaus5DaPv30X5P8Gpk4xsL5m6uUAAAAASUVORK5CYII=",
	playButton: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAD9ElEQVR42q2WW28bRRiG35092K4PcRw7rtMmassFQi3gFFqBOAghJCQkJC56D2mTCsqV/0HzAwAXJAQqIAshJIRAuUOAAAOlkIq0aUoILapwYwN2fFqvnd31ruNh9uCYNJQmbUcazcr2PM9833wzaw5u23/kkwt+vy/ZUFazHMdN/PbpkRzuQON6D4ef/4weOHA3ZLmF3PKfUDV9monSSx8/J98ZwQuf03137YPS6iAyIKG4UkWxVM51u93Urx89O3P7gokv6NjYHlwravCIBJGwFzwB/i6VoCgNO22LHz6z7bT1BUe/pLtH9yBfVJ1POQ5+n4jADg9UVUWtXpZN0zi1+MHTJ29R8BXdtXsMhRXNYtsC61tCCLweEQIvMpGMVrNupW3il/efym5LcOjY1zQxMopiVbPhnE3n1mU8y5fPKzERh4ZcYaKmtS+pS5knc1sUfEPjiVGs1K0IGJhwjsiNhCPOs0cSEPCLMA0dlXJV1vX2qUvvPXHy5oLJb2ksvgvVhu7AegIXzLnRdClA2TSfV0AoIKJarkGRFTttC+8+nr2h4MHJ72h0eARyq+3AWSeuxFwDOl1grevMsIVsFFm1RcMSRL6LSqmKpqLOgNIUE+U2C6a+p5HoCJpa24Zbq9RNakMtIWF7wLlSOxp3NmURhfw84kMSNFVD4VpZNtpmauGdxzIbBA9MnaHhSAKqYdhgq/MCsbsFJ7wDt0VuFL1GKbVBQwMCwkEBvy/loWnG3oXTj+bWf3Vw6gcaDO9EuaGBWlXjwnsCZ/xXBNcJrEMZj4iQCMXlxQJYFHsvnn6kL0hOnqWQomzlBniRt4GCJWB5Jj2ZG8n6xltw1iNBHgMBglq5hXyuInfMzsTFtx+e2ZCi+4+dpbwvBr1jOnCROCLRFV2XLkvi8xAMhwW0NQO5qxU0G1qa0u70/JuH5U2bnJz6kYr+GNsD04YLPTgb12WuRJIIYgzsFYHlP+r4q9DIWtVz/o3x+RuW6fjxn6gnGMNq2+yDJQfujM5zdFDEYEiAXNNwZclOR2oufV/mpgft4Iuz1BeKoql3NkLZKLIeCAhIRCVYBXzlchWNup5m+Z+ee3X//74v+mX60izdEY5BUc3+6ln3+QTEox52PRCslFaRX1bYaeVSP79yzzy20PqCE7M0ODiM+qppn1ALHhvyIBqR2C1qoJBXZL29lmIrzmwFvPkknzhHQ0Mx1JomS4eIkbiXVQ9QKLArumVmWNWk5l67d9uvz/5l9/I5OhgbBsdKMBjg2VtMRbncnOcISZ1/fTy7XfB/ChKjO9kJbKNaVWSzY9XzofStgjcJksfPXBBFKWmYnYy16vm3HrqtfxO99g+9n58oEoYjNgAAAABJRU5ErkJggg==",
	plotArea: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwgoj/YESWZkbaGXDwwAEUvr2DA40NQNeADogywN7eHuGCgwepawA2F5HmAjS5UQNwGEAKwDCAJN1QADeAEgAASfVhEZG1w5kAAAAASUVORK5CYII=",
	plus: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAGklEQVR42mNkwAIYkdj/YXxGJAG4QrwqUQAAnpADBqFDln8AAAAASUVORK5CYII=",
	polkaDot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAIUlEQVR42mNkYGD4D8SMDEgAmQOXRFEBk2REV4VNJVgSAAB4BQWMzsegAAAAAElFTkSuQmCC",
	positionLeftRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkoBAwgoj/QMQIZRMLYHpGDcBhwPr16/8HBgaiGIguhtMAkEIQjc0AZHGsBsAUEQIgQ2jjAqqEweCIRvobQAkAAJKCXBFioznAAAAAAElFTkSuQmCC",
	positionRightBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42r3RMQ7AIAgFUP7iuTg657KDhcQOJaYBiWUxMfAkX1CxsDs4iLoOt/8AEenM3EqAnQ8SAnRI++jy94ac3cBe1kZ4IJzBCkj9wjYwQ/OBIQx45GuLsxlkClMbySG8gErdVDpHEStOWvsAAAAASUVORK5CYII=",
	positionTopBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwgoj/YESWZkZGqrgAF1i/fv3/wMBARrIMAGmGsfEZwkhIMyFDaOeFIW4AVQKRomikWhgQAwY+MwEATx4sEd7ezfEAAAAASUVORK5CYII=",
	prcnt: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42q2SQQ4AIAjD2P8frXfdYItyMpE2A0U9Fn4LVirGAYOcS/TEAip1BSqRJZCws8QWrumSJLkYBDBNBQOOBdMTtgLnA1kjqLGiJVr1LNgwox4Rcow0WgAAAABJRU5ErkJggg==",
	print: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmFJREFUeJx9U01IVFEU/u7zvXFkJItEohnIIaRQCkJzUxEKSosCBcGgtm2s1pJYUSEVtGmRSOvANqG1EnSVQX8zIP2IJKYMM85zlHQc37x57917TovJNzNgfnDgwj3nO993DkcwM8px9d3c6dpA1QNDiDZdICJJIefIpOXKWM6V92eunftWni/KCW5M/ZgwNNETM7NI5Gy4qvhnaAINNTqiIQO2VJPT1y/0VhAsbeWDz+Mri0ub+cjH1S3sh2hIx0EdyTMhbnrW11HQAeDJp9/jqzsFvzhzqxPEADGDmDGXyeHymzgAYNmSiFSLyHuHxgH0itvTP89K4i+vF9J+F/NmB4jYJ1mzPZjZHVx5W7J/PKCgiNq1rCNHYma2QqYihuJSSKWQLhAoveLnZKSArWhEP1Rd1ZzI2QCA1iN1uBSt96XvKqivMXAxXIeBzrP4uukibmZhkUAtyWZNEYd3pz3W3YJM3i0qKAvaVRQIYqy7BZzPgSAglQrrklTJu+Vgx5W4M7v43y2YlgOV+AX9ZCukIuiOp1KGJsIeMUzLQeexw/uu0bQcAIBghqcopa/b7nxDjR5OWR7SlrtvcTl05cKFNq8HNQxFQ0ZXyvKw9o/90fmmPYvufihZ0woWPKmGBDOj69XsxB9H9SxbEnIhju3RwT0JDgw89d+Bo42TG8P9vYKZ8Xjqc3BmzV5cL6hI0iluRC7E9yQJNp4AOXbSTSeatkcHCxXH1P5yeoKJejJSwCIBgvAHpiu3KJt4cmO4v/KYytHyYuoUSD1kpdqUkhGpCC4h6THHJIt7G0N938vz/wJ5d32GTG29wQAAAABJRU5ErkJggg==",
	prot7: "data:image/png;base64,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",
	purpleCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQsLchZlPcAAAIxSURBVDjLhZNBS5RBGMd/zzPz+roukXZYP0Dr1koU5Cq4FVHXLlKQJfkNOvQF1st7rIMfwEPEYgi2aygdykOXEDpEgZnowq6igSgkxEqLu+902HXdVaM/DAzPML95/v+Zkbfz87+qtVq3C0McrXKAoCKIyO79kZEYZ+lNPu/+p52dHTeby02ftV+dq59bLG1QLG1S2tikWNqkWNoAIDs9TSwW42Y6/Xg2n399GtCYWGvwvONhrQFAVNnd26O3t5db6fSj3NzcbCvA0nCualGV5kIY1uuJeJz3i4u4MOTJ2BjOuQftAHfUgSJyDDDGUT4oM5hKMZhKNetyImrb9KKmCVABq4pXq1L5vc+fagjA+Z4LnLOcDTjyrAIdRon4hiC5AEDm+z1wEMRn8MRvD7G1A6OGTs8jEvEJkgsM3x1CsWA98DwUS+rONZ73LbhTAGuUiG/xuzoILs0xNDzI/nqFkCqIgAghVfbXK1y9keRF3zvXBvCsweuwBPEcAwMDHOwcUthaJVN4CCEQOjKFUQpbq5S3D+m/nmAy8cG1hYjUc6hVXAtaQE27b08Ia43rp5G8MQYQMoVRvi5/QY2QTPQTxGfqADUE8RmSl/tRT1j9ts7U9sS4qmrzxUEdlimM8mNtBdulbal74mM7lbWVAi9/BuPL5aWsvMpmP0aj0duhc+AcKkKnFXp85dNTQ0jI0GQNgM/PDL5EmNqeGF8uL2UbBrkIdJ/8JFeiw0n+oaPNAH8BdcfZHCX/PaMAAAAASUVORK5CYII=",
	radioOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA9ElEQVR42q3TQQqCQBQG4DczPrWWEhjhJpJEWkQHaBFdSDtIdpQWQYuoFh0joo0gbly7K2fAwWhUKB+4EOb//icqgT+HdA5so+hVd3gThqQR4OEwCGrbot3uCyGq8OG0lwcY08DEHqyWayVCVGHHcSSgMQSNIiRJokQ+gGqYACvaKehoCIBDj+ddIK1A2aoV6+toAhb3lFLIsgx8328G3PFUBo2iHRHl46Rp2gwcLwfwJj709L4I8os3lxPHcTNwvZ1h6npi/RJgjEkgz3OwLKse4MOR+WwhgtX1y7DyLaiQ4WAkw7ZtK8PdfolVpA5o/Rd+mTftdoURxG/ARwAAAABJRU5ErkJggg==",
	radioOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAzUlEQVR42mNkoBAwUt2Avv7+/7gUFxUWMuI1AKS5sKAAp239EyZgGMKITfOW3RvgCpiZWRg4WDkZHG2dsRrCiE3zhjuzMWyP1inCagiKAVg0/0XGQEN4QIYQa8AvJBqMix16JDQ1NYkyANnmb0D8HYSBBqjiNWD7vi0Ma29OR7b1J5T+AsJAAwzxGrD/8F6GpVf6GGA2ItsOxB+6whfbCQkJ4TYABKCGfIHa+hlGwzRjjQVshkiISMGjQlxcnAGbZuqmRGRDcBlAMC+QAwB3Z6QRz6fzNAAAAABJRU5ErkJggg==",
	range: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdklEQVR42r2SSw7AIAhE4WR6dDgZtiZNp2CtmlTiwg/zMiBMnbBjMRHjnYgYnrknhiRGQEqp7lW1DUCxhwwBfAne9hIARXsAVZQzqUiwPQUgsyD6DxC6vQJ4JG4B9IZkGBAeudFbswnAGQix2+RnCf4XrkF6iwJmQ8IBoMAIeQAAAABJRU5ErkJggg==",
	ratio: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAS0lEQVR42mNkoBAwDgoD/hNh6H9cljGiSf7HYwBWw0kxAK8L8IkhW/IfXR6Zg89mdBfAxRlxKCLGBRgGMOBTSI4BRIcBRWDUAAYGAA+fJwy2cgT4AAAAAElFTkSuQmCC",
	redCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQxCHwxLKwAAAITSURBVDjLhZNPT1NBFMV/M29e/wCWIkkJOxMJiRJ2ZdNoTBBwYYioGyW4YceCD8CnYMneNHUBtJhiYoASY+I3cOWClu4IGE0IWqB9x8VrS8EaTzLJyZ3MufecmTHvi8Uf9UYjqSBAdEKAwRqDMeb4xdxcim7YLBT0PxwdHWkjn891O2+lsG+5cki5UqVyWKVcqVKuHAKQzeVIpVI8yGRebxQK7/4WaBLnPHz/ajnnAWCs5fjkhKGhIR5mMq/yW1sbnQKOpnNrHdaa9kYQhPXRkRF29vZQELAwP4+kl9cF1JrAYsyVgOeJs19nTKTTTKTT7bq5EbVre7FeW8AacNbiN+qcn/6kVg8A6B+4zS1Hd4GWZ2sg4lniUY/dSB8A07VTEJSMof9miJ0TeNYj5vvE41F2I31Mb28TAXA++D4OmCiV+MqVj7aA8yzxqCPaE6HkYkytrsLSEnUAY8AYLgAWF7m/tsa3lsj65qYk6bz2Wwou9BGk5WVpbEyfQVIgXZ5LlzVJCmvj49LKig5A10LEhDmoWsUkEs2ADFjvuudkEqrVkK/n85KkoNEIu0naA2lyUpqaCnkTOyDNzCiYnVXTwoK11rZfHITX+Fjiy/4+Ghwk1pF4D8DwMAfFIqPwBsiat9nsp97e3keBBBLWGGLOMBC1JJ48IwC+fygAMPj0OQngTvNw0yB3gWSXj3aPfyPbIn8A8iAATPG95vgAAAAASUVORK5CYII=",
	redo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJklEQVR42oVTX0hTURz+DrpLrclwUzSRxfxTFPTiUxGjejDUh8ioJ0EQoihmD/VQECKED1E0gsRegl4ifSoUBEGK6CFGIEWyQmeuxrZMZXNsTWWt43fuydR20wsfv3O/c37f+d3f77sC2zz7D0knw13i+vQnkbU6I7YT8DbKSlc55pMpzPC1IxIW73YUqKmRBxhuEqcdDrja2oDaWiAQQIHcHaI3kRAFS4HqCulneHDFjxLfccC+B4h+A3I5wOMBBp8CI8NQVXTOLYqpLQJVTnm5uQUDZ84B2QwTY8DKyoa4YehKXo8D42N4Qer8j7QomAJlNtnAELrRAyPHpKxFu2KsZCpkVtSbyYvbWz6hDPJh50X4d9mBhaTemIsCXz4D9Qd1RZMTUDsdGYixoiaWQ4a7rqLha0yT0++BeASjXAacFXiZXsSEKjkFEbGcQiXkqu8sjKUlTU6+MoObUN2+T3QvQCz/1wdKoP4IDPFbkzN62m4mJbHDYwrshfzo8OKwzabJfS7gQxAjXF5SAyAeE83/5Ea+Q9SZAh7Ivp8luGWv0junWoFEyBSB0mw6AbR3bWQOPeLIguiPQnSvC1QzhFOAw3DqQyd5n+8YkGcXgm85/zeaX+YhdwGqH40UiP81Uh1kO9nnygK/bNbfW5rnDYy7Oc5ZiGdFVqYIDYwnHLtXmXC97aWmV0zEGS7MbvJC0c9EEXXJNaKFOPqHVj5QSfeYnN58fg0+QqwRCqE1hAAAAABJRU5ErkJggg==",
	refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAttJREFUeJx9k81rXFUYxn/nzL1z78ydTJp0migZho5FiU2VVpMgiAsFXbhqYzAG3Yrd+A8EaaurLkpBxEVFxF0KUhuC0kgKFaXY6ig1ja01NjFDmg8TzAzT6czcez5cTDNMEHzhrM77/M77PpxHWGtprzembzydisfed4UYdARZZTSVhlqphqpQCdXJy28+P9feL9oBb8/MX3SlOFpYL1Os1Ah1886Vgp6EQz5wqSk9NfvWC8d2Ae6WHvgf/vzXwt3tB9kfVkv8X+UDhz0OK0cC+/iZ0RfrDsDpa4uTq/frLXGn53D8cI7jh3OkPYflco3J22uc+7XIUlWR9UT2u4aZBI6Jd2d/G1LG/nj+9zUAcukE0yPPkEsnMNZiLFhrMcD8+jaj0zcoR5YDcY02ZjjWP/bO53OblQP/1CMApkeepSeI89GVXzj7zXVm5hdxnRj5zB72Bj5Hujwu/LFBhEAYvd/p8mIHi5UaAK8+to+BTAevffoV1xaK6I5ujO/w9cxNzicTDOV6Gcz1sl9dZVl2kzLqoNTG9u24fSiTYm6jxPU7S0T7sqjODKl0GpPoYK4ctVbq82NYpVBa90lldMthA1xdWsfEfYyXBODcK4dIxx1GnuhFW4u2lpTvIXSE0gbZiPQ9VwoAiuU65XrYEgMMP9rJlbEhAifWAtxZ30JoTaTNPblZC2/1JBwALi1t0t/bxZOP7G0BtLUEntsUG/hpcZW10n1kTBIib0lfMpEPXAAqoeLScon+7iQyrD8ENCHm4Tk19S3GTyKjBiqKJuQXo88VakpP5YPmFBcWNvjyz01E1Gj6YprCHdDp118m2Z0hMnZq68R4wQF4KRMfv7xRW8h6IrvSsOigs7XCwGff4xdv7/rOxvWqYXl7/D9hGv5k9qI15ujfSlA1AoPYCQyODpH1avPl98Z2h6m9Bj6eeQqjP7BaD2qtskobQsNKZG1BWXFia2L0Znv/vx0EgHzd5IKmAAAAAElFTkSuQmCC",
	refreshForm: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB7UlEQVR42n2TwUsUcRTHv6M7tqu7zbYishS2lI3owUPX7JAXo2MsShR1qCTBP6BbdFPPsqReDIpIpEuXAgsruwQevIStUKBQmrRmu1vurjR9Rkd2hZl+8H28ee/3PjO/33tjKGjZzmvsLWWNz/rPMgIzXU5Ru3veXTQOyAkExHQukdf7nPfmy9g76DwKo1/oE0oDWQ0CJPP2Qh73iVdomaZU37C/qa1dyi6phHsNyKwfIAUgg9trtehIU1T6uqa/QOpOnJS+LKtIbh7dQCaQ9cN3kPo4qIbOUYrj21va4ew/iMYTrWrMbWgLf4iiGe9u5sj385yrAmznBbYPFdAjNIy+o0V0lc2bNZf7DkCW2M1awDdsM5okMezF7uHf9+nOCoB6cqdqAWvYEsF2n3mYIn7b88fNiAYrfzhi1khWAWfKT2WYxwn21BS2YB+js6hVIU1YMQ2UyoruFPWSvRergFimU8mhDMELXnE/1u1K3LuXgnVMiY5uRT680U+er7P3+eFBshfcrlfQQ9QTa5bl5ir0xAwrlExJG6sqb2/qFcWX/EfZdtLYac4ZaYyq7iBc+i3x2e5EvkVXABSC/wXbacO609YRbtJRCnNeOx9Q+Mx3lH0gxt4shDRCy9YpPK2AFfw37oPcXo8BSAdt+QedQ54RRuFfdQAAAABJRU5ErkJggg==",
	regressionLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYElEQVR42p2OWw7AMAjD4GYcnZtRbRqV2vURkv/YViHm7mFmGiKhDODZd9YSYDK/33JBnhMGAVbmHFwwmyHAyQwX7MxHAGK+FtzMS0DFvC1AzQOAMf8KquYBwJg7gDXnGr6zWA9Os9seAAAAAElFTkSuQmCC",
	removeDoe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MEhcPMZK7fkQAAAFHSURBVDjLdZI9SgRBEIW/GhZMRQyMDEQw0WQnMNw2MzAR9QaiHkDEQyjGJoogiObmvQeYAyiLR/AG+gyme7amZy1YlnlU1fupBmhIJZBACMmBCE7e4PiVshqAMWnQL0DIL8i/oxf86rFlZksIgKnHYgNeQxmvlOa0sLNjyoPbGDNg5+CxhUZl5z9LwBgnz4fA5+9PEVznv82vgNthSSh1ZV3ZrubWvHUhzAwaRB2nsWsIk2AYVLm7Pzw3ZO2WOqOTEHrRjubtZubOD1bnO3vmkqAI0cwZaJSUhWASMI1xsKZ6cB/Xa1sgYW1ydbYVYxxcx06f2v/7JGa2usnt/iV6vpAkM4MYp/Le82PzSqpz4GNlg5vds26Y9LZ7oRVKMj4CuPv+gvcrwZB5YXQhdDerepEuLcP63oC5LK/EFr3gGOO/CnyFEPgDQeGnEO6lkuUAAAAASUVORK5CYII=",
	removeHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBUFLtl8+K4AAACpSURBVDjLlZNLEsMgDEMF03uhoysncxcJjENEQ73JD+QXyRQAIQkkC6aSFPnZrInHzSwQQMTZJNzmKikkLUUWFQAKANSEVd5ELoreEIMgrfkpQvLxsRpjrIjb7AjgPCnne0vlCNCubiRfjakmnr/KEmTskZdJRFJ8HEHHPnLok4mNvBN0xZXbkizJ8KCRILl0+zZ+zoOyOcs9nfy7mMdzpzJtzMd39wogvje5h32/0K0vAAAAAElFTkSuQmCC",
	removeRegressionLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MChUsK0dZW0EAAABpSURBVDjLpZJBDsAgCAT5/6v42fSiplIUNuVk4rIDG8z2wurC3RniVH8z4fWgFJ3+aExK1TzXaBkMMfQySk3oktO0TSTHKWSyBfIv+gpQIvMlo2AJAdYmyW0jXmjZfDehvy/HZiHtTfMASPJevSlK6REAAAAASUVORK5CYII=",
	reset: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAgUlEQVR42s3QSwqAIBAG4L9SKjpHmxbe/xLeJtB8ZCj0IHsZLfpXI8zHOJNxzh1eJPOQMZaEhDAfQkpp1Ki1fg7n5v37h/Box8EWIBBQKr+euJ9mzYCClOlflVKG2jlyD61VqKom1FL00MYdw208Wvccl/oUemBQh0NsQQTbtkNqJlogm4czJ+pqAAAAAElFTkSuQmCC",
	resize: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdUlEQVR42qWTQQ7AIAgEoYf+i5fzLw+moQmJBWvZ6gVFBycYWVWbiJx/I9PGsCLslVYHO1GLuYPoZmADL2YFygYjbKBHyGCEfA71wOG4/jSIMPQKK9gHvx2uwA+DWZMqzU0GCJwMLFmFpwZxE+oBcmsy2PnSF7tvlcmlu4ElAAAAAElFTkSuQmCC",
	resizeHor: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42mPcv3//L0dHRzZyaUYGCgDIEEaYSeQaQhsX/GNg+MXEwEBQDKsLcCnEJofhAnyacRnCiCxBiv9BhlDXBVQJA6rEAilgEKdEkl1ASZYGALvwi8koF2eCAAAAAElFTkSuQmCC",
	resizeL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAR0lEQVR42pXPQQoAIAhEUb25nrwyKIpMndkJz8VnAtbGGMGqSqWHhW3pw4lFhBnBYYOHvw0/7DZE+GnI8NVQwbuhimcDgu3uM5KV++8QfCcAAAAASUVORK5CYII=",
	resizeVer: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42mPcv3//L0dHRzZyaUYGCgDIEEaYSbgU/WNg+MXEwIBTHq8LQJphbGyG4HUBzGZ0migXICvGxaZPGBAyYBC7gNhAxOsCYqKRYBgQSkj0iQVCgBFmErlZGgB0Z5nJHhkihQAAAABJRU5ErkJggg==",
	resizeW: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAR0lEQVR42pXPQQoAIAhEUb25nrwyKIpMndkJz8VnAtbGGMGqSqWHhW3pw4lFhBnBYYOHvw0/7DZE+GnI8NVQwbuhimcDgu3uM5KV++8QfCcAAAAASUVORK5CYII=",
	right: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVR42uWSMYqDYBSE529yBr2DZwhWnsET2HkAAwkWIoiNoCAI6QKBdFpbWFgIYqediFaiN9DmrQpZNuwWstlup3kM/PPxmP8xvCn22yAB8xI+/A2gLEvKsgzTNIExhuPxCEEQ2G7A5XKh2+0GRVEwjiPCMITv+5Akie0CnM9nGoYBQRBsXtM0qqoKURR9ApIkmUVRPPwI0HWdiqKAaZqY53mby2OoqvoCWOcT8gKwLItc191Cfd+jbVukaQqe59kz+FUr5FsHTdNg6WHzsiwTx3FwHGffBqfTieq6xuPx2LxhGJTn+Vrmvg5s26au6+B53uav1yvFcYz7/b7vF94+pH8KeOoDAZOWEeU1jXoAAAAASUVORK5CYII=",
	rotateAnticlockwise: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACD0lEQVR4nKWTS0iUcRTFf/d7zIzj2Eap7CUYafSgjIIsraRNmYsoBJuY7OGmRUbRC4TEZdQiKsgiqVWbKCuwGokQozaRUEYwSBOKkRtrGopovm/+t02K2uiizvJc+HHvOVz4T8lUo8l1ls+2rWjGsMIWDapvkmlMl5fVxx1gpgUcDbjBkMjVctveb4kIgK2qET8rkazHgKGvWzV2H95PBDgAzQHXmSt2d7FjbRrIZj/ezWSupY0+DcP3QpFl60Wa9qipXQK9o1DzHPonrXE84LbdzA9rUzDwshDK6l130mkHwK4XOf0O9Bb0bYfQ+PCw64baw3np8+G8L3OgYqbAWkXu9EKqHErGPCtfqA6KFPRkvPgG1+mfCTCiuvcIrG6ET+MATykFGDbmTafn+zMBSmFxq8iFGmGgDuYDOEZNJmgMwT+B5tJlKA4L52qUaFjVygfJg93AJctH3xb4WSpEKhvFsnIBFkDLViWWhl8u4IBWwbaTYHFILOkQK/HEIrMOqnIBjsHCNdDcA8Oj4CUgNQhfq6EIgJ3Crleg92C4DtZOBVyBWXHh0Q8wp+BBC1wfgvRKKBvv+yC0nYCzPnhd0OnBMwM/S2BVJexbBEW34fVFaNgMg3GYt2NCG5wB2QLRh/DhM+gI6CjoN9AEpGNwY+mE/sf01zPVQiQFGyNQ4UIoCUM2vKiCZDt40zX1z/oNVVuwItdCCvMAAAAASUVORK5CYII=",
	rotateAnticlockwiseCont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVUlEQVR42pWTS0hVURiFv33U8FU0MMxMJcmoQYRoUHmhcpKYghaVOCgo6EH2JHJgFnYzMqKSDKpBUIFZUAraxSZGYC9SRBokSJaWmuAgyheZZ7e8htxuGbThcGCf8397r/Wv3/CXtRfCmiF5AjKSIXEcxoagbS4888FQ4L8muHgpJK2E0hOwdT7M/qE9AbB6XkPXRX1bBXfPTW1NARaraAP0PdX7MNQUQloPDL6A293Q7kBEGGRuhPxQ3e4CnL4Jp/yAtTDvDry7rkKdFKvd3GZDY6eloAi+Bt4uB9J3Ql0CxJcbNtdZHprlsKQBXo0JFgNRb2DgKJwXuPYSfAyWKHker0NTr3XeP5div4RK8O2GrBH8FaMyK7INruZDUTBgh3GccMfU5zhOts9OpPsBW+CgNFUOyxhB3CeG6hFL8QHoDyzeA7NewoJt8OkeLGyHD+aXtvgSQ3M/prXT2tJieMsMqwKWpRjjjcOmlVs80208C6GTVLWoT4Z+Dy68AnGRhor1lsJIcKLkmQw95AfsC3XSsk1IS4Pr+sZcm3vLum4woBaqUmH/FxhRFyIE4QY0+gG7jGPWQEe8cReVumQqMM3BgCOQoJzkK0jH1bnYQRgOl2fTEvIMm0osD9SFXhmap9a2BAKqYE6KocZjySqDegVrQKYW/BZlaSo7BicV3/FHurWC1SQto0mwYjVsT4SYami9rELlpPuxOvLHLKyDQgXJq8AkT37USSi+fIZvZ+C+5Hk7VDzjME2ubIiWWRnRkCpAeBf0hGgSPRqma1OzxT8B/7N+AnHBsnKLclM3AAAAAElFTkSuQmCC",
	rotateClockwise: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACRUlEQVR42qWTXUiUQRSGn5n9dv1JJUgq0IoESwKJyqKwCCos0yAxS7oJDMqgH4lCIU1U+iHEMOgikpIMrZsSKglCpTANKkzMIoSiopaibmIz3dlvp8NG0s8qRAfm5pw5zzm874ziP0NFS+4E7fWo3CR0nnJ0mmvVmE/z9KMbbm0yoaFJAZthQY5SLemaxQGPl4Djsa5SkXtha+0L120etXZPY9CM/QVYBZlHoTsRprVp3fHA2qbP1j4bgYQkrdYV+ny70z2euf5Q+J7fumvPBE1oHJALsdugNwsW1ShVkWBt/UVwf9aLvF7VZUx6QYyvOdtxVgwaU9sQNNXjgPkw5zwMdCp1p8baoolEmyEDDsXHdcqWzoAJTR8HHJfEVUhdDu/PQXAiQIHXcYKWli0xvuIhY3IigHxIOaLo8aMeD1tbVQ7PJ7NuodYVZXGxJ54ETWkEIPvuvwCNX8GKYOFuReuIpXwf+KMBlmldWRbjq+szpkQdFs9T4eYu2CDNvIVvUyG+H84WwN4/m3corWO1upGv9cYO62YpsS75MgyPiqXJMGUQPhyEU6vh+ukI7/dYCivrNF3vrH7VCxkqE+bdgkci3BUjIlfDph7F7WFLsYz/8muzaJVVAu2zRLNjisJ2yzV1QNQXQMp6Uf+uWFkmoO2w5A186oNLr8VaDXFeWJMnJjjgrYda0aw66lPOEIisWVUJW2dCYkhyshlWzkN42SA1sbrt5I9U9M9UKlN6IE2eYXYazBbAaAD6Rdz7HRCY9DP9a3wHTdrDDipUP8kAAAAASUVORK5CYII=",
	rotateClockwiseCont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACWklEQVR42p2TS0iVQRiGn/nVMLVoIZgeLyUYtggRDbqciNwkppBFZS4KCrrQxYrKyE5iJmREFyqoFkERZkEpaKIbI9AKUiRaJAgnsswCF1HeKP2n95xATkfd9MG/mJl/nvnmfd8xzFAFEPcdVsdBdhRE+6E/Ajq94L8Fv0P/NaGDUxq/hu3HoHo5pAcWBSBS31f4eR4ev9FaL3ycEbALqo7D2Qmd8gwadFS7C2NpkLUSdqRCfB10X4WStYK0QdIUYKNhU4XlyScYuKthM3SFwm/A/AxDvdeSXwVN6uzbXoGCgN3GMaug12PcxT6XPLXZEa7LUUh5AcWX4eQySBiCkWiwQcD+SCenwER0Nbtuy7hri+5Z1w0HNKiJbDggcUdTYG6M5u5A69QVsmDRNvj8CJJXwJfb8CsUcB0SYwy16yyl2uzESj9pVhYEFIKnwtAxiOnus9ZXDu+ZpWphaYYx1YnYnBqLNwjYAocl3LUR3WkU3OeGulFL+SEYDAdIuDmyOinQ7WmYMCfUTjI074F8bUYujC2AmB64WQwHwwE7jeNEO6ap0HEKWuxkrlkjbx9A37juFA+x72SPgnRRPjdcCfL+LQXMW+3QPmCdDy8h08iSJQpNl0SrV3ASKqGow9DaZynR8T9CN0urXAnXKBc8NYbNjZanpkxJFcCzXsrL57QjApVCTj8MvYL7yuxbR7YpOHkblAPFOuoSnJNmldOiHKhMQdSm7wxsXQjzFOvg67H6FDC/guSTzQ8v/J2aDgjUPp2iKKZP6kWmQ6oA48PQI3E7W2B41tf4P/UHCCa0cqUWC/kAAAAASUVORK5CYII=",
	sampleLabels1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbUlEQVR42sWSAQrAIAhF58n06HqyhsIgTKdtjEmgmT1+JhyTMfNQT0QQ5aMz8Jd0/xgQxd7aCtQjohWJSA/g4wjg1WwrmHMLoKPgFvCPAt+YbQXZJGZzsPxCVVRZChi2rACy+FvA6ydUTbzm5gTMzKwRcHHjEwAAAABJRU5ErkJggg==",
	sampleLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RQQ6AMAgE5WXdnzX+DF6G1qhwaJVGIqeGLNMh0PKxqNdkZg0DWhgA7RN6Eo9eKWW1lPtHjS0iNQ+QvgJgBupxzkaYax4g/wrAbUCL8bzN8xWigJ7W1ArR4DTgsmjrjd7/GIzq1SAK2AAqZoaHl47u/AAAAABJRU5ErkJggg==",
	sampleTitle1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42sWSAQrAIAhF58n06HqywmAQpmljYxJopp+HCddkzNzUExF4ee8NbJPeHwt4sbUygXpEHEUiUhOwsSdgaY4J5twiUCHYCvxDYAdzTBBtYrQHyy9kRZmFAtmG3kP/jqCNs22EVwQ62tKsEQGCzckAAAAASUVORK5CYII=",
	sampleTitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RSw7AIAgF5WS+m5neDE5GP6mFhW0xJWWjMTjMC1Q+Fo0emVnDgK1TTxLtHwEcZ611sS43R40tIi0XkBoBMAP1OGcjzC0XkLsF4DKgYjxv87yFKGCkNRUh2jgN6BY90uj+j8FdvRpEASvPmoKH79744gAAAABJRU5ErkJggg==",
	samples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA00lEQVR42qWTvQrCQBCEc2jSKYgRPFKIrfj+TyJYaiFGUSvBwhRxFidy/1FcGJJsbr/c7uRU9meoULLNsmlsPQquSQCLayiPQDSKTkEAi3fQyEiXUAEdjVyBwsYCRL4sizTvc76XqBSBLsDqjyHbXTt937wWEoAu7tAKBYfgEAk4Q4MeyNLchTvEMS57aJKANHTCBgS830KzCKQMATStMicvsYHm3wDEpicfH9Dinf44MUy2QIj8NDUXS3FFaOdOeogG5NLXu2djANI6ae8gRQG/xAvi9joRllkWpAAAAABJRU5ErkJggg==",
	save: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAkhJREFUeJx9U01rU1EQPfe+9zS1VYpNFFssCpHEb1RUKBSsqXQZxY246T9w1U0Xbq1EBDcuxJW/oAS6EqOiLZRqwbZ28aSRflgj5qsfSV/y3r0zLtKG16bxwOUu5pyZMzOMYGb48XYxd6PFNEakEBcFEPKIUPZ01lE0V9V6+OHZzik/X/gTjK8WUwFD3s6Uqyi5GrQdEwAMKSAAOJreD57viu1NEPj6Z2N5w/VCmVIV/4NmhqMo+7dc7X7cE66Y25XHXE2hxIdZTKZXsBYfbJqgPfkGz+73hQ4fNMcA9Jvjq8XegCFjS+sOgh1HIdc1cI1BzPCIoYjhEW3/DDnxGR9XCrhy/EjsyWS61yTmRKbcaPvTj2VoYmiuJdEMXD3dWY+3WQYKmhLmAUOGS67eJSZm9IRP7utgB62WgaWNStgkQpD2rLJYUfi2+BuaCZoYigFNjDNdx+ocKQRcrYOmR9Rg/+7oNAZOBUFcmzoxgxh4Ovd9F8/VDNNRlBNA0O9hPlfCfK7UdBMAoGrt5cyypxcMKYLK19/oZQu2bSMSiTQI7814AIC846LFNBakRzQk9qmQTCZh2zai0Wj9+ZFe28Kmp4bkg+iJCUdTSjPjVncHbna2AwDi8XiDaAd5xwUgUq8HLkwIZsarmZUAgGUJhA5ZBn5tVjCb3WwqXq+qLbtQ7ig86q/sOqYX04vvFHGszTLQahmQQtQHlndcpNe2AIjUyzvn+nc0Yu85J6Z+Xnc1j1QUXXKUCrmaASArhZg1pRh+3hf94uf/A8l2VQYGIFQOAAAAAElFTkSuQmCC",
	saveAs: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACDElEQVR42mP0rdjbx8DAkALEDBZaoiwMBMCJa6//QJlzNnc4FzF6l+7+pGSgxgsSmRQlR0g/Q96yR2D63oVbn7d2u/Ixehbt+KRirEmyAXfOXv+8vc+Dj9Etb+snZWMtsAHT4hQY7r7+yXDn1U8MjSpi7AzKouwMWYsegPl3z177vGuSNx+jU9bGT0rGOmADZicpEXRB6rx7EC+cvfJ53zR/Pkb71LWf5I11wQYsTFcl6IL4mbfB/IdnL38+ODuYj9E6YeUnWWM9sAHLczQIuiByyg0w/fjspc9HF4TzMZpHLf0kbawPNiDDRYrBVU8Qp+bdl94zzNjzDMx+evbi55PLovkYjUMXfJIwMuAlaDUaeHHuwuezqxP4GPUD5nwSNTQk2YDX589/vrghhY9R22vGJ2FDI7gB3VFSDMribBga7r78xRCXtYJB3MYOzH97/tznq9sy+BhVHCZ84jM0gRuwq1qNwT59B4OimjSDhaYokhH/wSQjEMLAjoM3GBgVbHrAeYHX0AxsyP56DQbb1B0MkhK8DDYi5xjc3D0YZGRkgdr/o7hIkJ+PwTN/O8Q4WYtOsCE8hua8h5u1wAqCKg4yZLn8ZQgOCWb49es3hpfYWFkYrGJXINwjbdoGNiQ7zpgdxN96+h2bi8J1hpCQEAYdXV2sAWkUMg/JQ2hAyaHvf3KSC96YWLH2BAMA5+ex+TA3+7wAAAAASUVORK5CYII=",
	scatter2d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAfElEQVR42qWSURKAIAgF4WRxdG9GVmBgQyHx44zK+lzF1hpDLyJCKNTZdECWAAws3YgjwUaKFBCzTOArYCRYAdgrZB0wXKcigNuXdhAC5gTRxvQrPABGWM3BFyDrwBDd64QJYhcTwCe4F7MypwS5z/PTQQCoNA+AliZZGXdUkHaPFrbwnwAAAABJRU5ErkJggg==",
	scatter3d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkUlEQVR42p2SCxKAIAhE4WRxdG9Gpml8QhyZZrR0X+sKllIYahERgiluD0BdQLlPzpvo+ZAB5D45frSLugrBgYZYOpiASVYA5vcFLSR2oI7gAUcZ7JRzYINzP+C+PrJyDqLkxdVowKoPptiI1BGiDGLbOuBfB+tQDcAKVnmkt9DF11jCLYBtkqgLtwAnlfZ6Nt7cXMJM2yxC4gAAAABJRU5ErkJggg==",
	scatterBubble2d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVR42p2RYRYAEQiEm5s5upu1ZENrCf3xpPnemBBjZEoVQgCdFJPoRJQhAnibVF7SG6c7sAQYBwNAZ1sfRAboOLDiPwi8DFyAcXAD+DpQQT+0n8EEsCo3Awm2boS775T1uhl0JB57gO/AA1gHOgTkLGwOWw4awHdxnMFkCwq4EVeAljo5OR/g7IKL69CFuAAAAABJRU5ErkJggg==",
	secondAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42u2PUQoAIQgF9WR5dD1Zm0Igu2La9z76CO0NEzLzhBUiQmhk2gGwkkJuAKuAmBnsXbQvGZwAoYEv+ZQN9D7GsEciAlcGEeBt0zbwsw1oGUSA3yAxgENSg2o+Bp2yfYlIy/gAeZq4AZtXqz8AAAAASUVORK5CYII=",
	secondAxisTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42mNkoBAwUmzAgQMH/oMYDg4OGIbB5LDJ/wcjWhiArAkZkGSAvb09WNHBgwepZwC6a0g2AFls1AA0A/AlHlwAOUopzwvYBPG5Aj1BUWwAAP+jk/0+0qb4AAAAAElFTkSuQmCC",
	segregate: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42r2SUQrAIAxDm5v16L1ZxkDRdS12A+2PoOSZhEKKY2ZUVfh7bAd0YT8pwibEEjD/mgLe1shmDhFsH2A8UDKAj3jryoBszgFGV8+OEGWbMy4BFZu/AdEifXbgV/lsBA+ISr4ASBWIEZkwgZIAAAAASUVORK5CYII=",
	selectAll: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABWElEQVR42mNsXB7+nwEIfE3TGDafnsWAj10fuZKRAQ0w1i0J+R9gkclACGw4MZ2hKWYNpgHn7uz9T1A3FBipOGMaEFSk+r8mawZBzS3TMhjW9d3GNMA3W/5/Y+E8ggbU9ycxbJ76kAZecE4Q+d9ds5Kg5nOHHoPplKQEFEMY7aMFwC7ob1zLUFgfzICLHes8gUFVTYXh9q07KIYwErQaCqZOn/k/JTmB4eLFSwyXLl+FG0K0ARMmT/0fGR7G8PnzZ4a3b94wXL56DWwI0Qb0TZj039/Pj+HTp48MvLx8DC9evmS4ceMG8S7o6Zvw39PDg4GNjY3h9OnTDE+fPWNgZmb+QLQB3b39//V0dRkePXrM4OzsyDBt+vR5PV2dk4g2oL6heR8nF5fj169fzsVGRxmtWrP2SU1VhSzRBgCBMhALAPHnSVOm3/z8+QtDdWUp8YGIBoyh9FkAkdmNuM38c64AAAAASUVORK5CYII=",
	shadow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAw4hD/j0XMDIhvAfFHogw4cOAAnOPg4DAEDMDwMx4DsAbifyBACDIy4jIAHdwixQB0YEaSAejyowZgMYCBdIBigCkZBjAgG8BPpgEMAKpwZLa/jK2kAAAAAElFTkSuQmCC",
	shapes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42mNkoBAwgoiGhob/2CSB4oxEG1BfX48i0djYOBwNQA4rmBzRgYhuCcwCgk4cPAbgDQN8GgjFBCM+zSAnE4pORnya0f1LlAHY0gQ+Q3AmFDxeY8RpADkAAKJSXhFNrWAkAAAAAElFTkSuQmCC",
	shift: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkElEQVR42u3X0QqAIAwF0In//8lSiBg25karXMH1zVnuOEswUWsbxbSUevJSytLMOecmqIDVyUcEAAAAAMAJ0E8n3vi4BJbGeEzqH4DZ5GNcA3hBJkCa1KoOf06LuQBaUm271ArMVmjt4aMAreRWklcAV5LcBnj+gt99A9I73zoJAQAAAADCALUTeTklCrye74KNFhLsjdcFAAAAAElFTkSuQmCC",
	shift24: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAjklEQVR42u2V0Q6AIAhF4Wvtk/JrbbZsyFDMbk95X5hM70HRyXQpxj0RUCFsnCN/YS4hLM0L9a2k5w1AmWvIAkwB5I2SOVlAGScxr5rTAugF5mIDRE8ALSMygNb7YQ+gj0cfiRWHdzBSMQQwWvlUD3pNhuygd009gNtkmBbgjwAkpPoydQKp89O3qCjzHA8IPcTNtsxFFwAAAABJRU5ErkJggg==",
	shiftToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABP0lEQVR42u2Xv4qDQBDGv0V9FYvUQkpTWQqihY2VYCnkAaysRbAMpLKxUMTWzlLwCfIqKp4RBM8Tc/HOmOOcZndm1/1+zP7BIU1rVVXB8zxcr1fcbjfc/TWMpmmwLAtd12GaZueTsiwbURSRZRkMw8DxeATDMKsAtFrI8xyXywWn0wlJkoA4jtNYltUBcBy3ivDYiqIAz/OwbRvkcDg0giDAdd2XiPd2Pp+RpilIuw+N7/tQVfWlAEEQQNM0kLbfhGEIWZZfChBFERRF2QF2gDcCkCQJFEVNTq7rumv78d4f2tTYODb04zj+DHB3phYffjQH8CzQtwGmFn2UnfG8qVivuQhgTnRuu2YzsOQM/DrAXMofiawC8IzIjwGW3II/dwaG8S+3YPOXcAfYAf4vwOa/5ZsXJpuXZpsXp1uX5x82oLBONRRgDQAAAABJRU5ErkJggg==",
	shiftZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAmUlEQVR42u3XYQqAIAwGUD2g4FEFD1gpGDXmRlau4PNH4Sz30hT0bisppcUZlBij9y15CGFq8pxzvVfA7ORHBAAAAADACdB2J1poOwfm2miMq++AXufHuAQYBakArlNtdOhzUmwIICWVpkscgd4XanP4KEAaci3JK4ArSW4DRlbB7/4B7p1v7YQAAAAAAGaAUjE7nJaL5fF8BZhDWfLStDLUAAAAAElFTkSuQmCC",
	shiftZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABNklEQVR42u2XMatFYBjH/4qvYjArI5NRicFiUkblA5jMUkZlshhIVptR+QS+CuVySp0rx7nn3ItT1396n/d5e/+/nudNHmIY1fc9giBAFEVo2xZTvIdIkgRN0zAMA5Zl3WKi67pBkiRUVQXTNMFxHCiK2gVg9EJd1wjDEIIgoCgKEJ7nDY7j3ABYlt3FeKmmacDzPFzXBcEwzCCKInzfP8R8lm3bKMsSxNiHIY5jaJp2KECSJNB1HcS4HtI0haIohwJkWQZVVS+AC+CDAGRZRp7nq4en3KQ5P8f3Wsst9+7jaf0NYGm2dskWwKtAPwZYu/RZdZbnHlX3bYAt0612bVbgnTfw5wBbJX9msgvAKya/Bnj0Bg4DOOINLNv6WV/CC+AC+L8Ap/+Wnz6YnD6anT6cnj2efwE7V6ROPOOEaAAAAABJRU5ErkJggg==",
	showSelected: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42uWR0QnAMAhEdTRHchJHcjRbSg0mMaD97f0YA/c4FSFIVY2IEBrCaFxrGeAQf3dS4GpMQKMXEWDmCV5O8I41eb7swFJA4QqW/OEGOCnE936MWd62Q6K5BTipA7DMWwVY6r7LjwAPJGNc45VSEVlc9M4AAAAASUVORK5CYII=",
	sizes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42mNkoBAw0s2AhoaG/1CaEacBIEXoCmDi9fX1YHZjYyOKIYzoitAVEG0APhcQ7QWaBiJBA2BOxOZMZDl0eUb0QEIPKHQ5dPlBYgC+MCDaAHyAYCBSJRrJBQBmo2YRZDBVxwAAAABJRU5ErkJggg==",
	smallerFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABuUlEQVR42qWSv6u5cRTH358sSn5uYjNIGQwGgzIyyiA2NmVmIQOTkslgQwoDGYiBP0CZJEoWSkJKwiBx7vM8917363sHT93TM53POa/nvN/nMPwxmNjC/X5P8/kcKpUKJpOJvQUQ97Gv90wmQ+l0Go/HA6fTCQ6HA/l8HgaDgbF3zcVikQKBAGKxGHw+H2azGfx+P5xOJ9rt9g/gu+nfZj4GgwGt12t4PJ5nzuv1Uq/Xw+FweAV8afo1FQegQqGA7XYLmUyGer2O2+2GxWLxG/A/pFKpUDAYhNFoFMZWKBQol8u4Xq9YLpfs7Rb0ej1ptVoMh8NnLeeBIIHbzCtgtVoR1/CSU6vVZLPZ0O12hXyn0yHeRJ1Oh+l0+gmYTCYUiURwv98FbdlsFhaLRXhLJBKUTCZhNpshkUhwPp+Fde52O1wul09AtVol7u/gICwcDtNms0Gj0XhOUqvVqN/vQy6XIxQK8eah1Wohl8v9SOCPhVsLRqMRpFIp77SoKxWK3G43KZVKlEolFo/HiZOEZrMpHmC328lqtcLlciEajQoGfZsmCjAejymVSkGj0QhmHY9H/nTFA/4SHyK+0BHbAaTZAAAAAElFTkSuQmCC",
	solid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwjhowWAz4z8DwC8pnBeLfxLKBmtmoY8DAh8GoAZQBAMGQDBFxscZKAAAAAElFTkSuQmCC",
	sortAsc: "data:image/gif;base64,R0lGODlhDQAFAIcAAGGQzUD/QOPu+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAANAAUAAAgbAAMIDABgoEGDABIeRJhQ4cKGEA8KmEiRosGAADs=",
	sortAsciiAsc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABLElEQVR42mNkQAHp/xkYZjIy4AdANQxwNUiKq4ASj4G0PBC3MJJhAMj2P0D6LRBvIMeAeKDEQiDfF0hvJtUAmO18QHwfiIWAeB4jCQbAbIcBvK5ANyAPKPAQyNQH4iYgPwDI/wtkcwLxKkYiDCAZYBrQAxT8BqQFgPgDEN8BYicgTsBuAaYBdUDBJijbE6KAYTtu1+H2QhtQ8iyQjgHiQDS5qOzq/4qKWgytJdEM1VO2Mhzft45h37q5jCiKbIEGgNLhEiy2T1l67H9OtBWcX9yzlaG3xBthQD5Q8y38TmcwtPT6f/74NgZNQ0uG6+ePM8K9MAuoeTGQTkYKuBKgWA+aYTBXgLzQmuONMMAOqBiUBtWB+CUQg2JEEYh7sbgmKLn6/7q5rRSlAxQAAG5SYhH0Y5aGAAAAAElFTkSuQmCC",
	sortAsciiDesc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABL0lEQVR42mNkAIIeBob/34C0ABB/AOI7QOwExAkMDIwMmOA/A5I4mFEHFGyCsj0hChi2Y9eM3QAYaANKngXSMUAcSI4BtkBJeSC9BLdm3AbkAyVu4Xc6bgNmAQUXA+lkpIArAYr1EBuIdkBBPiCtDsQvgRgUI4pA3EusASQCQgZEAxUsJT0QISAXKPkGSCsBcSvp0QgMQqDkLyD9Goh3o8hFZVf/V1TUYmgtiWaonrKV4fi+dQz71s1lRDMA5nwHIH0ARW7K2mP/c4Kt4Pzinq0MvSXeyAakAjV9BdIiQHwdiEWBeBmKIYaWXv/PH9/GoGloyXD9/HFGNC+gBx4WVywFuiLaCuyF1hxvZAMygYrvAWlTIG4BirkC+b8ZIPlzA4ohQcnV/9fNbaUoHaAAAPehYhFdEZx/AAAAAElFTkSuQmCC",
	spaceCloser: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkQAP/gYiRgYGRAQdAl2fEpgAqQZQcI7IEOkBWiEcNFVxA1TAgFYANOHDgANx/Dg4OjKTwRw0YNYAqBgAALTushTpA2asAAAAASUVORK5CYII=",
	spaceFarther: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAR0lEQVR42mNkQAL/gYiRgYGRgQBAVseILAgVIMoAmFpGZAFkgM0gHOqo4AKqhAG5AGzAgQMH4H5zcHCAG0qM+KgBowZQxQAAZMaEhWR+B8cAAAAASUVORK5CYII=",
	spaceWidth: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPklEQVR42mNkQAIHDhz47+DgwMhAACCrY0QWBNHEGgBTy4gsQA6gjguoEgYUeeE/GMEFGEnkjxowagDlBgAAKXdzPLooT1UAAAAASUVORK5CYII=",
	squares: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHUlEQVR42mNkgID/QMwIo2EMBiRBMAMD4FWJYiYAoTUIBMYCAfQAAAAASUVORK5CYII=",
	squigles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVR42mNkQID/QMzIACX+I0nABTEAI5p2rIJgPgDVcgQF2i5agQAAAABJRU5ErkJggg==",
	stacked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42q2TURKAIAhE5WTu0fFklVozthEa0/4IDjwXRyUdUtUNgKSAxAPU/TG3auQqegNkoMVF1QbMHPwKYNWe6QhAPuPSVnZ0c8CX1sEfAWyZAWP+GCEEYAdeQ8tzP0CLLgKGBhPAI3gNaw6igBRU6Ae6AH6Zs3wH9qq+UAzL0sAAAAAASUVORK5CYII=",
	stackedLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAoklEQVR42p2TYRaEIAiE8WRypvYc65nwZO2Qa4/UqAe/BORrxjQRQkR2Zk4UiOQBUP/aHHs+E0CH/80lIDMf6yqyBjwpUAAaG9YlBEB9g8TSIaMl1wICvb00WKUOs5YuCuyh6eYmO1MH9LpCbgHWcxsYAZqn80wuFqxn/cI94LQ0K/AGjjy33ypVXgLMwBIwWXAG3imIAigYoRfoAsab+ZT/APYuzVCdp3edAAAAAElFTkSuQmCC",
	stackedPercent: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42r2QUQoAIQhE9WTN0aeT7W5FENWGurD+iMR7jao8RfICoKWLowqjsyAB9TGTtZ/mKui/hgXeBECSxmSbYAS2gnmFE2BK8L/AvUJqN2KmMcEA2AQHYCtYVvAKPifoAgmWRsFXwXgTy3wDpsjjUIn1UagAAAAASUVORK5CYII=",
	stackedPercentLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnUlEQVR42qWT0Q2AIAxE6WR0JpxDZiqTaSkSUKEpyoflgHv0SATHg4gORASuu1sY7NngCfCIspmIpGpaANl80QTANfBCNANGHfBi4HkcARA9f0H21QgVUgz5TKq5g3NHzHoSoRnqYUW/O5jd2Nq+XWABtMxNdwAtwtMg2pc3okTGDjqDDaAYhoBXhFXA7w4qYOUn6gd8NU4B/ZtY9AkZN/JQjd2WywAAAABJRU5ErkJggg==",
	stop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAh1JREFUeJyNk79PVEEQxz+77+44AwYCWnExscBEEo3Rw1BakWBBILHh/7DWaELjP0InVFYWYKMBYoFI4cVI4KEWkAM9zru3uzMWb99xBAsn+WZe3nzn96xRVfpl+/Htu6ZSeYFN6mqTmkhAsm4qWXdLs+7zqbWD7X6+6Q+ws3BvBZvMd37s406bhBByg01IBocww6Pg/er02v7ChQD7r55Wf2+uN1zzqHaW7hEUAqARJiIB7MgYDFTT9rXaxMzrDx0L8Ov922XXPKq10j2cQhbRFcgk6vjPnxwT2me16vevywBm50l9SkU2Tj9/xCk4Ba/gAdHzCqyBElAyUDYQhscwqg9L0u0sdY9+EgpHhdmGgioafA6f6zf3R/O+gaTdQsqVJWuqVybdaZNA3rePw9EQeiAidbk9AOoznJrJkoiOhxDQWLIovcwEDyGg4vNABQdAFS8ybkVyQ7FMjdmRogLf05d4ErDi/SE2wRR7Beg59bURExU8MEgIh1bard1kcKg3aWs4zyxFG75XQcHxxlCSsGs2Zm7VQ3Cb2cE3srhGp5A6/ik3K/kaz0yCEZkyqsqHRzdW/J/2vD85/q87cMbiRVfnGrJgAbLaxCID1dRcHaEcD6USMdD3XY7OmWiaZrp46TG9m76+4kTnbbuF+iw/pjgwbwwdNRiR1bmGXHxM/bL+YPiOV1560boTrakECCE1ErYSlWezX+RTP/8vCdeMdxoMTC0AAAAASUVORK5CYII=",
	stripeHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAFElEQVR42mNkQID/QMzIACOoLAgAAJ8FBq03KwkAAAAASUVORK5CYII=",
	stripeVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAFElEQVR42mNkwAIYcQn+J1olBgAAPGkBBedvkn8AAAAASUVORK5CYII=",
	style: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAv9JREFUeNp0U01IVFEU/u59Y/5XOhJjaEapVDaLFlFRlBFIYYqLwoWbaBFtXLWIWrRoFeVO2mRGCwVN+tEUBLMspFIqHdMpHQVNLcvSaSZ/xnn3ns59mkTYg3l33nnnO+c73/keiAhKRWFOrTWuP/vmaWwbeEean0nBNnGTY5OT8+9PgpOkhAMWQmEHBQe7fF/2XLqMFPBrwXEoficV1rqkqQK4OEFC8fnW/2X9QkRj/4mPdYKxJi4ty8J/LimkC5qhpn5zq78mGLT5n0Zv/48CMKPHHSN0o/qVLcjCWhykuQklYMoMTYTKjh3InNYkMBsM48GTTxdu1b5Gc8cgqlq7c/+mYXiTGd+UVZbAg7axC+6UJIx2/cqLj7cgYMHX+7ni8+w8QvMReOLcfgNgSR00OZoJLiDN5IRgcKYiLXHdRMZB99mtmalcQONl3yhc5IKlYlBV320JscJBwBGemKnU3Knh7rR3JrgAEUeJLjV3OT05eWIxQpiLLPECotyJ8HUqhKa2oT7T888KHQaSpQ4nTvblbEmpL8zPTS06unND8fFtmeHFRbg3JSMpORaK29iuGDQ/D3jZFODGcNjwKLLpxQi9D8xi8lu0tPHp5EUTbGoPtA8OBZGRloB090YnWTCwp38K91omSgTpVTEFKbNsYQaClo51cLuul8an57C7/JDrFGlVdP4+Tc3MwOKEwvwcXCk/IlZHYCdgWOTEEp+mclW7L7emeYCtsIRQg8+urvdRamIMhM2ykmRfBFBZOZxhwGrZBxrZCESM6oaqx07o8WyKQ8bm9VBkw7aiOLxvGztyhTavL84THjc+sBjD/jGK8H4ZfOfmh6wWX3/CmbJdI8WH87KJBWaiuM9mPvm102569tFYF7UP/aCkse3nCkpG5LISpj8fqZHR0e8hjAWm801YMViy5Kf5i/N63Ve1Kcj9wpEI6GfWMIvCPhHLjr5W2UmPOj6YrwNdA6HxrLaBN8UFeXuNuI1PA3UNLf5SyY5lsrBYCxYaLq3ptwADADgQi9wCmSZlAAAAAElFTkSuQmCC",
	subtitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwInMOHDjwnxhNDg4OjFgNgIH/YITVNkYsYlT0Aj7vIDubNgYQCkCiDLC3t4dLHDx4kLoG4HIR0Qagy40agMMABhIAhgHkAgDJMlYRAtEIXQAAAABJRU5ErkJggg==",
	subtitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42sWTUQrAIAxD15OZm8lu1p6sw4EzH8UNiywIYqHPhKocSQkfVNW/NAGQENDl9wpvk6D2QwSOIb2xFdpeSjkHnvg+2GZW9wHSEYDhwBlHbky17gPkpwA8DoTeE7uZT2EF0LUcIaMQ8OaEf+MFAGx4EV8yaBwAAAAASUVORK5CYII=",
	subtitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAwogscOHDgPzEaHRwcGLEaAAP/wQirjYxofIitMBNJ9gLMyWQbgO4CUl1DfRcMbBig01RzAT4DsYYBVV1AyDDKYwFmACmakC3D8DexNEwfAHGXZhE3FEh+AAAAAElFTkSuQmCC",
	sum: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNpi/P//PwMlgImBQjDwBrCgmMYENq8RiLVxqL8KxPX//v1DiIACEYYZGRlBmBOIe4B4PRDrQMUYoGyQGIoebAbADJkAxFuAWA9JXJdYA0CYC4inAPFOINZHlkPWgxKIcFMhQA0aFveB+DbOUERxDhQAbTEC4qNAPBfqEmRx3F6AAhOgojNAvBikGckumDiKHhY0B3ECcTVQQhRIg/B1NNeeB1IgQ7/BXYvmdE6oAnYcPv4NxF+BerAbMDTzAkCAAQChYIl8b86M1gAAAABJRU5ErkJggg==",
	"switch": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACHElEQVR42pWSzWsTURTFfzFTRytSCbGBiNbEfJBoG7Fi686uBEEFP/4Cdeu6K9eu3dqNW0H8ABduAm4UtUWLcdJO6sSUoliLtS2tjpkw3vdmom0saC/cmXcf95x37jsvwlbCcB7K9xxeOtLeimwJT82/eivF2PX3eOQjAYHhPMBrnTek8OAeZC9tQO1yfGO1SVSW7tAhSEY5Gf/Bq9uzmkRYav7AjQxNF6pPVqRcgNVQooBJJ8ic6qZLSlN239haCiw34dmcVuBzNgVSn+iHnR8WePpoReNPX+5hMRbjpbXJPIuSE3VFMF3H23aQwQzshZhkd/0rc6+XSFxI8flT2NwQZX1x3cMXBZ6RT/a4knpYcgdY9xkq7Gd3UDG1BN/kv68HJqsNKF6U+cb1QSFY0ax34YiBNeGVCtv1KWrOxhpGtfHTo3hMqncYled45nAb3GHjtE3hQJZZ0dwnd9IbknyUy7HqVcgXpce/cjPHnVF7nY2mU8ZtjlAUi3qj2ksqMm9S5o2FJPMtTGsKtyTTyohHk9Jy1w5tNGo+wxntgg5lQKMerJWSWMftqz7l6XfJyRkCglLmD9ipzuMVzwRPz3pMrpDQF9sZqtdWBKY1TqtrUG/6ay9ola7J6m3Y1i82l0VrXL/UXE6PEIDVi8prG2X39xnLkrWOswZC0aJIbEyLWkds9P628d9hVsryzEZw05vZ+F8hVrGnDVbxC4XGtPVr0Q7zAAAAAElFTkSuQmCC",
	switchb: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABTUlEQVR42qWSzUoCYRSGn4kp+yEQsQIhKtERDTMIat0FRJvuoJto1brbaBsE0a5N0BVEIOMvTkZEpEQhFZMj05nRKGQcR3zhzB/fPLznPUdhTCnjA9TaBVZnX5UXC84heTCig4q9cZygbULhqiWvTfiIB3bmOLDZW4M2bGdh5r7JzWUrMEQAJQNrYpWtBCxARGrWeOXx9j0Q5N8B/YGd9DLz8jgtVRTAm9ybYSUgAFR008qlpxwnOKnWP1EL9W+LTOjvVMWWoBVPgKs5yWRFMlnsQZ4kHN0oQCoDJfvwROP0qCwTSyneAEfhhk0sKoH0IC8dQnoRM7eO0+JmDPJnXcjg/n6dRPq+iyEmpb6k7qpDNlHVn9HSS26w/ZJJUx4GcCGlhniNupuqaW4L3Z/LcvFrwRMmE4jLvtSqQkv6hDhIofy1rNkuZtxnjCPqB1jYZM1eYZpMAAAAAElFTkSuQmCC",
	switchu: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABS0lEQVR42qVSwUrDQBScldVoRSilKhREG9pIKlpB0LMfIF78A3/Ck2d/w6sgiDcvgl8gQtm0SWmsiIgNohSV2C3xdU0R2hpj+2CSTdiZt/NmGUYs9q/dWukSSGzD19lwAtwJoOeAWhWQeRZPgFcakEhzWkrDAGZo0STYNj2WWbQAF48wzHlF6i0lUo04wXQtwGIWSPX8bxHGCR+Em98Eko0AmTQwF34/taGJMvziirKwngFKJzY5G2Sh27lD7hh/oJbCtchvAagE+0cGjg++yX1D5BC+LJoTmA3J9Xdwq/4pUdB+dlESyA+KUdxhy1xQA5sklF+BF3p7ychBM4rJhRxbwgblS51ThIT7jPtrEnjT/4yZBMjzTlZNd3MVmLr1cHXejEUOLTjB2mEOLR+wLojoeLHJ3ROcQbZ31U0DTmlAe3HJfSkMUyMLfAGX52TNjrVPsAAAAABJRU5ErkJggg==",
	table: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABDUlEQVR42mNkkPg0jYGBIZOBdDCd4QVfFiODxNv/SZHfSNY9bzkXA8MLYUZGBukX/xn+spJuP/NvBoanElADWN+RbsBvIZgBz/7/fyIJFjt79iyDsbExXA0+PqPMc6ABUkAD5IEGPCDDAAWgAQ9BBsjd+39mHeleMAkCeuGREtAAxdv//99TId0FSncYGO6rAg1QvvL//x1t0g1QucrAcFcHaIDS+f9nVv0l3QthzAwM9wyBBqid////pgHpLlC/wMBwC2SAyvH//29bkG6A6gkGhjuWEAPOrCA9JZpE/IYaoH7k//8b1qS7QOMoA8NNG6ABmvv//7/mQLoBWgcYGK47Ag3Q2Ut+dr7inAUAiwqiEYN/1ZkAAAAASUVORK5CYII=",
	tagCloud: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAo0lEQVR42oVSAQ7EIAij/380JyeoQJ3dEoxiqQWIqIoAYtDxGSBQmWv8f4edj7MV53kQHEQrv5BEgQN+kSGTUQUjEgVZSahoz9l7bxgJLrmoxlkiizfybQ56YlQ9zaykyRDXiSr7reDbAaUdiSJdUp2NaOncI/lbbna7t5VNZ+p3b1W/3AnO8YTcp4/t1y6s2KxWaVPq+ZyAxepJUvACqrH7GT8Wn4n9RMz23QAAAABJRU5ErkJggg==",
	textShadow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB7ElEQVR42oWSu49pURjFFyERKomOBolHPJppUJAoRDHRiUY8ouYfEIVGVAoTlUa0EhGRqUQMEtEZJHMnEULhldEpvPc9Z9/cyTX3mFnV3ufb+3e+vb7Fw33pvux/cR3ifXdxNpu9SSQSyGQy/T3Qf4DJZEJyuRxqtRrW6zVYgNFoRDQaxePjo/4r5Abw/v5OvF4vBoMBlEol9Ho95vM5RqMRBAIB8vk8wuGw/i7A4/GQarUKn8+HTCYDuVzO22w2tKNkMsnuUSqVYLPZPiE3AOYPhHkC/H4/DAbDZ+3j44MoFAocj0d0Op37gH+13W4Jj/envN/voVarcTqdKMBisdwHVCoVUi6X8fr6Cj6fT79dr1cMh0Pqw8vLC6xWKzcgkUiQVCqFy+UCl8uFh4cHCIVCHA4H6gmrVqvFDWBaI06nEyKRCE9PTwgGgzdwsVhMWBD7BE5ANpslsVgMLKTRaNxcZkZJNBoNzucz2u02N6BYLJJAIACz2Yzn52cwrtPadDolkUiEhdLums0mt4nj8ZjY7XYsFguaPLfbjeVySeculUqx2+3oGOv1OhwOB7eJTHxJPB6nE/grFpROpxEKhdDv91EoFNj19znodruESSBUKhVMJhPNf6/Xe1utVtDpdNBqtT8GSYefRQG/AfzH5BHoatNLAAAAAElFTkSuQmCC",
	title: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUUlEQVR42mNkoBAwInP+gxFRmhixGgADBw4cwGqQg4MDIxbDqOgFfK7AZjt1DcDlb5IMsLe3h0scPHiQugbgchHRBqDLjRqAwwAGEgCGAeQCAEMiVhGsaR9tAAAAAElFTkSuQmCC",
	titleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42rWTgQrAIAhE55d1fxb7M/0yRwOnjBZbriOIAp93WLQlRfGg53pVRF2AiZm7IADUgf0Y4anzyA1ZYbtoeylld3zgq7NFpK4DpCMA7kAjLrgR5roOkJ8CcDmg8DCjm/EUZgCm6QgZffpM9+5NB3pNeBFWpMusAAAAAElFTkSuQmCC",
	titleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42mNkoBAwogv8ByOiNDJiNQAGDhw4gNUgBwcHRjSDIIrRJYj2Aswmsg1AdwGprqG+CwY2DNBpqrkAn4FYw4CqLiBkGOWxADOAFE3IlmH4m1gapg8A63hmEZrKgWAAAAAASUVORK5CYII=",
	titleSubtitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42mNkoBAwInP+gxFRmhixGkDIIEYs6rEaQLYXkMGBAwdQXOHg4MBIWwPQNaADogywt7eHSxw8eJC6BuByEdEGoMuNGoDDAAYSAIYB5AIAZaFUEeAKb8EAAAAASUVORK5CYII=",
	titleSubtitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAc0lEQVR42rWSUQoAIQhE15M1N4u9mZ7MxYXKD6lIGoIo8jmD0ZMU+YP+a6uIQsAKRMH7EHAcgZm3IpgAUAdYoV3YXkp5B97xdbBFpN4DpCMAw4F6nHMjzPUeID8FoDsg95+8m/kUTgBNxxEyCgErJ6276QOczHYRmJzoLQAAAABJRU5ErkJggg==",
	titleSubtitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAwogv8ByOiNDJiNYCQQYxoesCcAwcO/HdwcMBpGF6XgDSDGGQbgO4CUl1DfRcMbBig01RzAT4DsYYBVV1AyDDKYwFmACmakC3D8DexNEwfABYGZBGrZCCXAAAAAElFTkSuQmCC",
	top: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAm0lEQVR42rXPywkDIRAG4BHJ3q3BLtSDDahgMQoWYDeebMCzJW0OJi7sLWvEbH7wgTgfMwh+DOpbA9gXizd0SwdXKaXsUsptCejF532EoC/Fj/d6jpD/jXALMJOPgLW2YYyh1gqUUiCEQEoJTQM559bPGCOEEI43pdQ8cIZz3pxzYIy5/DcEGGPNe78O9A46oLVeA4QQxwjLwExedls1Efgb+DEAAAAASUVORK5CYII=",
	transform: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42rWSQRKAIAwD0/8/Oh4cHYQkIKO9wEC70IUCQJxR2IiriF8BKNbj7VwizQGvAX2eBNDMXQttu5XEEbmFKSBJvIFbT6cAvYfWh3MwFAyCxCglqpMS4BFu0/1MCZg5iKJXnvFfwAELrSwRQlW1oAAAAABJRU5ErkJggg==",
	transparency: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACcElEQVR42mNsaGjwZWBgkGQgDzxnrKmpSW9ubp5Bju7a2toMxsrKyvTW1tYZBgYG6aRovnDhwszq6uoMxpKSkoyOjo7pLi4u6fv37+cHyv24dOnSj3///jEADWUD8v+dPXv26+/fv/9aWFiA+MyOjo5Me/bsmVlRUZHJWFBQkNnV1TUtKioqffXq1SAF7w8ePPgNaMBfoEJ2IP/vpk2bvvz69etPSEgIiM8eGhoqtmzZspllZWVZjNnZ2Zm9vb3TUlJS0hcvXgxy3fvt27d/Adno5+cHMvDvvHnzPv348eNPVlYWyAC22NhYpTlz5swsLi7OYkxNTc2aOHHi1JycnPT4+Ph3r169ege16QeQ/+ratWvfT58+DeL/4+Dg+GJqasqppqbmNGXKlJn5+fnZjAkJCdmTJ0+eUlpamu7h4fHw5s2bb4FO+wPU8J2RkfEzyEn////nAdFA/hdFRUUWd3d3j+7u7pm5ubk5jEC/50yfPn0yKDo5OTnPzpgx4+XHjx+5YBqgBgiAKAEBgc+srKyMkZGRni0tLTMzMzNzGYODg3OB/pkETAvpwLA4AXI6kkaQzcxJSUnagoKCQmhpYCYw3PIYfX198xYsWDARGBPpwOg8CpT7jWYAIzC67IHpZeafP3/gBgDVMAC9n8/o5uaWv2TJkgnAgEwHOuswKLDQ/Q70ngMwwGYCLYAbADSUISYmpoDR2tq6YN26df1Tp07FmxKB0T3zxYsXDH19fQxFRUUMEhISDEFBQYWMSkpKJSdPnuxGdh4xgIWFhcHc3LyUkZubO4aJiUmanMwETK1PGUEpC4hB0cRCon6Qkz8AAFhXFNlVq9MXAAAAAElFTkSuQmCC",
	transpose: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB1ElEQVR42mNsXhU5jYGBIZOBdDC9Nmx5FmPD8rD/xsouJOs+e3cPQ0PkKkbG2sVB/5lZWEg24O+fPwzNsesYGSvn+f1/9vgpyQZIyUoztCdtYmQsmen5vzttG8RZZ88yGBsbI5yJh186y4uhJ307I2P+ZOf/E3L2EG3AiSAThuyH/xkKprgwTMzdy8iY2WP7P9mhnyhnX/A2YXCR8GLYd28bw+l6W4bpJYcZGVPazP/PrjxB0AWzpBkZYjx6GH7Pm8PwgfsPw7G/dxiifjAwMsbVG/5f2HAOrwFzJRgZwnLWMbyrbWPgZfjOwMXwj+Elw1eGE2yPGBgjKrT/l4QsxOv0S24mDAzMDAx6r+UZ1IBGPGd4y3CW7TnDDx4GBsbgItX/a3pvERWI84UZGcLfGTKsFDrPsDVBlWFt321GRt9s+f+bpjwg2YD1kfIMm6c+ZGT0SJX835K+mahYAHklEmjAcqABq4IlGXbMfs7I6Jwg8n/P/NcYNu7WVGEQuvGD4Z0GBwrNz8DGcFjoPsNSPxGGvQveMDLaRwv8P7DkPaYBjOIM4gwCwND+gEKfFbrFkPj2P4NDjCDDwaUfGBltwnmwZuek3V+wemOeKw+MOf3Iyi9ZAJi4122cufmuAAAAAElFTkSuQmCC",
	transposeData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBQYLb7brz8AAADoSURBVDjLlZPRjcMwDEPJtHN0FWl0epWMUaDgfThK3NRBcALyE8vSE0XT6EH8LyQd93xRwIA5HEnyeJ6ZXHzTyYCr24ziyY2gkmeJkTmFzEw8Jzf4DXAt0U62ruvj/X4vhWu7f4DdE1kaVJQeneD1+oyjjDStd5nqIAnLxuaaPzIN0gDQLsQbNaAkbiIdADYBoLU2Wco34VIC1b7bNu9FMCIYEQTAzATPMktCROBMEBEzIvDsMJKwXbj1/zEWzUxIOnww1rVdBATAWdcfJ+rWzVNBsWvQpM/wptgn4U6Umbx9jXc7v/LBH+FDl92wsFPlAAAAAElFTkSuQmCC",
	treemap: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42mM8cODAfwYKACPIAHsHB9wKGHCbf+DAwaFgAIr+Om0UqYPOU4eNAQ72DkTpp9gA5bqPKHLznM8PFgPsHexRJBj/IxvASD0D+Dagum6z4AEqGcBAAQAANUJzAdpYAIgAAAAASUVORK5CYII=",
	ua: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAw0tqA/4TUDW4D/kPl8RpCMwP+I8n9x6eeGAPwhgUjDs1EhxkuA/AZzIjPAHwBRjUDUOQZcSggJAeXp3lmIggA6gcUEZ7M1IgAAAAASUVORK5CYII=",
	ub: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAP0lEQVR42mNkoBAwUtOA/+RYis0F/3HI/cemjxQDsMrR1QCs4vgMIBiANHfB4AtEig0gGAbEJGWiYoEkQLEBANoSFRE2ehqdAAAAAElFTkSuQmCC",
	uc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAw0tKA/zjU/kfWx0hAMyMOA/Ea8J8UOUYSNCOrGVgDUMDQNIBgOqAoGvEZgtVgUpIyVvU0zUxEAQChZhQR8AFGQAAAAABJRU5ErkJggg==",
	ud: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkoBAwUtOA/+RYiM0F/3HIYRUnxQCscqQagCE/asAAGEBRNBJMSFRLyiQBig0AANNEFhH2/yopAAAAAElFTkSuQmCC",
	ue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwUtOA/+Tow+aC/6TIkWoATJ5kA5A1kWwAXhfhM4AYtbR1Aa4wIMsABlyG0TUdIAcuVgOolpRJAhQbAACFQxYRf67AzwAAAABJRU5ErkJggg==",
	uf: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQUlEQVR42mNkoBAwUtOA/+Tow+aC/6TIkWoATJ5kA5A1kWwAXhfhM4AYtbR1Aa4wIMsAnGBwGUBS6BMlSa4XSAIARkITEYwMI/4AAAAASUVORK5CYII=",
	ug: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42rWSwQ4AIAhC4/8/2k5ttQlSLq7JU0mMpvATEKQ2dh+EEQJIAcxM3zOAs1YKqLqnTV4Ah1xAMP/tBO0MrF9QkBKgICv98hJZaPYpX6kNmKeJGBFBzshvAAAAAElFTkSuQmCC",
	uh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALklEQVR42mNkoBAwUtOA/3jU4JTD5oL/SBoJyg1zA/CBIeKFIWgA1ZIySYBiAwDLNhcRr/PZxQAAAABJRU5ErkJggg==",
	ui: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJ0lEQVR42mNkoBAw0sqA/8SqJ+SC/4TUjRowagBNDaBaUiYIKDYAAJ2ADBEVe6i2AAAAAElFTkSuQmCC",
	uj: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAN0lEQVR42mNkoBAw0tqA/4T0EOuC/7jUjxpAQwPQNZBkwH8s8vQ3gBGLgVi9SygMCKmjfWYiCACLsxARkd8HyQAAAABJRU5ErkJggg==",
	uk: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUElEQVR42mNkoBAwUtOA/3jU/MelF5sL/iMrICROqgEY6ok14D8OtUQZgFMzMQb8J6AWrwHohpDtBQZ8htDNAJzi5BiAIkdJUgbLUTUzkQUANHsYETd9AKsAAAAASUVORK5CYII=",
	ul: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAN0lEQVR42mNkoBAwUtOA/+RYgk3yPzEaRw0Y6gb8R5Yj1QAMOVIMQE6pWA3AlZTxep2qmYksAABskA8RjsBjswAAAABJRU5ErkJggg==",
	um: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASUlEQVR42mNkoBAwUsuA/0Qa/p+Qov8kGMCIywBGJIWMhOQGvwEMSHz0AMdrALrCIWoAhmJCBmBLREQbgCsp/8fCxlBEEaDYAAC4PikPUmotIgAAAABJRU5ErkJggg==",
	un: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42q3TSQ4AIAgDQPj/o+tFE2OKQJWjy6QYdHss/wkgwcHuswQoIh61gLmOC+IWbDKAtVoC9sgywBAZWOfbwImYArAkbYA+ajooHYCOapbw62eSagDjLB0RXy9ipAAAAABJRU5ErkJggg==",
	unchecked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAN5JREFUOE/Nk0sLgkAUhfv/i/wpLYQI6UVZQg4lVBMyJsqECCKI6PrEFRwMbDDcNHDgLuZ8587jTiZ/saaGgV/10TiZq6oaLNrfCzCtGb5pvjKx3i2bEC3gwl10dfU9PMQdIvSxs7fDAR4/g8x++MAzChDLGEfnMAzQTSVjkiRI0xSMMT2Aztm2S0Yy5XmudOc3PcDaLJp2KTHLMhRFgbIslYIw0APoll+JVMlkrutaSUqpB9jOXpkpvWummjrTPqPLTuCcQwiBKIoaGB2lvQeqtYChv7H3I42ahTET/QZV7DlRP23G4AAAAABJRU5ErkJggg==",
	undo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACQ0lEQVR42o1SbUhTURh+Tou53YbOi+HiSrThB30sXBHin4ygkH4YRH/MkGIFEklhGJqRLLDEKIhFCTmMEfmjKAoKCeqHYO1HlgiKkRJuCxNlLNFpq3V67z3XdO0avfDyvOfjed6PcxhWMV8PtxH4W6vZcfzDmNHmpfu8gqB7rQnOnylIl4+yhf8SuHCPm1U+edM+D0xTcWAkDJBIjPaekLdfOcbGDAXO3+UlBA+3u+DeVQzMzAKWLECmRpI/gNEI0D+MJN0523GS3UkTaLjNTQSP3S5UFSpAfB5I/VrOQq3ATkJmwqFxqmoCJ26cYoG0CupvaiK+PDta8mUgNzuzXytVZCJGb0irpMh/hoUzhlh3jVcRBDcpyFEzf50BHHnAelmcr7MAiQTwZgjtnY2s2fAVvG28UG3Jng13fBZlFHcUbECF4hDnNqrkVQiDgRbmMRRQrbaVWwm6gj5WQ7GDBjq5bYs4k0igL4QFOpNWFVhp1c1csUmIFpWI9RpiDbxHsucqy9IEDp/jEwQb/+L1ki/9wu7yHahM6Ivvi/SsIxh8dF1v4WA99+8px+my0mV2/zvgw7CIPVtpiNT/py9iHZ8GohG0PfWzi5rAgTruJBh1bYbZKolLxQWAM1/En6eAjxERz9EHC4/hG4WuF50s9mcG+73ca5fRZculKecYz2KOaNFxpCg89DLAnqV9JNX21vJKdfKyA4oqZNGrWZwX5NiklrnmdZA9X+JkvMLuI1zN30iuiu3Ut9/qQ73V94DFVt7/DQLjqBFSiWXDAAAAAElFTkSuQmCC",
	unpin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC9UlEQVR42oVSa0hUQRidmbt3Tde0XA0tfKeEkhmGLygwUitRKvtRUf0INaUQbQUh6keEP3IzZUFSEUGlsAeSr9JMLS1tLSvfK3RdNc3F3dVd3W0f9965XQ1l1ayB4fDNcM6c73wDwf+W8BKyjwlzYwVAZ23KssDjxYhrvoZXr+FWPP+MekQ9TMLul2vyFhYMEovVQkEICnhyhSC+CDItWdw/Bc7IhonazGA2MqepGm1zutjdp6QBoyMBQvmg5XouiJNB8DqT+6uA+Gw50j5PwW4Jed7Yam6LiY3zV5uETFdvP8CMVUCQwmi2Ma0HnSxB6wRQQinETVdXrPndUW0XGak30LoYbtTNYQdHJ6gxEaxOrxcwFvN5uiG1hkwqJzY5IGMLXWmlCkSlppd4eoiTzQxiJikFmhloR0s6zVtu1wEps6h6h1slxrUMiKQKyNZf4VBC2Q2hnd1dX/9A5ljUfkcWkqB/XA3nJkfhPPXJYtZMRBnlZV8dD2cjQ1ch3hTiznPVPeEhgZF+XntYL8/dsGtEjSiKYrXf5YRxTllk6pZl258oIE2vJPS6MUbltqCee/HYN+WpJPFI6H2RSMQMq2jB+Mw81lBfkH566KdZOxXKKWrVG1vekIE7EX3z0bN9e31P682A/jZCQZXig4ABwmnOLz7EWha2sKXA4xftxIVTR9mWtq6cml6tdGjJlbZgAamZ12PDkg4Z9AsR+GV6ryCxDDENaet/okY7j1zFLphhufCP7zvl8u5OmaTVvc5RbHebA8TB5s+3nCeVyl8EAKO2r/Pz7ltzMDWtcjAbdH3tHR1sekbGIf7IHOEdAOUuyU5PJkp1SYmJmz5cZVVVH/wxMUF4+viwwwODDxRjiuy6xsbQqsrK/szyciRLSVmxKgVAbeKRLyZtBaZWHUjz853ELi4Dg0ND0sKiomIPDw/n2dlZhu+QA6SIZ9IYsBb8xzWwxZUMiOCgoECEUAAvMEaS5A6apnkyYPm9jMszt9qg1aZmfgNaxWeX/YISmQAAAABJRU5ErkJggg==",
	uo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNkoBAw0tKA/8SoZcSjkZEYcaIU4ZPHZgChcEExhBGXxKgB5BlAjCEEoxGfIUQlJHTFBNXSNDMRBQDrbBYRul13eAAAAABJRU5ErkJggg==",
	up: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOUlEQVR42mNkoBAwUtOA/+RYiM0F/3HIYRUnxQCsckPLAJLDABugKBaIM3FoG/CfCDWkSZLrBZIAAD0KERHY36CdAAAAAElFTkSuQmCC",
	uq: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42s1SOQ4AIAiz/3+0bgSNxSIOMtKLVNGKgwDrCheBEMpeIkU4EmLPKxsY728D9ozUwBfUAxEtcU2VsOcfiSVSzalxdoH1cGMwhWcMtj0MROcdETswwvAAAAAASUVORK5CYII=",
	ur: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwUtOA/+RYiM0F/3HI/cemjxQDsMrR1QCs4vgMICa8iHLBf3zqifXC/0FjAEmBiC8W/sPkiUnKeAOTqpmJLAAAXSwXEYB8u8oAAAAASUVORK5CYII=",
	us: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUElEQVR42r2SSQ4AMAgCy/8fTe8mIMa0HgXHuOAsA68AFD7WGphiCKAFUOSlNgFEI9Bo8RIZ+touESj9g9EVut/4c8aqSbAbgY13tEQZa8AFDjcUEayPQ4QAAAAASUVORK5CYII=",
	ut: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkoBAwUtuA/6Tqw2UAI5F82hjAiMdADDVUN4ABi4F41Y0aQEMD/hOrnuqZiWQAAPqKFBEVq6FIAAAAAElFTkSuQmCC",
	uu: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAN0lEQVR42mNkoBAwUtOA/wTUYJNnxOaC/2gascnD5UYNGDWAkCJs8v/RxfDlBaxJl6AAqYBiAwANsBcRBKw3BQAAAABJRU5ErkJggg==",
	uv: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwUtOA/wTU/Mcmjs0F/9E04pUjxwAUcXwGYJMnygB8rqDIgP/Y1OOLRnRD6G8AsiE41Q5+A3D6nRQD8AKKDQAAvoAUES0OguQAAAAASUVORK5CYII=",
	uw: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42s3RMQoAMAgDQP3/o+NUKCVGxA46pnBadRuW/wAgYFT5PQFIVuZTwDsAa1gCePYkAYZkwMnlf2H5jhYD6hr0bSfQqjEQtcomD6h8gakAAAAASUVORK5CYII=",
	ux: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42q1TQQ4AIAjK/z+atk7NEFzlMZCpUIzHip8CMByGB5sAqVFi1QqVCPKbE8grHHx1xH0KVFznAhyvY6MU6UwQSsTdgGWg7QKzsCVwHSQaVYEt/OtnuqoJy1QWEd43kfMAAAAASUVORK5CYII=",
	uy: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkoBAwUtOA/3jU/MelD5sL/uOQwypOqgEY6nGFAbohuAwlyQCsavHFwn9i1BJrAE51hNLB/xFswH9i1VM1M5EFAEYtEREV1FoeAAAAAElFTkSuQmCC",
	uz: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAS0lEQVR42q3TUQ4AMAREwbr/oblAl7fBZ9UETeMtI66BdGsU0MEj8BtLwQiQxfKQtO4C8l5sirvk2DoFxiVbT0aABDkMoLHPP5MdBQD7EhG/c8bvAAAAAElFTkSuQmCC",
	variableLabels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42r2R0QqAMAhF55d5P12/bLUoNHDlSPJpyN3xiNQ+FkVNEelpwAgDoP1HP4lHj5ldys3pxlbVQkD5CgBHQ282KlIIqL8CYKFmPG/zfIUsINJaWiEbXAZcFmO92fsfg1m9GmQBGz2tgIegBFX3AAAAAElFTkSuQmCC",
	variableLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42rWSQQ7AIAgE5WXuz0x/Bi+jTRsLB9tipF4kZjMOIpXFRaNDZtYwoIcBnHXfa62bpdw9amwRabmA1BYAM1CPczbC3HIBuVMAbgMqxvM271OIAkZaUy1Eg9MALZf3EaCn+l/AcgtfD9n/zQ4oCo6HGEvKBgAAAABJRU5ErkJggg==",
	variableTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42r2RWwrAMAgE48nco+vJ0gcNGrCtoVJ/EsJmHJHax6LoUUR6GrAn+0Wi4yOA82Rml3J9urFVtRhQOgLAUdPJRkWKAbVbACzUjOdtnreQBURaSyNkg8uAYTFGiu7/GNzVq0EWsAHi4XyHNxPQ2wAAAABJRU5ErkJggg==",
	variableTitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbElEQVR42rWRYQrAIAhG9WR9N4vdTE/mYNCUkK2Y608S9nwfMn08nD2KiC0DRjOAqx53a+3wrjDHnK2qvRZQGgFwA4u4YKMivRZQuwXgNmByXrR53sIqINPairDauA2Yo2X1vwZGZC8fuQRwAjYQjodDfLAKAAAAAElFTkSuQmCC",
	variables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42mNkYPgvx0ABYIQa8BCPGnkojU2NBqUGyIMM0AQyrhHQzIDFEKAc4yNGCPu/BZA4DsSfgZgXhwEYmqFhAANYvYJuwC8gZiNkwBMglkEzBKvtxLiAFAPwGsJALQNUgFruIgswYqrBawiK7aQagKGZVgZgNQSrZjwGoBiCUzMBA2CG4NYMAgAo8DVxyXmNoQAAAABJRU5ErkJggg==",
	venn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACOUlEQVR42oWTW0gUURjHfzO7W6vuyhYVFq4mSqZuktBDF+iheopQhB66QLCxhFBSFKRS9BAUIUTQhZ4qiIzAiHro8pCUkJFhQoqaWaERorRa6izjujs7fZvjZcTLGb6Z8/2/j//8z/+co7D4UGbNzaUapsfOle7l/ePxsz/1eGCt29mf6XbcafoT7ZKSsSRBwOPalOZUH1bn+gIFHhdjhsnt3lE+j0WPftFi9RHD1BYlKF2TerciOz1Y4F02jWnxBLd6Rzpe/daP9erx5tlK5hIoIb93oirX53Sq9tLzwYh5pmuoJipckkamPJlLoJ7L82lBvzfFodhL74d1o7Jj6NJwLHFd0uF5CMqLwH/8fF4oFPSvd6nKa8HuQ2ErlMGH7HEqG8PRcGviKR+5xid5IG4RHHHBqhaoKC5Jz+FqoYOcVCl5f8DNcsj8S7U5xGMjgtEj7ffo5g17aGHAIig7AbU3IO9/5nPCgXUK+adh4ORFXnKZNiZmxP6S2CtetHNBmVzG1jp4exBcdkceSByuSyq04+MSK2iQb8giyBJjGkVFlr3xikRVrbxq7PhXiX08o4cqi2D7ZvmVuHVI0nSrS4cNj0SFcOe3zcDhJKlENxU08WJqFxywJQi7TsHujaJRhYY+aH5CabNGEfspIR8NlUb6+E4970iu7dusbfR6IKMYojvk7Mk8TfwOd+LRB8kghxG2MYaH1SI8TKcIlC1idO5BEiWkMOmmYdkVSx6wBXBzvtu40BWeF/8HHwO4mBMafN4AAAAASUVORK5CYII=",
	violinOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42mNkwALuJyT8xyauuGABI7oYhgBQZz2M/SAhoQFEKyxY0ICkoZGgATCN6ABkEF4DYLaDDEC2FV0M2RBCBsAMaaC9AeiBh88LyIbgNAAaaDA+PBCJNgCfF0gxgHgvDHwsoBvAgAUQNABPbGD4nXYGgAAp2RkA3ciEET6Q1jgAAAAASUVORK5CYII=",
	widthSpace: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwUmzAfwaG/1CTCBoGUzvIDThw4MB/BwcHuGHIfIIGgBSD2OgGwMTwGnDwwAGCIW7v4IA/FihyAVXCYHBEI/0NIKSJEKDYAAA5GVD5SnvFkwAAAABJRU5ErkJggg==",
	widthSpaceThinner: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwUmzAfwaG/1CTCBp24MCB/0PAAJAiBwcHRrIMgCkgy4CDBw6QFPrUdwFVwoAqsTAEDSCkiRCg2AAAZvROBZyCAtgAAAAASUVORK5CYII=",
	widthSpaceWider: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARUlEQVR42mNkoBAwUmzAgQMH/oMYDg4OBA37D0ZDzgCQPEyObANg8ngNIAbYOzgw4DSAYhfQLAwojoUhYAAhTYQAxQYAAE8YVfmGXZXIAAAAAElFTkSuQmCC",
	windowGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42qXMQQmAQBhE4TWKAQQDCAYQDCAWEAMIBhA2gFhADCDYwAYmsIENVj35Dh4G/rnN4X2RcyF2hkUPkFqB3AqUuKuWfc0L1ABmEagJtABGEWgJ9AAGEegJeACdCHgCE4BGBCYCC4BKBBYCG4BCBDYCO4BMBHYCB4BEBA4Cpxb97wUuKxAswA00tC0CXCMQDQAAAABJRU5ErkJggg==",
	windowSolid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJklEQVR42mNkYPj/n4ECwDjYDGBkJE4bQs+oAaMG0MIA0sHAGwAAX10z8bIlEyoAAAAASUVORK5CYII=",
	xAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABEklEQVR42rWSsYqDQBCGf0kR8Am00sLGXrCS2OcFfA5BwcbGQjTgg1hY2Qr2gbQWYiCdqL2Fwly0ELxw3incsMuywz//frs7TJ7nhHfous7gQMxFk8lhg38hqOuaDMOYTGFZ1py73W7IsgxxHIPn+UX7I4Hv++Q4DqqqAhFBkiR4ngdN01bazTdQVZU4jsM4jmiaBvf7nfmu3XyDsixJURQMwzAVo23bD90mwfP5nA36vsfj8YAsyx+aTYLL5UKn0wnn8xld181X+HMfRFFEpmmiKAqwLAtBEBCGIWzbZn4leL1edL1eMU3XdedcEARIkgRpmkIUxe1f2NNcK4IjXbkQ7C1cGdA8jsVy4mTy3jB71y+z0a0PUbIQlAAAAABJRU5ErkJggg==",
	xAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVR42rWRbQoAIAhD82Ye3ZsVRYHR1xwkgf6Y82mSephZrllVJQViElcT1GBoZRQ0gZ96qm90/wiQ/SGClylFQN9gN0CYy08GXkz9QuRgkEGkeTHwFGgO4UIEPnJ7x8bWWwAOAolQfA/7LQAAAABJRU5ErkJggg==",
	xGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42mNkAIIDBw78d3BwYASx/wMRkEE0m5FiA0CaQYyBc8HQ8AJI3t7BgYEsAw4eOAB2Hf29gM/ZBA0g5GzaeYFYZ2M1AOYKslzwH4zIA4zoAqS6AADOZ74PsXcZywAAAABJRU5ErkJggg==",
	xg: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvklEQVR42qWTwQ3DIAxF8R7uFL0kS/SWKbllCffSKZJBAgJHH8umh1hCgIUf32BTemj03hOX+VUGB2dOWLPxHwpY+2AnWPqs56odZXwtYHMgNTD3gKpyAWgD1FMTCCpQq3v5fZqP1PsHopKH4AEAkA0gNpVcgmX4BfvkBbICxKaSpwomgFCFl4J+6eLUhwAkfETMXX0cqaAgGIvH/sqgwhYSwy3SU5g+KDm332Xa916ZK0SiZjoBEDVaa6b00C6L6V4Xz6Y0KgAAAABJRU5ErkJggg==",
	y: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAn0lEQVR42tWT0Q2AIAxEyx64hw7ilAyie8gggrkzZyxE45dNLpDmeNUWgn2MUBSLBqxe5KINe/UdeQImKDqHF8jEZ8wrYHYgFZAgg2eU/AGwDsQDRFSvuRykWoSBEEY1r+I5q7OJGpNALs3Cqj3JHqDXD3524mEP0PuVZNd+NAEmgPl/AF5rXhhvnEmm0gSMdn8fHOf6BNB6WApyAa9jB9FUPmXGbMfhAAAAAElFTkSuQmCC",
	yAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABG0lEQVR42rWRsYqDQBRF73xG0G+wCH5AagvTRgRBAoKlpWBnwI8QBO3TpNDW7WIhiI2ijbWlpc1sJoUk6K4bYS8Dwzzm3jnzHsFD9LEIQLBBhD79T/e2gH8j0HWdDsOA6/U61S3LonVdI0mSqfYjged51LZtlGUJQRBI3/eU4zgoioIoisgqAdPxeKRN06CqKnI6nWie5/B9H4fDYZ2A6Xa7UVmWcb/fWRgMw4Drum/3VqfgOA69XC6QJAlxHM/urE6hKAq63++f6OfzeR7wG0GaprTrOpimibZtwfP83wlY17Msg6ZpYH0Iw3CRcJGAvTyOI1RVhSiKCIIAu91uOeCVgBnZ+XVMa5oIvtL0I+OMgAVs0du/GcGn+zfMlaNQ+OlAKAAAAABJRU5ErkJggg==",
	yAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVR42rWRyw0AIAhDZTNGZzOVRBL/FhK5cCnlUSi1EpGsnZkpOWoQqwlqYFqqa3OdoDCBGcwEM82J7h8Bcj9E8DINEYQz2C24EiBEgzj0BU9gkIFneDHoKdDuwoUI0JMsqwLTeXtQiCq0vQAAAABJRU5ErkJggg==",
	yGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42tWPOw4AIAhD25tx9HoyNE4mJn5QBxsGlj54RImXIUAEwmOA13485x/8oSDJzYwhwKj8VmF2eQhYLd9X2LncAZKE3XIHCCu0aTVW9gxUr0dI2tNB5gAAAABJRU5ErkJggg==",
	yellowCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQvKwoXYgEAAAIkSURBVDjLhZNBS5RRFIafe7/7OTNppEEzy8IkaK8IUzEYtarQjKJEf0SLVm2DFv2CVoHJJMw4Y7gqpBwwopDoBxgzTkiYQpGZmjP3bfGN42hGL1w4nMt5znnP/T7zfGbmW61e75T3iFYJMFhjMMasDg8NJTlMU8Wi/qeVlRXlC4XsYfVWivqWK0uUK1UqS1XKlSrlyhIAE9ksyWSS8+n0nXyx+OxvQCNwLiAM945zAQDGWlbX1kilUlxIp28XpqfzrQBHw7m1DmtN88L7KH+mp4eXs7PIe0ZHRpB0Yz9AuxNYjNkDBIHY+LVBX28vfb29zbw5sGrX9GKDJsAacNYS1mtsr39nq+YBONZ1nKOOwwG7nq2BtsCSiAWUJjsAyNxaB0HpqSFxAGBbJwhsQDwMSSRilCY7yAy/wFrAhRCGWAvnBku8z+35aAJcYEnEHLEjbZSycTLXHqPlIbwHjAFj8B60fJW+y09YyDcguakpSdL21qbkf2tuHOnrfWnxpOazSPLSzra0syVJUe5Tt7T2QB+n0T4LmGgP2lkEd6K5d2wAtsV8kILalyjOFQqSJF+vR92kaIrqRal6KYobmhtH/vMV+eWbWsijgX5GrbW2+cVB9IyZMfFm/hWEp3AtjZ0DE3bz4W2Oe48Ye/2OCTM+MTHX3t6e8RJIWGOIO0NXzOJ+DOI9bHYUAUj8vE48BncfRsUNg5wGOg/+JAP9nOUf2i0G+AOIgBhW7Bye6QAAAABJRU5ErkJggg==",
	yg: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAtElEQVR42tWTwQ3DMAhFYQ9nil6aJXrzlL51CefSKZJBaqJP9NsQt0pPtYRsoc/DgK3y49LLXVLbh2bpQLM0m3Fm3ep3wAhLQXCFCenE/QzIAcQABSbQXMlf1bwdSARIyF4eN1nUUwGSCSJ01Qnn5NAWvJalJDTISJCXZmHfemLZI0CvH9XL8eAd4EMpHlxYvwMAkgnyTwB61v5gonEaYO5NYUDw+//wcU7fAI4+1gYKAWfWE0hXVxRNCdXsAAAAAElFTkSuQmCC",
	z: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAuElEQVR42qWTgQ3DIAwEzR5kjzAIUzJIskcZpCC90fM0aaNashwh+wxvJ9ifFug7Nt8Qv1lt/uqRAan5jshJJuB+fsAnQCb3pIrChOjn5Q6QqIPfzAFeXAAbGkQqNiR4cabuhbqbAviaFXowdOmugE0mkgU63o2cZQo8DddDhXN4t7OfKyDaLCZf/aRnDT3CD91ZNJ7SAtDuvDA6zqKASN11aXSZ7A7ASVer7LpMIj75kRj+cYyP7A2dTE0RinaMGwAAAABJRU5ErkJggg==",
	zAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABCklEQVR42rWRsY5EUBiFz5XQTaImMT2tRCNZXmDnFeglHmWn0KPR66jYXqL0AhqvILg7V2J3ZMdak8xJbiTiO//3X6QsS4pbLMsieCIzxEqeLniZgeM4tK5rcBw3H0EQ5pMkCWRZ/v520yDLMtp13QwPwwDXdWEYBvI8hyiKZNfgPr7vUza5qioo5zOD9g2WhGFI2fQ0TfF+uazgXYOmaaiqqswAH9frL3jXQNd1ejqdUBTF5nqbBp7n0SAIEEURFEXBOI7ze03TIEnS/h3Ytk3btgXP8+j7HoQQTNOEOI5hmubff+HWSB/t+3CFewM6s8B/4ZXBm2UdAlcFbPJnWR5lfwqWLHdx5PkF88ufjwIy5cIAAAAASUVORK5CYII=",
	zAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42pVT0Q4AMQSbP/Pp/mx3SyZxOaq8kKHt2GRdM7N9vKrKGtin+ICwAF4rHiAFCFhisooRGKUAKRHEmuVeli1hdqMZxObfEOMhw0wpqJojQbuFTHb6kKKCTjZ8id0qKYCJlStj/ejnUQrYK/mcHkP8u1D8QpTsAAAAAElFTkSuQmCC",
	zGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAX0lEQVR42mNkAIIDBw78d3BwYGQgAzBSbABIM4gxcC4YGl4A2vCfEaoWCxu/AQQ0M+L1AiHNeL1AjGacXiBBM6YXSNGM4QVSNaN4wd7BgYEMzYxwDjmJCO4FMkMfzAYA0Pt+CcV/PCoAAAAASUVORK5CYII=",
	zScore: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOklEQVR42mNkoBAwDl8D/hOrHp8BjESIEe2F/7jUEmPAf3zqCBnwn5AaRko04zOA4kCkOBqJBsPAAAB8dAoRZD+p8gAAAABJRU5ErkJggg==",
	zg: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAyUlEQVR42qVTwQ3DIAw0e5Ap+ilL9MeU/LpE8+kUZZAayUcPh0aJgmQZEd/ZPjtBLp6Ay+0pUd2iFg/gqtrn/ZDKBEndXS1xkN2ZuL2/mnmCrA6GoGrAZB7vZY8gIYN9SkQAcGngroH1n6n8QuBM2QEG+UDAZVbTg0k32T3BQipzRZwdushmCm4a0MMLB/J21tZKcOBIYF/6Sm1Va6WEA9lRurgpjQST7H1hJuMsAwFNwQs3WybZI+Cgf6sMXX4invyROvl0jGfPF/0QaRG760CwAAAAAElFTkSuQmCC"
};
CanvasXpress.doc = {
	F: {
		fill: {
			M: "Genome",
			T: "color",
			C: "Color for the feature"
		},
		id: {
			M: "Genome",
			T: "string",
			C: "Feature id"
		}
	},
	M: {
		Shadows: {
			D: "Shadow properties used in most visualizations :",
			P: ["shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "showShadow", "showTextShadow"]
		},
		Acknowledgment: {
			D: "Properties used to acknowledge the use of canvasXpress :",
			P: ["acknowledgment"]
		},
		"Sankey Diagrams": {
			D: "General parameters in sankey diagrams",
			P: ["sankeyColor", "sankeyCoordinateColor", "sankeyIterations", "sankeyNodeWidth", "sankeySource", "sankeyTarget"],
			U: {
				Sankey: "true"
			}
		},
		Clustering: {
			D: "Parameters used in clustering",
			P: ["clusterAxis", "distance", "imputeMethod", "kmeansSmpClusters", "kmeansVarClusters", "linkage", "maxIterations", "samplesClustered", "samplesKmeaned", "variablesClustered", "variablesKmeaned"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		"Dotplot Graphs": {
			D: "General parameters in dotplot graphs",
			P: ["dotplotType"],
			U: {
				DotLine: "true",
				Dotplot: "true"
			}
		},
		Histograms: {
			D: "Parameters used to create histograms in 2d scatter plots :",
			P: ["histogramBarWidth", "histogramBins", "histogramDensityKernel", "histogramStagger", "isCreateHistogram", "isHistogram", "showHistogramDensity"]
		},
		"Boxplot Graphs": {
			D: "General parameters in Boxplot Graphs",
			P: ["boxPlotOutliersRatio", "boxplotConnect", "boxplotConnectWidth", "boxplotDataPointTransparency", "boxplotMean", "boxplotMeanColor", "boxplotMeanColorBorder", "boxplotMedianColor", "boxplotMedianWidth", "showBoxplotOriginalData", "showViolinBoxplot"],
			U: {
				Boxplot: "true"
			}
		},
		"Space and Width": {
			D: "Properties used to size the bars and point in one\n",
			P: ["sampleSeparationFactor", "variableSeparationFactor", "widthFactor"]
		},
		"Axis Resizer": {
			D: "Parameters used when resizing graphs",
			P: ["resizerBackgroundColor", "resizerBackgroundColorCurrent", "resizerBackgroundColorOutlineCurrent", "resizerBackgroundImage", "resizerDataIndex", "resizerDraw", "resizerPosition", "resizerTransparency", "resizerType", "resizerWidth"],
			U: {
				StackedPercent: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				"*Bar": "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		"Y-Axis": {
			D: "Y axes parameters",
			P: ["setMaxY", "setMinY", "this", "yAxis", "yAxis2Show", "yAxis2Title", "yAxisAbsMax", "yAxisAbsMin", "yAxisBottomMajorTick", "yAxisCurrent", "yAxisExact", "yAxisHistogramHeight", "yAxisHistogramShow", "yAxisMajorTicks", "yAxisMaxStrLength", "yAxisMinorTicks", "yAxisMinorValues", "yAxisShow", "yAxisTickColor", "yAxisTickFormat", "yAxisTickStyle", "yAxisTicks", "yAxisTitle", "yAxisTopBottomTickColor", "yAxisTopMajorTick", "yAxisTransform", "yAxisTransformTicks", "yAxisValues", "yAxisValuesRaw"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Foreground: {
			D: "Foreground properties used in all visualizations :",
			P: ["foreground", "foregroundWindow", "windowBox"]
		},
		"Venn Diagrams": {
			D: "General parameters in Venn diagrams",
			P: ["vennColors", "vennCompartments", "vennGroups", "vennLegendColors"],
			U: {
				Venn: "true"
			}
		},
		"Heatmap Graphs": {
			D: "General parameters for heatmaps",
			P: ["adjustAspectRatioHeatmapIndicator", "heatmapAutoAdjust", "heatmapCellBox", "heatmapCellBoxColor", "heatmapCellBoxColorHighlight", "heatmapCellBoxHighlightWidth", "heatmapCellBoxWidth", "heatmapIndicatorHeight", "heatmapIndicatorHistogram", "heatmapIndicatorHistogramColor", "heatmapIndicatorPosition", "heatmapIndicatorWidth", "heatmapSeparatorWidth", "heatmapSmpSeparateBy", "heatmapVarSeparateBy", "isMultidimensionalData", "isOncoprint", "oncoprintAmplification", "oncoprintCode", "oncoprintDeletion", "showHeatmapIndicator", "smpIndicesStart", "varIndicesStart", "varTitleLabelOverlayPosition"],
			U: {
				Heatmap: "true"
			}
		},
		"Tag Cloud": {
			D: "General parameters used in tag clouds",
			P: ["tagCloudGridPoints", "tagCloudTextEllipticity", "tagCloudTextGridSize", "tagCloudTextRotateRatio", "tagCloudTextWeightFactor"],
			U: {
				Cloud: "true"
			}
		},
		Gradients: {
			D: "Properties used to adjust color gradients in all\n",
			P: ["gradient", "gradientOrientation", "gradientRatio", "gradientType", "useVocabulary"]
		},
		"Remote Procedures": {
			D: "Parameters used when getting data remotely :",
			P: ["remoteAutoPlay", "remoteAutoPlayDelay", "remoteData", "remoteDataIndex", "remoteDirection", "remoteIds", "remoteParamOverride", "remoteParams", "remoteParentId", "remoteService", "remoteServiceType", "remoteUpdate", "remoteUpdateDelay", "remoteUpdating"]
		},
		Animation: {
			D: "Animation parameters :",
			P: ["animationCycles", "animationTime", "animationType", "showAnimation", "showAnimationFontColor", "showAnimationFontSize", "showAnimationFontStyle", "showTransition", "snapshotCopyChangeOnly", "transitionFunction", "transitionStaggering", "transitionStep", "transitionTime"]
		},
		Events: {
			D: "Event parameters :",
			P: ["alignConfiguratorExamples", "broadcast", "broadcastType", "configuratorExamplesSize", "configuratorWidth", "dataFilterWidth", "disableAxisResizer", "disableConfigurator", "disableDataFilters", "disableDataTable", "disableEvents", "disableMenu", "disableToolbar", "disableTouchToolbar", "eventArrowKeys", "eventKeys", "eventPlusMinusKeys", "helpKeyEvents", "infoStartTime", "infoTimeIn", "infoTimeOut", "isLayoutConfigurator", "maintainZoomOnDrag", "maxItemMenuCheckbox", "maxSubMenus", "movable", "resizable", "resizableX", "resizableY", "resizeHeightOnLayout", "resizeWidthOnLayout", "showAdvancedConfiguration", "showConfiguratorExamplesOnSelect", "showFadeResizeMoveAnimation"]
		},
		"R-Axis": {
			D: "R axis parameters",
			P: ["rAxisAbsMax", "rAxisAbsMin", "rAxisLabelOrientation", "rAxisMajorTicks", "rAxisMaxStrLength", "rAxisMinorTicks", "rAxisMinorValues", "rAxisPercentShow", "rAxisShow", "rAxisTickColor", "rAxisTickFormat", "rAxisTicks", "rAxisValues", "rAxisValuesRaw"],
			U: {
				Circular: "true"
			}
		},
		Images: {
			D: "General parameters with images :",
			P: ["imageDir", "loadingImage"]
		},
		Videos: {
			D: "Video properties used in all visualizations",
			P: ["videoAutoplay", "videoClassName", "videoColor", "videoControls", "videoCurrentTime", "videoData", "videoGrid", "videoGridStep", "videoLoop", "videoPlaybackRate", "videoPoster", "videoPreload"],
			U: {
				Video: "true"
			}
		},
		"Genome Browser": {
			D: "General parameters used in genome browser",
			P: ["featureConfigurableProperties", "featureCoordinateHeight", "featureCoordinateShow", "featureDirColor", "featureFillColor", "featureHeightDefault", "featureNameFontColor", "featureNameFontSize", "featureNameFontStyle", "featureQualityHeight", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseHeight", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTraceHeight", "featureTraceTrim", "featureTracesShow", "featureTranslateHeight", "featureTranslateShow", "featureTypeDefault", "featureWidthDefault", "filterFeatureBy", "genomeResolution", "genomeTicks", "maxFeatureStringLen", "periodTicksLabels", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceFontSize", "sequenceFontStyle", "sequenceGAPColor", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackConfigurableProperties", "trackDirColor", "trackFillColor", "trackNameFontColor", "trackNameFontSize", "trackNameFontStyle", "wireColor"],
			U: {
				Genome: "true"
			}
		},
		Random: {
			D: "Properties used to generate random data sets :",
			P: ["pseudoRandom", "randomData", "randomDataMean", "randomDataSampleAnnotationRatio", "randomDataSampleAnnotations", "randomDataSamples", "randomDataSigma", "randomDataSymmetrical", "randomDataUniform", "randomDataVariableAnnotationRatio", "randomDataVariableAnnotations", "randomDataVariables", "randomMissingDataPercentage", "randomNetworkNodeEdgesMax", "randomNetworkNodes", "randomNetworkReduce", "randomSeed"]
		},
		Trees: {
			D: "General parameters in trees",
			P: ["treeCircular", "treeCoordinateColor", "treeInverted", "treeLinkColor", "treeLinkWidth", "treeNodeId", "treeNodeSize", "treeVarIndex"],
			U: {
				Tree: "true"
			}
		},
		"Data Table/Filter": {
			D: "Parameters associated with data table and data filter :\n",
			P: ["edgesProperties", "featuresProperties", "nodesProperties", "skipConfigurableProperties"]
		},
		Samples: {
			D: "Properties associated with samples",
			P: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelDescription", "smpLabelFontColor", "smpLabelFontSize", "smpLabelFontStyle", "smpLabelInterval", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleFontColor", "smpTitleFontSize", "smpTitleFontStyle", "smpTitleScaleFontFactor"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		Maps: {
			D: "Map properties used in all visualizations",
			P: ["isMap", "leafletCSS", "leafletConfig", "leafletId", "leafletInit", "leafletInitString", "leafletJS", "leafletLayer", "topoJSON"],
			U: {
				Map: "true"
			}
		},
		Snapshots: {
			D: "Paremeters used in snapshots",
			P: ["isAnimation", "snapshots"],
			U: {
				Network: "true"
			}
		},
		"General Attributes": {
			D: "Properties related to Shapes, Sizes, Images and Time :",
			P: ["images", "shapes", "sizes", "timeFormat"]
		},
		"Treemap Graphs": {
			D: "General parameters for treemaps",
			P: ["treemapBorderColor", "treemapBorderWidth"],
			U: {
				Treemap: "true"
			}
		},
		DOE: {
			D: "Parameters used to create pie and histograms in general data :",
			P: ["includeDOE", "maxDOENumber", "showDOEData"]
		},
		"Z-Axis": {
			D: "Z axes parameters",
			P: ["setMaxZ", "setMinZ", "zAxis", "zAxisAbsMax", "zAxisAbsMin", "zAxisCurrent", "zAxisExact", "zAxisMaxStrLength", "zAxisMinorValues", "zAxisShow", "zAxisTickColor", "zAxisTickFormat", "zAxisTickStyle", "zAxisTicks", "zAxisTitle", "zAxisValues", "zAxisValuesRaw"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true"
			}
		},
		Decorations: {
			D: "Additional elements added to graphs to increase data understanding",
			P: ["decorationFontSize", "decorationFontStyle", "decorationScaleFontFactor", "decorations", "decorationsBackgroundColor", "decorationsBox", "decorationsBoxColor", "decorationsColor", "decorationsColors", "decorationsHeight", "decorationsPosition", "decorationsProperties", "decorationsType", "decorationsWidth", "showDecorations", "showDecorationsKaplanMeierConfidence", "showDecorationsLegend", "showDecorationsRegressionConfidence"],
			U: {
				Network: "true",
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Loess: {
			D: "Parameters used to create smooth lines in 2d scatter plots :",
			P: ["loessAccuracy", "loessBandwidth", "loessColor", "loessDrawOptimizer", "loessIteration", "showLoessFit"]
		},
		"Aspect Ratio": {
			D: "Properties used to adjust the aspect ratio in one\n",
			P: ["adjustAspectRatio", "adjustAspectRatioMax", "adjustAspectRatioXTries", "adjustAspectRatioYTries", "percentAspectRatioPlotArea"]
		},
		Overlays: {
			D: "Colored boxes to help in the visualization of samples and variables",
			P: ["maxOverlayStringLen", "overlayFontColor", "overlayFontSize", "overlayFontStyle", "overlayScaleFontFactor", "overlaysLegendPosition", "overlaysThickness", "showLevelOverlays", "showOverlays", "showSmpOverlaysLegend", "showVarOverlaysLegend", "smpOverlayProperties", "smpOverlays", "varOverlayProperties", "varOverlays"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		Bins: {
			D: "Function to bin samples and variables",
			P: ["binConfigurations"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		Contours: {
			D: "Parameters used to create contours in one and two dimensional plots :",
			P: ["contourType", "contourXBinSize", "contourYBinSize", "contourZBinSize"]
		},
		Margins: {
			D: "Margin properties used in most visualizations :",
			P: ["margin", "marginBottom", "marginLeft", "marginRight", "marginTop"]
		},
		"Citations or References": {
			D: "Properties associated with citations or references of the plot :",
			P: ["citation", "citationColor", "citationFontSize", "citationFontStyle", "citationScaleFontFactor"]
		},
		Text: {
			D: "Properties associated with text attributes :",
			P: ["align", "autoScaleFont", "baseline", "fontName", "fontScaleFontFactor", "fontSize", "fontStyle", "maxTextSize", "minTextSize", "scaleTextConstantAdd", "scaleTextConstantMult"]
		},
		"Plot area": {
			D: "General parameters for the plotting area in one dimensional plots",
			P: ["blockContrast", "guides", "guidesColor", "guidesWidth", "is3DPlot", "jitter", "jitterColumns", "objectBorderColor", "plotByVariable", "showDataValues"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correlation: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		Variables: {
			D: "Properties associated with variables",
			P: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelDescription", "varLabelFontColor", "varLabelFontSize", "varLabelFontStyle", "varLabelInterval", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleFontColor", "varTitleFontSize", "varTitleFontStyle", "varTitleScaleFontFactor"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		"Data Point Attributes": {
			D: "General attributes for data points in scatter and one dimensional plots",
			P: ["colorBy", "colorByShowLegend", "colorKey", "connectBy", "connectByColor", "connectByData", "connectByWidth", "ellipseBy", "motionBy", "motionControlHeight", "motionTrails", "outlineBy", "outlineByData", "outlineByShowLegend", "patternBy", "patternByData", "patternByShowLegend", "patternKey", "shapeBy", "shapeByData", "shapeByShape", "shapeByShowLegend", "shapeKey", "sizeBy", "sizeByContinuous", "sizeByData", "sizeByShowLegend", "sizeKey", "treemapBy"],
			U: {
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				ScatterBubble2D: "true",
				Scatter3D: "true",
				ParallelCoordinates: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Sankey: "true",
				Heatmap: "true"
			}
		},
		"Scatter Plot Matrix": {
			D: "Parameters used to create a matrix of 2d scatter plots",
			P: ["scatterPlotMatrix", "scatterPlotMatrixType"],
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Dendrograms: {
			D: "General parameters in dendrograms",
			P: ["colorSmpDendrogramBy", "colorVarDendrogramBy", "dendrogramColor", "dendrogramHang", "dendrogramHeight", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramNewick", "smpDendrogramPosition", "varDendrogramNewick", "varDendrogramPosition"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		"Area Graphs": {
			D: "General parameters in area graphs",
			P: ["areaType"],
			U: {
				Area: "true",
				AreaLine: "true"
			}
		},
		"Candlestick Plots": {
			D: "General parameters in candlestick plots",
			P: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
			U: {
				Candlestick: "true"
			}
		},
		"Pie Charts": {
			D: "General parameters in pie charts",
			P: ["maxPieSectors", "pieColors", "pieInnerRadius", "pieLabelType", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
			U: {
				Pie: "true"
			}
		},
		General: {
			D: "General properties used in most visualizations :",
			P: ["canvasBox", "canvasBoxColor", "functions", "graphOrientation", "graphType", "higlightGreyOut", "higlightGreyOutTransparency", "invertGraph", "isR", "isReproducibleResearch", "loadImagesTimeOut", "plotBox", "plotBoxColor", "printType", "reproduceTime", "theme", "thumbnail", "transparency"]
		},
		Axis: {
			D: "General axis parameters",
			P: ["axisAlgorithm", "axisExtension", "axisMinMaxTickTickWidth", "axisTickColor", "axisTickFontSize", "axisTickFontStyle", "axisTickScaleFontFactor", "axisTickWidth", "axisTicksAutoAdjust", "axisTitleColor", "axisTitleFontSize", "axisTitleFontStyle", "axisTitleScaleFontFactor", "axisWilkinsonLoose", "setMax", "setMin"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				"*Bar": "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		"Bar Graphs": {
			D: "General parameters in bar graphs",
			P: ["barLollipopFactor", "barType"],
			U: {
				Bar: "true",
				BarLine: "true"
			}
		},
		"Line Graphs": {
			D: "General parameters in line graphs",
			P: ["coordinateLineColor", "hullScale", "lineDecoration", "lineErrorType", "lineThickness", "lineType", "parallelCoordinates", "tension", "tensionSegments"],
			U: {
				ParallelCoordinates: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		Colors: {
			D: "Properties to adjust Colors :",
			P: ["colorHSV", "colorRGB", "colorScheme", "colorSpectrum", "colorSpectrumBreaks", "colorSpectrumNumber", "colorSpectrumZeroValue", "colors", "evenColor", "oddColor"]
		},
		"X-Axis2": {
			D: "X2 Axis parameters",
			P: ["setMaxX2", "setMinX2", "xAxis2", "xAxis2AbsMax", "xAxis2MaxStrLength", "xAxis2MinorValues", "xAxis2Show", "xAxis2TickFormat", "xAxis2Ticks", "xAxis2Title", "xAxis2Values", "xAxis2ValuesRaw"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		"Combination Plots": {
			D: "Parameters used in complex plots :",
			P: ["layout", "layoutAdjust", "layoutAxis", "layoutBoxLabelColors", "layoutBoxShow", "layoutCanvasCompartments", "layoutCollapse", "layoutComb", "layoutCurrent", "layoutHeight", "layoutRemoveEmpty", "layoutTopology", "layoutWidth", "offsetX", "offsetY", "scaleX", "scaleY", "translateX", "translateY", "weight"]
		},
		"Network Graphs": {
			D: "General parameters used in networks",
			P: ["approximateNodePositions", "attractiveForceFunction", "autoHideOnDecorationsCenter", "calculateLayout", "calculateNetworkCommunities", "colorEdgeBy", "colorNodeBy3", "edgeConfigurableProperties", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "initialTemperature", "is3DNetwork", "isCoordinateNodeColorsNetworkConvexHull", "isNetworkCommunities", "isNetworkConvexHull", "isSelectNodes", "labelNodePosition", "layoutTime", "moveParentsWithChildren", "network2DRotate", "networkCommunities", "networkConvexHulls", "networkDepth", "networkDivisions", "networkForceConstant", "networkFreeze", "networkFreezeOnLoad", "networkLayoutType", "networkNodeMinDistance", "networkNodesOnTop", "networkRoot", "networkStack", "networkStackIndex", "networkStackStates", "nodeConfigurableProperties", "nodeFontColor", "nodeFontSize", "nodeFontStyle", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "overrideAnchorNodes", "overrideEventlessNodes", "preScaleNetwork", "repulsiveForceFunction", "selectNode", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkDecorationsLegend", "showNetworkEdgesLegend", "showNetworkNodesLegend", "showNetworkRadialLayout", "showNetworkTextLegend", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy", "skipClick", "subNetworks", "temperature"],
			U: {
				Network: "true"
			}
		},
		"Circular Graphs": {
			D: "General parameters in circular graphs",
			P: ["arcSegmentsSeparation", "bubbleColor", "chordColorOrigin", "chordThickness", "circularArc", "circularCenterProportion", "circularConnectionsTransparency", "circularLetterSeparationFactor", "circularRotate", "circularType", "connections", "rAxis", "rAxisZero", "ringSeparation", "ringsType", "ringsWeight", "showCircularConnections", "showRingLegend", "smpLabelOrientation"],
			U: {
				Circular: "true"
			}
		},
		Hierarchy: {
			D: "General parameters to build hierarchy for circular (sunburst) trees and bubbles graphs",
			P: ["hierarchy", "hierarchyVar", "hierarchyVarIndex"],
			U: {
				Tree: "true",
				Bubble: "true",
				Circular: "true"
			}
		},
		"Zooming and Panning": {
			D: "Parameters associated with zooming and panning\n",
			P: ["panningGlobalX", "panningGlobalY", "panningStep", "panningX", "panningY", "zoom", "zoomGlobal", "zoomSamplesDisable", "zoomStep", "zoomVariablesDisable"]
		},
		Lines: {
			D: "Properties to adjust Lines :",
			P: ["arrowPointSize", "capType", "dashLength", "dotLength", "joinType", "lineWidthEvent", "lines", "outlineWidth"]
		},
		Debug: {
			D: "Debugging parameters :",
			P: ["codeType", "debug", "errors", "showCode", "showVersion"]
		},
		Legends: {
			D: "Legends for variables and samples",
			P: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendColumns", "legendFontSize", "legendFontStyle", "legendInside", "legendOrder", "legendPosition", "legendScaleFontFactor", "showLegend"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				"*Bar": "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		Patterns: {
			D: "Properties related to Patterns :",
			P: ["patterns"]
		},
		"Data Table": {
			D: "Parameters associated with the data table :",
			P: ["axisTickFont", "axisTitleFont", "citationFont", "colWidth", "dataTableColumnWidth", "dataTableTransposed", "decorationFont", "featureNameFont", "font", "freezeColLeft", "freezeColRight", "freezeRowBottom", "freezeRowTop", "legendFont", "maxCols", "maxRows", "networkShowDataTable", "nodeFont", "overlayFont", "refresehDataTableOnDraw", "rowHeight", "sequenceFont", "showAnimationFont", "showDataTable", "showDataTableOnSelect", "smpLabelFont", "smpTitleFont", "startCol", "startRow", "subtitleFont", "titleFont", "trackNameFont", "varLabelFont", "varTitleFont"]
		},
		"Titles and Subtitles": {
			D: "Properties associated with titles and subtitles :",
			P: ["subtitle", "subtitleAlign", "subtitleColor", "subtitleFontSize", "subtitleFontStyle", "subtitleScaleFontFactor", "title", "titleAlign", "titleColor", "titleFontSize", "titleFontStyle", "titleScaleFontFactor"]
		},
		"Scatter Plots": {
			D: "General parameters in scatter plots",
			P: ["functionIntervals", "isSelectDataPoints", "scatterAxesEqual", "scatterOutlineThreshold", "scatterType", "selectDataMode", "selectDataModeDescription", "selectDataPoint"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Background: {
			D: "Background properties used in all visualizations :",
			P: ["background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "backgroundVideo", "backgroundWindow", "backgroundWindowGradient1Color", "backgroundWindowGradient2Color", "backgroundWindowGradientOrientation"]
		},
		"3D Attributes": {
			D: "General parameters in 3d scatter plots and networks",
			P: ["bar3DInverseWeight", "invMagnificationFactor", "perspectiveFactor", "rotationDelay", "rotationSensitivity", "rotationStep", "show3DGrid", "x3DRatio", "xRotate", "y3DRatio", "yRotate", "z3DRatio", "zRotate"],
			U: {
				Network: "true",
				Scatter3D: "true",
				Bar: "true"
			}
		},
		"Data Filters": {
			D: "Parameters associated with filtering :",
			P: ["filterSkipNullKeys", "filterSkipNullValues", "filterType"]
		},
		"Correlation Graphs": {
			D: "General parameters for correlation",
			P: ["correlationAnchorLegend", "correlationAnchorLegendAlignWidth", "correlationAxis", "correlationLabelInterval"],
			U: {
				Correlation: "true"
			}
		},
		Functions: {
			D: "Functions exposed in the configurator :",
			P: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createContour", "createHistogram", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "drawArea", "groupSamples", "hideCodeDiv", "hideInfoDiv", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeContour", "removeHistogram", "reset", "segregateSamples", "segregateVariables", "showCodeDiv", "showInfoDiv", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples", "updateCodeDiv"]
		},
		"X-Axis": {
			D: "X axis parameters",
			P: ["setMaxX", "setMinX", "this", "timeTicksFirst", "timeValueIndices", "timeValues", "xAxis", "xAxisAbsMax", "xAxisAbsMin", "xAxisCurrent", "xAxisExact", "xAxisHistogramHeight", "xAxisHistogramShow", "xAxisLeftMajorTick", "xAxisLeftRightTickColor", "xAxisMajorTicks", "xAxisMaxStrLength", "xAxisMinorTicks", "xAxisMinorValues", "xAxisRightMajorTick", "xAxisS2Show", "xAxisShow", "xAxisTickColor", "xAxisTickFormat", "xAxisTickStyle", "xAxisTicks", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks", "xAxisValues", "xAxisValuesRaw"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				StackedLine: "true",
				Scatter2D: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		},
		R: {
			D: "Parameters associated with R :",
			P: ["RdatastesURL", "loadRDatasets"]
		},
		Data: {
			D: "Data related parameters",
			P: ["erroBarsWidth", "errorBarsType", "errorEllipseConfidence", "groupingFactors", "isBoxPlotCalc", "isGroupedData", "isLogData", "isMarketDataFormated", "isMarketSwitched", "isTransformedData", "missingDataColor", "missingDataValue", "ratioGroupReference", "ratioLevelReference", "ratioReference", "ratioSampleReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "smpSort", "sortCaseSensitive", "sortDir", "standardDeviationType", "summaryType", "tmpAsciiArray", "transformAxis", "transformBase", "transformCeilValue", "transformFloorValue", "transformType", "transformedData", "varSort"],
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				ParallelCoordinates: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Sankey: "true",
				Stacked: "true"
			}
		}
	},
	N: {
		hideLabel: {
			M: "Network",
			T: "boolean",
			C: "Flag to hide the label node"
		},
		zIndex: {
			M: "Network",
			T: "integer",
			C: "Css property for the imagePath"
		},
		x: {
			M: "Network",
			T: "float",
			C: "X coordinate"
		},
		outline: {
			M: "Network",
			T: "color",
			C: "Color for the outline of the node"
		},
		imagePath: {
			M: "Network",
			T: "url",
			C: "Url for the node image"
		},
		parentNode: {
			M: "Network",
			T: "string",
			C: "Id of parent node"
		},
		y: {
			M: "Network",
			T: "float",
			C: "Y coordinate"
		},
		anchor: {
			M: "Network",
			T: "boolean",
			C: "Flag make the node transparent"
		},
		color: {
			M: "Network",
			T: "color",
			C: "Color for the node"
		},
		outlineWidth: {
			M: "Network",
			T: "integer",
			C: "Pixels used to raw the outline of the node"
		},
		eventless: {
			M: "Network",
			T: "boolean",
			C: "Flag to disable all events in the node"
		},
		pattern: {
			O: "open, closed",
			M: "Network",
			T: "option",
			C: "Whether to draw a solid shape or just an outline"
		},
		rotate: {
			M: "Network",
			T: "integer",
			C: "Number of degrees to rotate the shape"
		},
		hide: {
			M: "Network",
			T: "boolean",
			C: "Flag to hide the node"
		},
		shape: {
			M: "Network",
			T: "string",
			C: "Shape for the node. One of the ones defined in shapes"
		},
		z: {
			M: "Network",
			T: "float",
			C: "Z coordinate"
		}
	},
	P: {
		yAxisTransform: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "ceil", "floor"],
			M: "Y-Axis",
			T: "option",
			C: "Transformation for the values in the Y axis.",
			D: "false"
		},
		chordThickness: {
			M: "Circular Graphs",
			T: "integer",
			C: "Relative length in pixels for the thickness of the radial chords in circular graphs  @exs {}",
			D: "28"
		},
		vennCompartments: {
			Z: "true",
			M: "Venn Diagrams",
			T: "array",
			C: "Name for the compartments in the the Venn diagrams"
		},
		setMaxX: {
			Z: "true",
			H: ['{"setMaxX":200}', '{"setMaxX":50}', '{"setMaxX":null}'],
			M: "X-Axis",
			T: "float",
			C: "Maximum value to set the data in the X axis",
			D: "null"
		},
		adjustAspectRatioYTries: {
			Z: "true",
			M: "Aspect Ratio",
			T: "integer",
			C: "Counter set when trying to automatically adjust the vertical size of the canvas when adjustAspectRatio is true"
		},
		sequenceLColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the leucines in the genome browser",
			D: "rgb(0,103,0)"
		},
		pieSegmentLabels: {
			H: ["{*}"],
			O: ["inside", "outside"],
			M: "Pie Charts",
			T: "option",
			C: "Location for the values in the pie charts",
			D: "inside"
		},
		shapeBy: {
			S: ["shapeByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","shapeBy":"Annt1"}', '{"graphType":"Scatter3D","shapeBy":"Sample4"}', '{"graphType":"Dotplot","shapeBy":"Factor1"}', '{"graphType":"Dotplot","shapeBy":"Annt1"}', '{"graphType":"Dotplot","shapeBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to shape the variables. When shapeByData is specified shapeBy is used for the title in the legend."
		},
		yAxis2Title: {
			H: ['{"graphType":"Scatter2D","yAxisTitle":"Y-axistitle"}', '{"graphType":"Correlation","yAxisTitle":"Correlation Title"}'],
			M: "Y-Axis",
			T: "string",
			C: "Title for the Y axis in Scatter plots and in Correlation graphs.",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		sequenceFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the sequence in the genome browser"
		},
		networkStack: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array to keep state of the network after a drag or move"
		},
		desegregateSamples: {
			S: ["segregateSamples"],
			M: "Functions",
			T: "void",
			C: "Desegreagate samples previously segregated based on a sample category (data.x object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		is3DNetwork: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create or not a 3D network",
			D: "false"
		},
		variablesClustered: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to cluster variables",
			D: "false"
		},
		sankeySource: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			O: ["false"],
			M: "Sankey Diagrams",
			T: "option",
			C: "Name of a sample annotation to use as source in the sankey diagrams",
			D: "false",
			X: "getXData"
		},
		backgroundWindow: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"window"}'],
			M: "Background",
			T: "color",
			C: "Specifies the background color for the canvas when the background type is of a type 'window'.",
			D: "rgb(244,244,244)"
		},
		varDendrogramPosition: {
			H: ['{*,"data":"Generic","graphType":"Heatmap","showVarDendrogram":true}'],
			O: ["top", "bottom"],
			M: "Dendrograms",
			T: "option",
			C: "Position for the variable dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
			D: "top"
		},
		calculateLayout: {
			H: ['{"data":"NetworkBasic","calculateLayout":false}', '{"data":"LesMiserables","calculateLayout":true,"colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to force or not to calculate the network layout.",
			D: "true"
		},
		varLabelInterval: {
			H: ["{*}"],
			M: "Variables",
			T: "integer",
			C: "Interval for the variable labels in heatmaps",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		shapes: {
			H: ['{"data":"Shapes","calculateLayout":false,"graphType":"Network"}'],
			O: ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"],
			M: "General Attributes",
			T: "array",
			C: "Shapes used in network graphs"
		},
		yAxisMinorValues: {
			M: "Y-Axis",
			T: "array",
			C: "Values for the minor ticks in the Y axis",
			D: "[]"
		},
		transitionStaggering: {
			H: ["{*}"],
			M: "Animation",
			T: "integer",
			C: "Steps for transitionioning data objects",
			D: "10"
		},
		sequenceTColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the thymidines and threonines in the genome browser",
			D: "rgb(255,0,0)"
		},
		movable: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable moving the canvas by dragging the mouse from the move image in the toolbar",
			D: "true"
		},
		nodeFontColor: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "color",
			C: "Color for the network text",
			D: "rgb(0,0,0)"
		},
		networkNodeMinDistance: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Minimum distance between nodes in forceDirected and organic layouts",
			D: "4"
		},
		lineThickness: {
			S: ["outlineWidth"],
			H: ['{*,"graphType":"Line"}'],
			M: "Line Graphs",
			T: "float",
			C: "Thickness in pixels for the lines in the line plots.",
			D: "1"
		},
		title: {
			S: ["titleHeight", "titleColor"],
			H: ['{"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "string",
			C: "Title of the graph.",
			D: "false"
		},
		pieInnerRadius: {
			H: ['{"data":"Generic","pieInnerRadius":0.2}', '{"data":"Generic","pieInnerRadius":0.35}', '{"data":"Generic","pieInnerRadius":0.5}'],
			M: "Pie Charts",
			T: "float",
			C: "Percentage of the radius in the pies to remove to make a donut. It must be a number between 0 to 1",
			D: "0"
		},
		zAxisMaxStrLength: {
			Z: "true",
			M: "Z-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the Z axis"
		},
		remoteParamOverride: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to override parameters to maintain the state of the graphs when using remote services",
			D: "true"
		},
		yAxisExact: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data",
			D: "false"
		},
		rAxisTickFormat: {
			H: ['{*,"data":"Circular2","rAxisTickFormat":"%.4f cxs"}'],
			M: "R-Axis",
			T: "string",
			C: "Format for the tick values in the R axis",
			D: "false"
		},
		showShadow: {
			S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
			H: ["{*}"],
			M: "Shadows",
			T: "boolean",
			C: "Flag used to add shadows to all graph objects in the canvas. It will be forced to false if the browser is IE.",
			D: "false"
		},
		colorScheme: {
			S: ["colors"],
			O: ["YlGn", "YlGnBu", "GnBu", "BuGn", "PuBuGn", "PuBu", "BuPu", "RdPu", "PuRd", "OrRd", "YlOrRd", "YlOrBr", "Purples", "Blues", "Greens", "Oranges", "Reds", "Greys", "PuOr", "BrBG", "PRGn", "PiYG", "RdBu", "RdGy", "RdYlBu", "Spectral", "RdYlGn", "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3", "Default", "Basic", "Light", "Favorite", "Pastel", "Balanced", "Rpalette", "RlatticeBackground", "RlatticeShingle", "RlatticeLine", "RlatticePolygon", "Bootstrap", "Economist", "EconomistBG", "Excel", "Excel2", "Excel3", "GGPlot", "Solarized", "SolarizedBase", "PaulTol", "ColorBlind", "Tableau", "TableauGrey", "TableauColorBlind", "TableauTrafficLight", "TableauPurpleGrey", "TableauBlueRed", "TableauGreenOrange", "TableauCyclic", "TableauPairSequential", "TableauTripleDiverging", "WallStreetJournal", "WallStreetJournal2", "WallStreetJournal3", "WallStreetJournalRedGreen", "WallStreetJournalBlackGreen", "WallStreetJournalDemRep", "Stata", "Stata2", "Stata3", "StataMono", "BlackAndWhite", "CanvasXpress", "CanvasXpressT"],
			T: "option",
			X: "getColorSchemes",
			H: ['{*,"data":"Random:8:1:0:0:1","graphType":"Pie"}'],
			M: "Colors",
			D: "User",
			C: "Color schemes can be user defined which will take the colors in the color property or one provided in canvasXpress. The order of the colors will be used to sequentially select when a different color is needed in a particular visualization."
		},
		connectByColor: {
			H: ['{"graphType":"Scatter3D","connectBy":"Annt1"}', '{"graphType":"Scatter3D"}'],
			M: "Data Point Attributes",
			T: "color",
			C: "The color for the connectBy lines",
			D: "rgb(204,204,204)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		showNetworkDecorationsLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		zAxisTickFormat: {
			H: ['{"graphType":"Scatter3D","zAxisTickFormat":"%.2f cxs"}'],
			M: "Z-Axis",
			T: "string",
			C: "Format for the tick values in the Z axis",
			D: "false"
		},
		xAxisMinorValues: {
			M: "X-Axis",
			T: "array",
			C: "Values for the minor ticks in the X axis",
			D: "[]"
		},
		rAxisMinorValues: {
			M: "R-Axis",
			T: "array",
			C: "Values for the minor ticks in the R axis",
			D: "[]"
		},
		isMarketDataFormated: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data has been formated to display Candlestick."
		},
		segregateSamples: {
			S: ["desegregateSamples"],
			M: "Functions",
			T: "option",
			C: "Segregate samples based on a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		ratioSampleReference: {
			O: ["false"],
			M: "Data",
			T: "option",
			C: "Name of the sample used in ratio transformation.",
			D: "false",
			X: "getSamplesAsArray"
		},
		ringsWeight: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"ringsWeight":[0.5,0.25,0.25]}'],
			M: "Circular Graphs",
			T: "array",
			C: "Array containing the dimensions for each ring in the circular plots",
			D: "[]"
		},
		isTransformedData: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is transformed."
		},
		axisMinMaxTickTickWidth: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Width for the axis min and max ticks in one and two dimensional plots",
			D: "1"
		},
		background: {
			S: ["backgroundType"],
			H: ["{*}"],
			M: "Background",
			T: "color",
			C: "Specifies the background color for the canvas.",
			D: "rgb(255,255,255)"
		},
		colorSpectrumBreaks: {
			S: ["colorSpectrum"],
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "array",
			C: "An array with cumulative fractions in ascending order for the color spectrum to create discontinuous spectra. It must have the same length of the colorSpectrum array for example [0, 0.3, 1]",
			D: "[]"
		},
		removeContour: {
			S: ["contourXBinSize", "contourYBinSize", "contourZBinSize", "contourType"],
			M: "Functions",
			T: "void",
			C: "Remove contour",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		resizerTransparency: {
			M: "Axis Resizer",
			T: "boolean",
			C: "Flag to make the axis resizers transparent",
			D: "true"
		},
		hideUnhideVars: {
			M: "Functions",
			T: "array",
			C: "Hide or unhide variables. It works like a switch",
			X: "getVariablesAsArray",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		showTransition: {
			H: ["{*}"],
			M: "Animation",
			T: "boolean",
			C: "Flag to show or not transitions for the graphs",
			D: "false"
		},
		periodTicksLabels: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Number of ticks to skip between values in the genome browser",
			D: "5"
		},
		subtitleAlign: {
			O: ["left", "center", "right"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Subtitle alignment",
			D: "center"
		},
		colWidth: {
			M: "Data Table",
			T: "integer",
			C: "Mumber of pixels for the width of cells in the data table",
			D: "100"
		},
		showAnimationFontStyle: {
			O: ["", "bold", "italic", "bold italic"],
			M: "Animation",
			T: "option",
			C: "Font style for the animation.",
			D: ""
		},
		varLabelFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the variable labels in one dimensional plots"
		},
		scaleY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Scale factor for the Y axis"
		},
		startCol: {
			Z: "true",
			M: "Data Table",
			T: "integer",
			C: "Starting column in the data table"
		},
		xAxisTransform: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "ceil", "floor"],
			M: "X-Axis",
			T: "option",
			C: "Tranformation for the values in the X axis.",
			D: "false",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		nodesProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the nodes in the Network graph to include in the Data table and the data filter",
			D: "[]"
		},
		ratioReference: {
			H: ["{*}"],
			M: "Data",
			T: "integer",
			C: "Default index of sample used in ratio transformation.",
			D: "0"
		},
		citationColor: {
			S: ["citation"],
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "color",
			C: "Color for a reference citation of the graph",
			D: "rgb(0,0,0)"
		},
		showDecorationsKaplanMeierConfidence: {
			S: ["decorations"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeier","showLegend":false,"title":"Kaplan-Meier Plot","functions":["addKaplanMeierCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeierCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the confidence intervals in the Kaplan-Meier plots",
			D: "false"
		},
		rAxisZero: {
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to force the rAxis to start from zero otherwise it starts from the minimum value",
			D: "false"
		},
		decorationsPosition: {
			H: ['{*,"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["top","right"]}}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["bottom","left"]}}'],
			O: ["rightTop", "right", "rightBottom", "bottom", "leftBottom", "left", "leftTop", "top"],
			M: "Decorations",
			T: "option",
			C: "Position for the decorations in one dimensional plots, scatter plots and network graphs. If legendInside is true the all the options apply but if legendInside is false only right and bottom are valid options",
			D: "bottom"
		},
		transformedData: {
			H: ["{*}"],
			S: ["transformType", "transformAxis"],
			M: "Data",
			T: "boolean",
			C: "Flag to transform data as a parameter. Works with transformType and transformAxis",
			D: "false"
		},
		eventPlusMinusKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable plus / minus key binding events.",
			D: "false"
		},
		samplesKmeaned: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to k-mean samples",
			D: "false"
		},
		resizerBackgroundColorCurrent: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up the current area selected in the axes in the canvas",
			D: "rgb(237,247,255)"
		},
		correlationAnchorLegend: {
			H: ["{*}"],
			M: "Correlation Graphs",
			T: "boolean",
			C: "Flag to show a region above the correlation plot that anchror a sample/variable to a position",
			D: "false"
		},
		leafletLayer: {
			M: "Maps",
			T: "boolean",
			C: "Flag to indicate to add a Leaflet Layer from OpenStreet",
			D: "true"
		},
		connectByWidth: {
			H: ['{"graphType":"Scatter3D","connectBy":"Annt1"}', '{"graphType":"Scatter3D"}'],
			M: "Data Point Attributes",
			T: "integer",
			C: "Width for the line of the connectBy line",
			D: "2"
		},
		axisTitleColor: {
			H: ["{*}"],
			M: "Axis",
			T: "color",
			C: "Color for the axis title in one and two dimensional plots",
			D: "rgb(0,0,0)"
		},
		varTitleFontColor: {
			H: ['{*,"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "color",
			C: "Font color for the variable titles in one dimensional plots",
			D: "rgb(0,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		circularConnectionsTransparency: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "float",
			C: "Percentage of transparency applied to the connections in the circular graphs",
			D: "0.5"
		},
		guidesWidth: {
			H: ['{*,"graphType":"Heatmap","guides":true}'],
			M: "Plot area",
			T: "float",
			C: "The width for the thin line that appears in the middle of the variables and / or samples in one dimensional graphs and multidimensional heatmaps just for aesthetics.",
			D: "0.3"
		},
		loadImagesTimeOut: {
			M: "General",
			T: "integer",
			C: "Specifies the number of milliseconds to wait trying to load images before attempting to plot the data. For developers only.",
			D: "100"
		},
		xAxis2AbsMax: {
			Z: "true",
			M: "X-Axis2",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the 2nd X axis"
		},
		panningGlobalX: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative number of unit to pan the network in the X dimension"
		},
		xAxis: {
			H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "array",
			C: "Name of the samples or sample groups to be displayed in the X axis if scatter plot or variables if one dimensional graphs",
			D: "[]",
			X: "getSamplesVariablesAsArray"
		},
		featureNameFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the features in the genome browser"
		},
		offsetY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Additional amount to move for the Y axis."
		},
		selectNode: {
			Z: "true",
			M: "Network Graphs",
			T: "object",
			C: "Name of nodes (in the data object) to select.",
			D: "{}"
		},
		featureTraceHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the trace height",
			D: "40"
		},
		featureQualityShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show quality",
			D: "true"
		},
		smpLabelFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Samples",
			T: "option",
			C: "Font style for the sample label.",
			D: ""
		},
		lineDecoration: {
			H: ['{*,"graphType":"Line"}'],
			O: ["false", "dot", "symbol"],
			M: "Line Graphs",
			T: "option",
			C: "Lines decorations in the line graphs",
			D: "symbol"
		},
		kmeansVariables: {
			S: ["kmeansVarClusters", "maxIterations"],
			M: "Functions",
			T: "void",
			C: "Cluster variables using kmeans",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		clusterAxis: {
			S: ["distance", "linkage", "imputeMethod", "clusterSamples", "clusterVariables"],
			O: ["samples", "variables"],
			M: "Clustering",
			T: "option",
			C: "Default axis to use when clustering data.",
			D: "samples"
		},
		xAxisValues: {
			M: "X-Axis",
			T: "array",
			C: "Values for the ticks in the X axis",
			D: "[]"
		},
		varOverlayProperties: {
			M: "Overlays",
			T: "object",
			C: "Object to assign properties to the variable overlays. The key should be an annotation in the 'data.z' object and the value should be either type which could be either one of the one dimensional graph types or increasing, or decreasing for continuous annotations",
			D: "{}"
		},
		thumbnail: {
			M: "General",
			T: "string",
			C: "Name for the thumbnail",
			D: "false"
		},
		higlightGreyOut: {
			S: ["higlightGreyOutTransparency"],
			M: "General",
			T: "boolean",
			C: "Flag to add grey out when highlighting with mouse over",
			D: "false"
		},
		rotationDelay: {
			M: "3D Attributes",
			T: "integer",
			C: "Time in milliseconds to wait between rendering the plot when dragging the mouse.",
			D: "100"
		},
		varLabelScaleFontFactor: {
			H: ["{*}"],
			M: "Variables",
			T: "float",
			C: "Scaling factor used to increse or decrease variable font size in the canvas.",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		maxVarStringLen: {
			H: ['{"maxVarStringLen":50}', '{"maxVarStringLen":5}'],
			M: "Variables",
			T: "integer",
			C: "Maximum length in characters a variable label or description can have so anything above is truncated.",
			D: "30",
			U: {
				Heatmap: "true"
			}
		},
		varLabelRotate: {
			H: ['{"varLabelRotate":0}', '{"varLabelRotate":45}', '{"varLabelRotate":90}'],
			M: "Variables",
			T: "integer",
			C: "Rotation for variable labels in degrees It could be positive or negative.",
			D: "0",
			U: {
				Heatmap: "true"
			}
		},
		networkNodesOnTop: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Order to use when drawing nodes and edges in the networks",
			D: "true"
		},
		colorRGB: {
			Z: "true",
			M: "Colors",
			T: "array",
			C: "Color RGB. Red, Green, Blue used in the configurator"
		},
		setMaxZ: {
			H: ['{"graphType":"Scatter3D","setMaxZ":200}', '{"graphType":"Scatter3D","setMaxZ":50}', '{"graphType":"Scatter3D","setMaxZ":null}'],
			M: "Z-Axis",
			T: "float",
			C: "Maximum value to set the data in the Z axis",
			D: "null"
		},
		xAxisValuesRaw: {
			Z: "true",
			M: "X-Axis",
			T: "array",
			C: "Raw values for the ticks in the X axis"
		},
		dendrogramHeight: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
			S: ["dendrogramHang"],
			M: "Dendrograms",
			T: "integer",
			C: "Size in pixels for the dendrogram.",
			D: "50"
		},
		showFeatureNameThereshold: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Threshehold used to set te limit when there are too many features in the genome browser",
			D: "20"
		},
		zAxisAbsMin: {
			Z: "true",
			M: "Z-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the Z axis"
		},
		setMinZ: {
			H: ['{"graphType":"Scatter3D","setMinY":15}', '{"graphType":"Scatter3D","setMinY":30}', '{"graphType":"Scatter3D","setMinY":null}'],
			M: "Z-Axis",
			T: "float",
			C: "Minimum value to set the data in the Z axis",
			D: "null"
		},
		leafletId: {
			M: "Maps",
			T: "string",
			C: "Leaflet Id for the leaflet div in the DOM",
			D: "false"
		},
		varTitleFontSize: {
			H: ['{"varTitle":"VariableTitle","autoScaleFont":false,"varTitleFontSize":10}', '{"varTitle":"VariableTitle","autoScaleFont":false,"varTitleFontSize":20}'],
			M: "Variables",
			T: "integer",
			C: "Size for the variable title in one dimensional plots",
			D: "12",
			U: {
				Heatmap: "true"
			}
		},
		colorSpectrumNumber: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "integer",
			C: "Number of colors to use in the color spectrum",
			D: "100"
		},
		jitterColumns: {
			S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "jitter"],
			H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"jitterColumns":3,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"jitterColumns":5,"functions":["groupSamples:Factor1"]}'],
			M: "Plot area",
			T: "integer",
			C: "A number to indicate the ammount of discrete columns in the jitter function. The minimum number is three. It will be addjusted to be an odd number for aesthetic reasons.",
			D: "7"
		},
		edgeWidth: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Default width for the edges in the networks",
			D: "1"
		},
		genomeTicks: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Number of ticks in the genome browser",
			D: "50"
		},
		sequenceSColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate G/C and serines in the genome browser",
			D: "rgb(255,165,0)"
		},
		showCircularConnections: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to show connections in circular graphs",
			D: "true"
		},
		showTextShadow: {
			S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
			H: ["{*}"],
			M: "Shadows",
			T: "boolean",
			C: "Flag used to add shadows to all text in the canvas. It will be forced to false if the browser is IE.",
			D: "false"
		},
		maxIterations: {
			S: ["kmeansVarClusters", "kmeansSmpClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of maximum iterations when clustering data with kmeans for one dimensional graphs or maximum number of iterations when calculating force direct layout networks.",
			D: "10"
		},
		sortDir: {
			H: ["{*}"],
			O: ["ascending", "descending"],
			M: "Data",
			T: "option",
			C: "Default direction for data sorting.",
			D: "ascending"
		},
		filterSmpBy: {
			M: "Samples",
			T: "filter",
			C: "Filter samples by their annotation included in the 'data.x' object used in one dimensional plots",
			D: "[]",
			X: "getXData"
		},
		showOverlays: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "boolean",
			C: "Flag to indicate to show or not the overlays in one dimensional plots",
			D: "true"
		},
		graphOrientation: {
			H: ["{*}"],
			O: ["horizontal", "vertical"],
			M: "General",
			T: "option",
			C: "Specifies the orientation of one dimensional graphs.",
			D: "horizontal",
			U: {
				StackedPercent: "true",
				Tree: "true",
				Bar: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				TagCloud: "true",
				Candlestick: "true",
				ParallelCoordinates: "true",
				Area: "true",
				Line: "true",
				Sankey: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		outlineWidth: {
			S: ["lineThickness"],
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "float",
			C: "Default width in pixels for lines in networks and other line elements in all visualizations except for the lines in the line plots.",
			D: "1"
		},
		randomDataVariableAnnotationRatio: {
			M: "Random",
			T: "integer",
			C: "Approximate number of variables in each class",
			D: "1"
		},
		marginRight: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the right margin in the canvas.",
			D: "5"
		},
		boxplotMeanColorBorder: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the border of the mean of data in boxplots",
			D: "rgb(255,0,0)"
		},
		align: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["right", "center", "left"],
			M: "Text",
			T: "option",
			C: "Default horizontal alignment for drawing text.",
			D: "center"
		},
		dataTableTransposed: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to transpose the data in the data table",
			D: "true"
		},
		showDataTableOnSelect: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to show data after selecting data in the plot",
			D: "false"
		},
		wireColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the ticks in the genome browser",
			D: "rgba(204,204,204,0.1)"
		},
		sequenceVColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/G and valines in the genome browser",
			D: "rgb(0,103,0)"
		},
		sankeyCoordinateColor: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			M: "Sankey Diagrams",
			T: "boolean",
			C: "Flag to use same color for the nodes and for the lines (links) in the Sankey diagram.",
			D: "false"
		},
		marginTop: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the top margin in the canvas.",
			D: "5"
		},
		kmeansSmpClusters: {
			H: ['{"graphType":"Heatmap","kmeansSmpClusters":2,"functions":["kmeansSamples","kmeansVariables"]}', '{"graphType":"Heatmap","kmeansSmpClusters":4,"functions":["kmeansSamples","kmeansVariables"]}'],
			S: ["maxIterations", "kmeansVarClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of clusters when clustering sample data with kmeans.",
			D: "3"
		},
		setMin: {
			Z: "true",
			M: "Axis",
			T: "float",
			C: "Minimum value to set the data",
			D: "null"
		},
		animationCycles: {
			M: "Animation",
			T: "integer",
			C: "Number of cycles to plot the graph for the animations.",
			D: "20"
		},
		networkCommunities: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of network communities"
		},
		sequenceDColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G/T and aspartic acids in the genome browser",
			D: "rgb(0,0,0)"
		},
		sankeyColor: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			M: "Sankey Diagrams",
			T: "color",
			C: "The default color for the sankey lines (links)",
			D: "rgba(150,150,150,0.5)"
		},
		videoLoop: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to loop videos"
		},
		shapeNodeBy: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group","shapeNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to shape the nods.",
			D: "false"
		},
		tagCloudGridPoints: {
			Z: "true",
			M: "Tag Cloud",
			T: "array",
			C: "Array to keep state of the used space in the tag cloud visualization"
		},
		axisTickFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Axis",
			T: "option",
			C: "Font style for the axis.",
			D: ""
		},
		errors: {
			Z: "true",
			M: "Debug",
			T: "array",
			C: "Array containing benign errors produced when rendering canvasXpress",
			D: "[]"
		},
		xAxisShow: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the X axis",
			D: "true"
		},
		heatmapSeparatorWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the heatmap separator",
			D: "2.5"
		},
		canvasBoxColor: {
			S: ["canvasBox"],
			H: ['{*,"canvasBox":true}'],
			M: "General",
			T: "color",
			C: "Color for the box around the canvas",
			D: "rgb(204,204,204)"
		},
		featureConfigurableProperties: {
			F: "id:[string];Feature id;[],fill:[color];Color for the feature;[]",
			H: ["{*}"],
			M: "Genome Browser",
			T: "array",
			C: "Feature configurable properties",
			D: ["'id'", "'name'", "'label'", "'hideName'", "'fill'", "'outline'", "'dir'", "'showDir'", "'connect'", "'offset'", "'data'", "'subtype'", "'quality'", "'signalToNoise'", "'coordinate'", "'sequence'", "'trace'", "'gaps'", "'translate'", "'hide'", "'counter'"]
		},
		subtracksMaxDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Maximum number of subtracks to show in a track",
			D: "8"
		},
		remoteData: {
			Z: "true",
			M: "Remote Procedures",
			T: "array",
			C: "Array for the remote data pased after a service call"
		},
		shapeKey: {
			M: "Data Point Attributes",
			T: "object",
			C: "Object to assign custom shapes to sample annotations and variable annotations included in the data object. The key of the object is the name of an annotation in the data.x object or the name of an annotation in the data.z object. A default shape will be assigned to a data point whose value was not included the object.",
			D: "false"
		},
		contourZBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of Z bins in contour plots",
			D: "false"
		},
		acknowledgment: {
			H: ["{*}"],
			M: "Acknowledgment",
			T: "boolean",
			C: "Flag to include an acknowledgment image for canvasXpress",
			D: "false"
		},
		videoColor: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "color",
			C: "Color for the video grid and current time",
			D: "rgb(255,0,0)"
		},
		sankeyIterations: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			M: "Sankey Diagrams",
			T: "integer",
			C: "Number of iterations for the Sankey diagram",
			D: "32"
		},
		sizes: {
			H: ['{"data":"Random:16:3:16:0","graphType":"Scatter3D","sizeBy":"Annt1"}'],
			O: ["12", "14", "16", "18", "20", "22", "24", "26", "28", "30", "32", "34", "36", "38", "40", "42"],
			M: "General Attributes",
			T: "array",
			C: "Sizes used invisualizations"
		},
		infoTimeIn: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Time in milliseconds to start showing info after a mouse over",
			D: "50"
		},
		layoutHeight: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Height of the current segment of the canvas when there are multiple graphs."
		},
		sizeEdgeBy: {
			H: ['{"data":"LesMiserables","sizeEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the edges.",
			D: "false"
		},
		heatmapSmpSeparateBy: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "string",
			C: "Factor used to separate the heatmap",
			D: "false",
			X: "getXData"
		},
		xAxis2Title: {
			H: ['{"graphType":"BarLine","xAxis2Title":"2nd X-axis title"}'],
			M: "X-Axis2",
			T: "string",
			C: "Title for the 2nd X axis",
			D: "false"
		},
		loadingImage: {
			H: ["{*}"],
			O: ["loading1", "loading2"],
			M: "Images",
			T: "image",
			C: "Relative path to an image file to the loading image (not including the image directory)",
			D: "loading1"
		},
		treeCoordinateColor: {
			M: "Trees",
			T: "boolean",
			C: "Flag to use same color for the nodes and for the lines (links) in the tree.",
			D: "true"
		},
		foregroundWindow: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"window"}'],
			M: "Foreground",
			T: "color",
			C: "Specifies the foreground color for text or lines when the background type is of a type 'window'.",
			D: "rgb(0,0,0)"
		},
		heatmapCellBoxColorHighlight: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for highlighting heatmap cells",
			D: "rgb(255,215,0)"
		},
		colorBy: {
			H: ['{"graphType":"Scatter3D","colorBy":"Annt1"}', '{"graphType":"Scatter3D","colorBy":"Sample4"}', '{"graphType":"Bar","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Annt1"}'],
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Name of a variable annotation or a sample name or the string 'variable' to color the variables.",
			D: "false",
			X: "getXZData"
		},
		randomNetworkNodeEdgesMax: {
			M: "Random",
			T: "integer",
			C: "Default number of maximum edges when creating random networks",
			D: "5",
			U: {
				Network: "true"
			}
		},
		scaleTextConstantAdd: {
			Z: "true",
			M: "Text",
			T: "float",
			C: "Constants to autoscale text (extra)",
			D: "2.0"
		},
		randomSeed: {
			M: "Random",
			T: "integer",
			C: "Specifies the random seed number to create pseudo random numbers",
			D: "8"
		},
		outlineByData: {
			H: ['{"data":"MultidimensionalHeatmap","outlineByData":"data2","outlineBy":"DataOutline"}'],
			S: ["outlineBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to color the outline data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data4)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		transformBase: {
			H: ["{*}"],
			O: ["2", "10"],
			M: "Data",
			T: "integer",
			C: "Default log or exponential transformation.",
			D: "2"
		},
		plotBox: {
			S: ["plotBoxColor"],
			H: ["{*}"],
			M: "General",
			T: "boolean",
			C: "Flag to create a box around the plot",
			D: "false"
		},
		missingDataColor: {
			H: ['{*,"data":"Random:10:10::::::0.15","graphType":"Heatmap"}'],
			M: "Data",
			T: "color",
			C: "Color for the missing data",
			D: "rgba(204,204,204,0.33)"
		},
		patternByData: {
			H: ['{"data":"MultidimensionalHeatmap","patternByData":"data2","patternBy":"DataOutline"}'],
			S: ["patternBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to pattern the data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data4)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		rAxisMinorTicks: {
			H: ["{*}"],
			M: "R-Axis",
			T: "boolean",
			C: "A flag to show minor tick lines in the R axis",
			D: "true"
		},
		offsetX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Additional amount to move for the X axis"
		},
		videoAutoplay: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to autoplay videos"
		},
		rAxisAbsMin: {
			Z: "true",
			M: "R-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the R axis"
		},
		yAxis2Show: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to show or not the values of the ticks in the Y axis at the right in Scatter plots",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		zAxisTickStyle: {
			H: ['{*,"graphType":"Scatter3D"}'],
			O: ["solid", "dotted"],
			M: "Z-Axis",
			T: "option",
			C: "Style for the tick lines in the Z axis",
			D: "solid"
		},
		showNodeNameThreshold: {
			H: ['{"data":"LesMiserables","showNodeNameThreshold":50,"colorNodeBy":"group"}', '{"data":"LesMiserables","showNodeNameThreshold":100,"colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Thereshold used to set the limit to hide or display the name of nodes in a network. If the number of nodes exceed this thereshold then the name will not be shown.",
			D: "50"
		},
		arcSegmentsSeparation: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "integer",
			C: "Number of degrees to separate the segments in the circular plots",
			D: "8"
		},
		sizeByData: {
			H: ['{"data":"MultidimensionalHeatmap","sizeByData":"data3","sizeBy":"DataSize"}'],
			S: ["sizeBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to size data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data3)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		heatmapIndicatorHeight: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "integer",
			C: "Length in pixels for the heatmap indicator",
			D: "20"
		},
		transformAxis: {
			H: ["{*}"],
			S: ["transformedData", "transformType"],
			O: ["samples", "variables"],
			M: "Data",
			T: "option",
			C: "Default axis to use to transform the data.",
			D: "samples"
		},
		treeLinkColor: {
			M: "Trees",
			T: "color",
			C: "The default color for the tree lines (links)",
			D: "rgb(150,150,150)"
		},
		isSelectDataPoints: {
			Z: "true",
			M: "Scatter Plots",
			T: "integer",
			C: "Number of selected data points (in the data object).",
			D: "0"
		},
		randomDataSampleAnnotations: {
			M: "Random",
			T: "integer",
			C: "Default number of sample annotations when creating random data",
			D: "3"
		},
		smpLabelRotate: {
			H: ['{"smpLabelRotate":0}', '{"smpLabelRotate":-45}', '{"smpLabelRotate":90}'],
			M: "Samples",
			T: "integer",
			C: "Rotation for sample labels in degrees. It could be positive or negative.",
			D: "0"
		},
		randomDataUniform: {
			M: "Random",
			T: "boolean",
			C: "Flag to create or not uniform random data for debug and demonstration purposes",
			D: "false"
		},
		resizerWidth: {
			M: "Axis Resizer",
			T: "integer",
			C: "Length in pixels for the width of the visible axis resizer",
			D: "50"
		},
		showNetworkRadialLayout: {
			H: ['{*,"data":"NetworkRadial","networkLayoutType":"radial"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show or not a radial layout wire.",
			D: "false"
		},
		overlayFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the overlays in one dimensional plots"
		},
		infoTimeOut: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Time in milliseconds to wait between updates for the mouse over info to show up",
			D: "3000"
		},
		showDecorationsLegend: {
			H: ['{"showDecorationsLegends":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{"showDecorationsLegends":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the decoration legends",
			D: "true"
		},
		zAxisValuesRaw: {
			Z: "true",
			M: "Z-Axis",
			T: "array",
			C: "Raw values for the ticks in the Z axis"
		},
		decorationsBackgroundColor: {
			S: ["decorationsBox"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "color",
			C: "Color for the decoration legend background",
			D: "rgb(255,255,255)"
		},
		filterSkipNullValues: {
			M: "Data Filters",
			T: "boolean",
			C: "Flag to indicate to bypass filtering when a value is null",
			D: "false"
		},
		variablesKmeaned: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to k-mean variables",
			D: "false"
		},
		setMinY: {
			H: ['{"graphType":"Scatter2D","setMinY":15}', '{"graphType":"Scatter2D","setMinY":30}', '{"graphType":"Scatter2D","setMinY":null}'],
			M: "Y-Axis",
			T: "float",
			C: "Minimum value to set the data in the Y axis",
			D: "null"
		},
		showNetworkEdgesLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show edge legends in the networks",
			D: "true"
		},
		alignConfiguratorExamples: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to align examples to the configurator",
			D: "false"
		},
		featureDirColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the strand direction of the feature in the genome browser",
			D: "rgb(0,0,0)"
		},
		filterNodeBy: {
			M: "Network Graphs",
			T: "filter",
			C: "Filter nodes by their properties used in network graphs",
			D: "[]",
			X: "getNodeData"
		},
		panningGlobalY: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative number of unit to pan the network in the Y dimension"
		},
		treeNodeSize: {
			M: "Trees",
			T: "integer",
			C: "Size for the Tree nodes",
			D: "20"
		},
		sizeByContinuous: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the size data continuously as opposed to by binning the sizes",
			D: "false"
		},
		legendInside: {
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Position the legend inside the graphs",
			D: "false"
		},
		featureHeightDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the feature height",
			D: "14"
		},
		zAxisTicks: {
			Z: "true",
			M: "Z-Axis",
			T: "integer",
			C: "Number of ticks in the Z axis",
			D: "10"
		},
		invertGraph: {
			M: "General",
			T: "boolean",
			C: "Flag to invert horizontal one dimensional graph to plot from right to left",
			D: "false"
		},
		remoteIds: {
			Z: "true",
			M: "Remote Procedures",
			T: "array",
			C: "Array of the remoteIds passed after a service call"
		},
		freezeColLeft: {
			M: "Data Table",
			T: "integer",
			C: "Number of columns to freeze in the left side of the data table",
			D: "0"
		},
		yAxisTickFormat: {
			H: ['{"graphType":"Scatter2D","yAxisTickFormat":"%.2f cxs"}'],
			M: "Y-Axis",
			T: "string",
			C: "Format for the tick values in the Y axis",
			D: "false"
		},
		isGroupedData: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is grouped."
		},
		vennLegendColors: {
			H: ["{*}"],
			M: "Venn Diagrams",
			T: "boolean",
			C: "Flag to use the venn colors to use for the legends instead of the letters",
			D: "false"
		},
		samplesClustered: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to cluster samples",
			D: "false"
		},
		zoomGlobal: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative zoom factor for the networks."
		},
		decorationsType: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"conditional":{"decorations":[["exp1","exp2","exp3"],["exp1","exp2","exp3"],["exp4","exp5"],["exp4","exp5"],["exp4","exp5"]]}}'],
			O: ["pie", "bar", "heatmap", "stacked", "stackedpercent"],
			M: "Decorations",
			T: "option",
			C: "Type for the decorations in the networks. The types stacked and stackedpercent must be two dimensional. Heatmap could be one or two dimensional",
			D: "bar",
			U: {
				Network: "true"
			}
		},
		showVersion: {
			M: "Debug",
			T: "boolean",
			C: "Flag to show version when mouse over top-left corner of the canvas.",
			D: "true"
		},
		networkDepth: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Depth of the radial network."
		},
		showHiddenChildEdges: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show or not children nodes when the parent node is hidden.",
			D: "true"
		},
		scatterAxesEqual: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Scatter Plots",
			T: "boolean",
			C: "Keep same range in both axes",
			D: "false"
		},
		randomDataSigma: {
			M: "Random",
			T: "integer",
			C: "Sigma value when creating random data",
			D: "1"
		},
		resizeWidthOnLayout: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable resizing the width of the canvas after changing the layout",
			D: "true"
		},
		nodeConfigurableProperties: {
			M: "Network Graphs",
			T: "array",
			C: "Node configurable properties",
			N: "x:[float];X coordinate;[],y:[float];Y coordinate;[],z:[float];Z coordinate;[],parentNode:[string];Id of parent node;[],shape:[string];Shape for the node. One of the ones defined in shapes;[shapes],color:[color];Color for the node;[],outline:[color];Color for the outline of the node;[],pattern:[open|closed];Whether to draw a solid shape or just an outline;[],rotate:[integer];Number of degrees to rotate the shape;[],outlineWidth:[integer];Pixels used to raw the outline of the node;[],imagePath:[url];Url for the node image;[],zIndex:[integer];Css property for the imagePath;[],eventless:[boolean];Flag to disable all events in the node;[overrideEventlessNodes],hide:[boolean];Flag to hide the node;[],hideLabel:[boolean];Flag to hide the label node;[],anchor:[boolean];Flag make the node transparent;[]",
			D: ["'x'", "'y'", "'z'", "'shape'", "'color'", "'outline'", "'size'", "'width'", "'height'", "'pattern'", "'rotate'", "'outlineWidth'", "'imagePath'", "'zIndex'", "'eventless'"]
		},
		heatmapIndicatorPosition: {
			H: ["{*}"],
			O: ["topLeft", "top", "topRight", "right"],
			M: "Heatmap Graphs",
			T: "option",
			C: "Position for the heatmap indicator",
			D: "top"
		},
		zoomStep: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Percentage step for zooming networks and genome panel.",
			D: "0.2"
		},
		axisTitleScaleFontFactor: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Scaling factor used to increase or decrease title font size in the canvas in one and two dimensional plots",
			D: "1"
		},
		zAxisExact: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data in the Z axis",
			D: "false"
		},
		colorKey: {
			M: "Data Point Attributes",
			T: "object",
			C: "Object to assign custom colors to sample annotations and variable annotations included in the data object. The key of the object is the name of an annotation in the data.x object, or the name of an annotation in the data.z object. The value for each key could be either: (1) a scalar with a valid color scheme (see this.meta.def.colorSchemes), or (2) an array with valid colors, or (3) an object to specify custom colors for each of the values of the annotation. A default color will be assigned to a data point whose value was not included the object. CanvasXpress will handle string and numeric annotation approprietly. However, if an object is specified like that one in number (3) the annotation will be treated as categorical even if the annotation is numeric.",
			D: "false"
		},
		createContour: {
			S: ["contourXBinSize", "contourYBinSize", "contourZBinSize", "contourType"],
			M: "Functions",
			T: "void",
			C: "Create contour",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		featureSignalToNoiseValues: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show values for the quality",
			D: "false"
		},
		showNetworkTextLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		overlaysThickness: {
			S: ["adjustAspectRatio"],
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "integer",
			C: "Relative length in pixels for the thickness of the colored boxes to classify samples and or variables in one dimensional plots. This value is adjusted acording to the graph dimensions if the adjustAspectRatio parameter is set to 'true'.",
			D: "18"
		},
		createHistogram: {
			O: ["x", "y"],
			M: "Functions",
			T: "option",
			C: "Create a histogram in 2D-Scatter plots in the 'x' axis or the 'y' axis  @advanced",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		sma20Color: {
			H: ['{*,"stockIndicators":["Sma20"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 25 day single moving average",
			D: "rgb(0,0,255)"
		},
		axisTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the axis titles in one and two dimensional plots"
		},
		functions: {
			Z: "true",
			M: "General",
			T: "array",
			C: "Functions exposed to the api"
		},
		decorationsProperties: {
			H: ['{"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"decorationsProperties":{"exp1":{"color":"rgb(51,125,255)","shape":"square"},"exp2":{"color":"rgb(125,255,51)","shape":"square"},"exp2":{"color":"rgb(255,125,51)","shape":"square"}}}'],
			M: "Decorations",
			T: "object",
			C: "Object to assign properties like color for the network decorations",
			D: "{}",
			U: {
				Network: "true"
			}
		},
		ratioLevelReference: {
			M: "Data",
			T: "option",
			C: "Name of the level used in ratio transformation.",
			D: ""
		},
		tensionSegments: {
			H: ['{*,"data":"Circular"}'],
			M: "Line Graphs",
			T: "integer",
			C: "Number of segments to smooth a quadratic curve",
			D: "16"
		},
		rAxisMaxStrLength: {
			Z: "true",
			M: "R-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the R axis"
		},
		showAnimationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Initialize configurations  @param void @returns void"
		},
		isOncoprint: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to draw an oncoprint heatmap",
			D: "false"
		},
		transitionTime: {
			H: ["{*}"],
			M: "Animation",
			T: "integer",
			C: "Time in milliseconds for transition",
			D: "1000"
		},
		videoPoster: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "url",
			C: "Video poster for videos  @default"
		},
		nodeFontSize: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Size in pixels for the font size of text in the networks",
			D: "20"
		},
		sortSamplesByVariable: {
			S: ["sortDir", "sortSamplesByCategory"],
			M: "Functions",
			T: "array",
			C: "Sort the samples by the value of a variable",
			X: "getVariablesAsArray",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		resizerBackgroundImage: {
			M: "Axis Resizer",
			T: "url",
			C: "Resizer background image",
			D: "false"
		},
		sizeDecorationBy: {
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the network decoration.",
			D: "false"
		},
		trackConfigurableProperties: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "array",
			C: "Track configurable properties",
			D: ["'name'", "'hideName'", "'hideFeatureNames'", "'type'", "'height'", "'fill'", "'outline'", "'data'", "'hide'", "'connect'", "'subtracksMax'", "'highlight'"],
			G: "name:[string];Track name;[]"
		},
		xAxisTickColor: {
			H: ["{*}"],
			M: "X-Axis",
			T: "color",
			C: "Color for the tick lines in the X axis",
			D: "rgb(204,204,204)"
		},
		yAxisTickColor: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "color",
			C: "Color for the tick lines in the Y axis",
			D: "rgb(204,204,204)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		isAnimation: {
			Z: "true",
			M: "Snapshots",
			T: "boolean",
			C: "Flag to indicate if there is an active animation"
		},
		pieSegmentPrecision: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "integer",
			C: "Number of decimals for values in the Pie charts",
			D: "0"
		},
		disableToolbar: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the toolbar",
			D: "false"
		},
		decorationScaleFontFactor: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "float",
			C: "Scaling factor used to increase or decrease decoration font size in the canvas.",
			D: "1"
		},
		boxPlotOutliersRatio: {
			H: ['{"data":"Boxplot","boxPlotOutliersRatio":8,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","boxPlotOutliersRatio":10,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Ratio for the size of the outliers with respect to boxplot",
			D: "8"
		},
		panningY: {
			H: ["{*}"],
			M: "Zooming and Panning",
			T: "float",
			C: "Number of unit to pan the network in the Y dimension",
			D: "0"
		},
		errorBarsType: {
			H: ['{"errorBarsType":"standardDeviation","functions":["groupSamples:Factor1"]}', '{"errorBarsType":"standardErrorMean","functions":["groupSamples:Factor1"]}', '{"errorBarsType":"confidenceInterval95","functions":["groupSamples:Factor1"]}'],
			O: ["standardDeviation", "standardErrorMean", "confidenceInterval95"],
			M: "Data",
			T: "option",
			C: "Type of error bars.",
			D: "confidenceInterval95"
		},
		circularRotate: {
			M: "Circular Graphs",
			T: "int",
			C: "Number of degrees to rotate the circular graph to adjust the starting point  @exs {}",
			D: "0"
		},
		sankeyNodeWidth: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			M: "Sankey Diagrams",
			T: "integer",
			C: "Width for the Sankey nodes",
			D: "20"
		},
		chordColorOrigin: {
			O: ["source", "target"],
			M: "Circular Graphs",
			T: "option",
			C: "Color of the chord ribbon according to either the source or the target of the connection  @exs {}",
			D: "source"
		},
		connections: {
			M: "Circular Graphs",
			T: "array",
			C: "Array to store connections in circular graphs"
		},
		randomDataMean: {
			M: "Random",
			T: "integer",
			C: "Mean value when creating random data",
			D: "0"
		},
		transpose: {
			M: "Functions",
			T: "void",
			C: "Transpose the data. It takes no parameters",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		smpLabelScaleFontFactor: {
			H: ["{*}"],
			M: "Samples",
			T: "float",
			C: "Scaling factor used to increase or decrease sample label font size in the canvas.",
			D: "1"
		},
		transitionFunction: {
			O: ["linear", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInCubic", "easeOutCubic", "easeInOutCubic", "easeInQuart", "easeOutQuart", "easeInOutQuart", "easeInQuint", "easeOutQuint", "easeInOutQuint"],
			M: "Animation",
			T: "option",
			C: "Easing function for the transition",
			D: "easeInOutQuad"
		},
		circularLetterSeparationFactor: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "float",
			C: "Factor to adjust the spacing between letters in the circular graphs. The greater the number the closer the letters in the labels",
			D: "1.5"
		},
		debug: {
			M: "Debug",
			T: "boolean",
			C: "Flag to turn on alerts.",
			D: "false"
		},
		citation: {
			S: ["citationColor"],
			H: ['{"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "string",
			C: "A reference citation of the graph which is placed at the bottom right corner",
			D: "false"
		},
		smpSort: {
			Z: "true",
			M: "Data",
			T: "integer",
			C: "Sample index used in sorting the data."
		},
		resizerBackgroundColorOutlineCurrent: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up the current area selected in the axes in the canvas",
			D: "rgb(59,138,229)"
		},
		showAnimation: {
			H: ["{*}"],
			M: "Animation",
			T: "boolean",
			C: "Flag to show or not animation for the graphs",
			D: "false"
		},
		yAxisMajorTicks: {
			H: ["{*}"],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show major tick lines in the Y axis",
			D: "true"
		},
		networkFreezeOnLoad: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prevent autoscaling for the network layout after loading. Useful when images are part of the network.",
			D: "false"
		},
		layoutTime: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Time in milliseconds used to calculate the layout for the network",
			D: "15"
		},
		xAxisAbsMax: {
			Z: "true",
			M: "X-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the X axis"
		},
		showSmpOverlaysLegend: {
			H: ["{*}"],
			M: "Overlays",
			T: "boolean",
			C: "Flag to show or not the legend for the sample overlays in the graphs. If set to false the level information will be displayed in the actual colored boxes of the overlays",
			D: "false"
		},
		isLogData: {
			H: ["{*}"],
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is Log transformed.",
			D: "false"
		},
		barLollipopFactor: {
			H: ['{*,"graphType":"Bar","widthFactor":0.1}'],
			M: "Bar Graphs",
			T: "color",
			C: "Ratio for the lollipop in bar graphs. The higher the value the bigger the lollipop.",
			D: "3"
		},
		tension: {
			H: ['{*,"data":"Random:4:6","graphType":"Line","lineType":"spline"}'],
			M: "Line Graphs",
			T: "float",
			C: "Curvature for the splines and hulls",
			D: "0.3"
		},
		networkStackIndex: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Index in the network stack for undo and redo operations"
		},
		axisTickColor: {
			H: ["{*}"],
			M: "Axis",
			T: "color",
			C: "Color for the axis ticks in one and two dimensional plots",
			D: "rgb(0,0,0)"
		},
		sortCaseSensitive: {
			H: ["{*}"],
			M: "Data",
			T: "boolean",
			C: "Whether to use case sensitive in ascii sorting",
			D: "false"
		},
		resizerBackgroundColor: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up when resizing the axes in the canvas or the whole canvas",
			D: "rgba(204,204,204,0.7)"
		},
		groupSamples: {
			S: ["ungroupSamples"],
			M: "Functions",
			T: "array",
			C: "Group samples based on a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		zRotate: {
			H: ['{"graphType":"Scatter3D","zRotate":0}', '{"graphType":"Scatter3D","zRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the Z axis",
			D: "0"
		},
		parallelCoordinates: {
			Z: "true",
			M: "Line Graphs",
			T: "array",
			C: "Flag to draw a parallel coordinates plot",
			D: "[]"
		},
		guides: {
			H: ['{*,"graphType":"Heatmap"}'],
			O: ["false", "solid", "dotted"],
			M: "Plot area",
			T: "option",
			C: "This is a thin line that appears in the middle of the variables and / or samples in one dimensional graphs and multidimensional heatmaps just for aesthetics.",
			D: "false"
		},
		xAxisMajorTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show major tick lines in the X axis",
			D: "true"
		},
		remoteDirection: {
			S: ["remoteService", "remoteServiceType", "remoteParams"],
			O: ["next", "prev"],
			M: "Remote Procedures",
			T: "option",
			C: "Direction parameter used to obtain data remotely.",
			D: "next"
		},
		loadRDatasets: {
			M: "R",
			T: "boolean",
			C: "Flag to load R datasets from Github",
			D: "false"
		},
		featureWidthDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the feature width",
			D: "3"
		},
		leafletJS: {
			M: "Maps",
			T: "array",
			C: "Leaflet JS files",
			D: ["https://canvasxpress.org/js/topojson.v2.js", "https://canvasxpress.org/js/leaflet.js"]
		},
		rAxisShow: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the R axis",
			D: "true"
		},
		showVariableNames: {
			H: ["{*}"],
			M: "Variables",
			T: "boolean",
			C: "Flag to show the variable names in one dimensional plots",
			D: "true",
			U: {
				Heatmap: "true"
			}
		},
		decorationFontSize: {
			H: ['{*,"autoScaleFont":false,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "integer",
			C: "Font size for the decorations in scatter plots and network graphs",
			D: "12"
		},
		heatmapCellBoxWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the heatmap boxes around the cells",
			D: "0.5"
		},
		infoStartTime: {
			Z: "true",
			M: "Events",
			T: "time",
			C: "Time in milliseconds to keep track of time"
		},
		treemapBorderWidth: {
			M: "Treemap Graphs",
			T: "integer",
			C: "Width for the treemap border",
			D: "3"
		},
		fontSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Font size for text in complex plot only. See other categories to modify specific font sizes.",
			D: "12"
		},
		connectByData: {
			Z: "true",
			M: "Data Point Attributes",
			T: "object",
			C: "Object with connectBy data",
			D: "{}"
		},
		filterType: {
			O: ["and", "or"],
			M: "Data Filters",
			T: "option",
			C: "Type for the filter. Can be 'and' or 'or'",
			D: "and"
		},
		imageDir: {
			M: "Images",
			T: "url",
			C: "Relative path to a directory containing images.",
			D: ""
		},
		animationTime: {
			M: "Animation",
			T: "integer",
			C: "Time in milliseconds to wait between rendering the plot when showing the animation.",
			D: "30"
		},
		motionTrails: {
			S: ["motionBy"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show motion trails. Applicable only to 'String' factors.",
			D: "true"
		},
		loessColor: {
			H: ["{*}"],
			M: "Loess",
			T: "color",
			C: "Color for the loess fit line",
			D: "rgb(255,215,0)"
		},
		resizable: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable resizing the canvas by dragging the mouse over the edges",
			D: "true"
		},
		transitionStep: {
			H: ["{*}"],
			M: "Animation",
			T: "integer",
			C: "Steps for transition",
			D: "10"
		},
		attractiveForceFunction: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			O: ["Eades", "FruchtermanReingold"],
			M: "Network Graphs",
			T: "option",
			C: "Type of function to apply when calculating attractive force in forceDirected network layouts",
			D: "FruchtermanReingold"
		},
		rotationStep: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "integer",
			C: "Number of degrees used when the plot is automatically rotated",
			D: "2"
		},
		xAxis2Ticks: {
			Z: "true",
			M: "X-Axis2",
			T: "integer",
			C: "Number of ticks in the 2nd X axis. It is the same as xAxisTicks.",
			D: "5"
		},
		layoutCurrent: {
			Z: "true",
			M: "Combination Plots",
			T: "integer",
			C: "Integer to identify the current graph being displayed in the canvas."
		},
		graphType: {
			H: ['{*,"graphOrientation":"vertical"}'],
			O: ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "DotLine", "Heatmap", "Candlestick", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Tree", "Treemap", "TagCloud", "ParallelCoordinates", "Sankey", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Correlation", "Pie", "Venn", "Network", "Genome", "Circular"],
			M: "General",
			T: "option",
			C: "Specifies the type of graph.",
			D: "Bar"
		},
		distance: {
			H: ['{"graphType":"Heatmap","distance":"euclidian","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"manhattan","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"max","functions":["clusterSamples","clusterVariables"]}'],
			S: ["linkage", "clusterAxis", "clusterSamples", "clusterVariables"],
			O: ["euclidian", "manhattan", "max"],
			M: "Clustering",
			T: "option",
			C: "Distance metric to use when clustering data.",
			D: "euclidian"
		},
		featureSignalToNoiseShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show quality",
			D: "true"
		},
		remoteUpdateDelay: {
			M: "Remote Procedures",
			T: "integer",
			C: "Time in milliseconds to wait between tryig to get an upated version of the file containing the data",
			D: "10000"
		},
		layout: {
			Z: "true",
			M: "Combination Plots",
			T: "string",
			C: "Topology of the canvas. Number of rows and columns.",
			D: "1X1"
		},
		marginBottom: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the bottom margin in the canvas.",
			D: "5"
		},
		filterEdgeBy: {
			M: "Network Graphs",
			T: "filter",
			C: "Filter edges by their properties used in network graphs",
			D: "[]",
			X: "getEdgeData"
		},
		showPieValues: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the values for the pie",
			D: "true"
		},
		subtitleFontStyle: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Font style for the title.",
			D: ""
		},
		fontScaleFontFactor: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Text",
			T: "float",
			C: "Scaling factor used to increase or decrease the font size in the canvas.",
			D: "1"
		},
		smpTitleFontSize: {
			H: ['{"smpTitle":"SampleTitle","autoScaleFont":false,"smpTitleFontSize":10}', '{"smpTitle":"SampleTitle","autoScaleFont":false,"smpTitleFontSize":20}'],
			M: "Samples",
			T: "integer",
			C: "Size for the sample title in one dimensional plots",
			D: "12"
		},
		edgeConfigurableProperties: {
			M: "Network Graphs",
			T: "array",
			C: "Edge configurable properties",
			D: ["'width'", "'cap'", "'exact'", "'type'"],
			E: "color:[color];Color for the edge;[],width:[integer];Pixel width for the edges between nodes;[],cap:[butt|round|square];Type of cap for the end of the lines;[capType],exact:[boolean];Flag to indicate to create the edge between nodes without subtracting the size of the nodes;[],type:[string];Type of line use to join the nodes;[lines],hide:[boolean];Flag to hide the edge;[],anchor:[boolean];Flag make the edge transparent;[]"
		},
		showDOEData: {
			M: "DOE",
			T: "boolean",
			C: "Flag to plot the original data in the DOE",
			D: "true"
		},
		zoomSamplesDisable: {
			H: ['{*,"graphType":"Heatmap"}'],
			S: ["zoomVariablesDisable"],
			M: "Zooming and Panning",
			T: "boolean",
			C: "Flag to disable zooming of samples with mouse wheel in Heatmaps",
			D: "false"
		},
		decorationsColor: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "color",
			C: "Color for the decorations in scatter plots and network graphs",
			D: "rgb(0,0,0)"
		},
		sequenceUColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the uracils in the genome browser",
			D: "rgb(255,0,0)"
		},
		colorSpectrumZeroValue: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "float",
			C: "A value to be at the center of the color spectrum to produce symmetrical heatmaps",
			D: "null"
		},
		freezeRowTop: {
			M: "Data Table",
			T: "integer",
			C: "Number of rows to freeze at the top of the data table",
			D: "0"
		},
		trackDirColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the strand direction of the tracks in the genome browser",
			D: "rgb(0,0,0)"
		},
		nodeHighlightColor: {
			H: ['{*,"highlightNode":["Gene1","Gene2"]}'],
			M: "Network Graphs",
			T: "color",
			C: "The color for the highlighted nodes.",
			D: "rgb(255,0,0)"
		},
		oddColor: {
			S: ["blockContrast", "evenColor"],
			H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
			M: "Colors",
			T: "color",
			C: "The color for the odd numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
			D: "rgb(255,255,255)"
		},
		capType: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["butt", "round", "square"],
			M: "Lines",
			T: "option",
			C: "Default type of cap for lines.",
			D: "butt"
		},
		showAnimationFontColor: {
			M: "Animation",
			T: "color",
			C: "Color for the animation text",
			D: "rgb(255,255,255)"
		},
		patternBy: {
			S: ["patternByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","patternBy":"Annt1"}', '{"graphType":"Dotplot","patternBy":"Factor1"}', '{"graphType":"Dotplot","patternBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to pattern the variables. When patternByData is specified patternBy is used for the title in the legend."
		},
		showLoessFit: {
			M: "Loess",
			T: "boolean",
			C: "Flag to show the loess fit in Scatter2D plots",
			D: "false"
		},
		canvasBox: {
			S: ["canvasBoxColor"],
			H: ["{*}"],
			M: "General",
			T: "boolean",
			C: "Flag to create a box around the canvas",
			D: "false"
		},
		updateCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Update the code to generate the plot  @advanced"
		},
		videoGridStep: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "integer",
			C: "Number of steps to divide the grid in the video",
			D: "10"
		},
		rAxisTicks: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "integer",
			C: "Number of ticks in the R axis",
			D: "5"
		},
		sortVariablesBySample: {
			S: ["sortDir", "sortVariablesByCategory"],
			M: "Functions",
			T: "array",
			C: "Sort the variables by the value of a sample",
			X: "getSamplesAsArray",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		layoutWidth: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Width of the current segment of the canvas when there are multiple graphs."
		},
		histogramBarWidth: {
			S: ["scatterType", "isHistogram"],
			H: ['{*,"graphType":"Scatter2D","isHistogram":true}'],
			M: "Histograms",
			T: "float",
			C: "Length in pixels for half of the bar width in the 2D sccater plot histogram.",
			D: "0.5"
		},
		scatterOutlineThreshold: {
			H: ['{"data":"3DScatter","graphType":"Scatter3D","scatterOutlineThreshold":4000}', '{"data":"3DScatter","graphType":"Scatter3D","scatterOutlineThreshold":5}'],
			M: "Scatter Plots",
			T: "integer",
			C: "Maximum number of data points before skipping plotting their outline but only the fill color",
			D: "50000"
		},
		correlationAxis: {
			H: ["{*}"],
			O: ["samples", "variables"],
			M: "Correlation Graphs",
			T: "option",
			C: "Axis used for the correlation.",
			D: "samples"
		},
		overlaysLegendPosition: {
			H: ["{*}"],
			O: ["topRight", "right", "bottomLeft", "bottom"],
			M: "Overlays",
			T: "option",
			C: "Position for the variable and sample overlays legend in the graphs.",
			D: "topRight"
		},
		disableTouchToolbar: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the touch toolbar",
			D: "false"
		},
		shadowOffsetX: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Length in pixels for the shadow offset in the X axis.",
			D: "1"
		},
		heatmapAutoAdjust: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to adjust the range of the heatmaps when zooming in/out",
			D: "false"
		},
		xAxisTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "integer",
			C: "Number of ticks in the X axis",
			D: "5"
		},
		maxOverlayStringLen: {
			H: ['{"maxOverlayStringLen":50}', '{"maxOverlayStringLen":5}'],
			M: "Overlays",
			T: "integer",
			C: "Maximum length in characters an ovelay label can be so anything above is truncated.",
			D: "30"
		},
		sequenceZColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamines in the genome browser",
			D: "rgb(0,0,0)"
		},
		hierarchyVarIndex: {
			Z: "true",
			M: "Hierarchy",
			T: "integer",
			C: "Variable index to use in the sankey, sunburst and bubble graphs",
			D: "0"
		},
		areaType: {
			H: ['{*,"transparency":0.5}'],
			O: ["normal", "stacked", "percent"],
			M: "Area Graphs",
			T: "option",
			C: "Flag to produce normal, stacked, center or percent area graphs",
			D: "normal"
		},
		loessAccuracy: {
			M: "Loess",
			T: "float",
			C: "Loess accuracy",
			D: "1e-12"
		},
		setMaxY: {
			H: ['{"graphType":"Scatter2D","setMaxY":200}', '{"graphType":"Scatter2D","setMaxY":50}', '{"graphType":"Scatter2D","setMaxY":null}'],
			M: "Y-Axis",
			T: "float",
			C: "Maximum value to set the data in the Y axis",
			D: "null"
		},
		ungroupSamples: {
			S: ["groupSamples"],
			M: "Functions",
			T: "void",
			C: "Ungroup samples previously grouped according to a sample category (data.x object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		subtitleScaleFontFactor: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "float",
			C: "Scaling factor used to increase or decrease the subtitle font size in the canvas.",
			D: "1"
		},
		legendFontSize: {
			S: ["autoScaleFont", "legendScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Legends",
			T: "integer",
			C: "Font size for the legends. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the legend scaling factor",
			D: "12"
		},
		randomDataSamples: {
			M: "Random",
			T: "integer",
			C: "Default number of samples when creating random data",
			D: "36"
		},
		yAxisTopBottomTickColor: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "color",
			C: "Color for the top and bottom tick lines in the Y axis",
			D: "rgb(204,204,204)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		yAxisHistogramShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to indicate whether to show a histogram for the data in the Y axis",
			D: "false"
		},
		shapeByShape: {
			H: ["{*}"],
			O: ["false", "sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "mdavid"],
			M: "Data Point Attributes",
			T: "option",
			C: "String that identify the shape to use in regular and multidimensional heatmaps. shapeByData will take precedence over this property.",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		marginLeft: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the left margin in the canvas.",
			D: "5"
		},
		xAxis2: {
			H: ['{"xAxis2":["Variable1"],"xAxis":["Variable2"],"graphType":"BarLine"}'],
			M: "X-Axis2",
			T: "array",
			C: "Name of the variables in one dimensional graphs",
			D: "[]",
			X: "getVariablesAsArray"
		},
		layoutComb: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag that identify that multiple graphs will be displayed in the canvas.",
			D: "false"
		},
		broadcast: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable broadcasting to other canvasXpress objects in the page",
			D: "true"
		},
		yAxisTitle: {
			M: "Y-Axis",
			T: "string",
			C: 'Title for the Y axis in Scatter plots and in Correlation graphs.  @exs {"graphType":"Scatter2D","yAxisTitle":"Y-axistitle";"graphType":"Correlation","yAxisTitle":"Correlation Title"}',
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		summaryType: {
			O: ["false", "iqr", "median", "mean", "cor", "min", "max", "sum"],
			M: "Data",
			T: "option",
			C: "Summary type for the data when grouping",
			D: "false"
		},
		eventKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable key binding events. This prevent some default browser shortcuts and it is system specific. Please see the Event section bellow.",
			D: "true"
		},
		yRotate: {
			H: ['{"graphType":"Scatter3D","yRotate":0}', '{"graphType":"Scatter3D","yRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the Y axis",
			D: "0"
		},
		rAxisLabelOrientation: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			O: ["perpendicular", "circular"],
			M: "R-Axis",
			T: "option",
			C: "Orientation to show the ticks values in circular plots.",
			D: "perpendicular"
		},
		smpTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the sample title in one dimensional plots"
		},
		featureTraceTrim: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default triming for nucleotide values in the traces (expressed in percent)",
			D: "1"
		},
		hierarchy: {
			M: "Hierarchy",
			T: "array",
			C: "Hierarchy for circular, trees and bubble graphs made up of sample annotations",
			D: "[]",
			X: "getXData"
		},
		sequenceCColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the cytosines and cysteins in the genome browser",
			D: "rgb(0,0,255)"
		},
		segregateVariablesBy: {
			H: ['{"data":"Random:3:2:3:0:0:1","segregateVariablesBy":["Annt3"],"smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
			M: "Data",
			T: "array",
			C: "An array that holds the annotation(s) used to segregate the variables. It must be categories in the 'data.z' object",
			D: "[]"
		},
		windowBox: {
			H: ["{*}"],
			M: "Foreground",
			T: "color",
			C: "Specifies the color for the border of the plot'.",
			D: "rgb(0,0,0)"
		},
		maxDOENumber: {
			M: "DOE",
			T: "integer",
			C: "Maximum number of graphs when creating a DOE.",
			D: "8"
		},
		yAxisMaxStrLength: {
			Z: "true",
			M: "Y-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the Y axis"
		},
		showSmpDendrogram: {
			H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the sample dendrogram",
			D: "true"
		},
		showAdvancedConfiguration: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to show advanced configuration properties.",
			D: "false"
		},
		disableEvents: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable all events.",
			D: "false"
		},
		edgesProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the edges in the Network graph to include in the Data table and the data filter",
			D: "[]"
		},
		showVarDendrogram: {
			H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the variable dendrogram",
			D: "true"
		},
		freezeColRight: {
			M: "Data Table",
			T: "integer",
			C: "Number of columns to freeze in the right side of the data table",
			D: "0"
		},
		pieType: {
			H: ["{*}"],
			O: ["separated", "solid"],
			M: "Pie Charts",
			T: "option",
			C: "Position for the pices of the pie",
			D: "separated"
		},
		rAxis: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"rAxis":false}', '{"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "string",
			C: "Radial axis for circular plots. It must be the name of a variable",
			D: "false"
		},
		heatmapVarSeparateBy: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "string",
			C: "Factor used to separate the heatmap",
			D: "false",
			X: "getZData"
		},
		reset: {
			M: "Functions",
			T: "void",
			C: "Reset the canvas"
		},
		remoteDataIndex: {
			Z: "true",
			M: "Remote Procedures",
			T: "integer",
			C: "Index of the canvasXpress object requested"
		},
		oncoprintAmplification: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Threshold to qualify amplifications in oncoprints",
			D: "3"
		},
		showDecorations: {
			H: ['{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not extra decorations like (regression lines, splines, etc) in scatter plots and (heatmaps, pie charts or stacked bar graphs in) network graphs",
			D: "true"
		},
		motionBy: {
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Utility to create dynamic filtering of data in Scatter plots  @funtion getZData",
			D: "false"
		},
		backgroundVideo: {
			S: ["backgroundType"],
			H: ['{"graphType":"Video","videoAutoplay":true,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Background",
			T: "url",
			C: "An array containing urls for the background video when the background type is of the type 'video'.",
			D: "false"
		},
		approximateNodePositions: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to force approximate X, Y node positions.",
			D: "false"
		},
		treeCircular: {
			M: "Trees",
			T: "boolean",
			C: "Flag to plot a circular tree layout.",
			D: "false"
		},
		citationScaleFontFactor: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "float",
			C: "Scaling factor used to increase or decrease citation font size in the canvas",
			D: "1"
		},
		zoomVariablesDisable: {
			H: ['{*,"graphType":"Heatmap"}'],
			S: ["zoomSamplesDisable"],
			M: "Zooming and Panning",
			T: "boolean",
			C: "Flag to disable zooming of variables with mouse wheel in Heatmaps",
			D: "false"
		},
		hideInfoDiv: {
			M: "Functions",
			T: "void",
			C: "Hide additional information  @advanced"
		},
		xAxisTickStyle: {
			H: ["{*}"],
			O: ["solid", "dotted"],
			M: "X-Axis",
			T: "option",
			C: "Style for the tick lines in the X axis",
			D: "solid"
		},
		smpTitleScaleFontFactor: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "float",
			C: "Scaling factor used to increse or decrease sample title font size in the canvas",
			D: "1"
		},
		showConfiguratorExamplesOnSelect: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to display examples as the configurator property changes",
			D: "false"
		},
		lineWidthEvent: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the width for the events in the lines.",
			D: "3"
		},
		selectDataPoint: {
			Z: "true",
			M: "Scatter Plots",
			T: "array",
			C: "Ids of data points (in the data object) to select.",
			D: "[]"
		},
		axisTicksAutoAdjust: {
			H: ["{*}"],
			M: "Axis",
			T: "boolean",
			C: "Flag to indicate whether to adjust automatically the number of ticks to put in the axes",
			D: "false"
		},
		subtitle: {
			S: ["subtitleHeight", "subtitleColor"],
			H: ['{"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "string",
			C: "Subtitle of the graph.",
			D: "false"
		},
		animationType: {
			O: ["grow", "spring", "random"],
			M: "Animation",
			T: "option",
			C: "Type of animation",
			D: "grow"
		},
		circularCenterProportion: {
			H: ['{*,"data":"Circular"}'],
			M: "Circular Graphs",
			T: "float",
			C: "Proportion of the center of the circular graph to use as void",
			D: "0.3"
		},
		showErrorBars: {
			H: ['{"showErrorBars":true,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":false,"functions":["groupSamples:Factor1"]}'],
			M: "Data",
			T: "boolean",
			C: "Flag to indicate whether to show or not error bars in the graphs.",
			D: "true"
		},
		axisTickScaleFontFactor: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Scaling factor used to increase or decrease tick font size in the canvas in one and two dimensional plots",
			D: "1"
		},
		colorEdgeBy: {
			H: ['{"data":"LesMiserables","colorEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to color the edges.",
			D: "false"
		},
		margin: {
			S: ["adjustAspectRatio"],
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Relative length in pixels for the distance between various objects in the graphs. This value is adjusted acording to the graph dimensions if the adjustAspectRatio parameter is set to 'true'.",
			D: "5"
		},
		xAxisMaxStrLength: {
			Z: "true",
			M: "X-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the X axis"
		},
		layoutRemoveEmpty: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to remove empty combinations in segregated layouts.",
			D: "true"
		},
		broadcastType: {
			H: ["{*}"],
			O: ["var", "comb"],
			M: "Events",
			T: "option",
			C: "Model for broadcasting to identify either variables or a combination of variable and samples",
			D: "var"
		},
		showDecorationsRegressionConfidence: {
			S: ["decorations"],
			H: ['{"showDecorationsRegressionConfidence":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{"showDecorationsRegressionConfidence":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the confidence intervals in the regression plots",
			D: "true"
		},
		heatmapCellBoxHighlightWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the highlighting heatmap boxes around the cells",
			D: "1"
		},
		segregateSamplesBy: {
			H: ['{"data":"Random:2:3:0:3:0:1","segregateSamplesBy":["Factor3"],"smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
			M: "Data",
			T: "array",
			C: "An array that holds the annotation(s) used to segregate the samples. It must be categories in the 'data.x' object",
			D: "[]"
		},
		rAxisValuesRaw: {
			Z: "true",
			M: "R-Axis",
			T: "array",
			C: "Raw values for the ticks in the R axis"
		},
		print: {
			M: "Functions",
			T: "void",
			C: "Print the canvas"
		},
		backgroundType: {
			H: ['{*,"backgroundImage":"https://canvasxpress.org/images/nanotube.jpg","skipExample":["video"]}'],
			S: ["backgroundImage", "gradientOrientation", "backgroundGradient1Color", "backgroundGradient2Color"],
			O: ["solid", "gradient", "window", "windowGradient", "windowGradient2", "windowSolidGradient", "image", "windowImage", "video"],
			M: "Background",
			T: "option",
			C: "Specifies the style for the background of the canvas. The canvas background is composed of a frame with a window where the data is plotted. Either of these elements the may be a solid or gradient color or an image or a video of your choosing.",
			D: "solid"
		},
		maxSmpStringLen: {
			H: ['{"maxSmpStringLen":50}', '{"maxSmpStringLen":5}'],
			M: "Samples",
			T: "integer",
			C: "Maximum length in characters a sample label or description can have so anything above is truncated.",
			D: "30"
		},
		showAnimationFontSize: {
			M: "Animation",
			T: "integer",
			C: "Size in pixels for the font size of text involved in the animation",
			D: "10"
		},
		axisExtension: {
			H: ['{"graphType":"Scatter2D","axisExtension":0.1}', '{"graphType":"Scatter2D","axisExtension":0.2}'],
			M: "Axis",
			T: "float",
			C: "Percentage to extend the values in the data",
			D: "0.1"
		},
		lineErrorType: {
			H: ['{*,"graphType":"Line"}'],
			O: ["bar", "area"],
			M: "Line Graphs",
			T: "option",
			C: "Line error type in the line graphs",
			D: "bar"
		},
		heatmapIndicatorHistogramColor: {
			H: ["{*}"],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for the heatmap indicator histogram",
			D: "rgb(0,255,255)"
		},
		sequenceMColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G and methionines in the genome browser",
			D: "rgb(0,103,0)"
		},
		randomDataVariableAnnotations: {
			H: ["{*}"],
			M: "Random",
			T: "integer",
			C: "Default number of variable annotations when creating random data",
			D: "2"
		},
		axisWilkinsonLoose: {
			H: ['{*,"graphType":"Bar","axisAlgorithm":"wilkinson"}'],
			M: "Axis",
			T: "boolean",
			C: "Flag to indicate whether to use loose positioning when using the wilkinson algorithm to position the labels on the axis",
			D: "false"
		},
		featureTranslateHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the translation height",
			D: "12"
		},
		decorationsBox: {
			S: ["decorationsBoxColor", "decorationsBackgroundColor"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to create a box around the decoration legend",
			D: "true"
		},
		subNetworks: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array to keep independent networks"
		},
		legendFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Legends",
			T: "option",
			C: "Font style for the legend.",
			D: ""
		},
		showInfoDiv: {
			M: "Functions",
			T: "void",
			C: "Show additional information  @advanced"
		},
		sampleSeparationFactor: {
			S: ["widthFactor", "variableSeparationFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "integer",
			C: "Factor to adjust the spacing between the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider apart then increase this parameter (2 is twice as much).",
			D: "1"
		},
		isReproducibleResearch: {
			M: "General",
			T: "boolean",
			C: "Flag to indicate to track user modifications for Reproducible Research",
			D: "true"
		},
		yAxisAbsMin: {
			Z: "true",
			M: "Y-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the Y axis"
		},
		blockContrast: {
			S: ["evenColor", "oddColor"],
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "A flag to creates a shade between the samples so there are two backgrounds, one for the odd samples and one for the even samples.",
			D: "false"
		},
		featureSignalToNoiseHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the quality height",
			D: "12"
		},
		titleFontStyle: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Font style for the title.",
			D: ""
		},
		xAxisExact: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data in the X axis",
			D: "false"
		},
		boxplotMean: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","boxplotMean":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show mean of data in boxplots",
			D: "false"
		},
		videoData: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "object",
			C: "Data for videos",
			D: "{}"
		},
		resizeHeightOnLayout: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable resizing the height of the canvas after changing the layout",
			D: "true"
		},
		colorVarDendrogramBy: {
			O: ["false"],
			M: "Dendrograms",
			T: "option",
			C: "Name of a variable annotation to color the variable dendrogram.",
			D: "false",
			X: "getZData"
		},
		legendBox: {
			S: ["legendBoxColor", "legendBackgroundColor"],
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Flag to create a box around the legend",
			D: "true"
		},
		showDataTable: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to show the data table",
			D: "false"
		},
		remoteService: {
			S: ["remoteServiceType", "remoteParams", "remoteDirection"],
			M: "Remote Procedures",
			T: "url",
			C: "Url used to obtain data remotely thorugh a web service or directly from a file. If the remote service is a file then it expects a json file with a two dimensional array. Each of the arrays should have a key (which will be used in a drop down menu) and a value to point to a url where to get the data. If the remote service is a web service it expects a canvasXpress object. You may specify additional parameters for the web service but you must specify the type of remote service in remoteServiceType. The default parameters for web services are index (to identify the current record number) and dir (to identify the direction; it could be either next or prev)",
			D: "false"
		},
		randomDataVariables: {
			M: "Random",
			T: "integer",
			C: "Default number of variables when creating random data",
			D: "3"
		},
		gradientRatio: {
			S: ["gradientType"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
			M: "Gradients",
			T: "float",
			C: "Specifies the ratio used to generate linear gradients.",
			D: "1.3"
		},
		decorationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the decoration in scatter plots and network graphs"
		},
		sequenceRColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G and arginines in the genome browser",
			D: "rgb(255,0,0)"
		},
		zAxisShow: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the Z axis",
			D: "true"
		},
		isNetworkConvexHull: {
			Z: "true",
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create a convex hull for the network communities",
			D: "false"
		},
		sequenceNColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/G/T and asparagines in the genome browser",
			D: "rgb(0,0,0)"
		},
		smpOverlays: {
			H: ['{"data":"Random:10:10:0:3","smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "array",
			C: "Sample annotations included in the 'data.x' object used in one dimensional plots",
			D: "[]",
			X: "getXData"
		},
		translateY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Amount to translate for the Y axis."
		},
		axisTitleFontSize: {
			S: ["autoScaleFont", "axisTitleScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Axis",
			T: "integer",
			C: "Font size for the axis titles in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the axis title scaling factor",
			D: "12"
		},
		shapeByData: {
			H: ['{"data":"MultidimensionalHeatmap","shapeByData":"data4","shapeBy":"DataShape"}'],
			S: ["shapeBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to shape data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data2)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		draw: {
			M: "Functions",
			T: "void",
			C: "Redraw the canvas"
		},
		featureNameFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the features in the genome browser",
			D: "10"
		},
		sequenceFColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the phenylalanines in the genome browser",
			D: "rgb(0,0,255)"
		},
		plotBoxColor: {
			S: ["plotBox"],
			H: ['{*,"plotBox":true}'],
			M: "General",
			T: "color",
			C: "Color for the box around the plot",
			D: "rgb(204,204,204)"
		},
		xAxisTickFormat: {
			H: ['{"xAxisTickFormat":"%.2f cxs","graphOrientation":"vertical"}'],
			M: "X-Axis",
			T: "string",
			C: "Format for the tick values in the X axis",
			D: "false"
		},
		shapeByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the shapeBy legend",
			D: "true"
		},
		drawArea: {
			M: "Functions",
			T: "void",
			C: "Display event areas"
		},
		resizerDataIndex: {
			Z: "true",
			M: "Axis Resizer",
			T: "integer",
			C: "Object to store data when the canvas is zoomed with the axis resizer resizerEventData  @type {object}",
			D: "0"
		},
		addRegressionLine: {
			M: "Functions",
			T: "void",
			C: "Add regression line(s) to a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		histogramDensityKernel: {
			H: ['{*,"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}'],
			S: ["createHistogram", "showHistogramDensity"],
			O: ["epanechnikovKernel", "uniformKernel", "triangularKernel", "quarticKernel", "triweightKernel", "gaussianKernel", "cosineKernel"],
			M: "Histograms",
			T: "option",
			C: "Histogram density kernels",
			D: "epanechnikovKernel"
		},
		isR: {
			M: "General",
			T: "boolean",
			C: "Flag to indicate is running from the R library",
			D: "false"
		},
		showVarOverlaysLegend: {
			H: ["{*}"],
			M: "Overlays",
			T: "boolean",
			C: "Flag to show or not the legend for the variable overlays in the graphs. If set to false the level information will be displayed in the actual colored boxes of the overlays",
			D: "false"
		},
		nodeSize: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Length in pixels for the size of the nodes in the network",
			D: "20"
		},
		maxRows: {
			M: "Data Table",
			T: "integer",
			C: "Maximum number of rows to display in the data table",
			D: "10"
		},
		pieLabelType: {
			H: ["{*}"],
			O: ["percentage", "value"],
			M: "Pie Charts",
			T: "option",
			C: "Pie label type to show the percentage of the slice or the actual number",
			D: "percentage"
		},
		patternByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the patternBy legend",
			D: "true"
		},
		yAxisShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the Y axis",
			D: "true",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		connectBy: {
			O: ["false"],
			T: "option",
			X: "getZData",
			H: ['{"graphType":"Scatter3D","connectBy":"Annt1"}', '{"graphType":"Scatter3D"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation to connect the variables.",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		contourType: {
			H: ['{*,"graphType":"Scatter2D"}'],
			S: ["images", "isHistogram", "histogramBarWidth"],
			O: ["overlay", "color"],
			M: "Contours",
			T: "option",
			C: "Type of contour plot",
			D: "overlay"
		},
		axisTickFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the axis ticks in one and two dimensional plots"
		},
		heatmapCellBoxColor: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for the heatmap boxes around the cells",
			D: "rgb(220,220,220)"
		},
		baseline: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["top", "middle", "bottom"],
			M: "Text",
			T: "option",
			C: "Default vertical alignment for drawing text.",
			D: "middle"
		},
		ringSeparation: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "integer",
			C: "Number of pixels to separate the rings in the circular plots",
			D: "8"
		},
		setMinX2: {
			H: ['{"graphType":"BarLine","setMinX2":50}', '{"graphType":"BarLine","setMinX2":20}', '{"graphType":"BarLine","setMinX2":null}'],
			M: "X-Axis2",
			T: "float",
			C: "Minimum value to set the data in the 2nd axis",
			D: "null",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		smpDendrogramPosition: {
			H: ['{*,"data":"Generic","graphType":"Heatmap","showSmpDendrogram":true}'],
			O: ["right", "left"],
			M: "Dendrograms",
			T: "option",
			C: "Position for the sample dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
			D: "left"
		},
		errorEllipseConfidence: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Default confidence for error ellipses.",
			D: "0.99"
		},
		xAxisHistogramHeight: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "integer",
			C: "Number of pixels for the histogram in the X axis",
			D: "50"
		},
		is3DPlot: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to create or not a 3D plot",
			D: "false"
		},
		isLayoutConfigurator: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the configurator when there is a click in the full layout icon in the toolbar",
			D: "false"
		},
		removeHistogram: {
			M: "Functions",
			T: "void",
			C: "Remove histogram from a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		disableDataFilters: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing data filters",
			D: "false"
		},
		createRandomData: {
			M: "Functions",
			T: "void",
			C: "Create a random data set"
		},
		yAxisMinorTicks: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show minor tick lines in the Y axis",
			D: "true"
		},
		helpKeyEvents: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable help on key events.",
			D: "false"
		},
		remoteUpdate: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to indicate that the file to get the data needs to be updated",
			D: "false"
		},
		titleAlign: {
			O: ["left", "center", "right"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Title alignment",
			D: "center"
		},
		shadowOffsetY: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Length in pixels for the shadow offset in the Y axis.",
			D: "1"
		},
		variableSeparationFactor: {
			S: ["sampleSeparationFactor", "widthFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "float",
			C: "Factor to adjust the spacing between the variables in the one dimensional plots.",
			D: "2"
		},
		transformCeilValue: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Value to ceil the data when transform type is ceil",
			D: "false"
		},
		citationFontStyle: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Citations or References",
			T: "option",
			C: "Font style for the citation.",
			D: ""
		},
		treemapBorderColor: {
			M: "Treemap Graphs",
			T: "color",
			C: "The color for the treemap header and border",
			D: "rgb(204,204,204)"
		},
		varSort: {
			Z: "true",
			M: "Data",
			T: "integer",
			C: "Variable index used in sorting the data."
		},
		yAxisTicks: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "integer",
			C: "Number of ticks in the Y axis",
			D: "5"
		},
		boxplotMeanColor: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the mean of data in boxplots",
			D: "rgb(255,215,0)"
		},
		decorations: {
			H: ['{"data":"NetworkDecorations","graphType":"Network","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"NonLinearFit","xAxisTransform":"log10","xAxisTransformTicks":false,"setMaxY":350,"setMinY":100,"yAxisExact":true}', '{"showDecorations":true,"graphType":"Scatter2D",{"line":[{"x":0.4,"y":200,"color":"rgb(255,125,51)","type":"dashedLine"},"decorations":{"x":0.15,"color":"rgb(51,255,125)","type":"line"}]},"data":"DecorationLine"}', '{"showDecorations":true,"graphType":"Bar","decorations":{"line":[{"value":0.25,"label":"Background","color":"rgb(255,125,51)","type":"dashedLine"}]},"data":"DecorationLines","graphOrientation":"vertical"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addRegressionLine","draw"]}', '{"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","decorations":{"area":[{"x":1.42,"y":322,"label":"Area","width":1.2,"height":30,"color":"rgb(255,125,51,0.5)","ouline":"rgb(255,125,51,0.5)","pattern":"closed","rotate":0.1,"type":"oval"}]},"data":"DecorationArea"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeier","showLegend":false,"title":"Kaplan-Meier Plot","functions":["addKaplanMeierCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeierCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
			S: ["showDecorations"],
			M: "Decorations",
			T: "array",
			C: "Name of the node properties to include in the network decorations in the 'data.nodes' object",
			D: "false"
		},
		titleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the title"
		},
		layoutCollapse: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to make layout graphs without any space in between",
			D: "false"
		},
		sequenceFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the sequences.",
			D: ""
		},
		showCode: {
			M: "Debug",
			T: "boolean",
			C: "Flag to show code for the canvas.",
			D: "false"
		},
		autoHideOnDecorationsCenter: {
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to hide node when decorations are positioned on the center",
			D: "false"
		},
		colors: {
			S: ["colorScheme"],
			H: ['{"data":"Random:16:1:0:0:1","graphType":"Pie"}'],
			M: "Colors",
			T: "array",
			C: "Colors.",
			D: "colors"
		},
		showSampleNames: {
			H: ["{*}"],
			M: "Samples",
			T: "boolean",
			C: "Flag to show the sample names in one dimensional plots.",
			D: "true"
		},
		panningX: {
			M: "Zooming and Panning",
			T: "float",
			C: "Number of unit to pan the network in the X dimension",
			D: "0"
		},
		yAxisCurrent: {
			H: ['{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":0}', '{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":1}'],
			M: "Y-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the Y axis when there are more series in the X axis than in the Y axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		citationFontSize: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "integer",
			C: "Size for the text of the reference citation of the graph",
			D: "7"
		},
		maxItemMenuCheckbox: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Maximum number of items in a menu before it becomes a scroll box",
			D: "10"
		},
		shadowColor: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "color",
			C: "Color for the shadow.",
			D: "rgba(0,0,0,0.5)"
		},
		xAxis2Show: {
			H: ["{*}"],
			M: "X-Axis2",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the second X axis",
			D: "true"
		},
		showCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Show the code for the plot  @advanced"
		},
		treeNodeId: {
			Z: "true",
			M: "Trees",
			T: "integer",
			C: "Id for the nodes in the tree",
			D: "0"
		},
		hullScale: {
			M: "Line Graphs",
			T: "float",
			C: "Scaling factor for hulls",
			D: "1.25"
		},
		addNormalDistributionLine: {
			M: "Functions",
			T: "void",
			C: "Add a normaldistribution line(s) to a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		kmeansSamples: {
			S: ["kmeansSmpClusters", "maxIterations"],
			M: "Functions",
			T: "void",
			C: "Cluster samples using kmeans",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		eventArrowKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable arrow key binding events.",
			D: "true"
		},
		maxTextSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Maximum size for any text in the canvas.",
			D: "40"
		},
		xAxisTitle: {
			H: ['{"xAxisTitle":"X-axis title"}'],
			M: "X-Axis",
			T: "string",
			C: "Title for the X axis",
			D: "false"
		},
		functionIntervals: {
			H: ['{*,"data":"Function"}'],
			M: "Scatter Plots",
			T: "integer",
			C: "Number of intervals to use when drawing functions in the decorations. In Scatter 3D is more like a factor",
			D: "25"
		},
		layoutCanvasCompartments: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to draw lines around each graph in the layout in the canvas.",
			D: "false"
		},
		gradient: {
			S: ["gradientType"],
			H: ['{*,"data":"Random:1:3:0:0"}'],
			M: "Gradients",
			T: "boolean",
			C: "Flag used to apply gradients to all objects in the graphs.",
			D: "false"
		},
		yAxisTopMajorTick: {
			H: ["{*}"],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show the top major tick line in the Y axis in Scatter2D plots",
			D: "true"
		},
		genomeResolution: {
			Z: "true",
			O: ["low", "medium", "high"],
			M: "Genome Browser",
			T: "option",
			C: "Number to adjust the splines curvature"
		},
		erroBarsWidth: {
			H: ['{"showErrorBars":true,"erroBarsWidth":2,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":true,"erroBarsWidth":10,"functions":["groupSamples:Factor1"]}'],
			M: "Data",
			T: "integer",
			C: "Minimum size of the bar in pixels to determine to show or hide error bar ends in the graphs when available.",
			D: "2"
		},
		nodeFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text in networks"
		},
		maxCols: {
			M: "Data Table",
			T: "integer",
			C: "Maximum number of columns to display in the data table",
			D: "6"
		},
		sma5Color: {
			H: ['{*,"stockIndicators":["Sma5"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 5 day single moving average",
			D: "rgb(255,0,0)"
		},
		rAxisAbsMax: {
			Z: "true",
			M: "R-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the R axis"
		},
		x3DRatio: {
			H: ['{"graphType":"Scatter3D","x3DRatio":0.5}', '{"graphType":"Scatter3D","x3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the X Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		missingDataValue: {
			M: "Data",
			T: "string",
			C: "String value use to specify missing data",
			D: "NA "
		},
		histogramStagger: {
			H: ['{"data":"Random:500:3","functions":["createHistogram"],"histogramStagger":false}', '{"data":"Random:500:3","functions":["createHistogram"],histogramStagger":true}'],
			S: ["createHistogram"],
			M: "Histograms",
			T: "boolean",
			C: "Flag to stagger histograms when multiple variables are present",
			D: "false"
		},
		treeInverted: {
			M: "Trees",
			T: "boolean",
			C: "Flag to plot the tree inverted.",
			D: "false"
		},
		heatmapIndicatorHistogram: {
			H: ["{*}"],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to show histogram in the heatmap indicator",
			D: "false"
		},
		sequenceGAPColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the deletions, insertions and gaps in the genome browser",
			D: "rgb(255,0,255)"
		},
		tagCloudTextGridSize: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "integer",
			C: "Size for the grid in text tag cloud visualizations",
			D: "8"
		},
		smpTitleFontStyle: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Samples",
			T: "option",
			C: "Font style for the samples.",
			D: ""
		},
		showViolinBoxplot: {
			H: ['{"data":"Boxplot","showViolinBoxplot":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","showViolinBoxplot":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show violin plot in boxplots",
			D: "false"
		},
		remoteServiceType: {
			S: ["remoteService", "remoteParams"],
			O: ["webService", "file"],
			M: "Remote Procedures",
			T: "string",
			C: "Type of web service to obtain data remotely",
			D: "webService"
		},
		maintainZoomOnDrag: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable maintaining zooming after initial drag in one dimensional plots",
			D: "false"
		},
		disableConfigurator: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable configurator.",
			D: "false"
		},
		colorSpectrum: {
			S: ["colorSpectrumBreaks"],
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "array",
			C: "An array with valid color names to create a color brew for the default color indicators",
			D: ["#4575b4", "#91bfdb", "#e0f3f8", "#ffffbf", "#fee090", "#fc8d59", "#d73027"]
		},
		boxplotMedianColor: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the line of the median of data in boxplots",
			D: "rgb(0,0,0)"
		},
		sequenceIColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the isoleucines in the genome browser",
			D: "rgb(0,103,0)"
		},
		colorHSV: {
			Z: "true",
			M: "Colors",
			T: "array",
			C: "Color HSV. Hue, Saturation and Value used in the configurator"
		},
		correlationAnchorLegendAlignWidth: {
			H: ['{*,"correlationAnchorLegend":true}'],
			M: "Correlation Graphs",
			T: "integer",
			C: "Length in pixels of the height of the correlation anchor legend",
			D: "40"
		},
		smpTitle: {
			H: ['{"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "string",
			C: "Title for the sample axis in one dimensional plots",
			D: "false"
		},
		axisTitleFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Axis",
			T: "option",
			C: "Font style for the axis titles.",
			D: ""
		},
		shapeEdgeBy: {
			H: ['{"data":"LesMiserables","shapeEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to shape the nods.",
			D: "false"
		},
		tagCloudTextRotateRatio: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "float",
			C: "Ratio for rotation of text in cloud visualizations",
			D: "0.1"
		},
		featureNameFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the feature name.",
			D: ""
		},
		reproduceTime: {
			M: "General",
			T: "integer",
			C: "Time to wait in milliseconds to reproduce user modifications",
			D: "1000"
		},
		scatterPlotMatrixType: {
			H: ['{*,"graphType":"Scatter2D","scatterPlotMatrix":true}'],
			S: ["scatterPlotMatrix"],
			O: ["completeBoth", "completeUpper", "completeLower", "first"],
			M: "Scatter Plot Matrix",
			T: "option",
			C: "Type for the matrix of 2D sccaterplots",
			D: "completeBoth"
		},
		leafletConfig: {
			M: "Maps",
			T: "object",
			C: "Leaflet config",
			D: "false"
		},
		xAxis2MaxStrLength: {
			Z: "true",
			M: "X-Axis2",
			T: "string",
			C: "Longest string of all the values in the ticks in the 2nd X axis"
		},
		randomNetworkNodes: {
			M: "Random",
			T: "integer",
			C: "Default number of nodes when creating random networks",
			D: "50",
			U: {
				Network: "true"
			}
		},
		show3DGrid: {
			H: ["{*}"],
			M: "3D Attributes",
			T: "boolean",
			C: "Flag to show the X,Y,Z grid in 3D plots",
			D: "true",
			U: {
				Scatter3D: "true"
			}
		},
		legendOrder: {
			M: "Legends",
			T: "object",
			C: "Object to specify custom order for the levels in the legends. The key of the object is the name of an annotation in the data.x object, or the name of an annotation in the data.z object. The value for each key is an array with the levels for the corresponding factor  @defaul false"
		},
		showHistogramDensity: {
			H: ['{*,"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}'],
			S: ["createHistogram", "histogramDensityKernel"],
			M: "Histograms",
			T: "boolean",
			C: "Flag to show the density kernel in histograms",
			D: "false"
		},
		codeType: {
			O: ["pretty", "compact", "tab", "params"],
			M: "Debug",
			T: "option",
			C: "Output type for the JSON code",
			D: "params"
		},
		xAxis2MinorValues: {
			M: "X-Axis2",
			T: "array",
			C: "Values for the minor ticks in the 2nd X axis",
			D: "[]",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		fontName: {
			H: ["{*}"],
			O: ["Courier", "Arial", "Verdana", "sans-serif", "Indie Flower", "Ubuntu", "Architects Daughter", "Roboto"],
			M: "Text",
			T: "option",
			C: "Font name. It will be set depending on the browser.",
			D: "Arial"
		},
		smpLabelInterval: {
			H: ["{*}"],
			M: "Samples",
			T: "integer",
			C: "Interval for the sample labels in one dimensional and circular plots",
			D: "1"
		},
		ellipseBy: {
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Utility to create error ellipses in Scatter plots  @funtion getZData",
			D: "false"
		},
		dataTableColumnWidth: {
			Z: "true",
			M: "Data Table",
			T: "array",
			C: "Set the initial fonts"
		},
		highlightSmp: {
			H: ['{"highlightSmp":["Sample1","Sample3"]}'],
			M: "Samples",
			T: "array",
			C: "Name of samples in the 'data.y' object to highlight.",
			D: "[]",
			X: "getSamplesAsArray"
		},
		decorationsHeight: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"left","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "integer",
			C: "Length in pixels of the height for the decorations in the networks",
			D: "20",
			U: {
				Network: "true"
			}
		},
		smpLabelFontColor: {
			H: ["{*}"],
			M: "Samples",
			T: "color",
			C: "Font color for the sample labels in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		tagCloudTextWeightFactor: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "integer",
			C: "Factor weight for text in tag cloud visualizations",
			D: "1"
		},
		sequenceBColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate C/G/T and asparagines in the genome browser",
			D: "rgb(0,0,0)"
		},
		colorNodeBy3: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to color the nodes.",
			D: "false"
		},
		segregateVariables: {
			S: ["segregateVariables"],
			M: "Functions",
			T: "option",
			C: "Segregate variables based on a variable category (data.z object)",
			X: "getZData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		coordinateLineColor: {
			H: ['{*,"graphType":"BarLine"}'],
			M: "Line Graphs",
			T: "boolean",
			C: "Flag to used same color in BarLine plots. If set to true the color of the bars and the lines will be the same",
			D: "false"
		},
		axisTickWidth: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Width for the axis ticks in one and two dimensional plots",
			D: "1"
		},
		adjustAspectRatioMax: {
			M: "Aspect Ratio",
			T: "integer",
			C: "Specifies the number of times to try to automatically adjust the size of the canvas when adjustAspectRatio is true",
			D: "3"
		},
		dendrogramColor: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
			M: "Dendrograms",
			T: "color",
			C: "The color for the dendrograms",
			D: "rgb(0,0,0)"
		},
		widthFactor: {
			S: ["sampleSeparationFactor", "variableSeparationFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "integer",
			C: "Factor to adjust the width of the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider then increase this parameter (2 is twice as wide).",
			D: "1"
		},
		sequenceQColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamines in the genome browser",
			D: "rgb(0,0,0)"
		},
		oncoprintDeletion: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Threshold to qualify deletions in oncoprints",
			D: "1"
		},
		adjustAspectRatioHeatmapIndicator: {
			H: ["{*}"],
			S: ["adjustAspectRatio"],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to adjust aspect ratio of heatmap indicator. It depends on the adjustAspectRatio parameter; that is, the adjustAspectRatio parameter has to set to true for the adjustAspectRatioHeatmapIndicator to take effect.",
			D: "true"
		},
		layoutAxis: {
			Z: "true",
			O: ["1", "2", "3"],
			M: "Combination Plots",
			T: "option",
			C: "Flag to indicated whether to print axes values when multiple graphs are displayed in the canvas. The possible values are: 1: horizontal, 2: vertical, 3: both"
		},
		smpIndicesStart: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "integer",
			C: "Number that indicates starting point for samples in heatmaps when the canvas is zoom in."
		},
		adjustAspectRatioXTries: {
			Z: "true",
			M: "Aspect Ratio",
			T: "integer",
			C: "Counter set when trying to automatically adjust the horizontal size of the canvas when adjustAspectRatio is true"
		},
		RdatastesURL: {
			Z: "true",
			M: "R",
			T: "array",
			C: "URL for R objects"
		},
		xAxisCurrent: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":1}'],
			M: "X-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the X axis when there are more series in the Y axis than in the X axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		zAxisCurrent: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":1}'],
			M: "Z-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the Z axis when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true"
			}
		},
		isMultidimensionalData: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to indicate if there is more than a single data set."
		},
		nodeScaleFontFactor: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "float",
			C: "Scaling factor used to increse or decrease network text font size in the canvas.",
			D: "1"
		},
		evenColor: {
			S: ["blockContrast", "oddColor"],
			H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
			M: "Colors",
			T: "color",
			C: "The color for the even numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
			D: "rgb(245,245,245)"
		},
		backgroundWindowGradient2Color: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowSolidGradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the second color of the gradient if the background type is of the type of 'windowGradient'.",
			D: "rgb(0,0,36)"
		},
		startPieSectors: {
			H: ['{"startPieSectors":0}', '{"startPieSectors":90}', '{"startPieSectors":180}', '{"startPieSectors":270}'],
			M: "Pie Charts",
			T: "float",
			C: "Starting degrees for pie sectors. 0 is equivalent to 3:00 oclock",
			D: "0"
		},
		showLevelOverlays: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "boolean",
			C: "Flag to indicate to show or not the level overlays in one dimensional plots",
			D: "true"
		},
		sizeByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the sizeBy legend",
			D: "true"
		},
		legendBoxColor: {
			S: ["legendBox"],
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the box around the legend",
			D: "rgb(204,204,204)"
		},
		layoutTopology: {
			M: "Combination Plots",
			T: "string",
			C: "Topology of the canvas. Number of rows and columns separated by X. For example: 2X1, 1X3, etc.",
			D: "false"
		},
		rotationSensitivity: {
			M: "3D Attributes",
			T: "integer",
			C: "Factor to adjust the sensitivity of the mouse when rotating the graph",
			D: "450"
		},
		networkConvexHulls: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array for the Network community convex hull property object"
		},
		selectDataMode: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["area", "transparency", "name"],
			M: "Scatter Plots",
			T: "option",
			C: "Type of mode to highlight selected data points with mouse events. (Shift + mouse drag)  @see{selectDataModeDescription}",
			D: "area"
		},
		legendColumns: {
			H: ["{*}"],
			M: "Legends",
			T: "integer",
			C: "Number of columns for the variable legends in one dimensional plots",
			D: "1"
		},
		font: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "The combination of font name style and size.",
			D: "Verdana 12pt"
		},
		skipClick: {
			Z: "true",
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to skip click events after a mouse down event in the networks when the eventModel is global"
		},
		trackNameFontColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the text of the tracks in the genome browser",
			D: "rgb(0,0,0)"
		},
		trackFillColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the fill of the tracks in the genome browser",
			D: "rgb(255,255,255)"
		},
		patternKey: {
			M: "Data Point Attributes",
			T: "object",
			C: "Object to assign custom patterns to sample annotations and variable annotations included in the data object. The key of the object is the name of an annotation in the data.x object or the name of an annotation in the data.z object. A default pattern will be assigned to a data point whose value was not included the object.",
			D: "false"
		},
		scaleTextConstantMult: {
			Z: "true",
			M: "Text",
			T: "integer",
			C: "Constants to autoscale text",
			D: "25"
		},
		varLabelDescription: {
			H: ['{"data":"Random:16:3:3:0","varLabelDescription":"Annt3"}'],
			M: "Variables",
			T: "string",
			C: "Variable label description is a valid sample classification included in the 'data.z' object used in heatmaps",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		linkage: {
			H: ['{"graphType":"Heatmap","linkage":"single","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"complete","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"average","functions":["clusterSamples","clusterVariables"]}'],
			S: ["distance", "clusterAxis", "imputeMethod", "clusterSamples", "clusterVariables"],
			O: ["single", "complete", "average"],
			M: "Clustering",
			T: "option",
			C: "Linkage type to use when clustering data.",
			D: "complete"
		},
		images: {
			S: ["scatterType"],
			M: "General Attributes",
			T: "array",
			C: 'Array of urls of images used in scatter plots.  @exs {"data":"Random:6:3:0:0","graphType":"Scatter2D","scatterType":"image","images":["area", "bar", "boxplot", "heatmap", "line", "pie"]}',
			D: "[]"
		},
		titleFontSize: {
			S: ["title", "titleColor"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "integer",
			C: "Font size for the title of the graph. The font height will be adjusted automatically to fit in the canvas.",
			D: "16"
		},
		adjustAspectRatio: {
			S: ["variableSeparationFactor", "sampleSeparationFactor", "widthFactor", "adjustAspectRatioHeatmapIndicator"],
			H: ['{*,"graphOrientation":"vertical"}'],
			M: "Aspect Ratio",
			T: "boolean",
			C: "Flag to automatically adjust the size of the bars or points in the one dimensional plots to fit in the provided canvas width and height. If the flag is set to 'false' the width and height of the canvas will be sized according to the number of bars or points in the data set.",
			D: "true"
		},
		layoutBoxShow: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to draw the layout boxes.",
			D: "true"
		},
		sequenceStartColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the start codon in the genome browser",
			D: "rgb(0,204,0)"
		},
		smpLabelDescription: {
			H: ['{"data":"Random:16:3:0:3","smpLabelDescription":"Factor3"}'],
			M: "Samples",
			T: "string",
			C: "Sample label description is a valid sample classification included in the 'data.x' object used in heatmaps",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		backgroundGradient1Color: {
			S: ["backgroundType", "backgroundGradient2Color"],
			H: ['{*,"backgroundType":"gradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the first color of the gradient if the background type is of the type of 'gradient'.",
			D: "rgb(0,0,200)"
		},
		smpLabelFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the sample labels in one dimensional plots"
		},
		timeValueIndices: {
			M: "X-Axis",
			T: "array",
			C: "Array containing the indices of the values when the the graph is a time series",
			D: "[]"
		},
		yAxisBottomMajorTick: {
			H: ["{*}"],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show the bottom major tick line in the Y axis in Scatter2D plots",
			D: "true"
		},
		useVocabulary: {
			M: "Gradients",
			T: "boolean",
			C: "Use vocabulary to improve loading of large data sets. experimental",
			D: "false"
		},
		legendColor: {
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the legends",
			D: "rgb(0,0,0)"
		},
		layoutAdjust: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to force recalculating the ranges in the axes when multiple graphs are displayed in the canvas.",
			D: "false"
		},
		hierarchyVar: {
			H: ['{*,"graphType":"Circular","circularType":"sunburst","hierarchyVar":"Variable1"}'],
			M: "Hierarchy",
			T: "string",
			C: "Variable name to use in the sankey, sunburst and bubble graphs",
			D: "false"
		},
		invMagnificationFactor: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "float",
			C: "Factor to use initial magnification of the plot. The higher the value the smaller the maginication.",
			D: "4"
		},
		featureNameFontColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the text of the features in the genome browser",
			D: "rgb(0,0,0)"
		},
		xAxisLeftRightTickColor: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "color",
			C: "Color for the left and right tick lines in the Y axis",
			D: "rgb(204,204,204)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		isSelectNodes: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of selected nodes (in the data object).",
			D: "0"
		},
		treemapBy: {
			M: "Data Point Attributes",
			T: "array",
			C: "Array of sample annotations to treemap the variables. The array may also include 'sample' to use as last level.",
			D: "[]",
			X: "getXData"
		},
		varHighlightColor: {
			H: ['{*,"highlightVar":["Variable1","Variable3"]}'],
			M: "Variables",
			T: "color",
			C: "The color for the highlighted variables.",
			D: "rgb(255,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		startRow: {
			Z: "true",
			M: "Data Table",
			T: "integer",
			C: "Starting row in the data table"
		},
		remoteAutoPlayDelay: {
			M: "Remote Procedures",
			T: "integer",
			C: "Time in milliseconds to wait between iterations while automatically going over remote data sets",
			D: "3000"
		},
		transformFloorValue: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Value to floor the data when transform type is floor",
			D: "false"
		},
		axisAlgorithm: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["heckbert", "wilkinson", "wilkinsonExtended", "rPretty"],
			M: "Axis",
			T: "option",
			C: "Algorithm to position labels in axis",
			D: "heckbert"
		},
		heatmapCellBox: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to print a box around the heatmap cells",
			D: "true"
		},
		boxplotMedianWidth: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Width for the line of the median of data in boxplots",
			D: "1"
		},
		lines: {
			Z: "true",
			H: ['{"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["", "dashed", "dotted", "bezierY", "bezierX", "curved", "arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"],
			M: "Lines",
			T: "array",
			C: "Line types available network graphs The patterns can be: '', 'dashed', 'dotted', 'bezierY', 'bezierX' and 'curved'. The end could be: 'arrow', 'arrowHead', 'arrowTail', 'arrowHeadSquareTail', 'arrowTailSquareHead', 'square', 'squareHead', 'squareTail', 'squareHeadArrowTail' or 'squareTailArrowHead'."
		},
		varTitleScaleFontFactor: {
			H: ['{*,"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "float",
			C: "Scaling factor used to increse or decrease variable font size in the canvas.",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		sequenceHColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/T and histidines in the genome browser",
			D: "rgb(255,0,0)"
		},
		showPieGrid: {
			H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the labels for the grid when plotting multiple pies",
			D: "true"
		},
		timeFormat: {
			O: ["default", "shortDate", "mediumDate", "longDate", "fullDate", "shortTime", "mediumTime", "longTime", "isoDate", "isoTime", "isoDateTime", "isoUtcDateTime"],
			M: "General Attributes",
			T: "option",
			C: "Time Format according to date.format.js Steven Levithan <stevenlevithan.com>",
			D: "isoDate"
		},
		theme: {
			O: ["none", "economist", "excel", "tableau", "stata", "igray", "solarized", "paulTol", "ggplot", "wallStreetJournal", "cx"],
			M: "General",
			T: "option",
			C: "Themes for the plot. This parameter will overwrite colors, background, axes, etc",
			D: "none"
		},
		networkStackStates: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Number of states to keep in the network stack after a drag or move",
			D: "8"
		},
		sizeKey: {
			M: "Data Point Attributes",
			T: "object",
			C: "Object to assign custom sizes to sample annotations and variable annotations included in the data object. The key of the object is the name of an annotation in the data.x object or the name of an annotation in the data.z object. A default size will be assigned to a data point whose value was not included the object.",
			D: "false"
		},
		sequenceEColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamic acids in the genome browser",
			D: "rgb(0,0,0)"
		},
		treeVarIndex: {
			Z: "true",
			M: "Trees",
			T: "integer",
			C: "Variable index to use in the tree diagrams",
			D: "0"
		},
		hideCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Hide the code for the plot  @advanced"
		},
		varDendrogramNewick: {
			M: "Dendrograms",
			T: "string",
			C: "Dendrogram in Newick format for the variables",
			D: "true"
		},
		trackNameFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the tracks in the genome browser",
			D: "10"
		},
		sequenceEndColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the end codon in the genome browser",
			D: "rgb(255,0,0)"
		},
		subtitleColor: {
			S: ["subtitle", "subtitleHeight"],
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "color",
			C: "Color for the subtitle",
			D: "rgb(0,0,0)"
		},
		legendFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the legends"
		},
		xAxisHistogramShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to indicate whether to show a histogram for the data in the X axis",
			D: "false"
		},
		randomDataSampleAnnotationRatio: {
			M: "Random",
			T: "integer",
			C: "Approximate number of samples in each class",
			D: "6"
		},
		objectBorderColor: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "color",
			C: "The color for the border of all objects in one dimensional graphs.",
			D: "rgb(0,0,0)"
		},
		xAxis2Values: {
			M: "X-Axis2",
			T: "array",
			C: "Values for the ticks in the 2nd X axis",
			D: "[]",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		freezeRowBottom: {
			M: "Data Table",
			T: "integer",
			C: "Number of rows to freeze at the bottom of the data table",
			D: "0"
		},
		overrideEventlessNodes: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to override nodes that do not take events to be able to edit them",
			D: "false"
		},
		tagCloudTextEllipticity: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "float",
			C: "Ellipticity for the for text in tag cloud visualizations",
			D: "0.65"
		},
		xAxisTransformTicks: {
			H: ['{*,"xAxisTransform":"log10","graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to transform the values of the ticks in the X axis",
			D: "true",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		legendScaleFontFactor: {
			H: ["{*}"],
			M: "Legends",
			T: "float",
			C: "Scaling factor used to increase or decrease legend font size in the canvas.",
			D: "1"
		},
		tmpAsciiArray: {
			Z: "true",
			M: "Data",
			T: "array",
			C: "A temporary array to enable sorting data asciibetically."
		},
		boxplotDataPointTransparency: {
			S: ["showBoxplotOriginalData", "jitterColumns", "jitter"],
			H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.5,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.2,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "float",
			C: "Fraction to adjust color transparency for the data points when displaying original data in boxplots.",
			D: "0.5"
		},
		showRingLegend: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to show legends in each ring of a circular graph",
			D: "true"
		},
		sma50Color: {
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 50 day single moving average",
			D: "rgb(0,0,0)"
		},
		trackNameFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the tracks in the genome browser"
		},
		networkDivisions: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of angular divisions in the radial network."
		},
		calculateNetworkCommunities: {
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to calculate the network communities using the jLouvain algorithm. If this flag is false the property community for each node will need to be provided",
			D: "true"
		},
		pieColors: {
			H: ['{"data":"Generic","graphType":"Pie", "pieColors":["rgb(0,0,117)", "rgb(117,0,36)", "rgb(117,88,0)", "rgb(53,117,0)", "rgb(76,0,117)", "rgb(117,53,0)", "rgb(117,117,0)", "rgb(0,117,117)", "rgb(117,0,0)", "rgb(117,97,0)", "rgb(28,0,117)", "rgb(0,117,0)", "rgb(117,0,117)", "rgb(117,67,0)", "rgb(97,117,0)", "rgb(0,66,117)", "rgb(50,0,117)", "rgb(117,33,0)", "rgb(117,107,0)", "rgb(0,117,67)", "rgb(117,0,66)","rgb(117,78,0)", "rgb(78,117,0)", "rgb(0,36,117)"]}'],
			M: "Pie Charts",
			T: "array",
			C: "Pie Colors. Defaults to the parameter colors.",
			D: "[]"
		},
		randomData: {
			Z: "true",
			M: "Random",
			T: "boolean",
			C: "Flag to indicate random data for debug and demonstration purposes"
		},
		jitter: {
			H: ['{"data":"Boxplot","graphType":"Dotplot","jitter":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Dotplot","jitter":false,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":false,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}'],
			S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "jitterColumns"],
			M: "Plot area",
			T: "boolean",
			C: "Flag to jitter the point in dotplots and boxplots",
			D: "true",
			U: {
				Boxplot: "true",
				DotLine: "true",
				Dotplot: "true"
			}
		},
		resizerDraw: {
			M: "Axis Resizer",
			T: "boolean",
			C: "Flag to make the axis resizers draw the canvas as they move",
			D: "false"
		},
		temperature: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
			D: "0"
		},
		motionControlHeight: {
			S: ["motionBy"],
			M: "Data Point Attributes",
			T: "integer",
			C: "Length in pixels for the height of the motion controls",
			D: "50"
		},
		sequenceFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the sequence in the genome browser",
			D: "10"
		},
		featureTypeDefault: {
			O: ["box", "bar", "heatmap", "sequence", "triangle", "line"],
			M: "Genome Browser",
			T: "option",
			C: "Default type for the feature in the genome browser",
			D: "line"
		},
		panningStep: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Percentage step for panning networks.",
			D: "0.2"
		},
		contourYBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of Y bins in contour plots",
			D: "false"
		},
		resizableY: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable resizing the height of canvas by dragging the mouse over the edges",
			D: "true"
		},
		zAxisValues: {
			M: "Z-Axis",
			T: "array",
			C: "Values for the ticks in the Z axis",
			D: "[]"
		},
		disableAxisResizer: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable the axis resizer.",
			D: "false"
		},
		dotplotType: {
			H: ['{*,"graphType":"Dotplot"}'],
			O: ["normal", "stacked"],
			M: "Dotplot Graphs",
			T: "option",
			C: "Flag to produce normal or stacked dotplot graphs",
			D: "normal"
		},
		overlayFontSize: {
			H: ['{*,"autoScaleFont":false,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "integer",
			C: "Font size for the overlays in one dimensional plots",
			D: "12"
		},
		backgroundWindowGradientOrientation: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowGradient"}'],
			O: ["vertical", "horizontal"],
			M: "Background",
			T: "option",
			C: "Specifies the orientation of the gradient if the background type is of the type 'windowGradient' or 'windowGradient2'.",
			D: "vertical"
		},
		yAxisTransformTicks: {
			H: ['{*,"yAxisTransform":"log10","graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to transform the values of the ticks in the Y axis",
			D: "true"
		},
		isCreateHistogram: {
			Z: "true",
			M: "Histograms",
			T: "boolean",
			C: "Flag to indicate there is a histogram",
			D: "false"
		},
		setMaxX2: {
			H: ['{"graphType":"BarLine","setMaxX2":200}', '{"graphType":"BarLine","setMaxX2":50}', '{"graphType":"BarLine","setMaxX2":null}'],
			M: "X-Axis2",
			T: "float",
			C: "Maximum value to set the data in the 2nd axis",
			D: "null",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		varIndicesStart: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "integer",
			C: "Number that indicates starting point for variables in heatmaps when the canvas is zoom in."
		},
		autoScaleFont: {
			S: ["smpLabelFontSize", "varLabelFontSize", "legendFontSize", "axisTickFontSize", "axisTitleFontSize"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "boolean",
			C: "Flag to automatically adjust the font size in many visualization. Please be aware that scaling factors can still modify the font size. This flag needs to be false for the text to accept the specified font size.",
			D: "true"
		},
		rAxisValues: {
			M: "R-Axis",
			T: "array",
			C: "Values for the ticks in the R axis",
			D: "[]"
		},
		leafletCSS: {
			M: "Maps",
			T: "array",
			C: "Leaflet CSS files",
			D: ["https://canvasxpress.org/css/leaflet.css"]
		},
		backgroundGradient2Color: {
			S: ["backgroundType", "backgroundGradient1Color"],
			H: ['{*,"backgroundType":"gradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the second color of the gradient if the background type is of the type of 'gradient'.",
			D: "rgb(0,0,36)"
		},
		showHeatmapIndicator: {
			H: ['{*,"data":"Random:16:4:0:0","colorBy":"Sample4","graphType":"Scatter3D"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to show the heatmap color indicator",
			D: "true"
		},
		videoGrid: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to show grid in video",
			D: "false"
		},
		decorationFontStyle: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Decorations",
			T: "option",
			C: "Font style for the decorations.",
			D: ""
		},
		titleScaleFontFactor: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "float",
			C: "Scaling factor used to increase or decrease the title font size in the canvas.",
			D: "1"
		},
		rAxisPercentShow: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "boolean",
			C: "Flag to show on not the percent in each segment in the R axis",
			D: "true"
		},
		dataFilterWidth: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the data filters.",
			D: "180"
		},
		overlayFontStyle: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Overlays",
			T: "option",
			C: "Font style for the overlays.",
			D: ""
		},
		transparency: {
			H: ["{*}"],
			M: "General",
			T: "float",
			C: "Percentage of transparency applied to all elements in the visualizations",
			D: "null"
		},
		isNetworkCommunities: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create network communities",
			D: "false"
		},
		smpOverlayProperties: {
			M: "Overlays",
			T: "object",
			C: "Object to assign properties to the variable overlays. The key should be an annotation in the 'data.z' object and the value may contain 'type' which could be either one of the one dimensional graph types or Increase, or Decrease for continuous annotations; 'color' to assign the color for the Bar, Line, etc.; 'level' which is an object where the key is the level and the value is the corresponding color. 'height' to identify how tall the overlay will be",
			D: "{}"
		},
		zAxisTickColor: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "color",
			C: "Color for the tick lines in the Z axis",
			D: "rgb(204,204,204)"
		},
		transform: {
			S: ["transformType", "transformBase", "ratioReference", "zscoreAxis"],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
			M: "Functions",
			T: "option",
			C: "Transform all the data. Warning: the option 'save' overwrites the original data",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		leafletInit: {
			M: "Maps",
			T: "function",
			C: "Leaflet Init Function",
			D: "false"
		},
		transformType: {
			H: ["{*}"],
			S: ["transformedData", "transformAxis"],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "ceil", "floor", "save", "reset", "undo"],
			M: "Data",
			T: "option",
			C: "Default transformation type.",
			D: "false"
		},
		timeValues: {
			M: "X-Axis",
			T: "array",
			C: "Array containing the tick values when the the graph is a time series",
			D: "[]"
		},
		sequenceKColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate G/T and lysines in the genome browser",
			D: "rgb(255,0,0)"
		},
		backgroundWindowGradient1Color: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowSolidGradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the first color of the gradient if the background type is of the type of 'windowGradient'.",
			D: "rgb(0,0,200)"
		},
		disableDataTable: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing data table",
			D: "false"
		},
		maxFeatureStringLen: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Maximum length in characters a feature label can have so anything above is truncated.",
			D: "30"
		},
		yAxis: {
			H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "array",
			C: "Name of the samples groups or variables to be displayed in the Y axis",
			D: "[]",
			X: "getSamplesAsArray",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		setMinX: {
			H: ['{"setMinX":50}', '{"setMinX":20}', '{"setMinX":null}'],
			M: "X-Axis",
			T: "float",
			C: "Minimum value to set the data in the X axis",
			D: "null"
		},
		sizeBy: {
			S: ["sizeByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","sizeBy":"Annt1"}', '{"graphType":"Scatter3D","sizeBy":"Sample4"}', '{"graphType":"Dotplot","sizeBy":"Factor1"}', '{"graphType":"Dotplot","sizeBy":"Annt1"}', '{"graphType":"Dotplot","sizeBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to size the variables. When sizeByData is specified sizeBy is used for the title in the legend."
		},
		featureTranslateShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show tranlation",
			D: "true"
		},
		varTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the variable titles in one dimensional plots"
		},
		videoClassName: {
			H: ['{"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "string",
			C: "Video class name / css for videos",
			D: "video-js vjs-default-skin"
		},
		preScaleNetwork: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prescale or not the network. This is an aesthetic parameter to make the graph look nicer... Sometimes...",
			D: "false"
		},
		kmeansVarClusters: {
			H: ['{"graphType":"Heatmap","kmeansVarClusters":2,"functions":["kmeansSamples","kmeansVariables"]}', '{"graphType":"Heatmap","kmeansVarClusters":4,"functions":["kmeansSamples","kmeansVariables"]}'],
			S: ["maxIterations", "kmeansSmpClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of clusters when clustering variable data with kmeans.",
			D: "3"
		},
		sequencePColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the prolines in the genome browser",
			D: "rgb(255,165,0)"
		},
		randomDataSymmetrical: {
			M: "Random",
			T: "boolean",
			C: "Flag to add missing data to the random data for debug and demonstration purposes  @cfg {} randomDataMissing",
			D: "false"
		},
		isHistogram: {
			S: ["scatterType", "histogramBarWidth"],
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Histograms",
			T: "boolean",
			C: "Flag to convert the 2D scatter plot into a histogram. That is, the points in the scatter plot are converted to bars that start at the bottom of the Y axis. It is useful to represent proteomics spectra. This can also be done setting scatterType to 'bar'.",
			D: "false"
		},
		smpTitleFontColor: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "color",
			C: "Font color for the sample title in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		xRotate: {
			H: ['{"graphType":"Scatter3D","xRotate":0}', '{"graphType":"Scatter3D","xRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the X axis",
			D: "45"
		},
		featureCoordinateShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show coordinates",
			D: "true"
		},
		subtitleFontSize: {
			S: ["subtitle", "subtitleColor"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "integer",
			C: "Font size for the subtitle of the graph. The font height will be adjusted automatically to fit in the canvas.",
			D: "14"
		},
		weight: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Fraction of the canvas to be used (a value between 0 and 1). Used when multiple graphs are displayed in one canvas. Could be an number or an array of numbers."
		},
		showLegend: {
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Flag to show or not the legend in the graphs",
			D: "true"
		},
		sequenceYColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate C/T and tyrosines in the genome browser",
			D: "rgb(0,0,255)"
		},
		histogramBins: {
			H: ['{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}', '{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":10}'],
			S: ["createHistogram"],
			M: "Histograms",
			T: "integer",
			C: "Approximate number of bins in a histogram. It may vary considerably to the actual number used in the histogram to ensure a 'pretty' size for the intervals in the histogram.",
			D: "false"
		},
		yAxisTickStyle: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["solid", "dotted"],
			M: "Y-Axis",
			T: "option",
			C: "Style for the tick lines in the Y axis",
			D: "solid",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		networkFreeze: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prevent autoscaling for the network layout. Useful when images are part of the network.",
			D: "false"
		},
		varTitle: {
			H: ['{"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "string",
			C: "Title for the sample axis in one dimensional plots",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		stockIndicators: {
			H: ['{"graphType":"Candlestick"}'],
			O: ["Sma5", "Sma10", "Sma20", "Sma25", "Sma50"],
			M: "Candlestick Plots",
			T: "array",
			C: "Stock technical indicators",
			D: ["Sma5", "Sma10", "Sma25"]
		},
		scatterPlotMatrix: {
			H: ['{"graphType":"Scatter2D","scatterPlotMatrix":true}'],
			S: ["scatterPlotMatrixType"],
			M: "Scatter Plot Matrix",
			T: "boolean",
			C: "Flag to plot a matrix of 2D sccaterplots",
			D: "false"
		},
		loessIteration: {
			M: "Loess",
			T: "integer",
			C: "Loess iterations",
			D: "2"
		},
		featureCoordinateHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the coordinates height",
			D: "12"
		},
		showPieSampleLabel: {
			H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the sample label when plotting multiple pies",
			D: "true"
		},
		backgroundImage: {
			S: ["backgroundType"],
			H: ['{"backgroundType":"image","backgroundImage":"https://canvasxpress.org/images/nanotube.jpg"}', '{"backgroundType":"windowImage","backgroundImage":"https://canvasxpress.org/images/nanotube.jpg"}'],
			M: "Background",
			T: "url",
			C: "Specifies the url for the background image when the background type is of the type 'image' or 'windowImage'.",
			D: "false"
		},
		minTextSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Minimum size for any text in the canvas.",
			D: "4"
		},
		circularArc: {
			M: "Circular Graphs",
			T: "int",
			C: "Number of degrees to extend the circular graph  @exs {}",
			D: "360"
		},
		varLabelFontColor: {
			H: ["{*}"],
			M: "Variables",
			T: "color",
			C: "Font color for the variable labels in one dimensional plots",
			D: "rgb(0,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		isBoxPlotCalc: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the iqr has been calculated if the graph type is Boxplot."
		},
		nodeFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Network Graphs",
			T: "option",
			C: "Font style for the node label.",
			D: ""
		},
		pieSegmentSeparation: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "integer",
			C: "Length in pixels for the separation of the pieces of the pie charts",
			D: "1"
		},
		smpLabelOrientation: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			O: ["perpendicular", "circular"],
			M: "Circular Graphs",
			T: "option",
			C: "Orientation to show the sample names",
			D: "perpendicular"
		},
		timeTicksFirst: {
			H: ['{*,"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to indicate whether to use the first date on a time graph or the last",
			D: "false"
		},
		remoteParams: {
			S: ["remoteService", "remoteServiceType", "remoteDirection"],
			M: "Remote Procedures",
			T: "object",
			C: "Object to hold additional parameters used to obtain data remotely. The target property will be always added to the method as well as the direction [next|prev].",
			D: "{}"
		},
		dotLength: {
			H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the length between dots in the doted lines.",
			D: "1"
		},
		zAxisMinorValues: {
			M: "Z-Axis",
			T: "array",
			C: "Values for the minor ticks in the Z axis",
			D: "[]"
		},
		smpHighlightColor: {
			H: ['{*,"highlightSmp":["Sample1","Sample3"]}'],
			M: "Samples",
			T: "color",
			C: "The color for the higlighted samples.",
			D: "rgb(255,0,0)"
		},
		overrideAnchorNodes: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to override anchor nodes",
			D: "false"
		},
		network2DRotate: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of degrees to rotate network arround the X axis"
		},
		clusterSamples: {
			S: ["distance", "linkage", "clusterAxis", "imputeMethod"],
			M: "Functions",
			T: "void",
			C: "Cluster samples based on data and generate a dendrogram on the sample axis. It takes no parameters",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		arrowPointSize: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the arrow head in arrow lines.",
			D: "10"
		},
		yAxisValues: {
			M: "Y-Axis",
			T: "array",
			C: "Values for the ticks in the Y axis",
			D: "[]"
		},
		sequenceFill: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the background when showing sequnces in the box or sequence object in the Genome. The default is to use the background of the object. If specied a valid color then all the background of sequences will be uniform",
			D: "false"
		},
		sma25Color: {
			H: ['{*,"stockIndicators":["Sma25"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 25 day single moving average",
			D: "rgb(255,0,255)"
		},
		titleColor: {
			S: ["title", "titleHeight"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "color",
			C: "Color for the title",
			D: "rgb(0,0,0)"
		},
		outlineBy: {
			H: ["{*}"],
			S: ["outlineByData"],
			M: "Data Point Attributes",
			T: "string",
			C: "Name of the annotation for the outline when drawing a multidimensional Heatmap",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		resizableX: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable resizing the width of the canvas by dragging the mouse over the edges",
			D: "true"
		},
		maxSubMenus: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Maximum number of submenus in the context menus",
			D: "20"
		},
		ratioGroupReference: {
			O: ["false"],
			M: "Data",
			T: "option",
			C: "Name of the group used in ratio transformation.",
			D: "false",
			X: "getXData"
		},
		sortVariablesByCategory: {
			S: ["sortDir", "sortVariablesBySample"],
			M: "Functions",
			T: "array",
			C: "Sort the variables by a variable category (data.z object)",
			X: "getZData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		desegregateVariables: {
			S: ["segregateVariables"],
			M: "Functions",
			T: "void",
			C: "Desegregate variables previously segregated based on a variable category (data.z object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		setMax: {
			Z: "true",
			M: "Axis",
			T: "float",
			C: "Maximum value to set the data",
			D: "null"
		},
		selectDataModeDescription: {
			H: ['{"selectDataMode":"name","selectDataModeDescription":false}', '{"selectDataMode":"name","selectDataModeDescription":"Annt1"}'],
			O: ["false"],
			M: "Scatter Plots",
			T: "option",
			C: "Variable label to display when highlighting selected data points that must be in the 'data.z' object. (Shift + mouse drag)  @see{selectDataMode}",
			D: "false",
			X: "getZData"
		},
		includeDOE: {
			M: "DOE",
			T: "array",
			C: "Array containing the factors to include when exploring the DOE. If left empty all the factors will be included",
			D: "[]"
		},
		networkLayoutType: {
			H: ['{"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}', '{"data":"LesMiserables","networkLayoutType":"organic","colorNodeBy":"group"}', '{"data":"NetworkRadial","networkLayoutType":"radial"}'],
			O: ["forceDirected", "organic", "radial"],
			M: "Network Graphs",
			T: "option",
			C: "Type of network layout.",
			D: "forceDirected"
		},
		zoom: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Zoom factor for the networks. A number greater than zero",
			D: "1"
		},
		citationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the reference citation"
		},
		initialTemperature: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Initial temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
			D: "0"
		},
		legendBackgroundColor: {
			S: ["legendBox"],
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the legend background",
			D: "rgb(255,255,255)"
		},
		binConfigurations: {
			M: "Bins",
			T: "object",
			C: "Properties for the binning functions",
			D: "{}"
		},
		overlayScaleFontFactor: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "float",
			C: "Scaling factor used to increse or decrease overlays font size in the canvas in one dimensional plots",
			D: "1"
		},
		loessBandwidth: {
			M: "Loess",
			T: "float",
			C: "Loess bandwidth",
			D: "0.3"
		},
		colorByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the colorBy legend",
			D: "true"
		},
		showNetworkNodesLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		bubbleColor: {
			H: ['{"graphType":"Circular","circularType":"bubble"}'],
			M: "Circular Graphs",
			T: "color",
			C: "The default color for the bubles",
			D: "rgba(150,150,150,0.33)"
		},
		shadowBlur: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Amount in blur for the shadow.",
			D: "2"
		},
		perspectiveFactor: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "float",
			C: "Factor to use to make the 3D perspective. The higher the number the more perspective. Perspective of zero is no perspective at all.",
			D: "2.2"
		},
		varTitleLabelOverlayPosition: {
			H: ["{*}"],
			O: ["bottom", "top"],
			M: "Heatmap Graphs",
			T: "option",
			C: "Position for variable labels",
			D: "bottom"
		},
		remoteAutoPlay: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to automatically iterate over remote data sets",
			D: "false"
		},
		recalculateLayout: {
			M: "Functions",
			T: "void",
			C: "Recalculate the network layout",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		varTitleFontStyle: {
			H: ['{*,"varTitle":"Variable Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Variables",
			T: "option",
			C: "Font style for the var title.",
			D: "",
			U: {
				Heatmap: "true"
			}
		},
		sequenceXColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the any aminoacid code in the genome browser",
			D: "rgb(0,0,0)"
		},
		sizeNodeBy: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group","sizeNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the nodes.",
			D: "false"
		},
		overlayFontColor: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "color",
			C: "Color for the overlays in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		snapshotCopyChangeOnly: {
			M: "Animation",
			T: "boolean",
			C: "Flag to indicate whether to copy all or only the changed attributes in the network animation. This optimizes memory usage for snapshots.",
			D: "true"
		},
		axisTickFontSize: {
			S: ["autoScaleFont", "axisTickScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Axis",
			T: "integer",
			C: "Font size for the axis ticks in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the tick scaling factor",
			D: "12"
		},
		sequenceGColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the guanines and glycines in the genome browser",
			D: "rgb(0,0,0)"
		},
		xAxisMinorTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show minor tick lines in the X axis",
			D: "true"
		},
		guidesColor: {
			H: ['{*,"graphType":"Heatmap","guides":true}'],
			M: "Plot area",
			T: "color",
			C: "The color for the thin line that appears in the middle of the variables and / or samples in one dimensional graphs and multidimensional heatmaps just for aesthetics.",
			D: "rgb(204,204,204)"
		},
		legendPosition: {
			S: ["legendInside"],
			H: ["{*}"],
			O: ["topRight", "right", "bottomRight", "bottom", "bottomLeft", "left", "topLeft", "top"],
			M: "Legends",
			T: "option",
			C: "Position for the legend in the graphs. If legendInside is true the all the options apply but if legendInside is false only right and bottom are valid options",
			D: "right"
		},
		dashLength: {
			H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the length of the dashes and the separation between the dashes in the dashed lines.",
			D: "8"
		},
		zAxisTitle: {
			H: ['{"graphType":"Scatter3D","zAxisTitle":"Z-axis title"}'],
			M: "Z-Axis",
			T: "string",
			C: "Title for the Z axis",
			D: "false"
		},
		rAxisMajorTicks: {
			H: ["{*}"],
			M: "R-Axis",
			T: "boolean",
			C: "A flag to show major tick lines in the R axis",
			D: "true"
		},
		remoteParentId: {
			Z: "true",
			M: "Remote Procedures",
			T: "string",
			C: "Id for the parent holding the remoteWindow to prevent id collisions"
		},
		groupingFactors: {
			M: "Data",
			T: "array",
			C: "An array that holds the group names used for grouping the data. It must be a category in the 'data.x' object",
			D: "[]"
		},
		configuratorWidth: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the configurator.",
			D: "250"
		},
		featureQualityHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the quality height",
			D: "12"
		},
		joinType: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["mitter", "bevel", "round"],
			M: "Lines",
			T: "option",
			C: "Default type for joining lines.",
			D: "mitter"
		},
		translateX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Amount to translate for the X axis."
		},
		networkRoot: {
			H: ['{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene1"}', '{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene2"}'],
			M: "Network Graphs",
			T: "string",
			C: "Node Id of the network root.",
			D: "false"
		},
		varOverlays: {
			H: ['{"graphType":"Heatmap","data":"Random:10:10:3:0","varOverlays":["Annt1","Annt2","Annt3"]}'],
			M: "Overlays",
			T: "array",
			C: "Variable annotations included in the 'data.z' object used in one dimensional plots",
			D: "[]",
			X: "getZData"
		},
		higlightGreyOutTransparency: {
			S: ["higlightGreyOut"],
			M: "General",
			T: "float",
			C: "Fraction of transparency for grey out when highlighting with mouse over",
			D: "0.67"
		},
		z3DRatio: {
			H: ['{"graphType":"Scatter3D","z3DRatio":0.5}', '{"graphType":"Scatter3D","z3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the Z Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		remoteUpdating: {
			Z: "true",
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to indicate that updating data is in progress"
		},
		filterFeatureBy: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "filter",
			C: "Filter features by their properties used in genome browser",
			D: "[]",
			X: "getFeatureData"
		},
		foreground: {
			H: ['{*,"data":"Random:1:3:0:0","graphType":"Dotplot"}'],
			M: "Foreground",
			T: "color",
			C: "Specifies the foreground color for text or lines not covered in a more specific configuration property.",
			D: "rgb(0,0,0)"
		},
		topoJSON: {
			H: ['{*,"graphType":"Map"}'],
			M: "Maps",
			T: "object",
			C: "TopoJSON map object; the key is the name of the variable and the value is a url with the topoJSON",
			D: "false"
		},
		plotByVariable: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to indicate whether to group the data variable rather than by sample",
			D: "false"
		},
		rowHeight: {
			M: "Data Table",
			T: "integer",
			C: "Mumber of pixels for the height of cells in the data table",
			D: "18"
		},
		barType: {
			H: ['{*,"graphType":"Bar","widthFactor":0.1}'],
			O: ["normal", "lollipop"],
			M: "Bar Graphs",
			T: "option",
			C: "Flag to produce normal or lollipop bar graphs",
			D: "normal"
		},
		boxplotConnect: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show data in boxplots connected",
			D: "false"
		},
		scatterType: {
			S: ["images", "isHistogram", "histogramBarWidth"],
			O: ["false", "line", "bar", "dot", "image", "lineImage", "lineStep"],
			M: "Scatter Plots",
			T: "option",
			C: 'Type of scatter plot  @exs {*,"graphType":"Scatter2D","scatterType":"image","images":["area", "bar", "boxplot", "heatmap", "line", "pie"]}',
			D: "false"
		},
		subtitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the subtitle"
		},
		standardDeviationType: {
			H: ['{"standardDeviationType":"unbiased","functions":["groupSamples:Factor1"]}', '{"standardDeviationType":"unbiased","functions":["groupSamples:Factor1"]}'],
			O: ["biased", "unbiased"],
			M: "Data",
			T: "option",
			C: "Type of Standard Deviation. 'biased' uses n as denominator and 'unbiased' uses (n - 1) as denominator where n is the number of values",
			D: "unbiased"
		},
		videoCurrentTime: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to show video current time",
			D: "false"
		},
		featureQualityValues: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show values for the quality",
			D: "false"
		},
		dendrogramHang: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true,"dendrogramHeight":false}'],
			S: ["dendrogramHeight"],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the nodes in the dendrogram as hanging or not similar to that one in R",
			D: "false"
		},
		xAxis2ValuesRaw: {
			Z: "true",
			M: "X-Axis2",
			T: "array",
			C: "Raw values for the ticks in the 2nd X axis",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		bar3DInverseWeight: {
			H: ['{*,"data":"3DScatter","scatterType":"bar"}'],
			M: "3D Attributes",
			T: "float",
			C: "Value for adjusting the thickness of 3D bars. The larger the value the the thinner the bar",
			D: "1",
			U: {
				Scatter3D: "true"
			}
		},
		resizerPosition: {
			O: ["top", "rigth", "bottom", "left"],
			M: "Axis Resizer",
			T: "option",
			C: "Position for the axis resizer in complex plots",
			D: "bottom"
		},
		repulsiveForceFunction: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			O: ["square", "log", "pow", "sqrt"],
			M: "Network Graphs",
			T: "option",
			C: "Type of function to apply when calculating repulsive force in forceDirected network layouts",
			D: "square"
		},
		vennGroups: {
			H: ['{"vennGroups":2}', '{"vennGroups":3}', '{"vennGroups":4}'],
			M: "Venn Diagrams",
			T: "integer",
			C: "Number of groups in the Venn diagram",
			D: "4"
		},
		zAxis: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D"}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "array",
			C: "Name of the samples groups or variables to be displayed in the Z axis",
			D: "[]",
			X: "getSamplesAsArray"
		},
		videoPlaybackRate: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			M: "Videos",
			T: "float",
			C: "Video Playback Rate",
			D: "1"
		},
		lineType: {
			H: ['{*,"data":"Random:4:6","graphType":"Line"}'],
			O: ["rect", "spline"],
			M: "Line Graphs",
			T: "option",
			C: "Type of line used to join the points in line graphs",
			D: "rect"
		},
		y3DRatio: {
			H: ['{"graphType":"Scatter3D","y3DRatio":0.5}', '{"graphType":"Scatter3D","y3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the Y Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		featureStaggered: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to stagger the features in the genome panel",
			D: "false"
		},
		heatmapIndicatorWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "integer",
			C: "Length in pixels for the heatmap indicator line width used for increase the size of the indicator",
			D: "160"
		},
		decorationsWidth: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "integer",
			C: "Length in pixels of the width for the decorations in the networks",
			D: "10",
			U: {
				Network: "true"
			}
		},
		moveParentsWithChildren: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to make parents move when a child is moved",
			D: "false"
		},
		filterVarBy: {
			H: ["{*}"],
			M: "Variables",
			T: "filter",
			C: "Filter variables by their annotation included in the 'data.z' object used in one dimensional plots",
			D: "[]",
			X: "getZData"
		},
		layoutBoxLabelColors: {
			M: "Combination Plots",
			T: "array",
			C: "Layout box label background colors.",
			D: "[]"
		},
		disableMenu: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the menu on right clicks",
			D: "false"
		},
		maxPieSectors: {
			H: ['{"data":"Generic","maxPieSectors":2}', '{"data":"Generic","maxPieSectors":3}'],
			M: "Pie Charts",
			T: "float",
			C: "Max pie sectors. After that number the sectors will be put in a sector named 'other'.",
			D: "20"
		},
		yAxisAbsMax: {
			Z: "true",
			M: "Y-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the Y axis"
		},
		featureFillColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the fill of the feature in the genome browser",
			D: "rgb(255,255,255)"
		},
		xAxisAbsMin: {
			Z: "true",
			M: "X-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the X axis"
		},
		filterSkipNullKeys: {
			M: "Data Filters",
			T: "boolean",
			C: "Flag to indicate to bypass filtering when a key is non existent in the data objects",
			D: "false"
		},
		showFadeResizeMoveAnimation: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to show animation in data table, data filter and tool bar.",
			D: "true"
		},
		correlationLabelInterval: {
			H: ["{*}"],
			M: "Correlation Graphs",
			T: "integer",
			C: "Interval for the sample or variable labels in the correlation plot",
			D: "1"
		},
		colorSmpDendrogramBy: {
			O: ["false"],
			M: "Dendrograms",
			T: "option",
			C: "Name of a sample annotation to color the variable dendrogram.",
			D: "false",
			X: "getXData"
		},
		networkForceConstant: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "float",
			C: "Constant used for calculating attractive and repulsive forces in forcedDirected and organic layouts. A value based on the average area per node will be assigned if not specified",
			D: "0"
		},
		oncoprintCode: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to print code for mutations in oncoprint",
			D: "false"
		},
		patterns: {
			H: ['{"data":"Random:21:1:0:0:1","graphType":"Bar","graphOrientation":"vertical","setMaxX":1,"setMinX":0,"smpLabelRotate":90,"patternBy":"variable","showLegend":false,"colorScheme":"White"}'],
			O: ["solid", "hatchForward", "hatchReverse", "stripeHorizontal", "stripeVertical", "polkaDot", "crossHatch", "crossStripe", "squares", "circles", "plus", "minus", "bars", "squiglesVertical", "squiglesHorizontal", "brickForward", "brickReverse", "art", "pcx", "hatchForward3", "hatchReverse3"],
			M: "Patterns",
			T: "array",
			C: "Patterns used in visualizations to fill objects. This array must contain one or more pattern names and in concert with the color array can be used to specify the pattern colors for all filled objects in the visualizations."
		},
		yAxisValuesRaw: {
			Z: "true",
			M: "Y-Axis",
			T: "array",
			C: "Raw values for the ticks in the Y axis"
		},
		networkShowDataTable: {
			O: ["nodes", "edges"],
			M: "Data Table",
			T: "option",
			C: "Show nodes or edges on data table",
			D: "nodes"
		},
		pseudoRandom: {
			M: "Random",
			T: "boolean",
			C: "Flag to indicate to use pseudo random rather than random",
			D: "true"
		},
		vennColors: {
			S: ["colors"],
			H: ['{"vennColors":["rgb(51,151,255)","rgb(151,255,51)","rgb(255,51,125)"],"vennGroups":3}'],
			M: "Venn Diagrams",
			T: "array",
			C: "Colors for the Venn bubles. If not specified the colors will be chosen from the colors array. Colors in this array need to be at least the same number of groups in the Venn diagram",
			D: "[]"
		},
		xAxisLeftMajorTick: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show the left major tick line in the X axis in Scatter2D plots",
			D: "true"
		},
		skipConfigurableProperties: {
			M: "Data Table/Filter",
			T: "boolean",
			C: "Flag to indicate to exclude configurable parameters in the data table and the data filters in Networks and Genome Browser",
			D: "true"
		},
		outlineByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the outlineBy legend",
			D: "true"
		},
		scaleX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Scale factor for the X axis"
		},
		configuratorExamplesSize: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the examples in the configurator.",
			D: "400"
		},
		gradientType: {
			S: ["gradient"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true}'],
			O: ["linear", "radial"],
			M: "Gradients",
			T: "option",
			C: "Specifies the gradient pattern.",
			D: "radial"
		},
		"this": {
			M: "Y-Axis",
			T: "float",
			C: "Value to floor the data in the Y axis when transform type is floor",
			D: "false"
		},
		resizerType: {
			O: ["false", "samples", "box"],
			M: "Axis Resizer",
			T: "option",
			C: "String to indicate the type of axis resizer in complex plots",
			D: "false"
		},
		xAxisRightMajorTick: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show the right major tick line in the X axis in Scatter2D plots",
			D: "true"
		},
		showDataValues: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to indicate whether to show data values in the one bar graphs.",
			D: "false",
			U: {
				Bar: "true",
				Heatmap: "true"
			}
		},
		xAxisS2Show: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to show or not the values of the ticks in the X axis at the top in Scatter plots",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		smpDendrogramNewick: {
			M: "Dendrograms",
			T: "string",
			C: "Dendrogram in Newick format for the samples",
			D: "true"
		},
		featureTracesShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show traces",
			D: "true"
		},
		contourXBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of X bins in contour plots",
			D: "false"
		},
		hideUnhideSmps: {
			M: "Functions",
			T: "array",
			C: "Hide or unhide samples. It works like a switch",
			X: "getSamplesAsArray",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		decorationsColors: {
			H: ['{"data":"NetworkDecorations","decorationsPosition":"right","networkFreezeOnLoad":true,"showDecorations":true,"decorationsColors":["rgb(51,125,255)","rgb(125,255,51)","rgb(255,125,51)"],"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "array",
			C: "Array of colors used for selection in network decorations not to be confused by its singular form 'decorationsColor' above",
			D: "[]",
			U: {
				Network: "true"
			}
		},
		printType: {
			O: ["download", "window"],
			M: "General",
			T: "option",
			C: "Print type",
			D: "download"
		},
		zAxisAbsMax: {
			Z: "true",
			M: "Z-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the Z axis"
		},
		loessDrawOptimizer: {
			M: "Loess",
			T: "integer",
			C: "Loess draw optimizer is a number to skip values that that are the same to draw the loess fit",
			D: "5"
		},
		imputeMethod: {
			H: ['{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"mean","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"median","functions":["clusterSamples","clusterVariables"]}'],
			S: ["distance", "linkage", "clusterAxis", "clusterSamples", "clusterVariables"],
			O: ["mean", "median"],
			M: "Clustering",
			T: "option",
			C: "Imputation method for missing data when clustering",
			D: "mean"
		},
		isMarketSwitched: {
			H: ['{"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
			Z: "true",
			M: "Data",
			T: "boolean",
			D: "false",
			C: "Flag to indicate if the data is a time series so there is no need to plot every time interval. It is boolean in one dimensional plots or a string indicating the axis which is timed 'x', 'y' or 'z'  @cfg {boolean|string} isGraphTime"
		},
		labelNodePosition: {
			H: ['{*,"data":"LesMiserables","colorNodeBy":"group"}'],
			O: ["auto", "center", "top", "right", "bottom", "left"],
			M: "Network Graphs",
			T: "option",
			C: "Default position for the node label",
			D: "auto"
		},
		randomMissingDataPercentage: {
			M: "Random",
			T: "float",
			C: "Default percentage of missing values when creating random data. A value between 0 and 1.",
			D: "0"
		},
		videoPreload: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4","https://canvasxpress.org/images/oceans-clip.webm"]}'],
			O: ["Auto", "Metadata", "none"],
			M: "Videos",
			T: "option",
			C: "Preload type for videos",
			D: "none"
		},
		yAxisHistogramHeight: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "integer",
			C: "Number of pixels for the histogram in the Y axis",
			D: "50"
		},
		highlightVar: {
			H: ['{"highlightVar":["Variable1","Variable3"]}'],
			M: "Variables",
			T: "array",
			C: "Name of variables in the 'data.y' object to highlight.",
			D: "[]",
			X: "getVariablesAsArray",
			U: {
				Heatmap: "true"
			}
		},
		sortSamplesByCategory: {
			S: ["sortDir", "sortSamplesByVariable"],
			M: "Functions",
			T: "array",
			C: "Sort the samples by a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		featuresProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the features in the Genome graph to include in the Data table and the data filter",
			D: "[]"
		},
		boxplotConnectWidth: {
			H: ['{"data":"Boxplot","boxplotConnect":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Width for the line of the connection of boxes in boxplots",
			D: "2"
		},
		sequenceWColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/T and tryptophans in the genome browser",
			D: "rgb(0,0,255)"
		},
		fontStyle: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Text",
			T: "option",
			C: "Font style.",
			D: ""
		},
		showBoxplotOriginalData: {
			S: ["jitterColumns", "boxplotDataPointTransparency", "jitter"],
			H: ['{"data":"Boxplot","showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","showBoxplotOriginalData":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show original data in boxplots",
			D: "false"
		},
		rAxisTickColor: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "color",
			C: "Color for the tick lines in the R axis",
			D: "rgb(0,0,0)"
		},
		trackNameFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the track name.",
			D: ""
		},
		showVolume: {
			H: ["{*}"],
			M: "Candlestick Plots",
			T: "boolean",
			C: "Flag to show or not volume in the candlestick graphs",
			D: "true"
		},
		videoControls: {
			M: "Videos",
			T: "boolean",
			C: 'Flag to show controls in videos  @exs {*,"backgroundType":"video","backgroundVideo":["https://canvasxpress.org/images/oceans-clip.mp4", "https://canvasxpress.org/images/oceans-clip.webm"]}'
		},
		treeLinkWidth: {
			M: "Trees",
			T: "integer",
			C: "Width for the Tree lines",
			D: "1"
		},
		sma10Color: {
			H: ['{*,"stockIndicators":["Sma10"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 5 day single moving average",
			D: "rgb(0,255,0)"
		},
		varLabelFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Variables",
			T: "option",
			C: "Font style for the variable label.",
			D: "",
			U: {
				Heatmap: "true"
			}
		},
		ringsType: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"ringsType":["bar","heatmap","dot"]}'],
			M: "Circular Graphs",
			T: "array",
			C: "Array containing the types for each ring in the circular plots",
			D: "[]"
		},
		gradientOrientation: {
			S: ["backgroundType"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
			O: ["vertical", "horizontal"],
			M: "Gradients",
			T: "option",
			C: "Specifies the orientation of the gradient if the gradient type is of the type 'linear'",
			D: "vertical"
		},
		isCoordinateNodeColorsNetworkConvexHull: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to coordinate colors of the nodes with convex hull for the network communities",
			D: "false"
		},
		refresehDataTableOnDraw: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to refresh data after drawing the plot",
			D: "false"
		},
		percentAspectRatioPlotArea: {
			M: "Aspect Ratio",
			T: "float",
			C: "Specifies the minimum percentage for the ploting area",
			D: "0.5"
		},
		randomNetworkReduce: {
			M: "Random",
			T: "boolean",
			C: "Flag to create or not a single random network for debug and demonstration purposes",
			D: "true",
			U: {
				Network: "true"
			}
		},
		leafletInitString: {
			M: "Maps",
			T: "string",
			C: "Leaflet Init Function as a string",
			D: "false"
		},
		decorationsBoxColor: {
			S: ["decorationsBox"],
			M: "Decorations",
			T: "color",
			C: 'Color for the box around the decoration legend  @exs {*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}',
			D: "rgb(204,204,204)"
		},
		varLabelFontSize: {
			S: ["autoScaleFont", "varLabelScaleFontFactor"],
			H: ['{"autoScaleFont":false,"varLabelFontSize":10}', '{"autoScaleFont":false,"varLabelFontSize":20}'],
			M: "Variables",
			T: "integer",
			C: "Size for the variable labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the variable label scaling factor",
			D: "12",
			U: {
				Heatmap: "true"
			}
		},
		smpLabelFontSize: {
			S: ["autoScaleFont", "smpLabelScaleFontFactor"],
			H: ['{"autoScaleFont":false,"smpLabelFontSize":10}', '{"autoScaleFont":false,"smpLabelFontSize":20}'],
			M: "Samples",
			T: "integer",
			C: "Size for the sample labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the sample label scaling factor",
			D: "12"
		},
		sankeyTarget: {
			H: ['{"data":"Sankey","graphType":"Sankey"}'],
			O: ["false"],
			M: "Sankey Diagrams",
			T: "option",
			C: "Name of a sample annotation to use as target in the sankey diagrams",
			D: "false",
			X: "getXData"
		},
		sequenceAColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the adenines and alanines in the genome browser",
			D: "rgb(0,103,0)"
		},
		clusterVariables: {
			S: ["distance", "linkage", "clusterAxis", "imputeMethod"],
			M: "Functions",
			T: "void",
			C: "Cluster variables based on data and generate a dendrogram on the variable axis. It takes no parameters",
			U: {
				Heatmap: "true"
			}
		},
		xAxis2TickFormat: {
			M: "X-Axis2",
			T: "string",
			C: 'Format for the tick values in the second X axis  @exs {"graphType":"BarLine","xAxis2TickFormat":"%.2f cxs","graphOrientation":"vertical"}',
			D: "false"
		},
		highlightNode: {
			H: ['{"highlightNode":["Gene1","Gene2"]}'],
			M: "Network Graphs",
			T: "array",
			C: "Name of nodes in the 'data.nodes' object to highlight.",
			D: "[]"
		},
		snapshots: {
			Z: "true",
			M: "Snapshots",
			T: "array",
			C: "Array to hold the data used in the animation"
		},
		isMap: {
			Z: "true",
			M: "Maps",
			T: "boolean",
			C: "Flag to indicate to use Leaflet map"
		},
		circularType: {
			H: ['{*,"graphType":"Circular"}'],
			O: ["normal", "radar", "sunburst", "chord", "bubble"],
			M: "Circular Graphs",
			T: "option",
			C: "Property to produce normal, radar, sunburst, chord and bubble graphs. If set to sunburst or bubble then the smpOverlays will be used to build the hierarchy of the graph.",
			D: "normal"
		}
	},
	G: {
		name: {
			M: "Genome",
			T: "string",
			C: "Track name"
		}
	},
	E: {
		cap: {
			O: "butt, round, square",
			M: "Network",
			T: "option",
			C: "Type of cap for the end of the lines"
		},
		width: {
			M: "Network",
			T: "integer",
			C: "Pixel width for the edges between nodes"
		},
		anchor: {
			M: "Network",
			T: "boolean",
			C: "Flag make the edge transparent"
		},
		color: {
			M: "Network",
			T: "color",
			C: "Color for the edge"
		},
		hide: {
			M: "Network",
			T: "boolean",
			C: "Flag to hide the edge"
		},
		exact: {
			M: "Network",
			T: "boolean",
			C: "Flag to indicate to create the edge between nodes without subtracting the size of the nodes"
		},
		type: {
			M: "Network",
			T: "string",
			C: "Type of line use to join the nodes"
		}
	}
};
